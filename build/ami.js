(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AMI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// jshint ignore: start

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
 /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
 Copyright 2011 notmasteryet

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};
var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
    0,
    1, 8,
    16, 9, 2,
    3, 10, 17, 24,
    32, 25, 18, 11, 4,
    5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13, 6,
    7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1 = 4017;   // cos(pi/16)
  var dctSin1 = 799;   // sin(pi/16)
  var dctCos3 = 3406;   // cos(3*pi/16)
  var dctSin3 = 2276;   // sin(3*pi/16)
  var dctCos6 = 1567;   // cos(6*pi/16)
  var dctSin6 = 3784;   // sin(6*pi/16)
  var dctSqrt2 = 5793;   // sqrt(2)
  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;
      var bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }

    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null)
          return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }

    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[offset] = (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, offset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      component.blockData[offset] = (component.pred += diff);
    }

    function decodeDCSuccessive(component, offset) {
      component.blockData[offset] |= readBit() << successive;
    }

    var eobrun = 0;
    function decodeACFirst(component, offset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, offset) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
          case 0: // initial state
            var rs = decodeHuffman(component.huffmanTableAC);
            var s = rs & 15;
            r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1)
                throw "invalid ACn encoding";
              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }
            continue;
          case 1: // skipping r zero items
          case 2:
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              r--;
              if (r === 0)
                successiveACState = successiveACState == 2 ? 3 : 0;
            }
            break;
          case 3: // set value for a zero item
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            } else {
              component.blockData[offset + z] = successiveACNextValue << successive;
              successiveACState = 0;
            }
            break;
          case 4: // eob
            if (component.blockData[offset + z]) {
              component.blockData[offset + z] += (readBit() << successive);
            }
            break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      var offset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, offset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) {
      resetInterval = mcuExpected;
    }

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++) {
        components[i].pred = 0;
      }
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker <= 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  }

  // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.
  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable;
    var v0, v1, v2, v3, v4, v5, v6, v7, t;
    var i;

    // dequant
    for (i = 0; i < 64; i++) {
      p[i] = component.blockData[blockBufferOffset + i] * qt[i];
    }

    // inverse DCT on rows
    for (i = 0; i < 8; ++i) {
      var row = 8 * i;

      // check for all-zero AC coefficients
      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&
        p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&
        p[7 + row] === 0) {
        t = (dctSqrt2 * p[0 + row] + 512) >> 10;
        p[0 + row] = t;
        p[1 + row] = t;
        p[2 + row] = t;
        p[3 + row] = t;
        p[4 + row] = t;
        p[5 + row] = t;
        p[6 + row] = t;
        p[7 + row] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
      v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
      v2 = p[2 + row];
      v3 = p[6 + row];
      v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
      v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
      v5 = p[3 + row] << 4;
      v6 = p[5 + row] << 4;

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 + row] = v0 + v7;
      p[7 + row] = v0 - v7;
      p[1 + row] = v1 + v6;
      p[6 + row] = v1 - v6;
      p[2 + row] = v2 + v5;
      p[5 + row] = v2 - v5;
      p[3 + row] = v3 + v4;
      p[4 + row] = v3 - v4;
    }

    // inverse DCT on columns
    for (i = 0; i < 8; ++i) {
      var col = i;

      // check for all-zero AC coefficients
      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&
        p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&
        p[7 * 8 + col] === 0) {
        t = (dctSqrt2 * p[i + 0] + 8192) >> 14;
        p[0 * 8 + col] = t;
        p[1 * 8 + col] = t;
        p[2 * 8 + col] = t;
        p[3 * 8 + col] = t;
        p[4 * 8 + col] = t;
        p[5 * 8 + col] = t;
        p[6 * 8 + col] = t;
        p[7 * 8 + col] = t;
        continue;
      }

      // stage 4
      v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;
      v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;
      v2 = p[2 * 8 + col];
      v3 = p[6 * 8 + col];
      v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;
      v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;
      v5 = p[3 * 8 + col];
      v6 = p[5 * 8 + col];

      // stage 3
      t = (v0 - v1 + 1) >> 1;
      v0 = (v0 + v1 + 1) >> 1;
      v1 = t;
      t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
      v3 = t;
      t = (v4 - v6 + 1) >> 1;
      v4 = (v4 + v6 + 1) >> 1;
      v6 = t;
      t = (v7 + v5 + 1) >> 1;
      v5 = (v7 - v5 + 1) >> 1;
      v7 = t;

      // stage 2
      t = (v0 - v3 + 1) >> 1;
      v0 = (v0 + v3 + 1) >> 1;
      v3 = t;
      t = (v1 - v2 + 1) >> 1;
      v1 = (v1 + v2 + 1) >> 1;
      v2 = t;
      t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
      v7 = t;
      t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
      v6 = t;

      // stage 1
      p[0 * 8 + col] = v0 + v7;
      p[7 * 8 + col] = v0 - v7;
      p[1 * 8 + col] = v1 + v6;
      p[6 * 8 + col] = v1 - v6;
      p[2 * 8 + col] = v2 + v5;
      p[5 * 8 + col] = v2 - v5;
      p[3 * 8 + col] = v3 + v4;
      p[4 * 8 + col] = v3 - v4;
    }

    // convert to 8-bit integers
    for (i = 0; i < 64; ++i) {
      var index = blockBufferOffset + i;
      var q = p[i];
      q = (q <= -2056 / component.bitConversion) ? 0 :
        (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :
        (q + 2056 / component.bitConversion) >> 4;
      component.blockData[index] = q;
    }
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var computationBuffer = new Int32Array(64);

    var i, j, ll = 0;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }
    return component.blockData;
  }

  function clampToUint8(a) {
    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;
  }

  constructor.prototype = {
    load: function load(path) {
      var handleData = (function (data) {
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);

      if (path.indexOf("data:") > -1) {
        var offset = path.indexOf("base64,") + 7;
        var data = atob(path.substring(offset));
        var arr = new Uint8Array(data.length);
        for (var i = data.length - 1; i >= 0; i--) {
          arr[i] = data.charCodeAt(i);
        }
        handleData(data);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = (function () {
          // TODO catch parse error
          var data = new Uint8Array(xhr.response);
          handleData(data);
        }).bind(this);
        xhr.send(null);
      }
    },
    parse: function parse(data) {

      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }

      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;

          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0, length = data.length;
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch (fileMarker) {
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: {major: appData[5], minor: appData[6]},
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var zz = dctZigZag[j];
                  tableData[zz] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw "Only single frame JPEGs supported";
            }
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              if (maxH < h)
                maxH = h;
              if (maxV < v)
                maxV = v;
              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationTable: quantizationTables[qId],
                quantizationTableId: qId,
                bitConversion: 255 / ((1 << frame.precision) - 1)
              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }
            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength; ) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              var componentIndex = frame.componentIds[data[offset++]];
              component = frame.components[componentIndex];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
              data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      switch (frame.components.length)
      {
        case 1:
          this.colorspace = ColorSpace.Grayscale;
          break;
        case 3:
          if (this.adobe)
            this.colorspace = ColorSpace.AdobeRGB;
          else
            this.colorspace = ColorSpace.RGB;
          break;
        case 4:
          this.colorspace = ColorSpace.CYMK;
          break;
        default:
          this.colorspace = ColorSpace.Unknown;
      }
      for (var i = 0; i < frame.components.length; i++) {
        var component = frame.components[i];
        if (!component.quantizationTable && component.quantizationTableId !== null)
          component.quantizationTable = quantizationTables[component.quantizationTableId];
        this.components.push({
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn,
          bitConversion: component.bitConversion
        });
      }
    },
    getData16: function getData16(width, height) {
      if (this.components.length !== 1)
        throw 'Unsupported color mode';
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint16Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++];
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }
      return data;
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component, componentScaleX, componentScaleY;
      var x, y, i;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8Array(dataLength);
      var componentLine;

      // lineData is reused for all components. Assume first component is
      // the biggest
      var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *
      this.components[0].blocksPerColumn * 8);

      // First construct image data ...
      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;

        var j, k, ll = 0;
        var lineOffset = 0;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var lineOffset = (scanLine + j) * samplesPerLine;
              for (k = 0; k < 8; k++) {
                lineData[lineOffset + sample + k] =
                  component.output[bufferOffset + offset++] * component.bitConversion;
              }
            }
          }
        }

        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;

        var cx, cy;
        var index;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            cy = 0 | (y * componentScaleY);
            cx = 0 | (x * componentScaleX);
            index = cy * samplesPerLine + cx;
            data[offset] = lineData[index];
            offset += numComponents;
          }
        }
      }

      // ... then transform colors, if necessary
      switch (numComponents) {
        case 1:
        case 2:
          break;
        // no color conversion for one or two compoenents

        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i    ];
              Cb = data[i + 1];
              Cr = data[i + 2];

              R = clampToUint8(Y - 179.456 + 1.402 * Cr);
              G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);
              B = clampToUint8(Y - 226.816 + 1.772 * Cb);

              data[i    ] = R;
              data[i + 1] = G;
              data[i + 2] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          if (colorTransform) {
            for (i = 0; i < dataLength; i += numComponents) {
              Y = data[i];
              Cb = data[i + 1];
              Cr = data[i + 2];

              C = clampToUint8(434.456 - Y - 1.402 * Cr);
              M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);
              Y = clampToUint8(481.816 - Y - 1.772 * Cb);

              data[i    ] = C;
              data[i + 1] = M;
              data[i + 2] = Y;
              // K is unchanged
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    }
  };

  return constructor;
})();

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpegImage;
}
},{}],2:[function(require,module,exports){
/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,
           info, warn */

'use strict';

var JpxImage = (function JpxImageClosure() {
  // Table E.1
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {

      var head = readUint16(data, 0);
      // No box header, immediate start of codestream (SOC)
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0, length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          // XLBox: read UInt64 according to spec.
          // JavaScript's int precision of 53 bit should be sufficient here.
          lbox = readUint32(data, position) * 4294967296 +
                 readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          throw new Error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268: // 'jp2h'
            jumpDataLength = false; // parsing child boxes
            break;
          case 0x636F6C72: // 'colr'
            // Colorspaces are not used, the CS from the PDF is used.
            var method = data[position];
            var precedence = data[position + 1];
            var approximation = data[position + 2];
            if (method === 1) {
              // enumerated colorspace
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16: // this indicates a sRGB colorspace
                case 17: // this indicates a grayscale colorspace
                case 18: // this indicates a YUV colorspace
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263: // 'jp2c'
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020: // 'jP\024\024'
            if (0x0d0a870a !== readUint32(data, position)) {
              warn('Invalid JP2 signature');
            }
            break;
          // The following header types are valid but currently not used:
          case 0x6A501A1A: // 'jP\032\032'
          case 0x66747970: // 'ftyp'
          case 0x72726571: // 'rreq'
          case 0x72657320: // 'res '
          case 0x69686472: // 'ihdr'
            break;
          default:
            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,
                                                 (tbox >> 16) & 0xFF,
                                                 (tbox >> 8) & 0xFF,
                                                 tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = (oldByte << 8) | newByte;
        // Image and tile size (SIZ)
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0; // Byte 4
          var Ysiz = stream.getInt32() >>> 0; // Byte 8
          var XOsiz = stream.getInt32() >>> 0; // Byte 12
          var YOsiz = stream.getInt32() >>> 0; // Byte 16
          stream.skip(16);
          var Csiz = stream.getUint16(); // Byte 36
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          // Results are always returned as Uint8Arrays
          this.bitsPerComponent = 8;
          return;
        }
      }
      throw new Error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(data, start, end) {
      var context = {};
      try {
        var doNotRecover = false;
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;

          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
          switch (code) {
            case 0xFF4F: // Start of codestream (SOC)
              context.mainHeader = true;
              break;
            case 0xFFD9: // End of codestream (EOC)
              break;
            case 0xFF51: // Image and tile size (SIZ)
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              break;
            case 0xFF5C: // Quantization default (QCD)
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = (spqcdSize === 8);
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D: // Quantization component (QCC)
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = (spqcdSize === 8);
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < (length + position)) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52: // Coding style default (COD)
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];

              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('JPX Error: Unsupported COD options (' +
                                unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90: // Start of tile-part (SOT)
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];

              context.mainHeader = false;
              if (tile.partIndex === 0) {
                // reset component specific settings
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0); // clone of the global COC
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0); // clone of the global COC
              }
              context.currentTile = tile;
              break;
            case 0xFF93: // Start of data (SOD)
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              // moving to the end of the data
              length = tile.dataEnd - position;
              parseTilePackets(context, data, position, length);
              break;
            case 0xFF55: // Tile-part lengths, main header (TLM)
            case 0xFF57: // Packet length, main header (PLM)
            case 0xFF58: // Packet length, tile-part header (PLT)
            case 0xFF64: // Comment (COM)
              length = readUint16(data, position);
              // skipping content
              break;
            case 0xFF53: // Coding style component (COC)
              throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' +
                              'not implemented');
            default:
              throw new Error('JPX Error: Unknown codestream code: ' +
                              code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw e;
        } else {
          warn('Trying to recover from ' + e.message);
        }
      }
      this.tiles = transformComponents(context);
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
    }
  };
  function calculateComponentDimensions(component, siz) {
    // Section B.2 Component mapping
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    // Section B.3 Division into tile and tile-components
    var tile, tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;

    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    // calculate codeblock size as described in section B.7
    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :
                   Math.min(codOrCoc.xcb, result.PPx));
    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :
                   Math.min(codOrCoc.ycb, result.PPy));
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    // Section B.6 Division resolution to precincts
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    // Jasper introduces codeblock groups for mapping each subband codeblocks
    // to precincts. Precinct partition divides a resolution according to width
    // and height parameters. The subband that belongs to the resolution level
    // has a different size than the level, unless it is the zero resolution.

    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
    // The precinct partitioning for a particular subband is derived from a
    // partitioning of its parent LL band (i.e., the LL band at the next higher
    // resolution level)... The LL band associated with each resolution level is
    // divided into precincts... Each of the resulting precinct regions is then
    // mapped into its child subbands (if any) at the next lower resolution
    // level. This is accomplished by using the coordinate transformation
    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
    // coordinates of a point in the LL band and child subband, respectively.
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?
      Math.ceil(resolution.trx1 / precinctWidth) -
      Math.floor(resolution.trx0 / precinctWidth) : 0);
    var numprecinctshigh = (resolution.try1 > resolution.try0 ?
      Math.ceil(resolution.try1 / precinctHeight) -
      Math.floor(resolution.try0 / precinctHeight) : 0);
    var numprecincts = numprecinctswide * numprecinctshigh;

    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    // Section B.7 Division sub-band into code-blocks
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };

        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);

        // Calculate precinct number for this codeblock, codeblock position
        // should be relative to its subband, use actual dimension and position
        // See comment about codeblock group width and height
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /
          precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /
          precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);

        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ ||
            codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        // building precinct for the sub-band
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    // Section B.10.8 Order of info in packet
    var subbands = resolution.subbands;
    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0, r = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.1 Layer-resolution-component-position
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0, l = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.2 Resolution-layer-component-position
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(
      maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts,
            resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.3 Resolution-position-component-layer
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.4 Position-component-resolution-layer
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount =
              component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale =
                precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.5 Component-position-resolution-layer
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount =
          component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
    };
  }
  function getPrecinctIndexIfExist(
    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 ||
        posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex =
      (posY / sizeInImageScale.width) *
      resolution.precinctParameters.numprecinctswide;
    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution =
          scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution =
          scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(
          minWidthCurrentComponent,
          widthCurrentResolution);
        minHeightCurrentComponent = Math.min(
          minHeightCurrentComponent,
          heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,
          resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,
          resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    // Creating resolutions and sub-bands for each component
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      // Section B.5 Resolution levels and sub-bands
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << (decompositionLevelsCount - r);
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);

        var subband;
        if (r === 0) {
          // one sub-band (LL) with last decomposition
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << (decompositionLevelsCount - r + 1);
          var resolutionSubbands = [];
          // three sub-bands (HL, LH and HH) with rest of decompositions
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    // Generate the packets sequence
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator =
          new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator =
          new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator =
          new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator =
          new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator =
          new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        throw new Error('JPX Error: Unsupported progression order ' +
                        progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer, bufferSize = 0, skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        if(offset + position  >= data.length){
          throw new Error("Unexpected EOF");
        }
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = (buffer << 7) | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = (buffer << 8) | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return (buffer >>> bufferSize) & ((1 << count) - 1);
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF &&
          data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF &&
                 data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      try{
        alignToByte();
        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
          // Skip also marker segment length and packet sequence ID
          skipBytes(4);
        }
        var packet = packetsIterator.nextPacket();
        if (packet === undefined) {
          //No more packets. Stream is probably truncated.
          return;
        }
        if (!readBits(1)) {
          continue;
        }
        var layerNumber = packet.layerNumber;
        var queue = [], codeblock;
        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
          codeblock = packet.codeblocks[i];
          var precinct = codeblock.precinct;
          var codeblockColumn = codeblock.cbx - precinct.cbxMin;
          var codeblockRow = codeblock.cby - precinct.cbyMin;
          var codeblockIncluded = false;
          var firstTimeInclusion = false;
          var valueReady;
          if (codeblock['included'] !== undefined) {
            codeblockIncluded = !!readBits(1);
          } else {
            // reading inclusion tree
            precinct = codeblock.precinct;
            var inclusionTree, zeroBitPlanesTree;
            if (precinct['inclusionTree'] !== undefined) {
              inclusionTree = precinct.inclusionTree;
            } else {
              // building inclusion and zero bit-planes trees
              var width = precinct.cbxMax - precinct.cbxMin + 1;
              var height = precinct.cbyMax - precinct.cbyMin + 1;
              inclusionTree = new InclusionTree(width, height);
              zeroBitPlanesTree = new TagTree(width, height);
              precinct.inclusionTree = inclusionTree;
              precinct.zeroBitPlanesTree = zeroBitPlanesTree;
            }

            inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (inclusionTree.isAboveThreshold()){
                break;
              }
              if (inclusionTree.isKnown()) {
                inclusionTree.nextLevel();
                continue;
              }
              if (readBits(1)) {
                inclusionTree.setKnown();
                if (inclusionTree.isLeaf()) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                } else {
                  inclusionTree.nextLevel();
                }
              } else {
                inclusionTree.incrementValue();
              }
            }
          }
          if (!codeblockIncluded) {
            continue;
          }
          if (firstTimeInclusion) {
            zeroBitPlanesTree = precinct.zeroBitPlanesTree;
            zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
            while (true) {
              if (position >= data.length) {
                return;
              }
              if (readBits(1)) {
                valueReady = !zeroBitPlanesTree.nextLevel();
                if (valueReady) {
                  break;
                }
              } else {
                zeroBitPlanesTree.incrementValue();
              }
            }
            codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
          }
          var codingpasses = readCodingpasses();
          while (readBits(1)) {
            codeblock.Lblock++;
          }
          var codingpassesLog2 = log2(codingpasses);
          // rounding down log2
          var bits = ((codingpasses < (1 << codingpassesLog2)) ?
                      codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
          var codedDataLength = readBits(bits);
          queue.push({
            codeblock: codeblock,
            codingpasses: codingpasses,
            dataLength: codedDataLength
          });
        }
        alignToByte();
        if (ephMarkerUsed) {
          skipMarkerIfEqual(0x92);
        }
        while (queue.length > 0) {
          var packetItem = queue.shift();
          codeblock = packetItem.codeblock;
          if (codeblock['data'] === undefined) {
            codeblock.data = [];
          }
          codeblock.data.push({
            data: data,
            start: offset + position,
            end: offset + position + packetItem.dataLength,
            codingpasses: packetItem.codingpasses
          });
          position += packetItem.dataLength;
        }
      } catch (e) {
        return;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, levelWidth, levelHeight, subband,
                            delta, mb, reversible, segmentationSymbolUsed) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var width = subband.tbx1 - subband.tbx0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? levelWidth : 0;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,
                              codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2; // first bit plane starts from cleanup

      // collect data
      var data = codeblock.data, totalLength = 0, codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Int16Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      // decoding the item
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropogationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;
      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      position = 0;
      // Do the interleaving of Section F.3.3 here, so we do not need
      // to copy later. LL level is not interleaved, just copied.
      var interleave = (subband.type !== 'LL');
      for (j = 0; j < blockHeight; j++) {
        var row = (offset / width) | 0; // row in the non-interleaved subband
        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
        for (k = 0; k < blockWidth; k++) {
          n = magnitude[position];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[position] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[position];
            var pos = interleave ? (levelOffset + (offset << 1)) : offset;
            if (reversible && (nb >= mb)) {
              coefficients[pos] = n;
            } else {
              coefficients[pos] = n * (1 << (mb - nb));
            }
          }
          offset++;
          position++;
        }
        offset += width - blockWidth;
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount =
      codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;

    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = (reversible ? new ReversibleTransform() :
                                  new IrreversibleTransform());

    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];

      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      // Allocate space for the whole sublevel.
      var coefficients = new Float32Array(width * height);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          // formula E-5
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];

        // calulate quantization coefficient (Section E.1.1.1)
        var delta = (reversible ? 1 :
          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
        var mb = (guardBits + epsilon - 1);

        // In the first resolution level, copyCoefficients will fill the
        // whole array with coefficients. In the succeding passes,
        // copyCoefficients will consecutively fill in the values that belong
        // to the interleaved positions of the HL, LH, and HH coefficients.
        // The LL coefficients will then be interleaved in Transform.iterate().
        copyCoefficients(coefficients, width, height, subband, delta, mb,
                         reversible, segmentationSymbolUsed);
      }
      subbandCoefficients.push({
        width: width,
        height: height,
        items: coefficients
      });
    }

    var result = transform.calculate(subbandCoefficients,
                                     component.tcx0, component.tcy0);
    return {
      left: component.tcx0,
      top: component.tcy0,
      width: result.width,
      height: result.height,
      items: result.items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var isSigned = components[0].isSigned;
      if (isSigned) {
        var out = new Int16Array(tile0.items.length * componentsCount);
      } else {
        var out = new Uint16Array(tile0.items.length * componentsCount);
      }
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };

      // Section G.2.2 Inverse multi component transform
      var shift, offset, max, min, maxK;
      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;

        // HACK: The multiple component transform formulas below assume that
        // all components have the same precision. With this in mind, we
        // compute shift and offset only once.
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;

        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          // inverse irreversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          // inverse reversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - ((y2 + y1) >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
          }
        }
      } else { // no multi-component transform
        for (c = 0; c < componentsCount; c++) {
          if (components[c].precision === 8){
            var items = transformedTiles[c].items;
            shift = components[c].precision - 8;
            offset = (128 << shift) + 0.5;
            max = (127.5 * (1 << shift));
            min = -max;
            for (pos = c, j = 0, jj = items.length; j < jj; j++) {
              val = items[j];
              out[pos] = val <= min ? 0 :
                         val >= max ? 255 : (val + offset) >> shift;
              pos += componentsCount;
            }
          }else{
            var isSigned = components[c].isSigned;
            var items = transformedTiles[c].items;

            if(isSigned){
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                out[pos] = items[j];
                pos += componentsCount;
              }
            }else{
              shift = components[c].precision - 8;
              offset = (128 << shift) + 0.5;
              var precisionMax = Math.pow(2,components[c].precision)-1;
              for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                val = items[j];
                out[pos] = Math.max(Math.min((val + offset),precisionMax),0);
                pos += componentsCount;
              }
            }
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?
        context.currentTile.QCC[c] : context.currentTile.QCD);
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?
        context.currentTile.COC[c] : context.currentTile.COD);
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  // Section B.10.2 Tag trees
  var TagTree = (function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0, value = 0, level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  })();

  var InclusionTree = (function InclusionTreeClosure() {
    function InclusionTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        var status = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = 0;
          status[j] = 0;
        }

        var level = {
          width: width,
          height: height,
          items: items,
          status: status
        };
        this.levels.push(level);

        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        this.currentStopValue = stopValue;
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }

        this.currentLevel = this.levels.length - 1;
        this.minValue =this.levels[this.currentLevel].items[0];
        return;
      },
      incrementValue: function InclusionTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = level.items[level.index] + 1;
        if(level.items[level.index] > this.minValue) {
          this.minValue = level.items[level.index];
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        } else {
          this.currentLevel = currentLevel;
          var level = this.levels[currentLevel];
          if(level.items[level.index] < this.minValue) {
            level.items[level.index] = this.minValue;
          }else if (level.items[level.index] > this.minValue) {
            this.minValue = level.items[level.index];
          }
          return true;
        }
      },
    isLeaf: function InclusionTree_isLeaf(){
      return (this.currentLevel === 0);
    },
    isAboveThreshold: function InclusionTree_isAboveThreshold(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.items[level.index] > this.currentStopValue);
    },
    isKnown: function InclusionTree_isKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      return (level.status[level.index] > 0);
    },
    setKnown: function InclusionTree_setKnown(){
      var levelindex = this.currentLevel;
      var level = this.levels[levelindex];
      level.status[level.index] = 1;
      return;
    }

    };
    return InclusionTree;
  })();

  // Section D. Coefficient bit modeling
  var BitModel = (function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    // Table D-1
    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
    var LLAndLHContextsLabel = new Uint8Array([
      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8
    ]);
    var HLContextLabel = new Uint8Array([
      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8
    ]);
    var HHContextLabel = new Uint8Array([
      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8
    ]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;

      this.contextLabelTable = (subband === 'HH' ? HHContextLabel :
        (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));

      var coefficientCount = width * height;

      // coefficients outside the encoding region treated as insignificant
      // add border state cells for significanceState
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :
                                  mb > 6 ? new Uint16Array(coefficientCount) :
                                  new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);

      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;

      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        // We have 17 contexts that are accessed via context labels,
        // plus the uniform and runlength context.
        this.contexts = new Int8Array(19);

        // Contexts are packed into 1 byte:
        // highest 7 bits carry the index, lowest bit carries mps
        this.contexts[0] = (4 << 1) | 0;
        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
      },
      setNeighborsSignificance:
        function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width, height = this.height;
        var left = (column > 0);
        var right = (column + 1 < width);
        var i;

        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropogationPass:
        function BitModel_runSignificancePropogationPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              // clear processed flag first
              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] ||
                  !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;

        // calculate horizontal contribution
        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;

        // calculate vertical contribution and combine with the horizontal
        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass:
        function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {

              // significant but not those that have just become
              if (!coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                // first refinement
               var significance = neighborsSignificance[index] & 127;
               contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] =
                (coefficentsMagnitude[index] << 1) | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            // using the property: labels[neighborsSignificance[index]] === 0
            // when neighborsSignificance[index] === 0
            var allEmpty = (checkAllEmpty &&
              processingFlags[index0] === 0 &&
              processingFlags[index0 + oneRowDown] === 0 &&
              processingFlags[index0 + twoRowsDown] === 0 &&
              processingFlags[index0 + threeRowsDown] === 0 &&
              neighborsSignificance[index0] === 0 &&
              neighborsSignificance[index0 + oneRowDown] === 0 &&
              neighborsSignificance[index0 + twoRowsDown] === 0 &&
              neighborsSignificance[index0 + threeRowsDown] === 0);
            var i1 = 0, index = index0;
            var i = i0, sign;
            if (allEmpty) {
              var hasSignificantCoefficent =
                decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue; // next column
              }
              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                    decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;

              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                      decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          throw new Error('JPX Error: Invalid segmentation symbol');
        }
      }
    };

    return BitModel;
  })();

  // Section F, Discrete wavelet transformation
  var Transform = (function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate =
      function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      // Section F.3.7 extending... using max extension of 4
      var i1 = offset - 1, j1 = offset + 1;
      var i2 = offset + size - 2, j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,
                                                             u0, v0) {
      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
      var width = hl_lh_hh.width;
      var height = hl_lh_hh.height;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      // Interleave LL according to Section F.3.3
      for (k = 0, i = 0; i < llHeight; i++) {
        l = i * 2 * width;
        for (j = 0; j < llWidth; j++, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      // The LL band is not needed anymore.
      llItems = ll.items = null;

      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      // Section F.3.4 HOR_SR
      if (width === 1) {
        // if width = 1, when u0 even keep items as is, when odd divide by 2
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);

          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);

          items.set(
            rowBuffer.subarray(bufferPadding, bufferPadding + width),
            k);
        }
      }

      // Accesses to the items array can take long, because it may not fit into
      // CPU cache and has to be fetched from main memory. Since subsequent
      // accesses to the items array are not local when reading columns, we
      // have a cache miss every time. To reduce cache misses, get up to
      // 'numBuffers' items at a time and store them into the individual
      // buffers. The colBuffers should be small enough to fit into CPU cache.
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b, currentBuffer = 0;
      ll = bufferPadding + height;

      // Section F.3.5 VER_SR
      if (height === 1) {
          // if height = 1, when v0 even keep items as is, when odd divide by 2
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          // if we ran out of buffers, copy several image columns at once
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          // If this is last buffer in this group of buffers, flush all buffers.
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        width: width,
        height: height,
        items: items
      };
    };
    return Transform;
  })();

  // Section 3.8.2 Irreversible 9-7 filter
  var IrreversibleTransform = (function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter =
      function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;

      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;

      // step 1 is combined with step 3

      // step 2
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      // step 1 & 3
      j = offset - 2;
      current = delta * x[j -1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      // step 4
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 5
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 6
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  })();

  // Section 3.8.1 Reversible 5-3 filter
  var ReversibleTransform = (function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter =
      function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += (x[j - 1] + x[j + 1]) >> 1;
      }
    };

    return ReversibleTransform;
  })();

  return JpxImage;
})();


/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/* This class implements the QM Coder decoding as defined in
 *   JPEG 2000 Part I Final Committee Draft Version 1.0
 *   Annex C.3 Arithmetic decoding procedure 
 * available at http://www.jpeg.org/public/fcd15444-1.pdf
 * 
 * The arithmetic decoder is used in conjunction with context models to decode
 * JPEG2000 and JBIG2 streams.
 */
var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
  // Table C-2
  var QeTable = [
    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},
    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},
    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},
    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},
    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},
    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},
    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},
    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},
    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},
    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},
    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},
    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},
    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},
    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},
    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},
    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},
    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},
    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},
    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},
    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},
    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},
    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},
    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},
    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},
    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},
    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},
    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},
    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},
    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},
    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},
    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},
    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},
    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},
    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},
    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},
    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},
    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},
    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},
    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},
    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},
    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},
    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},
    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},
    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},
    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},
    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},
    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}
  ];

  // C.3.5 Initialisation of the decoder (INITDEC)
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;

    this.chigh = data[start];
    this.clow = 0;

    this.byteIn();

    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
    this.clow = (this.clow << 7) & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }

  ArithmeticDecoder.prototype = {
    // C.3.4 Compressed data input (BYTEIN)
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += (data[bp] << 9);
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += (this.clow >> 16);
        this.clow &= 0xFFFF;
      }
    },
    // C.3.2 Decoding a decision (DECODE)
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      // contexts are packed into 1 byte:
      // highest 7 bits carry cx.index, lowest bit carries cx.mps
      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        // exchangeLps
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        // exchangeMps
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      // C.3.3 renormD;
      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
        this.clow = (this.clow << 1) & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;

      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };

  return ArithmeticDecoder;
})();

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,
           Promise */

'use strict';

var globalScope = (typeof window === 'undefined') ? this : window;

var isWorker = (typeof window === 'undefined');

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];

var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};

var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};

var AnnotationType = {
  WIDGET: 1,
  TEXT: 2,
  LINK: 3
};

var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};

var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};

// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
  globalScope.PDFJS = {};
}

globalScope.PDFJS.pdfBug = false;

PDFJS.VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};

// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
  // Intentionally start from 1 so it is easy to spot bad operators that will be
  // 0's.
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};

// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}

// Non-fatal warnings.
function warn(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}

// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
  // If multiple arguments were passed, pass them all to the log function.
  if (arguments.length > 1) {
    var logArguments = ['Error:'];
    logArguments.push.apply(logArguments, arguments);
    console.log.apply(console, logArguments);
    // Join the arguments into a single string for the lines below.
    msg = [].join.call(arguments, ' ');
  } else {
    console.log('Error: ' + msg);
  }
  console.log(backtrace());
  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
  throw new Error(msg);
}

function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}

function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}

var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};

var UnsupportedManager = PDFJS.UnsupportedManager =
  (function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function (cb) {
      listeners.push(cb);
    },
    notify: function (featureId) {
      warn('Unsupported feature "' + featureId + '"');
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
})();

// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
    return url;
  }
  var i;
  if (url.charAt(0) === '/') {
    // absolute path
    i = baseUrl.indexOf('://');
    if (url.charAt(1) === '/') {
      ++i;
    } else {
      i = baseUrl.indexOf('/', i + 3);
    }
    return baseUrl.substring(0, i) + url;
  } else {
    // relative path
    var pathLength = baseUrl.length;
    i = baseUrl.lastIndexOf('#');
    pathLength = i >= 0 ? i : pathLength;
    i = baseUrl.lastIndexOf('?', pathLength);
    pathLength = i >= 0 ? i : pathLength;
    var prefixLength = baseUrl.lastIndexOf('/', pathLength);
    return baseUrl.substring(0, prefixLength + 1) + url;
  }
}

// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
  if (!url) {
    return false;
  }
  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)
  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
  if (!protocol) {
    return allowRelative;
  }
  protocol = protocol[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
    case 'ftp':
    case 'mailto':
    case 'tel':
      return true;
    default:
      return false;
  }
}
PDFJS.isValidUrl = isValidUrl;

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, { value: value,
                                     enumerable: true,
                                     configurable: true,
                                     writable: false });
  return value;
}
PDFJS.shadow = shadow;

var PasswordResponses = PDFJS.PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

var PasswordException = (function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;

  return PasswordException;
})();
PDFJS.PasswordException = PasswordException;

var UnknownErrorException = (function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;

  return UnknownErrorException;
})();
PDFJS.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = (function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;

  return InvalidPDFException;
})();
PDFJS.InvalidPDFException = InvalidPDFException;

var MissingPDFException = (function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;

  return MissingPDFException;
})();
PDFJS.MissingPDFException = MissingPDFException;

var UnexpectedResponseException =
    (function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;

  return UnexpectedResponseException;
})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;

var NotImplementedException = (function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }

  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;

  return NotImplementedException;
})();

var MissingDataException = (function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;

  return MissingDataException;
})();

var XRefParseException = (function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;

  return XRefParseException;
})();


function bytesToString(bytes) {
  assert(bytes !== null && typeof bytes === 'object' &&
         bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}

function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}

function string32(value) {
  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,
                             (value >> 8) & 0xff, value & 0xff);
}

function log2(x) {
  var n = 1, i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}

function readInt8(data, start) {
  return (data[start] << 24) >> 24;
}

function readUint16(data, offset) {
  return (data[offset] << 8) | data[offset + 1];
}

function readUint32(data, offset) {
  return ((data[offset] << 24) | (data[offset + 1] << 16) |
         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
}

// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return (buffer16[0] === 1);
}

Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
  }
});

//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)
//// Lazy test if the userAgant support CanvasTypedArrays
function hasCanvasTypedArrays() {
  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  var ctx = canvas.getContext('2d');
  var imageData = ctx.createImageData(1, 1);
  return (typeof imageData.data.buffer !== 'undefined');
}

Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
  configurable: true,
  get: function PDFJS_hasCanvasTypedArrays() {
    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
  }
});

var Uint32ArrayView = (function Uint32ArrayViewClosure() {

  function Uint32ArrayView(buffer, length) {
    this.buffer = buffer;
    this.byteLength = buffer.length;
    this.length = length === undefined ? (this.byteLength >> 2) : length;
    ensureUint32ArrayViewProps(this.length);
  }
  Uint32ArrayView.prototype = Object.create(null);

  var uint32ArrayViewSetters = 0;
  function createUint32ArrayProp(index) {
    return {
      get: function () {
        var buffer = this.buffer, offset = index << 2;
        return (buffer[offset] | (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
      },
      set: function (value) {
        var buffer = this.buffer, offset = index << 2;
        buffer[offset] = value & 255;
        buffer[offset + 1] = (value >> 8) & 255;
        buffer[offset + 2] = (value >> 16) & 255;
        buffer[offset + 3] = (value >>> 24) & 255;
      }
    };
  }

  function ensureUint32ArrayViewProps(length) {
    while (uint32ArrayViewSetters < length) {
      Object.defineProperty(Uint32ArrayView.prototype,
        uint32ArrayViewSetters,
        createUint32ArrayProp(uint32ArrayViewSetters));
      uint32ArrayViewSetters++;
    }
  }

  return Uint32ArrayView;
})();
//#else
//PDFJS.hasCanvasTypedArrays = true;
//#endif

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];

var Util = PDFJS.Util = (function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
  // creating many intermediate strings.
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  // Concatenates two transformation matrices together and returns the result.
  Util.transform = function Util_transform(m1, m2) {
    return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    ];
  };

  // For 2d affine transforms
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  // Applies the transform to the rectangle and finds the minimum axially
  // aligned bounding box.
  Util.getAxialAlignedBoundingBox =
    function Util_getAxialAlignedBoundingBox(r, m) {

    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [
      Math.min(p1[0], p2[0], p3[0], p4[0]),
      Math.min(p1[1], p2[1], p3[1], p4[1]),
      Math.max(p1[0], p2[0], p3[0], p4[0]),
      Math.max(p1[1], p2[1], p3[1], p4[1])
    ];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  // Apply a generic 3d matrix M on a 3-vector v:
  //   | a b c |   | X |
  //   | d e f | x | Y |
  //   | g h i |   | Z |
  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
  // with v as [X,Y,Z]
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
  };

  // This calculation uses Singular Value Decomposition.
  // The SVD can be represented with formula A = USV. We are interested in the
  // matrix S here because it represents the scale values.
  Util.singularValueDecompose2dScale =
    function Util_singularValueDecompose2dScale(m) {

    var transpose = [m[0], m[2], m[1], m[3]];

    // Multiply matrix m with its transpose.
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];

    // Solve the second degree polynomial to get roots.
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;

    // Scale values are the square roots of the eigenvalues.
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
  // For coordinate systems whose origin lies in the bottom-left, this
  // means normalization to (BL,TR) ordering. For systems with origin in the
  // top-left, this means (TL,BR) ordering.
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0); // clone rect
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };

  // Returns a rectangle [x1, y1, x2, y2] corresponding to the
  // intersection of rect1 and rect2. If no intersection, returns 'false'
  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    // Order points along the axes
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];

    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    // X: first and second points belong to different rectangles?
    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||
        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
      // Intersection must be between second and third points
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    // Y: first and second points belong to different rectangles?
    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||
        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
      // Intersection must be between second and third points
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                     name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function() {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
})();

/**
 * PDF page viewport created based on scale, rotation and offset.
 * @class
 * @alias PDFJS.PageViewport
 */
var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
  /**
   * @constructor
   * @private
   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
   * @param scale {number} scale of the viewport.
   * @param rotation {number} rotations of the viewport in degrees.
   * @param offsetX {number} offset X
   * @param offsetY {number} offset Y
   * @param dontFlip {boolean} if true, axis Y will not be flipped.
   */
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    // creating transform to convert pdf coordinate system to the normal
    // canvas like coordinates taking in account scale and rotation
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
        break;
      case 90:
        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
        break;
      case 270:
        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
        break;
      //case 0:
      default:
        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC; rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    // creating transform for the following operations:
    // translate(-centerX, -centerY), rotate and flip vertically,
    // scale, and translate(offsetCanvasX, offsetCanvasY)
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];

    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
    /**
     * Clones viewport with additional properties.
     * @param args {Object} (optional) If specified, may contain the 'scale' or
     * 'rotation' properties to override the corresponding properties in
     * the cloned viewport.
     * @returns {PDFJS.PageViewport} Cloned viewport.
     */
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation,
                              this.offsetX, this.offsetY, args.dontFlip);
    },
    /**
     * Converts PDF point to the viewport coordinates. For examples, useful for
     * converting PDF location into canvas pixel coordinates.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the viewport coordinate space.
     * @see {@link convertToPdfPoint}
     * @see {@link convertToViewportRectangle}
     */
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    /**
     * Converts PDF rectangle to the viewport coordinates.
     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
     * @returns {Array} Contains corresponding coordinates of the rectangle
     * in the viewport coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToViewportRectangle:
      function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    /**
     * Converts viewport coordinates to the PDF location. For examples, useful
     * for converting canvas pixel location into PDF one.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the PDF coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
})();

var PDFStringTranslateTable = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
];

function stringToPDFString(str) {
  var i, n = str.length, strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    // UTF16BE BOM
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(
        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isInt(v) {
  return typeof v === 'number' && ((v | 0) === v);
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isNull(v) {
  return v === null;
}

function isName(v) {
  return v instanceof Name;
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  var dictType = v.get('Type');
  return isName(dictType) && dictType.name === type;
}

function isArray(v) {
  return v instanceof Array;
}

function isStream(v) {
  return typeof v === 'object' && v !== null && v.getBytes !== undefined;
}

function isArrayBuffer(v) {
  return typeof v === 'object' && v !== null && v.byteLength !== undefined;
}

function isRef(v) {
  return v instanceof Ref;
}

/**
 * Promise Capability object.
 *
 * @typedef {Object} PromiseCapability
 * @property {Promise} promise - A promise object.
 * @property {function} resolve - Fullfills the promise.
 * @property {function} reject - Rejects the promise.
 */

/**
 * Creates a promise capability object.
 * @alias PDFJS.createPromiseCapability
 *
 * @return {PromiseCapability} A capability object contains:
 * - a Promise, resolve and reject methods.
 */
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}

PDFJS.createPromiseCapability = createPromiseCapability;

/**
 * Polyfill for Promises:
 * The following promise implementation tries to generally implement the
 * Promise/A+ spec. Some notable differences from other promise libaries are:
 * - There currently isn't a seperate deferred and promise object.
 * - Unhandled rejections eventually show an error if they aren't handled.
 *
 * Based off of the work in:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=810490
 */
(function PromiseClosure() {
  if (globalScope.Promise) {
    // Promises existing in the DOM/Worker, checking presence of all/resolve
    if (typeof globalScope.Promise.all !== 'function') {
      globalScope.Promise.all = function (iterable) {
        var count = 0, results = [], resolve, reject;
        var promise = new globalScope.Promise(function (resolve_, reject_) {
          resolve = resolve_;
          reject = reject_;
        });
        iterable.forEach(function (p, i) {
          count++;
          p.then(function (result) {
            results[i] = result;
            count--;
            if (count === 0) {
              resolve(results);
            }
          }, reject);
        });
        if (count === 0) {
          resolve(results);
        }
        return promise;
      };
    }
    if (typeof globalScope.Promise.resolve !== 'function') {
      globalScope.Promise.resolve = function (value) {
        return new globalScope.Promise(function (resolve) { resolve(value); });
      };
    }
    if (typeof globalScope.Promise.reject !== 'function') {
      globalScope.Promise.reject = function (reason) {
        return new globalScope.Promise(function (resolve, reject) {
          reject(reason);
        });
      };
    }
    if (typeof globalScope.Promise.prototype.catch !== 'function') {
      globalScope.Promise.prototype.catch = function (onReject) {
        return globalScope.Promise.prototype.then(undefined, onReject);
      };
    }
    return;
  }
//#if !MOZCENTRAL
  var STATUS_PENDING = 0;
  var STATUS_RESOLVED = 1;
  var STATUS_REJECTED = 2;

  // In an attempt to avoid silent exceptions, unhandled rejections are
  // tracked and if they aren't handled in a certain amount of time an
  // error is logged.
  var REJECTION_TIMEOUT = 500;

  var HandlerManager = {
    handlers: [],
    running: false,
    unhandledRejections: [],
    pendingRejectionCheck: false,

    scheduleHandlers: function scheduleHandlers(promise) {
      if (promise._status === STATUS_PENDING) {
        return;
      }

      this.handlers = this.handlers.concat(promise._handlers);
      promise._handlers = [];

      if (this.running) {
        return;
      }
      this.running = true;

      setTimeout(this.runHandlers.bind(this), 0);
    },

    runHandlers: function runHandlers() {
      var RUN_TIMEOUT = 1; // ms
      var timeoutAt = Date.now() + RUN_TIMEOUT;
      while (this.handlers.length > 0) {
        var handler = this.handlers.shift();

        var nextStatus = handler.thisPromise._status;
        var nextValue = handler.thisPromise._value;

        try {
          if (nextStatus === STATUS_RESOLVED) {
            if (typeof handler.onResolve === 'function') {
              nextValue = handler.onResolve(nextValue);
            }
          } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;

              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
          }
        } catch (ex) {
          nextStatus = STATUS_REJECTED;
          nextValue = ex;
        }

        handler.nextPromise._updateStatus(nextStatus, nextValue);
        if (Date.now() >= timeoutAt) {
          break;
        }
      }

      if (this.handlers.length > 0) {
        setTimeout(this.runHandlers.bind(this), 0);
        return;
      }

      this.running = false;
    },

    addUnhandledRejection: function addUnhandledRejection(promise) {
      this.unhandledRejections.push({
        promise: promise,
        time: Date.now()
      });
      this.scheduleRejectionCheck();
    },

    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
      promise._unhandledRejection = false;
      for (var i = 0; i < this.unhandledRejections.length; i++) {
        if (this.unhandledRejections[i].promise === promise) {
          this.unhandledRejections.splice(i);
          i--;
        }
      }
    },

    scheduleRejectionCheck: function scheduleRejectionCheck() {
      if (this.pendingRejectionCheck) {
        return;
      }
      this.pendingRejectionCheck = true;
      setTimeout(function rejectionCheck() {
        this.pendingRejectionCheck = false;
        var now = Date.now();
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
            var unhandled = this.unhandledRejections[i].promise._value;
            var msg = 'Unhandled rejection: ' + unhandled;
            if (unhandled.stack) {
              msg += '\n' + unhandled.stack;
            }
            warn(msg);
            this.unhandledRejections.splice(i);
            i--;
          }
        }
        if (this.unhandledRejections.length) {
          this.scheduleRejectionCheck();
        }
      }.bind(this), REJECTION_TIMEOUT);
    }
  };

  function Promise(resolver) {
    this._status = STATUS_PENDING;
    this._handlers = [];
    try {
      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
    } catch (e) {
      this._reject(e);
    }
  }
  /**
   * Builds a promise that is resolved when all the passed in promises are
   * resolved.
   * @param {array} array of data and/or promises to wait for.
   * @return {Promise} New dependant promise.
   */
  Promise.all = function Promise_all(promises) {
    var resolveAll, rejectAll;
    var deferred = new Promise(function (resolve, reject) {
      resolveAll = resolve;
      rejectAll = reject;
    });
    var unresolved = promises.length;
    var results = [];
    if (unresolved === 0) {
      resolveAll(results);
      return deferred;
    }
    function reject(reason) {
      if (deferred._status === STATUS_REJECTED) {
        return;
      }
      results = [];
      rejectAll(reason);
    }
    for (var i = 0, ii = promises.length; i < ii; ++i) {
      var promise = promises[i];
      var resolve = (function(i) {
        return function(value) {
          if (deferred._status === STATUS_REJECTED) {
            return;
          }
          results[i] = value;
          unresolved--;
          if (unresolved === 0) {
            resolveAll(results);
          }
        };
      })(i);
      if (Promise.isPromise(promise)) {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
    return deferred;
  };

  /**
   * Checks if the value is likely a promise (has a 'then' function).
   * @return {boolean} true if value is thenable
   */
  Promise.isPromise = function Promise_isPromise(value) {
    return value && typeof value.then === 'function';
  };

  /**
   * Creates resolved promise
   * @param value resolve value
   * @returns {Promise}
   */
  Promise.resolve = function Promise_resolve(value) {
    return new Promise(function (resolve) { resolve(value); });
  };

  /**
   * Creates rejected promise
   * @param reason rejection value
   * @returns {Promise}
   */
  Promise.reject = function Promise_reject(reason) {
    return new Promise(function (resolve, reject) { reject(reason); });
  };

  Promise.prototype = {
    _status: null,
    _value: null,
    _handlers: null,
    _unhandledRejection: null,

    _updateStatus: function Promise__updateStatus(status, value) {
      if (this._status === STATUS_RESOLVED ||
          this._status === STATUS_REJECTED) {
        return;
      }

      if (status === STATUS_RESOLVED &&
          Promise.isPromise(value)) {
        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                   this._updateStatus.bind(this, STATUS_REJECTED));
        return;
      }

      this._status = status;
      this._value = value;

      if (status === STATUS_REJECTED && this._handlers.length === 0) {
        this._unhandledRejection = true;
        HandlerManager.addUnhandledRejection(this);
      }

      HandlerManager.scheduleHandlers(this);
    },

    _resolve: function Promise_resolve(value) {
      this._updateStatus(STATUS_RESOLVED, value);
    },

    _reject: function Promise_reject(reason) {
      this._updateStatus(STATUS_REJECTED, reason);
    },

    then: function Promise_then(onResolve, onReject) {
      var nextPromise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
      this._handlers.push({
        thisPromise: this,
        onResolve: onResolve,
        onReject: onReject,
        nextPromise: nextPromise
      });
      HandlerManager.scheduleHandlers(this);
      return nextPromise;
    },

    catch: function Promise_catch(onReject) {
      return this.then(undefined, onReject);
    }
  };

  globalScope.Promise = Promise;
//#else
//throw new Error('DOM Promise is not present');
//#endif
})();

var StatTimer = (function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = {};
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      // Remove timer from started so it can be called again.
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      // Find the longest name for padding purposes.
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
})();

PDFJS.createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  // Blob builder is deprecated in FF14 and removed in FF18.
  var bb = new MozBlobBuilder();
  bb.append(data);
  return bb.getBlob(contentType);
};

PDFJS.createObjectURL = (function createObjectURLClosure() {
  // Blob/createObjectURL is not available, falling back to data schema.
  var digits =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return function createObjectURL(data, contentType) {
    if (!PDFJS.disableCreateObjectURL &&
        typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = PDFJS.createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);
      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
})();

function MessageHandler(name, comObj) {
  this.name = name;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = {};
  var ah = this.actionHandler = {};

  ah['console_log'] = [function ahConsoleLog(data) {
    console.log.apply(console, data);
  }];
  ah['console_error'] = [function ahConsoleError(data) {
    console.error.apply(console, data);
  }];
  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
    UnsupportedManager.notify(data);
  }];

  comObj.onmessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  };
}

MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
   */
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that other side will callback with the response.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise:
    function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  /**
   * Sends raw message to the comObj.
   * @private
   * @param message {Object} Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   */
  postMessage: function (message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
};

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = JpxImage;
}

function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = (function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  });
  img.onerror = (function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  });
  img.src = imageUrl;
}
},{}],3:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":86}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],9:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],10:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./messages":14,"./trees":15}],11:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],12:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":6,"./adler32":7,"./crc32":9,"./inffast":11,"./inftrees":13}],13:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":6}],14:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],15:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":6}],16:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],17:[function(require,module,exports){
(function (process,Buffer){
var msg = require('pako/lib/zlib/messages');
var zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (mode < exports.DEFLATE || mode > exports.UNZIP)
    throw new TypeError("Bad argument");
    
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}

Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
  this.windowBits = windowBits;
  this.level = level;
  this.memLevel = memLevel;
  this.strategy = strategy;
  // dictionary not supported.
  
  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
    this.windowBits += 16;
    
  if (this.mode === exports.UNZIP)
    this.windowBits += 32;
    
  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
    this.windowBits = -this.windowBits;
    
  this.strm = new zstream();
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateInit2(
        this.strm,
        this.level,
        exports.Z_DEFLATED,
        this.windowBits,
        this.memLevel,
        this.strategy
      );
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      var status  = zlib_inflate.inflateInit2(
        this.strm,
        this.windowBits
      );
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
    return;
  }
  
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype.params = function() {
  throw new Error("deflateParams Not supported");
};

Zlib.prototype._writeCheck = function() {
  if (!this.init_done)
    throw new Error("write before init");
    
  if (this.mode === exports.NONE)
    throw new Error("already finalized");
    
  if (this.write_in_progress)
    throw new Error("write already in progress");
    
  if (this.pending_close)
    throw new Error("close is pending");
};

Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
  this._writeCheck();
  this.write_in_progress = true;
  
  var self = this;
  process.nextTick(function() {
    self.write_in_progress = false;
    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
    self.callback(res[0], res[1]);
    
    if (self.pending_close)
      self.close();
  });
  
  return this;
};

// set method for Node buffers, used by pako
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}

Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this._writeCheck();
  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this.write_in_progress = true;
  
  if (flush !== exports.Z_NO_FLUSH &&
      flush !== exports.Z_PARTIAL_FLUSH &&
      flush !== exports.Z_SYNC_FLUSH &&
      flush !== exports.Z_FULL_FLUSH &&
      flush !== exports.Z_FINISH &&
      flush !== exports.Z_BLOCK) {
    throw new Error("Invalid flush value");
  }
  
  if (input == null) {
    input = new Buffer(0);
    in_len = 0;
    in_off = 0;
  }
  
  if (out._set)
    out.set = out._set;
  else
    out.set = bufferSet;
  
  var strm = this.strm;
  strm.avail_in = in_len;
  strm.input = input;
  strm.next_in = in_off;
  strm.avail_out = out_len;
  strm.output = out;
  strm.next_out = out_off;
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflate(strm, flush);
      break;
    case exports.UNZIP:
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflate(strm, flush);
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
    this._error(status);
  }
  
  this.write_in_progress = false;
  return [strm.avail_in, strm.avail_out];
};

Zlib.prototype.close = function() {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }
  
  this.pending_close = false;
  
  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else {
    zlib_inflate.inflateEnd(this.strm);
  }
  
  this.mode = exports.NONE;
};

Zlib.prototype.reset = function() {
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflateReset(this.strm);
      break;
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
  }
};

Zlib.prototype._error = function(status) {
  this.onerror(msg[status] + ': ' + this.strm.msg, status);
  
  this.write_in_progress = false;
  if (this.pending_close)
    this.close();
};

exports.Zlib = Zlib;

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":68,"buffer":20,"pako/lib/zlib/constants":8,"pako/lib/zlib/deflate.js":10,"pako/lib/zlib/inflate.js":12,"pako/lib/zlib/messages":14,"pako/lib/zlib/zstream":16}],18:[function(require,module,exports){
(function (process,Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this,require('_process'),require("buffer").Buffer)

},{"./binding":17,"_process":68,"_stream_transform":79,"assert":3,"buffer":20,"util":86}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":27,"isarray":21}],21:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],22:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 1 11111111 00000000000000000000000 => 4286578688 => 0xff800000 (see IEEE 754-2008)
var NINF = 0xff800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = NINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],23:[function(require,module,exports){
'use strict';

// VARIABLES //

var FLOAT32_VIEW = new Float32Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT32_VIEW.buffer );

// 0 11111111 00000000000000000000000 => 2139095040 => 0x7f800000 (see IEEE 754-2008)
var PINF = 0x7f800000;

// Set the ArrayBuffer bit sequence:
UINT32_VIEW[ 0 ] = PINF;


// EXPORTS //

module.exports = FLOAT32_VIEW[ 0 ];

},{}],24:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":29}],25:[function(require,module,exports){
(function (Buffer){
/*! dicom-parser - v1.7.3 - 2016-08-18 | (c) 2014 Chris Hafey | https://github.com/chafey/dicomParser */
(function (root, factory) {

    // node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else {
        // Browser globals
        if(typeof cornerstone === 'undefined'){
            dicomParser = {};

            // meteor
            if (typeof Package !== 'undefined') {
                root.dicomParser = dicomParser;
            }
        }
        dicomParser = factory();
    }
}(this, function () {

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.parseDicom = function(byteArray, options) {

        if(byteArray === undefined)
        {
            throw "dicomParser.parseDicom: missing required parameter 'byteArray'";
        }

        function readTransferSyntax(metaHeaderDataSet) {
            if(metaHeaderDataSet.elements.x00020010 === undefined) {
                throw 'dicomParser.parseDicom: missing required meta header attribute 0002,0010';
            }
            var transferSyntaxElement = metaHeaderDataSet.elements.x00020010;
            return dicomParser.readFixedString(byteArray, transferSyntaxElement.dataOffset, transferSyntaxElement.length);
        }

        function isExplicit(transferSyntax) {
            if(transferSyntax === '1.2.840.10008.1.2') // implicit little endian
            {
                return false;
            }
            // all other transfer syntaxes should be explicit
            return true;
        }

        function getDataSetByteStream(transferSyntax, position) {
            if(transferSyntax === '1.2.840.10008.1.2.1.99')
            {
                // if an infalter callback is registered, use it
                if (options && options.inflater) {
                    var fullByteArrayCallback = options.inflater(byteArray, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayCallback, 0);
                }
                // if running on node, use the zlib library to inflate
                // http://stackoverflow.com/questions/4224606/how-to-check-whether-a-script-is-running-under-node-js
                else if (typeof module !== 'undefined' && this.module !== module) {
                    // inflate it
                    var zlib = require('zlib');
                    var deflatedBuffer = dicomParser.sharedCopy(byteArray, position, byteArray.length - position);
                    var inflatedBuffer = zlib.inflateRawSync(deflatedBuffer);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArrayBuffer = dicomParser.alloc(byteArray, inflatedBuffer.length + position);
                    byteArray.copy(fullByteArrayBuffer, 0, 0, position);
                    inflatedBuffer.copy(fullByteArrayBuffer, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArrayBuffer, 0);
                }
                // if pako is defined - use it.  This is the web browser path
                // https://github.com/nodeca/pako
                else if(typeof pako !== "undefined") {
                    // inflate it
                    var deflated = byteArray.slice(position);
                    var inflated = pako.inflateRaw(deflated);

                    // create a single byte array with the full header bytes and the inflated bytes
                    var fullByteArray = dicomParser.alloc(byteArray, inflated.length + position);
                    fullByteArray.set(byteArray.slice(0, position), 0);
                    fullByteArray.set(inflated, position);
                    return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, fullByteArray, 0);
                }
                // throw exception since no inflater is available
                else {
                    throw 'dicomParser.parseDicom: no inflater available to handle deflate transfer syntax';
                }
            }
            if(transferSyntax === '1.2.840.10008.1.2.2') // explicit big endian
            {
                return new dicomParser.ByteStream(dicomParser.bigEndianByteArrayParser, byteArray, position);
            }
            else
            {
                // all other transfer syntaxes are little endian; only the pixel encoding differs
                // make a new stream so the metaheader warnings don't come along for the ride
                return new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray, position);
            }
        }

        function mergeDataSets(metaHeaderDataSet, instanceDataSet)
        {
            for (var propertyName in metaHeaderDataSet.elements)
            {
                if(metaHeaderDataSet.elements.hasOwnProperty(propertyName))
                {
                    instanceDataSet.elements[propertyName] = metaHeaderDataSet.elements[propertyName];
                }
            }
            if (metaHeaderDataSet.warnings !== undefined) {
                instanceDataSet.warnings = metaHeaderDataSet.warnings.concat(instanceDataSet.warnings);
            }
            return instanceDataSet;
        }

        function readDataSet(metaHeaderDataSet)
        {
            var transferSyntax = readTransferSyntax(metaHeaderDataSet);
            var explicit = isExplicit(transferSyntax);
            var dataSetByteStream = getDataSetByteStream(transferSyntax, metaHeaderDataSet.position);

            var elements = {};
            var dataSet = new dicomParser.DataSet(dataSetByteStream.byteArrayParser, dataSetByteStream.byteArray, elements);
            dataSet.warnings = dataSetByteStream.warnings;

            try{
                if(explicit) {
                    dicomParser.parseDicomDataSetExplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
                else
                {
                    dicomParser.parseDicomDataSetImplicit(dataSet, dataSetByteStream, dataSetByteStream.byteArray.length, options);
                }
            }
            catch(e) {
                var ex = {
                    exception: e,
                    dataSet: dataSet
                };
                throw ex;
            }
            return dataSet;
        }

        // main function here
        function parseTheByteStream() {
            var metaHeaderDataSet = dicomParser.readPart10Header(byteArray, options);

            var dataSet = readDataSet(metaHeaderDataSet);

            return mergeDataSets(metaHeaderDataSet, dataSet);
        }

        // This is where we actually start parsing
        return parseTheByteStream();
    };

    return dicomParser;
})(dicomParser);

/**
 * Utility function for creating a basic offset table for JPEG transfer syntaxes
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // Each JPEG image has an end of image marker 0xFFD9
  function isEndOfImageMarker(dataSet, position) {
    return (dataSet.byteArray[position] === 0xFF &&
    dataSet.byteArray[position + 1] === 0xD9);
  }

  function isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex) {
    var fragment = pixelDataElement.fragments[fragmentIndex];
    // Need to check the last two bytes and the last three bytes for marker since odd length
    // fragments are zero padded
    if(isEndOfImageMarker(dataSet, fragment.position + fragment.length - 2) ||
      isEndOfImageMarker(dataSet, fragment.position + fragment.length - 3)) {
      return true;
    }
    return false;
  }

  function findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragment) {
    for(var fragmentIndex=startFragment; fragmentIndex < pixelDataElement.fragments.length; fragmentIndex++) {
      if(isFragmentEndOfImage(dataSet, pixelDataElement, fragmentIndex)) {
        return fragmentIndex;
      }
    }
  }

  /**
   * Creates a basic offset table by scanning fragments for JPEG start of image and end Of Image markers
   * @param {object} dataSet - the parsed dicom dataset
   * @param {object} pixelDataElement - the pixel data element
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {Array} basic offset table (array of offsets to beginning of each frame)
   */
  dicomParser.createJPEGBasicOffsetTable = function(dataSet, pixelDataElement, fragments) {
    // Validate parameters
    if(dataSet === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet';
    }
    if(pixelDataElement === undefined) {
      throw 'dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement';
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(fragments && fragments.length <=0) {
      throw "dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";
    }

    // Default values
    fragments = fragments || pixelDataElement.fragments;

    var basicOffsetTable = [];

    var startFragmentIndex = 0;

    while(true) {
      // Add the offset for the start fragment
      basicOffsetTable.push(pixelDataElement.fragments[startFragmentIndex].offset);
      var endFragmentIndex = findLastImageFrameFragmentIndex(dataSet, pixelDataElement, startFragmentIndex);
      if(endFragmentIndex === undefined || endFragmentIndex === pixelDataElement.fragments.length -1) {
        return basicOffsetTable;
      }
      startFragmentIndex = endFragmentIndex + 1;
    }
  };

  return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * converts an explicit dataSet to a javascript object
     * @param dataSet
     * @param options
     */
    dicomParser.explicitDataSetToJS = function (dataSet, options) {

        if(dataSet === undefined) {
            throw 'dicomParser.explicitDataSetToJS: missing required parameter dataSet';
        }

        options = options || {
            omitPrivateAttibutes: true, // true if private elements should be omitted
            maxElementLength : 128      // maximum element length to try and convert to string format
        };

        var result = {

        };

        for(var tag in dataSet.elements) {
            var element = dataSet.elements[tag];

            // skip this element if it a private element and our options specify that we should
            if(options.omitPrivateAttibutes === true && dicomParser.isPrivateTag(tag))
            {
                continue;
            }

            if(element.items) {
                // handle sequences
                var sequenceItems = [];
                for(var i=0; i < element.items.length; i++) {
                    sequenceItems.push(dicomParser.explicitDataSetToJS(element.items[i].dataSet, options));
                }
                result[tag] = sequenceItems;
            } else {
                var asString;
                asString = undefined;
                if(element.length < options.maxElementLength) {
                    asString = dicomParser.explicitElementToString(dataSet, element);
                }

                if(asString !== undefined) {
                    result[tag] = asString;
                }  else {
                    result[tag] = {
                        dataOffset: element.dataOffset,
                        length : element.length
                    };
                }
            }
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
var dicomParser = (function (dicomParser) {
    "use strict";

    if (dicomParser === undefined) {
        dicomParser = {};
    }

    /**
     * Converts an explicit VR element to a string or undefined if it is not possible to convert.
     * Throws an error if an implicit element is supplied
     * @param dataSet
     * @param element
     * @returns {*}
     */
    dicomParser.explicitElementToString = function(dataSet, element)
    {
        if(dataSet === undefined || element === undefined) {
            throw 'dicomParser.explicitElementToString: missing required parameters';
        }
        if(element.vr === undefined) {
            throw 'dicomParser.explicitElementToString: cannot convert implicit element to string';
        }
        var vr = element.vr;
        var tag = element.tag;

        var textResult;

        function multiElementToString(numItems, func) {
            var result = "";
            for(var i=0; i < numItems; i++) {
                if(i !== 0) {
                    result += '/';
                }
                result += func.call(dataSet, tag, i).toString();
            }
            return result;
        }

        if(dicomParser.isStringVr(vr) === true)
        {
            textResult = dataSet.string(tag);
        }
        else if (vr == 'AT') {
            var num = dataSet.uint32(tag);
            if(num === undefined) {
                return undefined;
            }
            if (num < 0)
            {
                num = 0xFFFFFFFF + num + 1;
            }

            return 'x' + num.toString(16).toUpperCase();
        }
        else if (vr == 'US')
        {
            textResult = multiElementToString(element.length / 2, dataSet.uint16);
        }
        else if(vr === 'SS')
        {
            textResult = multiElementToString(element.length / 2, dataSet.int16);
        }
        else if (vr == 'UL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.uint32);
        }
        else if(vr === 'SL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.int32);
        }
        else if(vr == 'FD')
        {
            textResult = multiElementToString(element.length / 8, dataSet.double);
        }
        else if(vr == 'FL')
        {
            textResult = multiElementToString(element.length / 4, dataSet.float);
        }

        return textResult;
    };
    return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  // algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month
  function daysInMonth(m, y) { // m is 0 indexed: 0-11
    switch (m) {
      case 2 :
        return (y % 4 == 0 && y % 100) || y % 400 == 0 ? 29 : 28;
      case 9 : case 4 : case 6 : case 11 :
      return 30;
      default :
        return 31
    }
  }

  function isValidDate(d, m, y) {
    // make year is a number
    if(isNaN(y)) {
      return false;
    }
    return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
  }


  /**
   * Parses a DA formatted string into a Javascript object
   * @param {string} date a string in the DA VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long
   */
  dicomParser.parseDA = function(date, validate)
  {
    if(date && date.length === 8)
    {
      var yyyy = parseInt(date.substring(0, 4), 10);
      var mm = parseInt(date.substring(4, 6), 10);
      var dd = parseInt(date.substring(6, 8), 10);

      if(validate) {
        if (isValidDate(dd, mm, yyyy) !== true) {
          throw "invalid DA '" + date + "'";
        }
      }
      return {
        year: yyyy,
        month: mm,
        day: dd
      };
    }
    if(validate) {
      throw "invalid DA '" + date + "'";
    }
    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds
   * @param {string} time - a string in the TM VR format
   * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
   * @returns {*} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined
   */
  dicomParser.parseTM = function(time, validate) {

    if (time.length >= 2) // must at least have HH
    {
      // 0123456789
      // HHMMSS.FFFFFF
      var hh = parseInt(time.substring(0, 2), 10);
      var mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;
      var ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;
      var ffffff = time.length >= 8 ? parseInt(time.substring(7, 13), 10) : undefined;

      if(validate) {
        if((isNaN(hh)) ||
          (mm !== undefined && isNaN(mm)) ||
          (ss !== undefined && isNaN(ss)) ||
          (ffffff !== undefined && isNaN(ffffff)) ||
          (hh < 0 || hh > 23) ||
          (mm && (mm <0 || mm > 59))  ||
          (ss && (ss <0 || ss > 59))  ||
          (ffffff && (ffffff <0 || ffffff > 999999)))
        {
          throw "invalid TM '" + time + "'";
        }
      }

      return {
        hours: hh,
        minutes: mm,
        seconds: ss,
        fractionalSeconds: ffffff
      };
    }

    if(validate) {
      throw "invalid TM '" + time + "'";
    }

    return undefined;
  };

  return dicomParser;
}(dicomParser));
/**
 * Utility functions for dealing with DICOM
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var stringVrs = {
        AE: true,
        AS: true,
        AT: false,
        CS: true,
        DA: true,
        DS: true,
        DT: true,
        FL: false,
        FD: false,
        IS: true,
        LO: true,
        LT: true,
        OB: false,
        OD: false,
        OF: false,
        OW: false,
        PN: true,
        SH: true,
        SL: false,
        SQ: false,
        SS: false,
        ST: true,
        TM: true,
        UI: true,
        UL: false,
        UN: undefined, // dunno
        UR: true,
        US: false,
        UT: true
    };

    /**
     * Tests to see if vr is a string or not.
     * @param vr
     * @returns true if string, false it not string, undefined if unknown vr or UN type
     */
    dicomParser.isStringVr = function(vr)
    {
        return stringVrs[vr];
    };

    /**
     * Tests to see if a given tag in the format xggggeeee is a private tag or not
     * @param tag
     * @returns {boolean}
     */
    dicomParser.isPrivateTag = function(tag)
    {
        var lastGroupDigit = parseInt(tag[4]);
        var groupIsOdd = (lastGroupDigit % 2) === 1;
        return groupIsOdd;
    };

    /**
     * Parses a PN formatted string into a javascript object with properties for givenName, familyName, middleName, prefix and suffix
     * @param personName a string in the PN VR format
     * @param index
     * @returns {*} javascript object with properties for givenName, familyName, middleName, prefix and suffix or undefined if no element or data
     */
    dicomParser.parsePN = function(personName) {
        if(personName === undefined) {
            return undefined;
        }
        var stringValues = personName.split('^');
        return {
            familyName: stringValues[0],
            givenName: stringValues[1],
            middleName: stringValues[2],
            prefix: stringValues[3],
            suffix: stringValues[4]
        };
    };



    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    var deprecatedNoticeLogged = false;

    /**
     * Returns the pixel data for the specified frame in an encapsulated pixel data element.  If no basic offset
     * table is present, it assumes that all fragments are for one frame.  Note that this assumption/logic is not
     * valid for multi-frame instances so this function has been deprecated and will eventually be removed.  Code
     * should be updated to use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     *
     * @deprecated since version 1.6 - use readEncapsulatedPixelDataFromFragments() or readEncapsulatedImageFrame()
     * @param dataSet - the dataSet containing the encapsulated pixel data
     * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
     * @param frame - the zero based frame index
     * @returns {object} with the encapsulated pixel data
     */


    dicomParser.readEncapsulatedPixelData = function(dataSet, pixelDataElement, frame)
    {
        if(!deprecatedNoticeLogged) {
            deprecatedNoticeLogged = true;
            if(console && console.log) {
                console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated");
            }
        }

        if(dataSet === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";
        }
        if(pixelDataElement === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";
        }
        if(frame === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";
        }
        if(pixelDataElement.tag !== 'x7fe00010') {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010'";
        }
        if(pixelDataElement.encapsulatedPixelData !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.hadUndefinedLength !== true) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.basicOffsetTable === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(pixelDataElement.fragments === undefined) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
        }
        if(frame < 0) {
            throw "dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";
        }

        // If the basic offset table is not empty, we can extract the frame
        if(pixelDataElement.basicOffsetTable.length !== 0)
        {
            return dicomParser.readEncapsulatedImageFrame(dataSet, pixelDataElement, frame);
        }
        else
        {
            // No basic offset table, assume all fragments are for one frame - NOTE that this is NOT a valid
            // assumption but is the original behavior so we are keeping it for now
            return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, 0, pixelDataElement.fragments.length);
        }
    };

    return dicomParser;
}(dicomParser));

/**
 *
 * Internal helper function to allocate new byteArray buffers
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a new byteArray of the same type (Uint8Array or Buffer) of the specified length.
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param length number of bytes of the Byte Array
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.alloc = function(byteArray, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return Buffer.alloc(length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(length);
    } else {
      throw 'dicomParser.alloc: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a big-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.bigEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return (byteArray[position] << 8) + byteArray[position + 1];
        },

        /**
         *
         * Parses a signed int 16 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = (byteArray[position] << 8) + byteArray[position + 1];
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },

        /**
         * Parses an unsigned int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (256 * (256 * (256 * byteArray[position] +
                                              byteArray[position + 1]) +
                                              byteArray[position + 2]) +
                                              byteArray[position + 3]);

            return uint32;
        },

        /**
         * Parses a signed int 32 from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = ((byteArray[position] << 24) +
                         (byteArray[position + 1] << 16) +
                         (byteArray[position + 2] << 8) +
                          byteArray[position + 3]);

            return int32;
        },

        /**
         * Parses 32-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[3] = byteArray[position];
            byteArrayForParsingFloat[2] = byteArray[position + 1];
            byteArrayForParsingFloat[1] = byteArray[position + 2];
            byteArrayForParsingFloat[0] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a big-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'bigEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'bigEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[7] = byteArray[position];
            byteArrayForParsingFloat[6] = byteArray[position + 1];
            byteArrayForParsingFloat[5] = byteArray[position + 2];
            byteArrayForParsingFloat[4] = byteArray[position + 3];
            byteArrayForParsingFloat[3] = byteArray[position + 4];
            byteArrayForParsingFloat[2] = byteArray[position + 5];
            byteArrayForParsingFloat[1] = byteArray[position + 6];
            byteArrayForParsingFloat[0] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions common to parsing byte arrays of any type
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.  Trailing and leading
     * spaces are preserved (not trimmed)
     * @param byteArray the byteArray to read from
     * @param position the position in the byte array to read from
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     * @access private
     */
    dicomParser.readFixedString = function(byteArray, position, length)
    {
        if(length < 0)
        {
            throw 'dicomParser.readFixedString - length cannot be less than 0';
        }

        if(position + length > byteArray.length) {
            throw 'dicomParser.readFixedString: attempt to read past end of buffer';
        }

        var result = "";
        var byte;
        for(var i=0; i < length; i++)
        {
            byte = byteArray[position + i];
            if(byte === 0) {
                position +=  length;
                return result;
            }
            result += String.fromCharCode(byte);
        }

        return result;
    };


    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper class to assist with parsing. Supports reading from a byte
 * stream contained in a Uint8Array.  Example usage:
 *
 *  var byteArray = new Uint8Array(32);
 *  var byteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);
 *
 * */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Constructor for ByteStream objects.
     * @param byteArrayParser a parser for parsing the byte array
     * @param byteArray a Uint8Array containing the byte stream
     * @param position (optional) the position to start reading from.  0 if not specified
     * @constructor
     * @throws will throw an error if the byteArrayParser parameter is not present
     * @throws will throw an error if the byteArray parameter is not present or invalid
     * @throws will throw an error if the position parameter is not inside the byte array
     */
    dicomParser.ByteStream = function(byteArrayParser, byteArray, position) {
        if(byteArrayParser === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArrayParser'";
        }
        if(byteArray === undefined)
        {
            throw "dicomParser.ByteStream: missing required parameter 'byteArray'";
        }
        if((byteArray instanceof Uint8Array) === false &&
          (byteArray instanceof Buffer) === false ) {
            throw 'dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer';
        }
        if(position < 0)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be less than 0";
        }
        if(position >= byteArray.length)
        {
            throw "dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";

        }
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.position = position ? position : 0;
        this.warnings = []; // array of string warnings encountered while parsing
    };

    /**
     * Safely seeks through the byte stream.  Will throw an exception if an attempt
     * is made to seek outside of the byte array.
     * @param offset the number of bytes to add to the position
     * @throws error if seek would cause position to be outside of the byteArray
     */
    dicomParser.ByteStream.prototype.seek = function(offset)
    {
        if(this.position + offset < 0)
        {
            throw "dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";
        }
        this.position += offset;
    };

    /**
     * Returns a new ByteStream object from the current position and of the requested number of bytes
     * @param numBytes the length of the byte array for the ByteStream to contain
     * @returns {dicomParser.ByteStream}
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readByteStream = function(numBytes)
    {
        if(this.position + numBytes > this.byteArray.length) {
            throw 'dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread';
        }
        var byteArrayView = dicomParser.sharedCopy(this.byteArray, this.position, numBytes);
        this.position += numBytes;
        return new dicomParser.ByteStream(this.byteArrayParser, byteArrayView);
    };

    /**
     *
     * Parses an unsigned int 16 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parsed unsigned int 16
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint16 = function()
    {
        var result = this.byteArrayParser.readUint16(this.byteArray, this.position);
        this.position += 2;
        return result;
    };

    /**
     * Parses an unsigned int 32 from a byte array and advances
     * the position by 2 bytes
     *
     * @returns {*} the parse unsigned int 32
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readUint32 = function()
    {
        var result = this.byteArrayParser.readUint32(this.byteArray, this.position);
        this.position += 4;
        return result;
    };

    /**
     * Reads a string of 8-bit characters from an array of bytes and advances
     * the position by length bytes.  A null terminator will end the string
     * but will not effect advancement of the position.
     * @param length the maximum number of bytes to parse
     * @returns {string} the parsed string
     * @throws error if buffer overread would occur
     */
    dicomParser.ByteStream.prototype.readFixedString = function(length)
    {
        var result = dicomParser.readFixedString(this.byteArray, this.position, length);
        this.position += length;
        return result;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * The DataSet class encapsulates a collection of DICOM Elements and provides various functions
 * to access the data in those elements
 *
 * Rules for handling padded spaces:
 * DS = Strip leading and trailing spaces
 * DT = Strip trailing spaces
 * IS = Strip leading and trailing spaces
 * PN = Strip trailing spaces
 * TM = Strip trailing spaces
 * AE = Strip leading and trailing spaces
 * CS = Strip leading and trailing spaces
 * SH = Strip leading and trailing spaces
 * LO = Strip leading and trailing spaces
 * LT = Strip trailing spaces
 * ST = Strip trailing spaces
 * UT = Strip trailing spaces
 *
 */
var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getByteArrayParser(element, defaultParser)
    {
        return (element.parser !== undefined ? element.parser : defaultParser);
    }

    /**
     * Constructs a new DataSet given byteArray and collection of elements
     * @param byteArrayParser
     * @param byteArray
     * @param elements
     * @constructor
     */
    dicomParser.DataSet = function(byteArrayParser, byteArray, elements)
    {
        this.byteArrayParser = byteArrayParser;
        this.byteArray = byteArray;
        this.elements = elements;
    };

    /**
     * Finds the element for tag and returns an unsigned int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint16(this.byteArray, element.dataOffset + (index *2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 16 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 16 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int16 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt16(this.byteArray, element.dataOffset + (index * 2));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an unsigned int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} unsigned int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.uint32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readUint32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns an signed int 32 if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} signed int 32 or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.int32 = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readInt32(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 32 bit floating point number (VR=FL) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or has data of length 0
     */
    dicomParser.DataSet.prototype.float = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readFloat(this.byteArray, element.dataOffset + (index * 4));
        }
        return undefined;
    };

    /**
     * Finds the element for tag and returns a 64 bit floating point number (VR=FD) if it exists and has data
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the value in a multivalued element.  Default is index 0 if not supplied
     * @returns {*} float or undefined if the attribute is not present or doesn't has data of length 0
     */
    dicomParser.DataSet.prototype.double = function(tag, index)
    {
        var element = this.elements[tag];
        index = (index !== undefined) ? index : 0;
        if(element && element.length !== 0)
        {
            return getByteArrayParser(element, this.byteArrayParser).readDouble(this.byteArray, element.dataOffset + (index * 8));
        }
        return undefined;
    };

    /**
     * Returns the number of string values for the element
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @returns {*} the number of string values or undefined if the attribute is not present or has zero length data
     */
    dicomParser.DataSet.prototype.numStringValues = function(tag)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            var numMatching = fixedString.match(/\\/g);
            if(numMatching === null)
            {
                return 1;
            }
            return numMatching.length + 1;
        }
        return undefined;
    };

    /**
     * Returns a string for the element.  If index is provided, the element is assumed to be
     * multi-valued and will return the component specified by index.  Undefined is returned
     * if there is no component with the specified index, the element does not exist or is zero length.
     *
     * Use this function for VR types of AE, CS, SH and LO
     *
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the entire string
     * @returns {*}
     */
    dicomParser.DataSet.prototype.string = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                // trim trailing spaces
                return values[index].trim();
            }
            else
            {
                // trim trailing spaces
                return fixedString.trim();
            }
        }
        return undefined;
    };

    /**
     * Returns a string with the leading spaces preserved and trailing spaces removed.
     *
     * Use this function to access data for VRs of type UT, ST and LT
     *
     * @param tag
     * @param index
     * @returns {*}
     */
    dicomParser.DataSet.prototype.text = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            var fixedString = dicomParser.readFixedString(this.byteArray, element.dataOffset, element.length);
            if(index >= 0)
            {
                var values = fixedString.split('\\');
                return values[index].replace(/ +$/, '');
            }
            else
            {
                return fixedString.replace(/ +$/, '');
            }
        }
        return undefined;
    };

    /**
     * Parses a string to a float for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} a floating point number or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.floatString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0)
        {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseFloat(value);
            }
        }
        return undefined;
    };

    /**
     * Parses a string to an integer for the specified index in a multi-valued element.  If index is not specified,
     * the first value in a multi-valued VR will be parsed if present.
     * @param tag The DICOM tag in the format xGGGGEEEE
     * @param index the index of the desired value in a multi valued string or undefined for the first value
     * @returns {*} an integer or undefined if not present or data not long enough
     */
    dicomParser.DataSet.prototype.intString = function(tag, index)
    {
        var element = this.elements[tag];
        if(element && element.length > 0) {
            index = (index !== undefined) ? index : 0;
            var value = this.string(tag, index);
            if(value !== undefined) {
                return parseInt(value);
            }
        }
        return undefined;
    };

    //dicomParser.DataSet = DataSet;

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * reads from the byte stream until it finds the magic number for the Sequence Delimitation Item item
   * and then sets the length of the element
   * @param byteStream
   * @param element
   */
  dicomParser.findAndSetUNElementLength = function(byteStream, element)
  {
    if(byteStream === undefined)
    {
      throw "dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";
    }

    var itemDelimitationItemLength = 8; // group, element, length
    var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
    while(byteStream.position <= maxPosition)
    {
      var groupNumber;
      groupNumber = byteStream.readUint16();
      if(groupNumber === 0xfffe)
      {
        var elementNumber;
        elementNumber = byteStream.readUint16();
        if(elementNumber === 0xe0dd)
        {
          // NOTE: It would be better to also check for the length to be 0 as part of the check above
          // but we will just log a warning for now
          var itemDelimiterLength;
          itemDelimiterLength = byteStream.readUint32(); // the length
          if(itemDelimiterLength !== 0) {
            byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
          }
          element.length = byteStream.position - element.dataOffset;
          return;
        }
      }
    }

    // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
    element.length = byteStream.byteArray.length - element.dataOffset;
    byteStream.seek(byteStream.byteArray.length - byteStream.position);
  };


  return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads an encapsulated pixel data element and adds an array of fragments to the element
     * containing the offset and length of each fragment and any offsets from the basic offset
     * table
     * @param byteStream
     * @param element
     */
    dicomParser.findEndOfEncapsulatedElement = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";
        }

        element.encapsulatedPixelData = true;
        element.basicOffsetTable = [];
        element.fragments = [];
        var basicOffsetTableItemTag = dicomParser.readTag(byteStream);
        if(basicOffsetTableItemTag !== 'xfffee000') {
            throw "dicomParser.findEndOfEncapsulatedElement: basic offset table not found";
        }
        var basicOffsetTableItemlength = byteStream.readUint32();
        var numFragments = basicOffsetTableItemlength / 4;
        for(var i =0; i < numFragments; i++) {
            var offset = byteStream.readUint32();
            element.basicOffsetTable.push(offset);
        }
        var baseOffset = byteStream.position;

        while(byteStream.position < byteStream.byteArray.length)
        {
            var tag = dicomParser.readTag(byteStream);
            var length = byteStream.readUint32();
            if(tag === 'xfffee0dd')
            {
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }
            else if(tag === 'xfffee000')
            {
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
            }
            else {
                if(warnings) {
                    warnings.push('unexpected tag ' + tag + ' while searching for end of pixel data element with undefined length');
                }
                if(length > byteStream.byteArray.length - byteStream.position)
                {
                    // fix length
                    length = byteStream.byteArray.length - byteStream.position;
                }
                element.fragments.push({
                    offset: byteStream.position - baseOffset - 8,
                    position : byteStream.position,
                    length : length
                });
                byteStream.seek(length);
                element.length = byteStream.position - element.dataOffset;
                return;
            }

            byteStream.seek(length);
        }

        if(warnings) {
            warnings.push("pixel data element " + element.tag + " missing sequence delimiter tag xfffee0dd");
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads from the byte stream until it finds the magic numbers for the item delimitation item
     * and then sets the length of the element
     * @param byteStream
     * @param element
     */
    dicomParser.findItemDelimitationItemAndSetElementLength = function(byteStream, element)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var itemDelimitationItemLength = 8; // group, element, length
        var maxPosition = byteStream.byteArray.length - itemDelimitationItemLength;
        while(byteStream.position <= maxPosition)
        {
            var groupNumber = byteStream.readUint16();
            if(groupNumber === 0xfffe)
            {
                var elementNumber = byteStream.readUint16();
                if(elementNumber === 0xe00d)
                {
                    // NOTE: It would be better to also check for the length to be 0 as part of the check above
                    // but we will just log a warning for now
                    var itemDelimiterLength = byteStream.readUint32(); // the length
                    if(itemDelimiterLength !== 0) {
                        byteStream.warnings('encountered non zero length following item delimiter at position' + byteStream.position - 4 + " while reading element of undefined length with tag ' + element.tag");
                    }
                    element.length = byteStream.position - element.dataOffset;
                    return;
                }
            }
        }

        // No item delimitation item - silently set the length to the end of the buffer and set the position past the end of the buffer
        element.length = byteStream.byteArray.length - element.dataOffset;
        byteStream.seek(byteStream.byteArray.length - byteStream.position);
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing different types from a little-endian byte array
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    dicomParser.littleEndianByteArrayParser = {
        /**
         *
         * Parses an unsigned int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint16: attempt to read past end of buffer';
            }
            return byteArray[position] + (byteArray[position + 1] * 256);
        },

        /**
         *
         * Parses a signed int 16 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed signed int 16
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt16: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt16: position cannot be less than 0';
            }
            if (position + 2 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt16: attempt to read past end of buffer';
            }
            var int16 = byteArray[position] + (byteArray[position + 1] << 8);
            // fix sign
            if (int16 & 0x8000) {
                int16 = int16 - 0xFFFF - 1;
            }
            return int16;
        },


        /**
         * Parses an unsigned int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readUint32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readUint32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readUint32: attempt to read past end of buffer';
            }

            var uint32 = (byteArray[position] +
            (byteArray[position + 1] * 256) +
            (byteArray[position + 2] * 256 * 256) +
            (byteArray[position + 3] * 256 * 256 * 256 ));

            return uint32;
        },

        /**
         * Parses a signed int 32 from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed unsigned int 32
         * @throws error if buffer overread would occur
         * @access private
         */
        readInt32: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readInt32: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readInt32: attempt to read past end of buffer';
            }

            var int32 = (byteArray[position] +
            (byteArray[position + 1] << 8) +
            (byteArray[position + 2] << 16) +
            (byteArray[position + 3] << 24));

            return int32;

        },

        /**
         * Parses 32-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 32-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readFloat: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readFloat: position cannot be less than 0';
            }

            if (position + 4 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readFloat: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(4);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            var floatArray = new Float32Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        },

        /**
         * Parses 64-bit float from a little-endian byte array
         *
         * @param byteArray the byte array to read from
         * @param position the position in the byte array to read from
         * @returns {*} the parsed 64-bit float
         * @throws error if buffer overread would occur
         * @access private
         */
        readDouble: function (byteArray, position) {
            if (position < 0) {
                throw 'littleEndianByteArrayParser.readDouble: position cannot be less than 0';
            }

            if (position + 8 > byteArray.length) {
                throw 'littleEndianByteArrayParser.readDouble: attempt to read past end of buffer';
            }

            // I am sure there is a better way than this but this should be safe
            var byteArrayForParsingFloat = new Uint8Array(8);
            byteArrayForParsingFloat[0] = byteArray[position];
            byteArrayForParsingFloat[1] = byteArray[position + 1];
            byteArrayForParsingFloat[2] = byteArray[position + 2];
            byteArrayForParsingFloat[3] = byteArray[position + 3];
            byteArrayForParsingFloat[4] = byteArray[position + 4];
            byteArrayForParsingFloat[5] = byteArray[position + 5];
            byteArrayForParsingFloat[6] = byteArray[position + 6];
            byteArrayForParsingFloat[7] = byteArray[position + 7];
            var floatArray = new Float64Array(byteArrayForParsingFloat.buffer);
            return floatArray[0];
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing implicit and explicit DICOM data sets
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * reads an explicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetExplicit = function (dataSet, byteStream, maxPosition, options) {

        maxPosition = (maxPosition === undefined) ? byteStream.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxPosition'";
        }
        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, dataSet.warnings, options.untilTag);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
        if(byteStream.position > maxPosition) {
            throw "dicomParser:parseDicomDataSetExplicit: buffer overrun";
        }
    };

    /**
     * reads an implicit data set
     * @param byteStream the byte stream to read from
     * @param maxPosition the maximum position to read up to (optional - only needed when reading sequence items)
     */
    dicomParser.parseDicomDataSetImplicit = function(dataSet, byteStream, maxPosition, options)
    {
        maxPosition = (maxPosition === undefined) ? dataSet.byteArray.length : maxPosition ;
        options = options || {};

        if(byteStream === undefined)
        {
            throw "dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";
        }
        if(maxPosition < byteStream.position || maxPosition > byteStream.byteArray.length)
        {
            throw "dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";
        }

        var elements = dataSet.elements;

        while(byteStream.position < maxPosition)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, options.untilTag, options.vrCallback);
            elements[element.tag] = element;
            if(element.tag === options.untilTag) {
                return;
            }
        }
    };

    return dicomParser;
}(dicomParser));

/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function getDataLengthSizeInBytesForVR(vr)
    {
        if( vr === 'OB' ||
            vr === 'OW' ||
            vr === 'SQ' ||
            vr === 'OF' ||
            vr === 'UT' ||
            vr === 'UN')
        {
            return 4;
        }
        else
        {
            return 2;
        }
    }

    dicomParser.readDicomElementExplicit = function(byteStream, warnings, untilTag)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            vr : byteStream.readFixedString(2)
            // length set below based on VR
            // dataOffset set below based on VR and size of length
        };

        var dataLengthSizeBytes = getDataLengthSizeInBytesForVR(element.vr);
        if(dataLengthSizeBytes === 2)
        {
            element.length = byteStream.readUint16();
            element.dataOffset = byteStream.position;
        }
        else
        {
            byteStream.seek(2);
            element.length = byteStream.readUint32();
            element.dataOffset = byteStream.position;
        }

        if(element.length === 4294967295)
        {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        // if VR is SQ, parse the sequence items
        if(element.vr === 'SQ')
        {
            dicomParser.readSequenceItemsExplicit(byteStream, element, warnings);
            return element;
        }


        if(element.length === 4294967295)
        {
            if(element.tag === 'x7fe00010') {
                dicomParser.findEndOfEncapsulatedElement(byteStream, element, warnings);
                return element;
            }   else if(element.vr === 'UN') {
                dicomParser.findAndSetUNElementLength(byteStream, element);
                return element;
            } else {
                dicomParser.readSequenceItemsImplicit(byteStream, element);
                //dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
                return element;
            }
        }

        byteStream.seek(element.length);
        return element;
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function isSequence(element, byteStream, vrCallback) {
        // if a data dictionary callback was provided, use that to verify that the element is a sequence.
        if (typeof vrCallback !== 'undefined') {
            return (vrCallback(element.tag) === 'SQ');
        }
        if ((byteStream.position + 4) <= byteStream.byteArray.length) {
            var nextTag = dicomParser.readTag(byteStream);
            byteStream.seek(-4);
            // Item start tag (fffe,e000) or sequence delimiter (i.e. end of sequence) tag (0fffe,e0dd)
            // These are the tags that could potentially be found directly after a sequence start tag (the delimiter
            // is found in the case of an empty sequence). This is not 100% safe because a non-sequence item
            // could have data that has these bytes, but this is how to do it without a data dictionary.
            return (nextTag === 'xfffee000') || (nextTag === 'xfffee0dd');
        }
        byteStream.warnings.push('eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR');
        return false;
    }

    dicomParser.readDicomElementImplicit = function(byteStream, untilTag, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length: byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if(element.length === 4294967295) {
            element.hadUndefinedLength = true;
        }

        if(element.tag === untilTag) {
            return element;
        }

        if (isSequence(element, byteStream, vrCallback)) {
            // parse the sequence
            dicomParser.readSequenceItemsImplicit(byteStream, element);
            return element;
        }

        // if element is not a sequence and has undefined length, we have to
        // scan the data for a magic number to figure out when it ends.
        if(element.hadUndefinedLength)
        {
            dicomParser.findItemDelimitationItemAndSetElementLength(byteStream, element);
            return element;
        }

        // non sequence element with known length, skip over the data part
        byteStream.seek(element.length);
        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function findFragmentIndexWithOffset(fragments, offset) {
    for(var i=0; i < fragments.length; i++) {
      if(fragments[i].offset === offset) {
        return i;
      }
    }
  }

  function calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex) {
    // special case for last frame
    if(frameIndex === basicOffsetTable.length -1) {
      return fragments.length - startFragmentIndex;
    }

    // iterate through each fragment looking for the one matching the offset for the next frame
    var nextFrameOffset = basicOffsetTable[frameIndex + 1];
    for(var i=startFragmentIndex + 1; i < fragments.length; i++) {
      if(fragments[i].offset === nextFrameOffset) {
        return i - startFragmentIndex;
      }
    }

    throw "dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table";
  }

  /**
   * Returns the pixel data for the specified frame in an encapsulated pixel data element that has a non
   * empty basic offset table.  Note that this function will fail if the basic offset table is empty - in that
   * case you need to determine which fragments map to which frames and read them using
   * readEncapsulatedPixelDataFromFragments().  Also see the function createJEPGBasicOffsetTable() to see
   * how a basic offset table can be created for JPEG images
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the frame from
   * @param frameIndex - the zero based frame index
   * @param [basicOffsetTable] - optional array of starting offsets for frames
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedImageFrame = function(dataSet, pixelDataElement, frameIndex, basicOffsetTable, fragments)
  {
    // default parameters
    basicOffsetTable = basicOffsetTable || pixelDataElement.basicOffsetTable;
    fragments = fragments || pixelDataElement.fragments;

    // Validate parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";
    }
    if(frameIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";
    }
    if(basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";
    }
    if(basicOffsetTable.length === 0) {
      throw "dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";
    }
    if(frameIndex < 0) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";
    }
    if(frameIndex >= basicOffsetTable.length) {
      throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";
    }

    // find starting fragment based on the offset for the frame in the basic offset table
    var offset = basicOffsetTable[frameIndex];
    var startFragmentIndex = findFragmentIndexWithOffset(fragments, offset);
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";
    }

    // calculate the number of fragments for this frame
    var numFragments = calculateNumberOfFragmentsForFrame(frameIndex, basicOffsetTable, fragments, startFragmentIndex);

    // now extract the frame from the fragments
    return dicomParser.readEncapsulatedPixelDataFromFragments(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments);
  };

  return dicomParser;
}(dicomParser));

/**
 * Functionality for extracting encapsulated pixel data
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  function calculateBufferSize(fragments, startFragment, numFragments) {
    var bufferSize = 0;
    for(var i=startFragment; i < startFragment + numFragments; i++) {
      bufferSize += fragments[i].length;
    }
    return bufferSize;
  }

  /**
   * Returns the encapsulated pixel data from the specified fragments.  Use this function when you know
   * the fragments you want to extract data from.  See
   *
   * @param dataSet - the dataSet containing the encapsulated pixel data
   * @param pixelDataElement - the pixel data element (x7fe00010) to extract the fragment data from
   * @param startFragmentIndex - zero based index of the first fragment to extract from
   * @param [numFragments] - the number of fragments to extract from, default is 1
   * @param [fragments] - optional array of objects describing each fragment (offset, position, length)
   * @returns {object} byte array with the encapsulated pixel data
   */
  dicomParser.readEncapsulatedPixelDataFromFragments = function(dataSet, pixelDataElement, startFragmentIndex, numFragments, fragments)
  {
    // default values
    numFragments = numFragments || 1;
    fragments = fragments || pixelDataElement.fragments;

    // check parameters
    if(dataSet === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";
    }
    if(pixelDataElement === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";
    }
    if(startFragmentIndex === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";
    }
    if(numFragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";
    }
    if(pixelDataElement.tag !== 'x7fe00010') {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
    }
    if(pixelDataElement.encapsulatedPixelData !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.hadUndefinedLength !== true) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.basicOffsetTable === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments === undefined) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(pixelDataElement.fragments.length <= 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
    }
    if(startFragmentIndex < 0) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";
    }
    if(startFragmentIndex >= pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";
    }
    if(numFragments < 1) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";
    }
    if(startFragmentIndex + numFragments > pixelDataElement.fragments.length) {
      throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";
    }

    // create byte stream on the data for this pixel data element
    var byteStream = new dicomParser.ByteStream(dataSet.byteArrayParser, dataSet.byteArray, pixelDataElement.dataOffset);

    // seek past the basic offset table (no need to parse it again since we already have)
    var basicOffsetTable = dicomParser.readSequenceItem(byteStream);
    if(basicOffsetTable.tag !== 'xfffee000')
    {
      throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
    }
    byteStream.seek(basicOffsetTable.length);

    var fragmentZeroPosition = byteStream.position;
    var fragmentHeaderSize = 8; // tag + length

    // if there is only one fragment, return a view on this array to avoid copying
    if(numFragments === 1) {
      return dicomParser.sharedCopy(byteStream.byteArray, fragmentZeroPosition + fragments[startFragmentIndex].offset + fragmentHeaderSize, fragments[startFragmentIndex].length);
    }

    // more than one fragment, combine all of the fragments into one buffer
    var bufferSize = calculateBufferSize(fragments, startFragmentIndex, numFragments);

    var pixelData = dicomParser.alloc(byteStream.byteArray, bufferSize);

    var pixelDataIndex = 0;
    for(var i=startFragmentIndex; i < startFragmentIndex + numFragments; i++) {
      var fragmentOffset = fragmentZeroPosition + fragments[i].offset + fragmentHeaderSize;
      for(var j=0; j < fragments[i].length; j++) {
        pixelData[pixelDataIndex++] = byteStream.byteArray[fragmentOffset++];
      }
    }

    return pixelData;
  };

  return dicomParser;
}(dicomParser));

/**
 * Parses a DICOM P10 byte array and returns a DataSet object with the parsed elements.  If the options
 * argument is supplied and it contains the untilTag property, parsing will stop once that
 * tag is encoutered.  This can be used to parse partial byte streams.
 *
 * @param byteArray the byte array
 * @param options object to control parsing behavior (optional)
 * @returns {DataSet}
 * @throws error if an error occurs while parsing.  The exception object will contain a property dataSet with the
 *         elements successfully parsed before the error.
 */
var dicomParser = (function(dicomParser) {
  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.readPart10Header = function(byteArray, options) {

    if(byteArray === undefined)
    {
      throw "dicomParser.readPart10Header: missing required parameter 'byteArray'";
    }

    var littleEndianByteStream = new dicomParser.ByteStream(dicomParser.littleEndianByteArrayParser, byteArray);

    function readPrefix()
    {
      littleEndianByteStream.seek(128);
      var prefix = littleEndianByteStream.readFixedString(4);
      if(prefix !== "DICM")
      {
        throw "dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.";
      }
    }

    // main function here
    function readTheHeader() {
      // Per the DICOM standard, the header is always encoded in Explicit VR Little Endian (see PS3.10, section 7.1)
      // so use littleEndianByteStream throughout this method regardless of the transfer syntax
      readPrefix();

      var warnings = [];
      var elements = {};
      while(littleEndianByteStream.position < littleEndianByteStream.byteArray.length) {
        var position = littleEndianByteStream.position;
        var element = dicomParser.readDicomElementExplicit(littleEndianByteStream, warnings);
        if(element.tag > 'x0002ffff') {
          littleEndianByteStream.position = position;
          break;
        }
        // Cache the littleEndianByteArrayParser for meta header elements, since the rest of the data set may be big endian
        // and this parser will be needed later if the meta header values are to be read.
        element.parser = dicomParser.littleEndianByteArrayParser;
        elements[element.tag] = element;
      }
      var metaHeaderDataSet = new dicomParser.DataSet(littleEndianByteStream.byteArrayParser, littleEndianByteStream.byteArray, elements);
      metaHeaderDataSet.warnings = littleEndianByteStream.warnings;
      metaHeaderDataSet.position = littleEndianByteStream.position;
      return metaHeaderDataSet;
    }

    // This is where we actually start parsing
    return readTheHeader();
  };

  return dicomParser;
})(dicomParser);

/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetExplicitUndefinedLength(byteStream, warnings)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementExplicit(byteStream, warnings);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }

        }

        // eof encountered - log a warning and return what we have for the element
        warnings.push('eof encountered before finding item delimiter tag while reading sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemExplicit(byteStream, warnings)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetExplicitUndefinedLength(byteStream, warnings);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetExplicit(item.dataSet, byteStream, byteStream.position + item.length);
        }
        return item;
    }

    function readSQElementUndefinedLengthExplicit(byteStream, element, warnings)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
        warnings.push('eof encountered before finding sequence delimitation tag while reading sequence of undefined length');
        element.length = byteStream.position - element.dataOffset;
    }

    function readSQElementKnownLengthExplicit(byteStream, element, warnings)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemExplicit(byteStream, warnings);
            element.items.push(item);
        }
    }

    dicomParser.readSequenceItemsExplicit = function(byteStream, element, warnings)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthExplicit(byteStream, element, warnings);
        }
        else
        {
            readSQElementKnownLengthExplicit(byteStream, element, warnings);
        }
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    function readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback)
    {
        var elements = {};

        while(byteStream.position < byteStream.byteArray.length)
        {
            var element = dicomParser.readDicomElementImplicit(byteStream, undefined, vrCallback);
            elements[element.tag] = element;

            // we hit an item delimiter tag, return the current offset to mark
            // the end of this sequence item
            if(element.tag === 'xfffee00d')
            {
                return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
            }
        }
        // eof encountered - log a warning and return what we have for the element
        byteStream.warnings.push('eof encountered before finding sequence item delimiter in sequence item of undefined length');
        return new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, elements);
    }

    function readSequenceItemImplicit(byteStream, vrCallback)
    {
        var item = dicomParser.readSequenceItem(byteStream);

        if(item.length === 4294967295)
        {
            item.hadUndefinedLength = true;
            item.dataSet = readDicomDataSetImplicitUndefinedLength(byteStream, vrCallback);
            item.length = byteStream.position - item.dataOffset;
        }
        else
        {
            item.dataSet = new dicomParser.DataSet(byteStream.byteArrayParser, byteStream.byteArray, {});
            dicomParser.parseDicomDataSetImplicit(item.dataSet, byteStream, byteStream.position + item.length, {vrCallback: vrCallback});
        }
        return item;
    }

    function readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback)
    {
        while((byteStream.position + 4) <= byteStream.byteArray.length)
        {
          // end reading this sequence if the next tag is the sequence delimitation item
          var nextTag = dicomParser.readTag(byteStream);
          byteStream.seek(-4);
          if (nextTag === 'xfffee0dd') {
            // set the correct length
            element.length = byteStream.position - element.dataOffset;
            byteStream.seek(8);
            return element;
          }

          var item = readSequenceItemImplicit(byteStream, vrCallback);
          element.items.push(item);
        }
        byteStream.warnings.push('eof encountered before finding sequence delimiter in sequence of undefined length');
        element.length = byteStream.byteArray.length - element.dataOffset;
    }

    function readSQElementKnownLengthImplicit(byteStream, element, vrCallback)
    {
        var maxPosition = element.dataOffset + element.length;
        while(byteStream.position < maxPosition)
        {
            var item = readSequenceItemImplicit(byteStream, vrCallback);
            element.items.push(item);
        }
    }

    /**
     * Reads sequence items for an element in an implicit little endian byte stream
     * @param byteStream the implicit little endian byte stream
     * @param element the element to read the sequence items for
     * @param vrCallback an optional method that returns a VR string given a tag
     */
    dicomParser.readSequenceItemsImplicit = function(byteStream, element, vrCallback)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";
        }
        if(element === undefined)
        {
            throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";
        }

        element.items = [];

        if(element.length === 4294967295)
        {
            readSQElementUndefinedLengthImplicit(byteStream, element, vrCallback);
        }
        else
        {
            readSQElementKnownLengthImplicit(byteStream, element, vrCallback);
        }
    };

    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads the tag and length of a sequence item and returns them as an object with the following properties
     *  tag : string for the tag of this element in the format xggggeeee
     *  length: the number of bytes in this item or 4294967295 if undefined
     *  dataOffset: the offset into the byteStream of the data for this item
     * @param byteStream the byte
     * @returns {{tag: string, length: integer, dataOffset: integer}}
     */
    dicomParser.readSequenceItem = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readSequenceItem: missing required parameter 'byteStream'";
        }

        var element = {
            tag : dicomParser.readTag(byteStream),
            length : byteStream.readUint32(),
            dataOffset :  byteStream.position
        };

        if (element.tag !== 'xfffee000') {
            var startPosition = byteStream.position;
            throw "dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset " + startPosition;
        }

        return element;
    };


    return dicomParser;
}(dicomParser));
/**
 * Internal helper functions for parsing DICOM elements
 */

var dicomParser = (function (dicomParser)
{
    "use strict";

    if(dicomParser === undefined)
    {
        dicomParser = {};
    }

    /**
     * Reads a tag (group number and element number) from a byteStream
     * @param byteStream the byte stream to read from
     * @returns {string} the tag in format xggggeeee where gggg is the lowercase hex value of the group number
     * and eeee is the lower case hex value of the element number
     */
    dicomParser.readTag = function(byteStream)
    {
        if(byteStream === undefined)
        {
            throw "dicomParser.readTag: missing required parameter 'byteStream'";
        }

        var groupNumber =  byteStream.readUint16() * 256 * 256;
        var elementNumber = byteStream.readUint16();
        var tag = "x" + ('00000000' + (groupNumber + elementNumber).toString(16)).substr(-8);
        return tag;
    };

    return dicomParser;
}(dicomParser));
/**
 *
 * Internal helper function to create a shared copy of a byteArray
 *
 */
var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  /**
   * Creates a view of the underlying byteArray.  The view is of the same type as the byteArray (e.g.
   * Uint8Array or Buffer) and shares the same underlying memory (changing one changes the other)
   * @param byteArray the underlying byteArray (either Uint8Array or Buffer)
   * @param byteOffset offset into the underlying byteArray to create the view of
   * @param length number of bytes in the view
   * @returns {object} Uint8Array or Buffer depending on the type of byteArray
   */
  dicomParser.sharedCopy = function(byteArray, byteOffset, length) {
    if (typeof Buffer !== 'undefined' && byteArray instanceof Buffer) {
      return byteArray.slice(byteOffset, byteOffset + length);
    }
    else if(byteArray instanceof Uint8Array) {
      return new Uint8Array(byteArray.buffer, byteArray.byteOffset + byteOffset, length);
    } else {
      throw 'dicomParser.from: unknown type for byteArray';
    }
  };

  return dicomParser;
}(dicomParser));
/**
 * Version
 */

var dicomParser = (function (dicomParser)
{
  "use strict";

  if(dicomParser === undefined)
  {
    dicomParser = {};
  }

  dicomParser.version = "1.7.3";

  return dicomParser;
}(dicomParser));
    return dicomParser;
}));

}).call(this,require("buffer").Buffer)

},{"buffer":20,"zlib":18}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],30:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {
    this.hSamp = 0; // Horizontal sampling factor
    this.quantTableSel = 0; // Quantization table destination selector
    this.vSamp = 0; // Vertical
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ComponentSpec;
}

},{}],31:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {
    this.buffer = new DataView(data, offset, length);
    this.index = 0;
};



jpeg.lossless.DataStream.prototype.get16 = function () {
    var value = this.buffer.getUint16(this.index, false);
    this.index += 2;
    return value;
};



jpeg.lossless.DataStream.prototype.get8 = function () {
    var value = this.buffer.getUint8(this.index);
    this.index += 1;
    return value;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.DataStream;
}

},{}],32:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {
    this.buffer = buffer;
    this.frame = new jpeg.lossless.FrameHeader();
    this.huffTable = new jpeg.lossless.HuffmanTable();
    this.quantTable = new jpeg.lossless.QuantizationTable();
    this.scan = new jpeg.lossless.ScanHeader();
    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component
    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);
    this.IDCT_Source = [];
    this.nBlock = []; // number of blocks in the i-th Comp in a scan
    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan
    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan
    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan
    this.marker = 0;
    this.markerIndex = 0;
    this.numComp = 0;
    this.restartInterval = 0;
    this.selection = 0;
    this.xDim = 0;
    this.yDim = 0;
    this.xLoc = 0;
    this.yLoc = 0;
    this.numBytes = 0;
    this.outputData = null;
    this.restarting = false;
    this.mask = 0;

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }
};


/*** Static Pseudo-constants ***/

jpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,
    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];
jpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
jpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;
jpeg.lossless.Decoder.MSB = 0x80000000;
jpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;
jpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;

/*** Prototype Methods ***/

jpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {
    return this.decode(buffer, offset, length).buffer;
};



jpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {
    /*jslint bitwise: true */

    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;

    if (typeof buffer !== "undefined") {
        this.buffer = buffer;
    }

    if (typeof numBytes !== "undefined") {
        this.numBytes = numBytes;
    }

    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);
    this.buffer = null;

    this.xLoc = 0;
    this.yLoc = 0;
    current = this.stream.get16();

    if (current !== 0xFFD8) { // SOI
        throw new Error("Not a JPEG file");
    }

    current = this.stream.get16();

    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15
        switch (current) {
            case 0xFFC4: // DHT
                this.huffTable.read(this.stream, this.HuffTab);
                break;
            case 0xFFCC: // DAC
                throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
            case 0xFFDB:
                this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                break;
            case 0xFFDD:
                this.restartInterval = this.readNumber();
                break;
            case 0xFFE0:
            case 0xFFE1:
            case 0xFFE2:
            case 0xFFE3:
            case 0xFFE4:
            case 0xFFE5:
            case 0xFFE6:
            case 0xFFE7:
            case 0xFFE8:
            case 0xFFE9:
            case 0xFFEA:
            case 0xFFEB:
            case 0xFFEC:
            case 0xFFED:
            case 0xFFEE:
            case 0xFFEF:
                this.readApp();
                break;
            case 0xFFFE:
                this.readComment();
                break;
            default:
                if ((current >> 8) !== 0xFF) {
                    throw new Error("ERROR: format throw new IOException! (decode)");
                }
        }

        current = this.stream.get16();
    }

    if ((current < 0xFFC0) || (current > 0xFFC7)) {
        throw new Error("ERROR: could not handle arithmetic code!");
    }

    this.frame.read(this.stream);
    current = this.stream.get16();

    do {
        while (current !== 0x0FFDA) { // SOS
            switch (current) {
                case 0xFFC4: // DHT
                    this.huffTable.read(this.stream, this.HuffTab);
                    break;
                case 0xFFCC: // DAC
                    throw new Error("Program doesn't support arithmetic coding. (format throw new IOException)");
                case 0xFFDB:
                    this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);
                    break;
                case 0xFFDD:
                    this.restartInterval = this.readNumber();
                    break;
                case 0xFFE0:
                case 0xFFE1:
                case 0xFFE2:
                case 0xFFE3:
                case 0xFFE4:
                case 0xFFE5:
                case 0xFFE6:
                case 0xFFE7:
                case 0xFFE8:
                case 0xFFE9:
                case 0xFFEA:
                case 0xFFEB:
                case 0xFFEC:
                case 0xFFED:
                case 0xFFEE:
                case 0xFFEF:
                    this.readApp();
                    break;
                case 0xFFFE:
                    this.readComment();
                    break;
                default:
                    if ((current >> 8) !== 0xFF) {
                        throw new Error("ERROR: format throw new IOException! (Parser.decode)");
                    }
            }

            current = this.stream.get16();
        }

        this.precision = this.frame.precision;
        this.components = this.frame.components;

        if (!this.numBytes) {
            this.numBytes = parseInt(Math.ceil(this.precision / 8));
        }

        if (this.numBytes == 1) {
            this.mask = 0xFF;
        } else {
            this.mask = 0xFFFF;
        }

        this.scan.read(this.stream);
        this.numComp = this.scan.numComp;
        this.selection = this.scan.selection;

        if (this.numBytes === 1) {
            if (this.numComp === 3) {
                this.getter = this.getValueRGB;
                this.setter = this.setValueRGB;
                this.output = this.outputRGB;
            } else {
                this.getter = this.getValue8;
                this.setter = this.setValue8;
                this.output = this.outputSingle;
            }
        } else {
            this.getter = this.getValue16;
            this.setter = this.setValue16;
            this.output = this.outputSingle;
        }

        switch (this.selection) {
            case 2:
                this.selector = this.select2;
                break;
            case 3:
                this.selector = this.select3;
                break;
            case 4:
                this.selector = this.select4;
                break;
            case 5:
                this.selector = this.select5;
                break;
            case 6:
                this.selector = this.select6;
                break;
            case 7:
                this.selector = this.select7;
                break;
            default:
                this.selector = this.select1;
                break;
        }

        this.scanComps = this.scan.components;
        this.quantTables = this.quantTable.quantTables;

        for (i = 0; i < this.numComp; i+=1) {
            compN = this.scanComps[i].scanCompSel;
            this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];
            this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;
            this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];
            this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];
        }

        this.xDim = this.frame.dimX;
        this.yDim = this.frame.dimY;
        this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));

        scanNum+=1;

        while (true) { // Decode one scan
            temp[0] = 0;
            index[0] = 0;

            for (i = 0; i < 10; i+=1) {
                pred[i] = (1 << (this.precision - 1));
            }

            if (this.restartInterval === 0) {
                current = this.decodeUnit(pred, temp, index);

                while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {
                    this.output(pred);
                    current = this.decodeUnit(pred, temp, index);
                }

                break; //current=MARKER
            }

            for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {
                this.restarting = (mcuNum == 0);
                current = this.decodeUnit(pred, temp, index);
                this.output(pred);

                if (current !== 0) {
                    break;
                }
            }

            if (current === 0) {
                if (this.markerIndex !== 0) {
                    current = (0xFF00 | this.marker);
                    this.markerIndex = 0;
                } else {
                    current = this.stream.get16();
                }
            }

            if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&
                (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {
                break; //current=MARKER
            }
        }

        if ((current === 0xFFDC) && (scanNum === 1)) { //DNL
            this.readNumber();
            current = this.stream.get16();
        }
    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));

    return this.outputData;
};



jpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {
    if (this.numComp == 1) {
        return this.decodeSingle(prev, temp, index);
    } else if (this.numComp == 3) {
        return this.decodeRGB(prev, temp, index);
    } else {
        return -1;
    }
};



jpeg.lossless.Decoder.prototype.select1 = function (compOffset) {
    return this.getPreviousX(compOffset);
};



jpeg.lossless.Decoder.prototype.select2 = function (compOffset) {
    return this.getPreviousY(compOffset);
};



jpeg.lossless.Decoder.prototype.select3 = function (compOffset) {
    return this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select4 = function (compOffset) {
    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);
};



jpeg.lossless.Decoder.prototype.select5 = function (compOffset) {
    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select6 = function (compOffset) {
    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);
};



jpeg.lossless.Decoder.prototype.select7 = function (compOffset) {
    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);
};



jpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, actab, dctab, qtab, ctrC, i, k, j;

    prev[0] = this.selector(0);
    prev[1] = this.selector(1);
    prev[2] = this.selector(2);

    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {
        qtab = this.qTab[ctrC];
        actab = this.acTab[ctrC];
        dctab = this.dcTab[ctrC];
        for (i = 0; i < this.nBlock[ctrC]; i+=1) {
            for (k = 0; k < this.IDCT_Source.length; k+=1) {
                this.IDCT_Source[k] = 0;
            }

            value = this.getHuffmanValue(dctab, temp, index);

            if (value >= 0xFF00) {
                return value;
            }

            prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);
            this.IDCT_Source[0] *= qtab[0];

            for (j = 1; j < 64; j+=1) {
                value = this.getHuffmanValue(actab, temp, index);

                if (value >= 0xFF00) {
                    return value;
                }

                j += (value >> 4);

                if ((value & 0x0F) === 0) {
                    if ((value >> 4) === 0) {
                        break;
                    }
                } else {
                    this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];
                }
            }
        }
    }

    return 0;
};



jpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {
    /*jslint bitwise: true */

    var value, i, n, nRestart;

    if (this.restarting) {
        this.restarting = false;
        prev[0] = (1 << (this.frame.precision - 1));
    } else {
        prev[0] = this.selector();
    }

    for (i = 0; i < this.nBlock[0]; i+=1) {
        value = this.getHuffmanValue(this.dcTab[0], temp, index);
        if (value >= 0xFF00) {
            return value;
        }

        n = this.getn(prev, value, temp, index);
        nRestart = (n >> 8);

        if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {
            return nRestart;
        }

        prev[0] += n;
    }

    return 0;
};



//	Huffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8
//	bits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.
//	HuffTab[*][*][0-256] is always the only 1st-layer table.
//
//	An entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal
//
//	HuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                ):
//	    return: Huffman Value of table
//	            0xFF?? if it receives a MARKER
//	    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)
//	                temp    temp storage for remainded bits
//	                index   index to bit of temp
//	                in      FILE pointer
//	    Effect:
//	        temp  store new remainded bits
//	        index change to new index
//	        in    change to new position
//	    NOTE:
//	      Initial by   temp=0; index=0;
//	    NOTE: (explain temp and index)
//	      temp: is always in the form at calling time or returning time
//	       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |
//	       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER
//	                                               ^index=3 (from 0 to 15)
//	                                               321
//	    NOTE (marker and marker_index):
//	      If get a MARKER from 'in', marker=the low-byte of the MARKER
//	        and marker_index=9
//	      If marker_index=9 then index is always > 8, or HuffmanValue()
//	        will not be called
jpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {
    /*jslint bitwise: true */

    var code, input, mask;
    mask = 0xFFFF;

    if (index[0] < 8) {
        temp[0] <<= 8;
        input = this.stream.get8();
        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }
        temp[0] |= input;
    } else {
        index[0] -= 8;
    }

    code = table[temp[0] >> index[0]];

    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {
        if (this.markerIndex !== 0) {
            this.markerIndex = 0;
            return 0xFF00 | this.marker;
        }

        temp[0] &= (mask >> (16 - index[0]));
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];
        index[0] += 8;
    }

    index[0] += 8 - (code >> 8);

    if (index[0] < 0) {
        throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");
    }

    if (index[0] < this.markerIndex) {
        this.markerIndex = 0;
        return 0xFF00 | this.marker;
    }

    temp[0] &= (mask >> (16 - index[0]));
    return code & 0xFF;
};



jpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {
    /*jslint bitwise: true */

    var result, one, n_one, mask, input;
    one = 1;
    n_one = -1;
    mask = 0xFFFF;

    if (n === 0) {
        return 0;
    }

    if (n === 16) {
        if (PRED[0] >= 0) {
            return -32768;
        } else {
            return 32768;
        }
    }

    index[0] -= n;

    if (index[0] >= 0) {
        if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    } else {
        temp[0] <<= 8;
        input = this.stream.get8();

        if (input === 0xFF) {
            this.marker = this.stream.get8();
            if (this.marker !== 0) {
                this.markerIndex = 9;
            }
        }

        temp[0] |= input;
        index[0] += 8;

        if (index[0] < 0) {
            if (this.markerIndex !== 0) {
                this.markerIndex = 0;
                return (0xFF00 | this.marker) << 8;
            }

            temp[0] <<= 8;
            input = this.stream.get8();

            if (input === 0xFF) {
                this.marker = this.stream.get8();
                if (this.marker !== 0) {
                    this.markerIndex = 9;
                }
            }

            temp[0] |= input;
            index[0] += 8;
        }

        if (index[0] < 0) {
            throw new Error("index=" + index[0] + " in getn()");
        }

        if (index[0] < this.markerIndex) {
            this.markerIndex = 0;
            return (0xFF00 | this.marker) << 8;
        }

        result = temp[0] >> index[0];
        temp[0] &= (mask >> (16 - index[0]));
    }

    if (result < (one << (n - 1))) {
        result += (n_one << n) + 1;
    }

    return result;
};



jpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {
    /*jslint bitwise: true */

    if (this.xLoc > 0) {
        return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);
    } else if (this.yLoc > 0) {
        return this.getPreviousY(compOffset);
    } else {
        return (1 << (this.frame.precision - 1));
    }
};



jpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {
    /*jslint bitwise: true */

    if ((this.xLoc > 0) && (this.yLoc > 0)) {
        return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);
    } else {
        return this.getPreviousY(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {
    /*jslint bitwise: true */

    if (this.yLoc > 0) {
        return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);
    } else {
        return this.getPreviousX(compOffset);
    }
};



jpeg.lossless.Decoder.prototype.isLastPixel = function () {
    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));
};



jpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {
    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {
    var offset = ((this.yLoc * this.xDim) + this.xLoc);

    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {
        this.setter(offset, PRED[0], 0);
        this.setter(offset, PRED[1], 1);
        this.setter(offset, PRED[2], 2);

        this.xLoc+=1;

        if (this.xLoc >= this.xDim) {
            this.yLoc+=1;
            this.xLoc = 0;
        }
    }
};



jpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {
    this.outputData.setInt16(index * 2, val, true);
};



jpeg.lossless.Decoder.prototype.getValue16 = function (index) {
    return this.outputData.getInt16(index * 2, true);
};



jpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {
    this.outputData.setInt8(index, val);
};



jpeg.lossless.Decoder.prototype.getValue8 = function (index) {
    return this.outputData.getInt8(index);
};



jpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {
    this.outputData.setUint8(index * 3 + compOffset, val);
};



jpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {
    return this.outputData.getUint8(index * 3 + compOffset);
};



jpeg.lossless.Decoder.prototype.readApp = function() {
    var count = 0, length = this.stream.get16();
    count += 2;

    while (count < length) {
        this.stream.get8();
        count+=1;
    }

    return length;
};



jpeg.lossless.Decoder.prototype.readComment = function () {
    var sb = "", count = 0, length;

    length = this.stream.get16();
    count += 2;

    while (count < length) {
        sb += this.stream.get8();
        count+=1;
    }

    return sb;
};



jpeg.lossless.Decoder.prototype.readNumber = function() {
    var Ld = this.stream.get16();

    if (Ld !== 4) {
        throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");
    }

    return this.stream.get16();
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Decoder;
}

},{"./data-stream.js":31,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-header.js":38,"./utils.js":39}],33:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);


/*** Constructor ***/
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {
    this.components = []; // Components
    this.dimX = 0; // Number of samples per line
    this.dimY = 0; // Number of lines
    this.numComp = 0; // Number of component in the frame
    this.precision = 0; // Sample Precision (from the original image)
};



/*** Prototype Methods ***/

jpeg.lossless.FrameHeader.prototype.read = function (data) {
    /*jslint bitwise: true */

    var count = 0, length, i, c, temp;

    length = data.get16();
    count += 2;

    this.precision = data.get8();
    count+=1;

    this.dimY = data.get16();
    count += 2;

    this.dimX = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;
    for (i = 1; i <= this.numComp; i+=1) {
        if (count > length) {
            throw new Error("ERROR: frame format error");
        }

        c = data.get8();
        count+=1;

        if (count >= length) {
            throw new Error("ERROR: frame format error [c>=Lf]");
        }

        temp = data.get8();
        count+=1;

        if (!this.components[c]) {
            this.components[c] = new jpeg.lossless.ComponentSpec();
        }

        this.components[c].hSamp = temp >> 4;
        this.components[c].vSamp = temp & 0x0F;
        this.components[c].quantTableSel = data.get8();
        count+=1;
    }

    if (count !== length) {
        throw new Error("ERROR: frame format error [Lf!=count]");
    }

    return 1;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.FrameHeader;
}

},{"./component-spec.js":30,"./data-stream.js":31}],34:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {
    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);
    this.th = [];
    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);
    this.tc = jpeg.lossless.Utils.createArray(4, 2);

    this.tc[0][0] = 0;
    this.tc[1][0] = 0;
    this.tc[2][0] = 0;
    this.tc[3][0] = 0;
    this.tc[0][1] = 0;
    this.tc[1][1] = 0;
    this.tc[2][1] = 0;
    this.tc[3][1] = 0;
    this.th[0] = 0;
    this.th[1] = 0;
    this.th[2] = 0;
    this.th[3] = 0;
};



/*** Static Pseudo-constants ***/

jpeg.lossless.HuffmanTable.MSB = 0x80000000;


/*** Prototype Methods ***/

jpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, c, i, j;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;
        if (t > 3) {
            throw new Error("ERROR: Huffman table ID > 3");
        }

        c = temp >> 4;
        if (c > 2) {
            throw new Error("ERROR: Huffman table [Table class > 2 ]");
        }

        this.th[t] = 1;
        this.tc[t][c] = 1;

        for (i = 0; i < 16; i+=1) {
            this.l[t][c][i] = data.get8();
            count+=1;
        }

        for (i = 0; i < 16; i+=1) {
            for (j = 0; j < this.l[t][c][i]; j+=1) {
                if (count > length) {
                    throw new Error("ERROR: Huffman table format error [count>Lh]");
                }

                this.v[t][c][i][j] = data.get8();
                count+=1;
            }
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Huffman table format error [count!=Lf]");
    }

    for (i = 0; i < 4; i+=1) {
        for (j = 0; j < 2; j+=1) {
            if (this.tc[i][j] !== 0) {
                this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);
            }
        }
    }

    return 1;
};



//	Build_HuffTab()
//	Parameter:  t       table ID
//	            c       table class ( 0 for DC, 1 for AC )
//	            L[i]    # of codewords which length is i
//	            V[i][j] Huffman Value (length=i)
//	Effect:
//	    build up HuffTab[t][c] using L and V.
jpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {
    /*jslint bitwise: true */

    var currentTable, temp, k, i, j, n;
    temp = 256;
    k = 0;

    for (i = 0; i < 8; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i + 1)); n+=1) {
                tab[k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }
        }
    }

    for (i = 1; k < 256; i+=1, k+=1) {
        tab[k] = i | jpeg.lossless.HuffmanTable.MSB;
    }

    currentTable = 1;
    k = 0;

    for (i = 8; i < 16; i+=1) { // i+1 is Code length
        for (j = 0; j < L[i]; j+=1) {
            for (n = 0; n < (temp >> (i - 7)); n+=1) {
                tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);
                k+=1;
            }

            if (k >= 256) {
                if (k > 256) {
                    throw new Error("ERROR: Huffman table error(1)!");
                }

                k = 0;
                currentTable+=1;
            }
        }
    }
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.HuffmanTable;
}

},{"./data-stream.js":31,"./utils.js":39}],35:[function(require,module,exports){
/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== 'undefined') ? require('./component-spec.js') : null);
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== 'undefined') ? require('./decoder.js') : null);
jpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== 'undefined') ? require('./frame-header.js') : null);
jpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== 'undefined') ? require('./huffman-table.js') : null);
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== 'undefined') ? require('./quantization-table.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== 'undefined') ? require('./scan-header.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Exports ***/
var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg;
}

},{"./component-spec.js":30,"./data-stream.js":31,"./decoder.js":32,"./frame-header.js":33,"./huffman-table.js":34,"./quantization-table.js":36,"./scan-component.js":37,"./scan-header.js":38,"./utils.js":39}],36:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== 'undefined') ? require('./utils.js') : null);


/*** Constructor ***/
jpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {
    this.precision = []; // Quantization precision 8 or 16
    this.tq = []; // 1: this table is presented
    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables

    this.tq[0] = 0;
    this.tq[1] = 0;
    this.tq[2] = 0;
    this.tq[3] = 0;
};



/*** Static Methods ***/

jpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {
    /*jslint bitwise: true */

    var i;

    for (i = 0; i < 8; i+=1) {
        qtab[table[(0 * 8) + i]] *= 90;
        qtab[table[(4 * 8) + i]] *= 90;
        qtab[table[(2 * 8) + i]] *= 118;
        qtab[table[(6 * 8) + i]] *= 49;
        qtab[table[(5 * 8) + i]] *= 71;
        qtab[table[(1 * 8) + i]] *= 126;
        qtab[table[(7 * 8) + i]] *= 25;
        qtab[table[(3 * 8) + i]] *= 106;
    }

    for (i = 0; i < 8; i+=1) {
        qtab[table[0 + (8 * i)]] *= 90;
        qtab[table[4 + (8 * i)]] *= 90;
        qtab[table[2 + (8 * i)]] *= 118;
        qtab[table[6 + (8 * i)]] *= 49;
        qtab[table[5 + (8 * i)]] *= 71;
        qtab[table[1 + (8 * i)]] *= 126;
        qtab[table[7 + (8 * i)]] *= 25;
        qtab[table[3 + (8 * i)]] *= 106;
    }

    for (i = 0; i < 64; i+=1) {
        qtab[i] >>= 6;
    }
};


/*** Prototype Methods ***/

jpeg.lossless.QuantizationTable.prototype.read = function (data, table) {
    /*jslint bitwise: true */

    var count = 0, length, temp, t, i;

    length = data.get16();
    count += 2;

    while (count < length) {
        temp = data.get8();
        count+=1;
        t = temp & 0x0F;

        if (t > 3) {
            throw new Error("ERROR: Quantization table ID > 3");
        }

        this.precision[t] = temp >> 4;

        if (this.precision[t] === 0) {
            this.precision[t] = 8;
        } else if (this.precision[t] === 1) {
            this.precision[t] = 16;
        } else {
            throw new Error("ERROR: Quantization table precision error");
        }

        this.tq[t] = 1;

        if (this.precision[t] === 8) {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get8();
                count+=1;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        } else {
            for (i = 0; i < 64; i+=1) {
                if (count > length) {
                    throw new Error("ERROR: Quantization table format error");
                }

                this.quantTables[t][i] = data.get16();
                count += 2;
            }

            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);
        }
    }

    if (count !== length) {
        throw new Error("ERROR: Quantization table error [count!=Lq]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.QuantizationTable;
}

},{"./data-stream.js":31,"./utils.js":39}],37:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {
    this.acTabSel = 0; // AC table selector
    this.dcTabSel = 0; // DC table selector
    this.scanCompSel = 0; // Scan component selector
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanComponent;
}

},{}],38:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};
jpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== 'undefined') ? require('./data-stream.js') : null);
jpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== 'undefined') ? require('./scan-component.js') : null);


/*** Constructor ***/
jpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {
    this.ah = 0;
    this.al = 0;
    this.numComp = 0; // Number of components in the scan
    this.selection = 0; // Start of spectral or predictor selection
    this.spectralEnd = 0; // End of spectral selection
    this.components = [];
};


/*** Prototype Methods ***/

jpeg.lossless.ScanHeader.prototype.read = function(data) {
    /*jslint bitwise: true */

    var count = 0, length, i, temp;

    length = data.get16();
    count += 2;

    this.numComp = data.get8();
    count+=1;

    for (i = 0; i < this.numComp; i+=1) {
        this.components[i] = new jpeg.lossless.ScanComponent();

        if (count > length) {
            throw new Error("ERROR: scan header format error");
        }

        this.components[i].scanCompSel = data.get8();
        count+=1;

        temp = data.get8();
        count+=1;

        this.components[i].dcTabSel = (temp >> 4);
        this.components[i].acTabSel = (temp & 0x0F);
    }

    this.selection = data.get8();
    count+=1;

    this.spectralEnd = data.get8();
    count+=1;

    temp = data.get8();
    this.ah = (temp >> 4);
    this.al = (temp & 0x0F);
    count+=1;

    if (count !== length) {
        throw new Error("ERROR: scan header format error [count!=Ns]");
    }

    return 1;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.ScanHeader;
}

},{"./data-stream.js":31,"./scan-component.js":37}],39:[function(require,module,exports){
/*
 * Copyright (C) 2015 Michael Martinez
 * Changes: Added support for selection values 2-7, fixed minor bugs &
 * warnings, split into multiple class files, and general clean up.
 *
 * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.
 */

/*
 * Copyright (C) Helmut Dersch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/
var jpeg = jpeg || {};
jpeg.lossless = jpeg.lossless || {};


/*** Constructor ***/
jpeg.lossless.Utils = jpeg.lossless.Utils || {};


/*** Static methods ***/

// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
jpeg.lossless.Utils.createArray = function (length) {
    var arr = new Array(length || 0),
        i = length;

    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);
    }

    return arr;
};


// http://stackoverflow.com/questions/18638900/javascript-crc32
jpeg.lossless.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};

jpeg.lossless.Utils.crc32 = function(dataView) {
    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = jpeg.lossless.Utils;
}

},{}],40:[function(require,module,exports){
'use strict';

/**
* FUNCTION: abs( x )
*	Computes the absolute value of `x`.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	}
	if ( x === 0 ) {
		return 0; // handle negative zero
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;

},{}],41:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.ceil;

},{}],42:[function(require,module,exports){
'use strict';

// MODULES //

var floor = require( 'math-floor' );


// DIV2 //

/**
* FUNCTION: div2( x )
*	Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.
*
* @param {Number} x - nonnegative integer
* @returns {String} bit representation
*/
function div2( x ) {
	var str = '';
	var y;

	// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...
	while ( x > 0 ) {
		y = x / 2;
		x = floor( y );
		if ( y === x ) {
			str = '0' + str;
		} else {
			str = '1' + str;
		}
	}
	return str;
} // end FUNCTION div2()


// EXPORTS //

module.exports = div2;

},{"math-floor":45}],43:[function(require,module,exports){
'use strict';

// MODULES //

var pinf = require( 'const-pinf-float32' );
var ninf = require( 'const-ninf-float32' );
var abs = require( 'math-abs' );
var floor = require( 'math-floor' );
var rpad = require( 'utils-right-pad-string' );
var lpad = require( 'utils-left-pad-string' );
var repeat = require( 'utils-repeat-string' );
var div2 = require( './div2.js' );
var mult2 = require( './mult2.js' );


// CONSTANTS //

var BIAS = 127; // exponent bias => (2**8)/2 - 1


// BINARY STRING //

/**
* FUNCTION: binaryString( x )
*	Returns a string giving the literal bit representation of a single-precision floating-point number.
*
* @param {Number} x - input value
* @returns {String} bit representation
*/
function binaryString( x ) {
	var nbits;
	var sign;
	var str;
	var exp;
	var n;
	var f;
	var i;

	// Check for a negative value or negative zero...
	if ( x < 0 || 1/x === ninf ) {
		sign = '1';
	} else {
		sign = '0';
	}
	// Special case: +-infinity
	if ( x === pinf || x === ninf ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	// Special case: NaN
	if ( x !== x ) {
		// Based on IEEE 754-2008...
		exp = repeat( '1', 8 ); // all 1s
		str = '1' + repeat( '0', 22 ); // can't be all 0s
		return sign + exp + str;
	}
	// Special case: +-0
	if ( x === 0 ) {
		// Based on IEEE 754-2008...
		exp = repeat( '0', 8 ); // all 0s
		str = repeat( '0', 23 ); // all 0s
		return sign + exp + str;
	}
	x = abs( x );

	// Isolate the integer part (digits before the decimal):
	n = floor( x );

	// Isolate the fractional part (digits after the decimal):
	f = x - n;

	// Convert the integer and fractional parts to bit strings:
	n = div2( n );
	f = mult2( f );

	// Determine the exponent needed to normalize the integer+fractional parts...
	if ( n ) {
		// Move the decimal `d` digits to the left:
		exp = n.length - 1;
	} else {
		// Find the first '1' bit...
		for ( i = 0; i < f.length; i++ ) {
			if ( f[ i ] === '1' ) {
				nbits = i + 1;
				break;
			}
		}
		// Move the decimal `d` digits to the right:
		exp = -nbits;
	}
	// Normalize the combined integer+fractional string...
	str = n + f;
	if ( exp < 0 ) {
		// Handle subnormals...
		if ( exp <= -BIAS ) {
			// Cap the number of bits removed:
			nbits = BIAS - 1;
		}
		// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:
		str = str.substring( nbits );
	} else {
		// Remove the leading '1' (implicit/hidden bit):
		str = str.substring( 1 );
	}
	// Convert the exponent to a bit string:
	exp = div2( exp + BIAS );
	exp = lpad( exp, 8, '0' );

	// Fill in any trailing zeros and ensure we have only 23 fraction bits:
	str = rpad( str, 23, '0' ).substring( 0, 23 );

	// Return a bit representation:
	return sign + exp + str;
} // end FUNCTION binaryString()


// EXPORTS //

module.exports = binaryString;

},{"./div2.js":42,"./mult2.js":44,"const-ninf-float32":22,"const-pinf-float32":23,"math-abs":40,"math-floor":45,"utils-left-pad-string":87,"utils-repeat-string":88,"utils-right-pad-string":89}],44:[function(require,module,exports){
'use strict';

// VARIABLES //

var MAX_ITER = 149; // 127+22 (subnormals)
var MAX_BITS = 24; // only 23 bits for fraction


// MULT2 //

/**
* FUNCTION: mult2( x )
*	Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.
*
* @param {Number} x - number less than 1
* @returns {String} bit representation
*/
function mult2( x ) {
	var str;
	var y;
	var i;
	var j;

	str = '';
	if ( x === 0 ) {
		return str;
	}
	j = MAX_ITER;

	// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..
	for ( i = 0; i < MAX_ITER; i++ ) {
		y = x * 2;
		if ( y >= 1 ) {
			x = y - 1;
			str += '1';
			if ( j === MAX_ITER ) {
				j = i; // first '1'
			}
		} else {
			x = y;
			str += '0';
		}
		// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...
		if ( y === 1 || i-j > MAX_BITS ) {
			break;
		}
	}
	return str;
} // end FUNCTION mult2()


// EXPORTS //

module.exports = mult2;

},{}],45:[function(require,module,exports){
'use strict';

// EXPORTS //

module.exports = Math.floor;

},{}],46:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

/**
 * nifti
 * @type {*|{}}
 */
var nifti = nifti || {};
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);
nifti.NIFTI2 = nifti.NIFTI2 || ((typeof require !== 'undefined') ? require('./nifti2.js') : null);
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);

var pako = pako || ((typeof require !== 'undefined') ? require('pako') : null);



/*** Static Methods ***/

/**
 * Returns true if this data represents a NIFTI-1 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI1 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI1.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI1.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI1.MAGIC_NUMBER[1]) &&
        (mag3 === nifti.NIFTI1.MAGIC_NUMBER[2]));
};


/**
 * Returns true if this data represents a NIFTI-2 header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI2 = function (data) {
    var buf, mag1, mag2, mag3;

    buf = new DataView(data);
    mag1 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION);
    mag2 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 1);
    mag3 = buf.getUint8(nifti.NIFTI2.MAGIC_NUMBER_LOCATION + 2);

    return !!((mag1 === nifti.NIFTI2.MAGIC_NUMBER[0]) && (mag2 === nifti.NIFTI2.MAGIC_NUMBER[1]) &&
    (mag3 === nifti.NIFTI2.MAGIC_NUMBER[2]));
};



/**
 * Returns true if this data represents a NIFTI header.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isNIFTI = function (data) {
    return (nifti.isNIFTI1(data) || nifti.isNIFTI2(data));
};



/**
 * Returns true if this data is GZIP compressed.
 * @param {ArrayBuffer} data
 * @returns {boolean}
 */
nifti.isCompressed = function (data) {
    var buf, magicCookie1, magicCookie2;

    if (data) {
        buf = new DataView(data);

        magicCookie1 = buf.getUint8(0);
        magicCookie2 = buf.getUint8(1);

        if (magicCookie1 === nifti.Utils.GUNZIP_MAGIC_COOKIE1) {
            return true;
        }

        if (magicCookie2 === nifti.Utils.GUNZIP_MAGIC_COOKIE2) {
            return true;
        }
    }

    return false;
};



/**
 * Returns decompressed data.
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.decompress = function (data) {
    return pako.inflate(data).buffer;
};



/**
 * Reads and returns the header object.
 * @param {ArrayBuffer} data
 * @returns {nifti.NIFTI1|nifti.NIFTI2|null}
 */
nifti.readHeader = function (data) {
    var header = null;

    if (nifti.isCompressed(data)) {
        data = nifti.decompress(data);
    }

    if (nifti.isNIFTI1(data)) {
        header = new nifti.NIFTI1();
    } else if (nifti.isNIFTI2(data)) {
        header = new nifti.NIFTI2();
    }

    if (header) {
        header.readHeader(data);
    } else {
        console.error("That file does not appear to be NIFTI!");
    }

    return header;
};



/**
 * Returns true if this header contains an extension.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @returns {boolean}
 */
nifti.hasExtension = function (header) {
    return (header.extensionFlag[0] != 0);
};



/**
 * Returns the image data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readImage = function (header, data) {
    var imageOffset = header.vox_offset,
        timeDim = 1,
        statDim = 1;

    if (header.dims[4]) {
        timeDim = header.dims[4];
    }

    if (header.dims[5]) {
        statDim = header.dims[5];
    }

    var imageSize = header.dims[1] * header.dims[2] * header.dims[3] * timeDim * statDim * (header.numBitsPerVoxel / 8);
    return data.slice(imageOffset, imageOffset + imageSize);
};



/**
 * Returns the extension data (including extension header).
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtension = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc, loc + size);
};



/**
 * Returns the extension data.
 * @param {nifti.NIFTI1|nifti.NIFTI2} header
 * @param {ArrayBuffer} data
 * @returns {ArrayBuffer}
 */
nifti.readExtensionData = function (header, data) {
    var loc = header.getExtensionLocation(),
        size = header.extensionSize;

    return data.slice(loc + 8, loc + size - 8);
};


/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti;
}

},{"./nifti1.js":47,"./nifti2.js":48,"./utilities.js":49,"pako":51}],47:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);



/*** Constructor ***/

/**
 * The NIFTI1 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {boolean} isHDR - if hdr/img format
 * @property {number[]} extensionFlag
 * @property {number} extensionSize
 * @property {number} extensionCode
 * @type {Function}
 */
nifti.NIFTI1 = nifti.NIFTI1 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.isHDR = false;
    this.extensionFlag = [0, 0, 0, 0];
    this.extensionSize = 0;
    this.extensionCode = 0;
};



/*** Static Pseudo-constants ***/

// datatype codes
nifti.NIFTI1.TYPE_NONE            = 0;
nifti.NIFTI1.TYPE_BINARY          = 1;
nifti.NIFTI1.TYPE_UINT8           = 2;
nifti.NIFTI1.TYPE_INT16           = 4;
nifti.NIFTI1.TYPE_INT32           = 8;
nifti.NIFTI1.TYPE_FLOAT32        = 16;
nifti.NIFTI1.TYPE_COMPLEX64      = 32;
nifti.NIFTI1.TYPE_FLOAT64        = 64;
nifti.NIFTI1.TYPE_RGB24         = 128;
nifti.NIFTI1.TYPE_INT8          = 256;
nifti.NIFTI1.TYPE_UINT16        = 512;
nifti.NIFTI1.TYPE_UINT32        = 768;
nifti.NIFTI1.TYPE_INT64        = 1024;
nifti.NIFTI1.TYPE_UINT64       = 1280;
nifti.NIFTI1.TYPE_FLOAT128     = 1536;
nifti.NIFTI1.TYPE_COMPLEX128   = 1792;
nifti.NIFTI1.TYPE_COMPLEX256   = 2048;

// transform codes
nifti.NIFTI1.XFORM_UNKNOWN        = 0;
nifti.NIFTI1.XFORM_SCANNER_ANAT   = 1;
nifti.NIFTI1.XFORM_ALIGNED_ANAT   = 2;
nifti.NIFTI1.XFORM_TALAIRACH      = 3;
nifti.NIFTI1.XFORM_MNI_152        = 4;

// unit codes
nifti.NIFTI1.SPATIAL_UNITS_MASK = 0x07;
nifti.NIFTI1.TEMPORAL_UNITS_MASK = 0x38;
nifti.NIFTI1.UNITS_UNKNOWN        = 0;
nifti.NIFTI1.UNITS_METER          = 1;
nifti.NIFTI1.UNITS_MM             = 2;
nifti.NIFTI1.UNITS_MICRON         = 3;
nifti.NIFTI1.UNITS_SEC            = 8;
nifti.NIFTI1.UNITS_MSEC          = 16;
nifti.NIFTI1.UNITS_USEC          = 24;
nifti.NIFTI1.UNITS_HZ            = 32;
nifti.NIFTI1.UNITS_PPM           = 40;
nifti.NIFTI1.UNITS_RADS          = 48;

// nifti1 codes
nifti.NIFTI1.MAGIC_COOKIE = 348;
nifti.NIFTI1.MAGIC_NUMBER_LOCATION = 344;
nifti.NIFTI1.MAGIC_NUMBER = [0x6E, 0x2B, 0x31];  // n+1 (.nii)
nifti.NIFTI1.MAGIC_NUMBER2 = [0x6E, 0x69, 0x31];  // ni1 (.hdr/.img)
nifti.NIFTI1.EXTENSION_HEADER_SIZE = 8;


/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI1.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index;

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI1.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.dim_info = nifti.Utils.getByteAt(rawData, 39);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 40 + (ctr * 2);
        this.dims[ctr] = nifti.Utils.getShortAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getFloatAt(rawData, 56, this.littleEndian);
    this.intent_p2 = nifti.Utils.getFloatAt(rawData, 60, this.littleEndian);
    this.intent_p3 = nifti.Utils.getFloatAt(rawData, 64, this.littleEndian);
    this.intent_code = nifti.Utils.getShortAt(rawData, 68, this.littleEndian);

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 70, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 72, this.littleEndian);

    this.slice_start = nifti.Utils.getShortAt(rawData, 74, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 76 + (ctr * 4);
        this.pixDims[ctr] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getFloatAt(rawData, 108, this.littleEndian);

    this.scl_slope = nifti.Utils.getFloatAt(rawData, 112, this.littleEndian);
    this.scl_inter = nifti.Utils.getFloatAt(rawData, 116, this.littleEndian);

    this.slice_end = nifti.Utils.getShortAt(rawData, 120, this.littleEndian);
    this.slice_code = nifti.Utils.getByteAt(rawData, 122);

    this.xyzt_units = nifti.Utils.getByteAt(rawData, 123);

    this.cal_max = nifti.Utils.getFloatAt(rawData, 124, this.littleEndian);
    this.cal_min = nifti.Utils.getFloatAt(rawData, 128, this.littleEndian);

    this.slice_duration = nifti.Utils.getFloatAt(rawData, 132, this.littleEndian);
    this.toffset = nifti.Utils.getFloatAt(rawData, 136, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 148, 228);
    this.aux_file = nifti.Utils.getStringAt(rawData, 228, 252);

    this.qform_code = nifti.Utils.getShortAt(rawData, 252, this.littleEndian);
    this.sform_code = nifti.Utils.getShortAt(rawData, 254, this.littleEndian);

    this.quatern_b = nifti.Utils.getFloatAt(rawData, 256, this.littleEndian);
    this.quatern_c = nifti.Utils.getFloatAt(rawData, 260, this.littleEndian);
    this.quatern_d = nifti.Utils.getFloatAt(rawData, 264, this.littleEndian);
    this.qoffset_x = nifti.Utils.getFloatAt(rawData, 268, this.littleEndian);
    this.qoffset_y = nifti.Utils.getFloatAt(rawData, 272, this.littleEndian);
    this.qoffset_z = nifti.Utils.getFloatAt(rawData, 276, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 280 + (((ctrOut * 4) + ctrIn) * 4);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getFloatAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.intent_name = nifti.Utils.getStringAt(rawData, 328, 344);
    this.magic = nifti.Utils.getStringAt(rawData, 344, 348);

    this.isHDR = (this.magic === nifti.NIFTI1.MAGIC_NUMBER2);

    if (rawData.byteLength > nifti.NIFTI1.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 348);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 348 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 348 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 348 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};


/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI1.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Dim Info = " + this.dim_info + "\n");

    string += ("Image Dimensions (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Datatype = " + this.datatypeCode +  " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + this.numBitsPerVoxel + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
        "b = " + fmt(this.quatern_b) + "  " +
        "c = " + fmt(this.quatern_c) + "  " +
        "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
        "x = " + this.qoffset_x + "  " +
        "y = " + this.qoffset_y + "  " +
        "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
        fmt(this.affine[0][0]) + ", " +
        fmt(this.affine[0][1]) + ", " +
        fmt(this.affine[0][2]) + ", " +
        fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
        fmt(this.affine[1][0]) + ", " +
        fmt(this.affine[1][1]) + ", " +
        fmt(this.affine[1][2]) + ", " +
        fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
        fmt(this.affine[2][0]) + ", " +
        fmt(this.affine[2][1]) + ", " +
        fmt(this.affine[2][2]) + ", " +
        fmt(this.affine[2][3]) + "\n");

    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    if (this.extensionFlag[0]) {
        string += ("Extension: Size = " + this.extensionSize + "  Code = " + this.extensionCode + "\n");

    }

    return string;
};


/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getDatatypeCodeString = function (code) {
    if (code === nifti.NIFTI1.TYPE_UINT8) {
        return "1-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT16) {
        return "2-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT32) {
        return "4-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT32) {
        return "4-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_FLOAT64) {
        return "8-Byte Float";
    } else if (code === nifti.NIFTI1.TYPE_RGB24) {
        return "RGB";
    } else if (code === nifti.NIFTI1.TYPE_INT8) {
        return "1-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT16) {
        return "2-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT32) {
        return "4-Byte Unsigned Integer";
    } else if (code === nifti.NIFTI1.TYPE_INT64) {
        return "8-Byte Signed Integer";
    } else if (code === nifti.NIFTI1.TYPE_UINT64) {
        return "8-Byte Unsigned Integer";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getTransformCodeString = function (code) {
    if (code === nifti.NIFTI1.XFORM_SCANNER_ANAT) {
        return "Scanner";
    } else if (code === nifti.NIFTI1.XFORM_ALIGNED_ANAT) {
        return "Aligned";
    } else if (code === nifti.NIFTI1.XFORM_TALAIRACH) {
        return "Talairach";
    } else if (code === nifti.NIFTI1.XFORM_MNI_152) {
        return "MNI";
    } else {
        return "Unknown";
    }
};


/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI1.prototype.getUnitsCodeString = function (code) {
    if (code === nifti.NIFTI1.UNITS_METER) {
        return "Meters";
    } else if (code === nifti.NIFTI1.UNITS_MM) {
        return "Millimeters";
    } else if (code === nifti.NIFTI1.UNITS_MICRON) {
        return "Microns";
    } else if (code === nifti.NIFTI1.UNITS_SEC) {
        return "Seconds";
    } else if (code === nifti.NIFTI1.UNITS_MSEC) {
        return "Milliseconds";
    } else if (code === nifti.NIFTI1.UNITS_USEC) {
        return "Microseconds";
    } else if (code === nifti.NIFTI1.UNITS_HZ) {
        return "Hz";
    } else if (code === nifti.NIFTI1.UNITS_PPM) {
        return "PPM";
    } else if (code === nifti.NIFTI1.UNITS_RADS) {
        return "Rads";
    } else {
        return "Unknown";
    }
};


/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.getQformMat = function () {
    return this.convertNiftiQFormToNiftiSForm(this.quatern_b, this.quatern_c, this.quatern_d, this.qoffset_x,
        this.qoffset_y, this.qoffset_z, this.pixDims[1], this.pixDims[2], this.pixDims[3], this.pixDims[0]);
};



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm = function (qb, qc, qd, qx, qy, qz, dx, dy, dz,
                                                qfac) {
    var R = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        a,
        b = qb,
        c = qc,
        d = qd,
        xd,
        yd,
        zd;

    // last row is always [ 0 0 0 1 ]
    R[3][0] = R[3][1] = R[3][2] = 0.0;
    R[3][3] = 1.0;

    // compute a parameter from b,c,d
    a = 1.0 - (b * b + c * c + d * d);
    if (a < 0.0000001) {                   /* special case */

        a = 1.0 / Math.sqrt(b * b + c * c + d * d);
        b *= a;
        c *= a;
        d *= a;        /* normalize (b,c,d) vector */
        a = 0.0;                        /* a = 0 ==> 180 degree rotation */
    } else {

        a = Math.sqrt(a);                     /* angle = 2*arccos(a) */
    }

    // load rotation matrix, including scaling factors for voxel sizes
    xd = (dx > 0.0) ? dx : 1.0;       /* make sure are positive */
    yd = (dy > 0.0) ? dy : 1.0;
    zd = (dz > 0.0) ? dz : 1.0;

    if (qfac < 0.0) {
        zd = -zd;         /* left handedness? */
    }

    R[0][0] =       (a * a + b * b - c * c - d * d) * xd;
    R[0][1] = 2.0 * (b * c - a * d) * yd;
    R[0][2] = 2.0 * (b * d + a * c) * zd;
    R[1][0] = 2.0 * (b * c + a * d) * xd;
    R[1][1] =       (a * a + c * c - b * b - d * d) * yd;
    R[1][2] = 2.0 * (c * d - a * b) * zd;
    R[2][0] = 2.0 * (b * d - a * c) * xd;
    R[2][1] = 2.0 * (c * d + a * b) * yd;
    R[2][2] =       (a * a + d * d - c * c - b * b) * zd;

    // load offsets
    R[0][3] = qx;
    R[1][3] = qy;
    R[2][3] = qz;

    return R;
};



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI1.prototype.convertNiftiSFormToNEMA = function (R) {
    var xi, xj, xk, yi, yj, yk, zi, zj, zk, val, detQ, detP, i, j, k, p, q, r, ibest, jbest, kbest, pbest, qbest, rbest,
        M, vbest, Q, P, iChar, jChar, kChar, iSense, jSense, kSense;
    k = 0;

    Q = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    P = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

    //if( icod == NULL || jcod == NULL || kcod == NULL ) return ; /* bad */

    //*icod = *jcod = *kcod = 0 ; /* this.errorMessage returns, if sh*t happens */

    /* load column vectors for each (i,j,k) direction from matrix */

    /*-- i axis --*/ /*-- j axis --*/ /*-- k axis --*/

    xi = R[0][0];
    xj = R[0][1];
    xk = R[0][2];

    yi = R[1][0];
    yj = R[1][1];
    yk = R[1][2];

    zi = R[2][0];
    zj = R[2][1];
    zk = R[2][2];

    /* normalize column vectors to get unit vectors along each ijk-axis */

    /* normalize i axis */
    val = Math.sqrt(xi * xi + yi * yi + zi * zi);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xi /= val;
    yi /= val;
    zi /= val;

    /* normalize j axis */
    val = Math.sqrt(xj * xj + yj * yj + zj * zj);
    if (val === 0.0) {  /* stupid input */
        return null;
    }

    xj /= val;
    yj /= val;
    zj /= val;

    /* orthogonalize j axis to i axis, if needed */
    val = xi * xj + yi * yj + zi * zj;    /* dot product between i and j */
    if (Math.abs(val) > 1.E-4) {
        xj -= val * xi;
        yj -= val * yi;
        zj -= val * zi;
        val = Math.sqrt(xj * xj + yj * yj + zj * zj);  /* must renormalize */
        if (val === 0.0) {              /* j was parallel to i? */
            return null;
        }
        xj /= val;
        yj /= val;
        zj /= val;
    }

    /* normalize k axis; if it is zero, make it the cross product i x j */
    val = Math.sqrt(xk * xk + yk * yk + zk * zk);
    if (val === 0.0) {
        xk = yi * zj - zi * yj;
        yk = zi * xj - zj * xi;
        zk = xi * yj - yi * xj;
    } else {
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to i */
    val = xi * xk + yi * yk + zi * zk;    /* dot product between i and k */
    if (Math.abs(val) > 1.E-4) {
        xk -= val * xi;
        yk -= val * yi;
        zk -= val * zi;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {    /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    /* orthogonalize k to j */
    val = xj * xk + yj * yk + zj * zk;    /* dot product between j and k */
    if (Math.abs(val) > 1.e-4) {
        xk -= val * xj;
        yk -= val * yj;
        zk -= val * zj;
        val = Math.sqrt(xk * xk + yk * yk + zk * zk);
        if (val === 0.0) {     /* bad */
            return null;
        }
        xk /= val;
        yk /= val;
        zk /= val;
    }

    Q[0][0] = xi;
    Q[0][1] = xj;
    Q[0][2] = xk;
    Q[1][0] = yi;
    Q[1][1] = yj;
    Q[1][2] = yk;
    Q[2][0] = zi;
    Q[2][1] = zj;
    Q[2][2] = zk;

    /* at this point, Q is the rotation matrix from the (i,j,k) to (x,y,z) axes */

    detQ = this.nifti_mat33_determ(Q);
    if (detQ === 0.0) { /* shouldn't happen unless user is a DUFIS */
        return null;
    }

    /* Build and test all possible +1/-1 coordinate permutation matrices P;
     then find the P such that the rotation matrix M=PQ is closest to the
     identity, in the sense of M having the smallest total rotation angle. */

    /* Despite the formidable looking 6 nested loops, there are
     only 3*3*3*2*2*2 = 216 passes, which will run very quickly. */

    vbest = -666.0;
    ibest = pbest = qbest = rbest = 1;
    jbest = 2;
    kbest = 3;

    for (i = 1; i <= 3; i += 1) {     /* i = column number to use for row #1 */
        for (j = 1; j <= 3; j += 1) {    /* j = column number to use for row #2 */
            if (i !== j) {
                for (k = 1; k <= 3; k += 1) {  /* k = column number to use for row #3 */
                    if (!(i === k || j === k)) {
                        P[0][0] = P[0][1] = P[0][2] = P[1][0] = P[1][1] = P[1][2] = P[2][0] = P[2][1] = P[2][2] = 0.0;
                        for (p = -1; p <= 1; p += 2) {    /* p,q,r are -1 or +1      */
                            for (q = -1; q <= 1; q += 2) {   /* and go into rows #1,2,3 */
                                for (r = -1; r <= 1; r += 2) {
                                    P[0][i - 1] = p;
                                    P[1][j - 1] = q;
                                    P[2][k - 1] = r;
                                    detP = this.nifti_mat33_determ(P);           /* sign of permutation */
                                    if ((detP * detQ) > 0.0) {
                                        M = this.nifti_mat33_mul(P, Q);

                                        /* angle of M rotation = 2.0*acos(0.5*sqrt(1.0+trace(M)))       */
                                        /* we want largest trace(M) == smallest angle == M nearest to I */

                                        val = M[0][0] + M[1][1] + M[2][2]; /* trace */
                                        if (val > vbest) {
                                            vbest = val;
                                            ibest = i;
                                            jbest = j;
                                            kbest = k;
                                            pbest = p;
                                            qbest = q;
                                            rbest = r;
                                        }
                                    }  /* doesn't match sign of Q */
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* At this point ibest is 1 or 2 or 3; pbest is -1 or +1; etc.

     The matrix P that corresponds is the best permutation approximation
     to Q-inverse; that is, P (approximately) takes (x,y,z) coordinates
     to the (i,j,k) axes.

     For example, the first row of P (which contains pbest in column ibest)
     determines the way the i axis points relative to the anatomical
     (x,y,z) axes.  If ibest is 2, then the i axis is along the y axis,
     which is direction P2A (if pbest > 0) or A2P (if pbest < 0).

     So, using ibest and pbest, we can assign the output code for
     the i axis.  Mutatis mutandis for the j and k axes, of course. */

    iChar = jChar = kChar = iSense = jSense = kSense = 0;

    switch (ibest * pbest) {
        case 1: /*i = NIFTI_L2R*/
            iChar = 'X';
            iSense = '+';
            break;
        case -1: /*i = NIFTI_R2L*/
            iChar = 'X';
            iSense = '-';
            break;
        case 2: /*i = NIFTI_P2A*/
            iChar = 'Y';
            iSense = '+';
            break;
        case -2: /*i = NIFTI_A2P*/
            iChar = 'Y';
            iSense = '-';
            break;
        case 3: /*i = NIFTI_I2S*/
            iChar = 'Z';
            iSense = '+';
            break;
        case -3: /*i = NIFTI_S2I*/
            iChar = 'Z';
            iSense = '-';
            break;
    }

    switch (jbest * qbest) {
        case 1: /*j = NIFTI_L2R*/
            jChar = 'X';
            jSense = '+';
            break;
        case -1: /*j = NIFTI_R2L*/
            jChar = 'X';
            jSense = '-';
            break;
        case 2: /*j = NIFTI_P2A*/
            jChar = 'Y';
            jSense = '+';
            break;
        case -2: /*j = NIFTI_A2P*/
            jChar = 'Y';
            jSense = '-';
            break;
        case 3: /*j = NIFTI_I2S*/
            jChar = 'Z';
            jSense = '+';
            break;
        case -3: /*j = NIFTI_S2I*/
            jChar = 'Z';
            jSense = '-';
            break;
    }

    switch (kbest * rbest) {
        case 1: /*k = NIFTI_L2R*/
            kChar = 'X';
            kSense = '+';
            break;
        case -1: /*k = NIFTI_R2L*/
            kChar = 'X';
            kSense = '-';
            break;
        case 2: /*k = NIFTI_P2A*/
            kChar = 'Y';
            kSense = '+';
            break;
        case -2: /*k = NIFTI_A2P*/
            kChar = 'Y';
            kSense = '-';
            break;
        case 3: /*k = NIFTI_I2S*/
            kChar = 'Z';
            kSense = '+';
            break;
        case -3: /*k = NIFTI_S2I*/
            kChar = 'Z';
            kSense = '-';
            break;
    }

    return (iChar + jChar + kChar + iSense + jSense + kSense);
};



nifti.NIFTI1.prototype.nifti_mat33_mul = function (A, B) {
    var C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        i,
        j;

    for (i = 0; i < 3; i += 1) {
        for (j = 0; j < 3; j += 1) {
            C[i][j] =  A[i][0] * B[0][j]  + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
    }

    return C;
};



nifti.NIFTI1.prototype.nifti_mat33_determ = function (R) {
    var r11, r12, r13, r21, r22, r23, r31, r32, r33;
    /*  INPUT MATRIX:  */
    r11 = R[0][0];
    r12 = R[0][1];
    r13 = R[0][2];
    r21 = R[1][0];
    r22 = R[1][1];
    r23 = R[1][2];
    r31 = R[2][0];
    r32 = R[2][1];
    r33 = R[2][2];

    return (r11 * r22 * r33 - r11 * r32 * r23 - r21 * r12 * r33 + r21 * r32 * r13 + r31 * r12 * r23 - r31 * r22 * r13);
};


/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionLocation = function() {
    return nifti.NIFTI1.MAGIC_COOKIE + 4;
};


/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionSize = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation(), this.littleEndian);
};



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI1.prototype.getExtensionCode = function(data) {
    return nifti.Utils.getIntAt(data, this.getExtensionLocation() + 4, this.littleEndian);
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI1;
}

},{"./utilities.js":49}],48:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || ((typeof require !== 'undefined') ? require('./utilities.js') : null);
nifti.NIFTI1 = nifti.NIFTI1 || ((typeof require !== 'undefined') ? require('./nifti1.js') : null);


/*** Constructor ***/

/**
 * The NIFTI2 constructor.
 * @constructor
 * @property {boolean} littleEndian
 * @property {number} dim_info
 * @property {number[]} dims - image dimensions
 * @property {number} intent_p1
 * @property {number} intent_p2
 * @property {number} intent_p3
 * @property {number} intent_code
 * @property {number} datatypeCode
 * @property {number} numBitsPerVoxel
 * @property {number} slice_start
 * @property {number} slice_end
 * @property {number} slice_code
 * @property {number[]} pixDims - voxel dimensions
 * @property {number} vox_offset
 * @property {number} scl_slope
 * @property {number} scl_inter
 * @property {number} xyzt_units
 * @property {number} cal_max
 * @property {number} cal_min
 * @property {number} slice_duration
 * @property {number} toffset
 * @property {string} description
 * @property {string} aux_file
 * @property {string} intent_name
 * @property {number} qform_code
 * @property {number} sform_code
 * @property {number} quatern_b
 * @property {number} quatern_c
 * @property {number} quatern_d
 * @property {number} quatern_x
 * @property {number} quatern_y
 * @property {number} quatern_z
 * @property {Array.<Array.<number>>} affine
 * @property {string} magic
 * @property {number[]} extensionFlag
 * @type {Function}
 */
nifti.NIFTI2 = nifti.NIFTI2 || function () {
    this.littleEndian = false;
    this.dim_info = 0;
    this.dims = [];
    this.intent_p1 = 0;
    this.intent_p2 = 0;
    this.intent_p3 = 0;
    this.intent_code = 0;
    this.datatypeCode = 0;
    this.numBitsPerVoxel = 0;
    this.slice_start = 0;
    this.slice_end = 0;
    this.slice_code = 0;
    this.pixDims = [];
    this.vox_offset = 0;
    this.scl_slope = 1;
    this.scl_inter = 0;
    this.xyzt_units = 0;
    this.cal_max = 0;
    this.cal_min = 0;
    this.slice_duration = 0;
    this.toffset = 0;
    this.description = "";
    this.aux_file = "";
    this.intent_name = "";
    this.qform_code = 0;
    this.sform_code = 0;
    this.quatern_b = 0;
    this.quatern_c = 0;
    this.quatern_d = 0;
    this.qoffset_x = 0;
    this.qoffset_y = 0;
    this.qoffset_z = 0;
    this.affine = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    this.magic = 0;
    this.extensionFlag = [0, 0, 0, 0];
};



/*** Static Pseudo-constants ***/

nifti.NIFTI2.MAGIC_COOKIE = 540;
nifti.NIFTI2.MAGIC_NUMBER_LOCATION = 4;
nifti.NIFTI2.MAGIC_NUMBER = [0x6E, 0x2B, 0x32, 0, 0x0D, 0x0A, 0x1A, 0x0A];  // n+2\0



/*** Prototype Methods ***/

/**
 * Reads the header data.
 * @param {ArrayBuffer} data
 */
nifti.NIFTI2.prototype.readHeader = function (data) {
    var rawData = new DataView(data),
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian),
        ctr,
        ctrOut,
        ctrIn,
        index,
        array;

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {  // try as little endian
        this.littleEndian = true;
        magicCookieVal = nifti.Utils.getIntAt(rawData, 0, this.littleEndian);
    }

    if (magicCookieVal !== nifti.NIFTI2.MAGIC_COOKIE) {
        throw new Error("This does not appear to be a NIFTI file!");
    }

    this.datatypeCode = nifti.Utils.getShortAt(rawData, 12, this.littleEndian);
    this.numBitsPerVoxel = nifti.Utils.getShortAt(rawData, 14, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 16 + (ctr * 8);
        this.dims[ctr] = nifti.Utils.getLongAt(rawData, index, this.littleEndian);
    }

    this.intent_p1 = nifti.Utils.getDoubleAt(rawData, 80, this.littleEndian);
    this.intent_p2 = nifti.Utils.getDoubleAt(rawData, 88, this.littleEndian);
    this.intent_p3 = nifti.Utils.getDoubleAt(rawData, 96, this.littleEndian);

    for (ctr = 0; ctr < 8; ctr += 1) {
        index = 104 + (ctr * 8);
        this.pixDims[ctr] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
    }

    this.vox_offset = nifti.Utils.getLongAt(rawData, 168, this.littleEndian);

    this.scl_slope = nifti.Utils.getDoubleAt(rawData, 176, this.littleEndian);
    this.scl_inter = nifti.Utils.getDoubleAt(rawData, 184, this.littleEndian);

    this.cal_max = nifti.Utils.getDoubleAt(rawData, 192, this.littleEndian);
    this.cal_min = nifti.Utils.getDoubleAt(rawData, 200, this.littleEndian);

    this.slice_duration = nifti.Utils.getDoubleAt(rawData, 208, this.littleEndian);

    this.toffset = nifti.Utils.getDoubleAt(rawData, 216, this.littleEndian);

    this.slice_start = nifti.Utils.getLongAt(rawData, 224, this.littleEndian);
    this.slice_end = nifti.Utils.getLongAt(rawData, 232, this.littleEndian);

    this.description = nifti.Utils.getStringAt(rawData, 240, 240 + 80);
    this.aux_file = nifti.Utils.getStringAt(rawData, 320, 320 + 24);

    this.qform_code = nifti.Utils.getIntAt(rawData, 344, this.littleEndian);
    this.sform_code = nifti.Utils.getIntAt(rawData, 348, this.littleEndian);

    this.quatern_b = nifti.Utils.getDoubleAt(rawData, 352, this.littleEndian);
    this.quatern_c = nifti.Utils.getDoubleAt(rawData, 360, this.littleEndian);
    this.quatern_d = nifti.Utils.getDoubleAt(rawData, 368, this.littleEndian);
    this.qoffset_x = nifti.Utils.getDoubleAt(rawData, 376, this.littleEndian);
    this.qoffset_y = nifti.Utils.getDoubleAt(rawData, 384, this.littleEndian);
    this.qoffset_z = nifti.Utils.getDoubleAt(rawData, 392, this.littleEndian);

    for (ctrOut = 0; ctrOut < 3; ctrOut += 1) {
        for (ctrIn = 0; ctrIn < 4; ctrIn += 1) {
            index = 400 + (((ctrOut * 4) + ctrIn) * 8);
            this.affine[ctrOut][ctrIn] = nifti.Utils.getDoubleAt(rawData, index, this.littleEndian);
        }
    }

    this.affine[3][0] = 0;
    this.affine[3][1] = 0;
    this.affine[3][2] = 0;
    this.affine[3][3] = 1;

    this.slice_code = nifti.Utils.getIntAt(rawData, 496, this.littleEndian);
    this.xyzt_units = nifti.Utils.getIntAt(rawData, 500, this.littleEndian);
    this.intent_code = nifti.Utils.getIntAt(rawData, 504, this.littleEndian);
    this.intent_name = nifti.Utils.getStringAt(rawData, 508, 508 + 16);

    this.dim_info = nifti.Utils.getByteAt(rawData, 524);

    if (rawData.byteLength > nifti.NIFTI2.MAGIC_COOKIE) {
        this.extensionFlag[0] = nifti.Utils.getByteAt(rawData, 540);
        this.extensionFlag[1] = nifti.Utils.getByteAt(rawData, 540 + 1);
        this.extensionFlag[2] = nifti.Utils.getByteAt(rawData, 540 + 2);
        this.extensionFlag[3] = nifti.Utils.getByteAt(rawData, 540 + 3);

        if (this.extensionFlag[0]) {
            this.extensionSize = this.getExtensionSize(rawData);
            this.extensionCode = this.getExtensionCode(rawData);
        }
    }
};



/**
 * Returns a formatted string of header fields.
 * @returns {string}
 */
nifti.NIFTI2.prototype.toFormattedString = function () {
    var fmt = nifti.Utils.formatNumber,
        string = "";

    string += ("Datatype = " +  + this.datatypeCode + " (" + this.getDatatypeCodeString(this.datatypeCode) + ")\n");
    string += ("Bits Per Voxel = " + " = " + this.numBitsPerVoxel + "\n");
    string += ("Image Dimensions" + " (1-8): " +
        this.dims[0] + ", " +
        this.dims[1] + ", " +
        this.dims[2] + ", " +
        this.dims[3] + ", " +
        this.dims[4] + ", " +
        this.dims[5] + ", " +
        this.dims[6] + ", " +
        this.dims[7] + "\n");

    string += ("Intent Parameters (1-3): " +
        this.intent_p1 + ", " +
        this.intent_p2 + ", " +
        this.intent_p3) + "\n";

    string += ("Voxel Dimensions (1-8): " +
        fmt(this.pixDims[0]) + ", " +
        fmt(this.pixDims[1]) + ", " +
        fmt(this.pixDims[2]) + ", " +
        fmt(this.pixDims[3]) + ", " +
        fmt(this.pixDims[4]) + ", " +
        fmt(this.pixDims[5]) + ", " +
        fmt(this.pixDims[6]) + ", " +
        fmt(this.pixDims[7]) + "\n");

    string += ("Image Offset = " + this.vox_offset + "\n");
    string += ("Data Scale:  Slope = " + fmt(this.scl_slope) + "  Intercept = " + fmt(this.scl_inter) + "\n");
    string += ("Display Range:  Max = " + fmt(this.cal_max) + "  Min = " + fmt(this.cal_min) + "\n");
    string += ("Slice Duration = " + this.slice_duration + "\n");
    string += ("Time Axis Shift = " + this.toffset + "\n");
    string += ("Slice Start = " + this.slice_start + "\n");
    string += ("Slice End = " + this.slice_end + "\n");
    string += ("Description: \"" + this.description + "\"\n");
    string += ("Auxiliary File: \"" + this.aux_file + "\"\n");
    string += ("Q-Form Code = " + this.qform_code + " (" + this.getTransformCodeString(this.qform_code) + ")\n");
    string += ("S-Form Code = " + this.sform_code + " (" + this.getTransformCodeString(this.sform_code) + ")\n");
    string += ("Quaternion Parameters:  " +
    "b = " + fmt(this.quatern_b) + "  " +
    "c = " + fmt(this.quatern_c) + "  " +
    "d = " + fmt(this.quatern_d) + "\n");

    string += ("Quaternion Offsets:  " +
    "x = " + this.qoffset_x + "  " +
    "y = " + this.qoffset_y + "  " +
    "z = " + this.qoffset_z + "\n");

    string += ("S-Form Parameters X: " +
    fmt(this.affine[0][0]) + ", " +
    fmt(this.affine[0][1]) + ", " +
    fmt(this.affine[0][2]) + ", " +
    fmt(this.affine[0][3]) + "\n");

    string += ("S-Form Parameters Y: " +
    fmt(this.affine[1][0]) + ", " +
    fmt(this.affine[1][1]) + ", " +
    fmt(this.affine[1][2]) + ", " +
    fmt(this.affine[1][3]) + "\n");

    string += ("S-Form Parameters Z: " +
    fmt(this.affine[2][0]) + ", " +
    fmt(this.affine[2][1]) + ", " +
    fmt(this.affine[2][2]) + ", " +
    fmt(this.affine[2][3]) + "\n");

    string += ("Slice Code = " + this.slice_code + "\n");
    string += ("Units Code = " + this.xyzt_units + " (" + this.getUnitsCodeString(nifti.NIFTI1.SPATIAL_UNITS_MASK & this.xyzt_units) + ", " + this.getUnitsCodeString(nifti.NIFTI1.TEMPORAL_UNITS_MASK & this.xyzt_units) + ")\n");
    string += ("Intent Code = " + this.intent_code + "\n");
    string += ("Intent Name: \"" + this.intent_name + "\"\n");

    string += ("Dim Info = " + this.dim_info + "\n");

    return string;
};



/**
 * Returns the byte index of the extension.
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionLocation = function() {
    return nifti.NIFTI2.MAGIC_COOKIE + 4;
};



/**
 * Returns the extension size.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionSize = nifti.NIFTI1.prototype.getExtensionSize;



/**
 * Returns the extension code.
 * @param {DataView} data
 * @returns {number}
 */
nifti.NIFTI2.prototype.getExtensionCode = nifti.NIFTI1.prototype.getExtensionCode;



/**
 * Returns a human-readable string of datatype.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getDatatypeCodeString = nifti.NIFTI1.prototype.getDatatypeCodeString;



/**
 * Returns a human-readable string of transform type.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getTransformCodeString = nifti.NIFTI1.prototype.getTransformCodeString;



/**
 * Returns a human-readable string of spatial and temporal units.
 * @param {number} code
 * @returns {string}
 */
nifti.NIFTI2.prototype.getUnitsCodeString = nifti.NIFTI1.prototype.getUnitsCodeString;



/**
 * Returns the qform matrix.
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.getQformMat = nifti.NIFTI1.prototype.getQformMat;



/**
 * Converts qform to an affine.  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {number} qb
 * @param {number} qc
 * @param {number} qd
 * @param {number} qx
 * @param {number} qy
 * @param {number} qz
 * @param {number} dx
 * @param {number} dy
 * @param {number} dz
 * @param {number} qfac
 * @returns {Array.<Array.<number>>}
 */
nifti.NIFTI2.prototype.convertNiftiQFormToNiftiSForm = nifti.NIFTI1.prototype.convertNiftiQFormToNiftiSForm;



/**
 * Converts sform to an orientation string (e.g., XYZ+--).  (See http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c)
 * @param {Array.<Array.<number>>} R
 * @returns {string}
 */
nifti.NIFTI2.prototype.convertNiftiSFormToNEMA = nifti.NIFTI1.prototype.convertNiftiSFormToNEMA;



nifti.NIFTI2.prototype.nifti_mat33_mul = nifti.NIFTI1.prototype.nifti_mat33_mul;



nifti.NIFTI2.prototype.nifti_mat33_determ = nifti.NIFTI1.prototype.nifti_mat33_determ;



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.NIFTI2;
}

},{"./nifti1.js":47,"./utilities.js":49}],49:[function(require,module,exports){

/*jslint browser: true, node: true */
/*global require, module */

"use strict";

/*** Imports ***/

var nifti = nifti || {};
nifti.Utils = nifti.Utils || {};



/*** Static Pseudo-constants ***/

nifti.Utils.crcTable = null;
nifti.Utils.GUNZIP_MAGIC_COOKIE1 = 31;
nifti.Utils.GUNZIP_MAGIC_COOKIE2 = 139;



/*** Static methods ***/

nifti.Utils.getStringAt = function (data, start, end) {
    var str = "", ctr, ch;

    for (ctr = start; ctr < end; ctr += 1) {
        ch = data.getUint8(ctr);

        if (ch !== 0) {
            str += String.fromCharCode(ch);
        }
    }

    return str;
};



nifti.Utils.getByteAt = function (data, start) {
    return data.getInt8(start);
};



nifti.Utils.getShortAt = function (data, start, littleEndian) {
    return data.getInt16(start, littleEndian);
};



nifti.Utils.getIntAt = function (data, start, littleEndian) {
    return data.getInt32(start, littleEndian);
};



nifti.Utils.getFloatAt = function (data, start, littleEndian) {
    return data.getFloat32(start, littleEndian);
};



nifti.Utils.getDoubleAt = function (data, start, littleEndian) {
    return data.getFloat64(start, littleEndian);
};



nifti.Utils.getLongAt = function (data, start, littleEndian) {
    var ctr, array = [], value = 0;

    for (ctr = 0; ctr < 8; ctr += 1) {
        array[ctr] = nifti.Utils.getByteAt(data, start + ctr, littleEndian);
    }

    for (ctr = array.length - 1; ctr >= 0; ctr--) {
        value = (value * 256) + array[ctr];
    }

    return value;
};



nifti.Utils.toArrayBuffer = function (buffer) {
    var ab, view, i;

    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = 0; i < buffer.length; i += 1) {
        view[i] = buffer[i];
    }
    return ab;
};



nifti.Utils.isString = function (obj) {
    return (typeof obj === "string" || obj instanceof String);
};


nifti.Utils.formatNumber = function (num, shortFormat) {
    var val = 0;

    if (nifti.Utils.isString(num)) {
        val = Number(num);
    } else {
        val = num;
    }

    if (shortFormat) {
        val = val.toPrecision(5);
    } else {
        val = val.toPrecision(7);
    }

    return parseFloat(val);
};



// http://stackoverflow.com/questions/18638900/javascript-crc32
nifti.Utils.makeCRCTable = function(){
    var c;
    var crcTable = [];
    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        crcTable[n] = c;
    }
    return crcTable;
};



nifti.Utils.crc32 = function(dataView) {
    var crcTable = nifti.Utils.crcTable || (nifti.Utils.crcTable = nifti.Utils.makeCRCTable());
    var crc = 0 ^ (-1);

    for (var i = 0; i < dataView.byteLength; i++ ) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];
    }

    return (crc ^ (-1)) >>> 0;
};



/*** Exports ***/

var moduleType = typeof module;
if ((moduleType !== 'undefined') && module.exports) {
    module.exports = nifti.Utils;
}

},{}],50:[function(require,module,exports){
"use strict";
var assert = require('assert');

var lineSeparatorRE = /[ \f\t\v]*\r?\n/;
var NRRDMagicRE = /^NRRD\d{4}$/;
var lineRE = /^([^:]*)(:[ =])(.*)$/;
var dataFileListRE = /^LIST(?: (\d+))?$/;

// The minimal object this accepts is formed like this:
//   {data: SomeTypedArray, sizes: [...]}
// On the other hand, if data is not given it must have a form like this:
//   {buffer: SomeArrayBuffer, type: ..., endian: ..., sizes: [...]}
// Of course, if 'type' is an 8-bit type, endian is not needed, and if 'type' equals 'block', 'blockSize' should be set instead of 'endian'. In this case, no interpretation of buffer is done (at all, it is written serialized directly to the buffer).
// TODO: For now this only supports serializing "inline" files, or files for which you have already prepared the data.
module.exports.serialize = function (nrrdOrg) {
    var i, buffer, arr, totalLen = 1, nrrd = {}, prop, nativeType, nativeSize, bufferData, arrData, line, lines = [], header;
    
    // Copy nrrdOrg to nrrd to allow modifications without altering the original
    for(prop in nrrdOrg) {
        nrrd[prop] = nrrdOrg[prop];
    }
    
    // For saving files we allow inferring certain information if it is not explicitly given.
    // Also we normalize some fields to make our own lives easier.
    if (nrrd.sizes===undefined) { // 'sizes' should ALWAYS be given
        throw new Error("Sizes missing from NRRD file!");
    } else if (nrrd.dimension===undefined) {
        nrrd.dimension = nrrd.sizes.length;
    }
    if (nrrd.data instanceof Int8Array) {
        nativeType = "int8";
    } else if (nrrd.data instanceof Uint8Array) {
        nativeType = "uint8";
    } else if (nrrd.data instanceof Int16Array) {
        nativeType = "int16";
    } else if (nrrd.data instanceof Uint16Array) {
        nativeType = "uint16";
    } else if (nrrd.data instanceof Int32Array) {
        nativeType = "int32";
    } else if (nrrd.data instanceof Uint32Array) {
        nativeType = "uint32";
    //} else if (nrrd.data instanceof Int64Array) {
    //    nativeType = "int64";
    //} else if (nrrd.data instanceof Uint64Array) {
    //    nativeType = "uint64";
    } else if (nrrd.data instanceof Float32Array) {
        nativeType = "float";
    } else if (nrrd.data instanceof Float64Array) {
        nativeType = "double";
    }
    if (nrrd.type===undefined && nativeType!==undefined) {
        nrrd.type = nativeType;
    } else if (nrrd.type===undefined) {
        throw new Error("Type of data is not given and cannot be inferred!");
    } else if ((typeof nrrd.type) == "string" || nrrd.type instanceof String) {
        nrrd.type = parseNRRDType(nrrd.type);
    }
    if (nrrd.encoding===undefined) {
        nrrd.encoding = "raw";
    } else if ((typeof nrrd.encoding) == "string" || nrrd.encoding instanceof String) {
        nrrd.encoding = parseNRRDEncoding(nrrd.encoding);
    }
    if (nrrd.data && nrrd.type != 'block' && nrrd.type != 'int8' && nrrd.type != 'uint8' && nrrd.encoding != 'ascii') {
        nrrd.endian = systemEndianness;
    } else if (nrrd.type == 'block' || nrrd.type == 'int8' || nrrd.type == 'uint8' || nrrd.encoding == 'ascii') {
        nrrd.endian = undefined;
    } else if ((typeof nrrd.endian) == "string" || nrrd.endian instanceof String) {
        nrrd.endian = parseNRRDEndian(nrrd.endian);
    }
    
    // Try to infer spatial dimension
    var spaceDimension = undefined;
    if (nrrd.spaceDimension!==undefined) {
        spaceDimension = nrrd.spaceDimension;
    } else if (nrrd.space!==undefined) {
        switch(nrrd.space) {
        case "right-anterior-superior":
        case "RAS":
            spaceDimension = 3;
            break;
        case "left-anterior-superior":
        case "LAS":
            spaceDimension = 3;
            break;
        case "left-posterior-superior":
        case "LPS":
            spaceDimension = 3;
            break;
     	  case "right-anterior-superior-time":
     	  case "RAST":
     	      spaceDimension = 4;
     	      break;
        case "left-anterior-superior-time":
        case "LAST":
            spaceDimension = 4;
            break;
        case "left-posterior-superior-time":
        case "LPST":
            spaceDimension = 4;
            break;
        case "scanner-xyz":
            spaceDimension = 3;
            break;
        case "scanner-xyz-time":
            spaceDimension = 4;
            break;
        case "3D-right-handed":
            spaceDimension = 3;
            break;
        case "3D-left-handed":
            spaceDimension = 3;
            break;
        case "3D-right-handed-time":
            spaceDimension = 4;
            break;
        case "3D-left-handed-time":
            spaceDimension = 4;
            break;
        default:
            console.warn("Unrecognized space: " + nrrd.space);
        }
    }
    
    // Now check that we have a valid nrrd structure.
    checkNRRD(nrrd);

    // Determine number of elements and check that we have enough data (if possible)
    for(i=0; i<nrrd.sizes.length; i++) {
        if (nrrd.sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= nrrd.sizes[i];
    }
    if (nrrd.data) {
        if (nrrd.data.length < totalLen) {
            throw new Error("Missing data to serialize!");
        }
    } else if (nrrd.buffer) {
        if (nrrd.encoding == "raw") {
            if (nrrd.type=="block" && nrrd.blockSize!==undefined) {
                nativeSize = nrrd.blockSize;
            } else {
                nativeSize = getNRRDTypeSize(nrrd.type);
            }
            if (nrrd.buffer.byteLength < totalLen*nativeSize) {
                throw new Error("Missing data to serialize!");
            }
        }
    } else if (nrrd.dataFile) {
        // Okay, if you have your data ready, we'll just write a header.
    } else {
        throw new Error("Will not serialize an empty NRRD file!");
    }
    
    // Make sure we have the correct buffer in bufferData.
    if (nrrd.data) {
        switch(nrrd.encoding) {
        case 'raw':
            if (nrrd.type == nativeType && nrrd.endian == systemEndianness) {
                bufferData = nrrd.data.buffer.slice(nrrd.data.byteOffset, nrrd.data.byteOffset+nrrd.data.byteLength);
            } else if (nrrd.endian == systemEndianness) {
                bufferData = castTypedArray(nrrd.data, nrrd.type);
                bufferData = bufferData.buffer.slice(bufferData.byteOffset, bufferData.byteOffset+bufferData.byteLength);
            } else {
                bufferData = serializeToBuffer(nrrd.data, nrrd.type, nrrd.endian);
            }
            break;
        case 'ascii':
            if (nrrd.type == nativeType) {
                bufferData = serializeToTextBuffer(nrrd.data);
            } else {
                bufferData = serializeToTextBuffer(castTypedArray(nrrd.data, nrrd.type));
            }
            break;
        default:
            throw new Error("Unsupported NRRD encoding: " + nrrd.encoding);
        }
    } else if (nrrd.buffer) {
        bufferData = nrrd.buffer;
    }
    
    // Start header
    lines.push("NRRD0005"); // TODO: Adjust version based on features that are actually used and/or the version specified by the user (if any).
    lines.push("# Generated by nrrd-js");
    
    // Put in dimension and space dimension (the NRRD spec requires that these are present before any lists whose length depends on them)
    var firstProps = ['dimension', 'spaceDimension', 'space'];
    for(i=0; i<firstProps.length; i++) {
        prop = firstProps[i];
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in field specifications
    for(prop in nrrd) {
        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.
        if (firstProps.indexOf(prop)>=0) continue; // Skip the fields we already output.
        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);
        if (line!==undefined) lines.push(line);
    }
    
    // Put in keys (if any)
    if (nrrd.keys) for(prop in nrrd.keys) {
        if (prop.indexOf(":=")>=0) throw new Error("The combination ':=' is not allowed in an NRRD key!");
        lines.push(prop + ":=" + escapeValue(nrrd[prop]));
    }
    
    // Put in data file list (if any)
    if (nrrd.dataFile && nrrd.dataFile.length) {
        lines.push("data file: LIST");
        Array.prototype.push.apply(lines, nrrd.dataFile);
    } else if (nrrd.dataFile && nrrd.dataFile.files && 'subdim' in nrrd.dataFile) {
        lines.push("data file: LIST " + nrrd.dataFile.subdim);
        Array.prototype.push.apply(lines, nrrd.dataFile.files);
    }
    
    // Put in empty line and inline data (if we have inline data) and convert lines to buffer
    if (bufferData && !('dataFile' in nrrd)) {
        lines.push("");
        lines.push(""); // We actually need an extra blank line to make sure the previous is terminated.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length + bufferData.byteLength);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
        arrData = new Uint8Array(bufferData);
        arr.set(arrData, header.length);
    } else {
        lines.push(""); // Blank line to at least terminate the last line.
        header = lines.join("\n");
        buffer = new ArrayBuffer(header.length);
        arr = new Uint8Array(buffer);
        for(i=0; i<header.length; i++) {
            arr[i] = header.charCodeAt(i);
        }
    }
    
    return buffer;
};

// This expects an ArrayBuffer.
module.exports.parse = function (buffer) {
    var i, header, dataStart, ret = {data: undefined/* parsed data */, buffer: undefined/* raw buffer holding data */, keys: {}, version: undefined},
        lines, match, match2,
        buf8 = new Uint8Array(buffer);

    // A work-around for incompatibilities between Node's Buffer and ArrayBuffer.
    if (buf8.buffer !== buffer) buffer = buf8.buffer;

    // First find the separation between the header and the data (if there is one)
    // Note that we need to deal with with LF and CRLF as possible line endings.
    // Luckily this means the line always ends with LF, so we only need to consider
    // LFLF and LFCRLF as patterns for the separating empty line.
    i=2; // It is safe to start at position 2 (in fact, we could start even later), as the file HAS to start with a magic word.
    while(i<buf8.length) {
        if (buf8[i] == 10) { // We hit an LF
            if (buf8[i-1] == 10 || (buf8[i-1] == 13 && buf8[i-2] == 10)) { // Safe because we start at position 2 and never move backwards
                dataStart = i+1;
                break;
            } else {
                i++; // Move forward just once
            }
        } else if (buf8[i] == 13) { // We hit a CR
            i++; // Move forward just once
        } else {
            i += 2; // Move forward two places, 
        }
    }
    
    // Now split up the header and data
    if (dataStart === undefined) {
        header = String.fromCharCode.apply(null, buf8);
    } else {
        header = String.fromCharCode.apply(null, buf8.subarray(0,dataStart));
        ret.buffer = buffer.slice(dataStart);
    }
    
    // Split header into lines, remove comments (and blank lines) and check magic.
    // All remaining lines except the first should be field specifications or key/value pairs.
    // TODO: This explicitly removes any whitespace at the end of lines, however, I am not sure that this is actually desired behaviour for all kinds of lines.
    lines = header.split(lineSeparatorRE);
    lines = lines.filter(function (l) { return l.length>0 && l[0] != '#'; }); // Remove comment lines
    if (!NRRDMagicRE.test(lines[0])) {
        throw new Error("File is not an NRRD file!");
    }
    ret.version = parseInt(lines[0].substring(4, 8), 10);
    if (ret.version>5) {
        console.warn("Reading an unsupported version of the NRRD format; things may go haywire.");
    }

    // Parse lines
    for(i=1; i<lines.length; i++) {
        match = lineRE.exec(lines[i]);
        if (!match) {
            console.warn("Unrecognized line in NRRD header: " + lines[i]);
            continue;
        }
        if (match[2] == ': ') { // Field specification
            match[1] = mapNRRDToJavascript(match[1]);
            if ( match[1] == 'dataFile' &&
                 (match2 = dataFileListRE.exec(match[3]))) {
                // This should be the last field specification,
                // and the rest of the lines should contain file names.
                if (match2.length == 2 && match2[1]) { // subdim specification
                    ret[match[1]] = {
                        files: lines.slice(i+1),
                        subdim: parseNRRDInteger(match2[1])
                    };
                } else {
                    ret[match[1]] = lines.slice(i+1);
                }
                lines.length = i;
            } else {
                ret[match[1]] = parseField(match[1], match[3]);
            }
        } else if (match[2] == ':=') { // Key/value pair
            ret.keys[match[1]] = unescapeValue(match[3]);
        } else {
            throw new Error("Logic error in NRRD parser."); // This should never happen (unless the NRRD syntax is extended and the regexp is updated, but this section is not, or some other programmer error).
        }
    }

    // Make sure the file satisfies the requirements of the NRRD format
    checkNRRD(ret);
    
    // "Parse" data
    if ('dataFile' in ret) {
        console.warn("No support for external data yet!");
    } else {
        switch(ret.encoding) {
        case 'raw':
            ret.data = parseNRRDRawData(ret.buffer, ret.type, ret.sizes, {
                endian: ret.endian, blockSize: ret.blockSize
            });
            break;
        case 'ascii':
            ret.data = parseNRRDTextData(ret.buffer, ret.type, ret.sizes);
            break;
        default:
            console.warn("Unsupported NRRD encoding: " + ret.encoding);
        }
    }
    
    return ret;
};

function escapeValue(val) {
    return val.replace('\\', '\\\\').replace('\n', '\\n');
}

function unescapeValue(val) {
    return val.split('\\\\').map(
        function(s) { return s.replace('\\n', '\n'); }
        ).join('\\');
}

// Serializes NRRD fields
function serializeField(prop, value, dimension, spaceDimension) {
    var line;
    var propNRRD = mapJavascriptToNRRD(prop);
    switch(prop) {
    // nrrd-js stuff: skip
    case 'data':
    case 'buffer':
    case 'keys':
    case 'version':
        break;
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
    case 'space':
        line = propNRRD + ": " + value;
        break;
    // Integers (no infinity or whatever, just a plain integer, so the default serialization is good enough)
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'dimension':
    case 'spaceDimension':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should at least contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Floats (default serialization is good enough, as NaN contains nan, ignoring case, and similarly for Infinity inf)
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should contain a number!");
        line = propNRRD + ": " + value;
        break;
    // Vectors
    case 'spaceOrigin':
        assert(value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": (" + value.join(",") + ")";
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "string" || val instanceof String, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.map(serializeNRRDQuotedString).join(" ");
        break;
    // Lists of integers
    case 'sizes':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });
        line = propNRRD + ": " + value.join(" ");
        break;
    // Lists of vectors (dimension sized)
    case 'spaceDirections':
        assert(value.length !== undefined && value.length === dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // Lists of vectors (space dimension sized)
    case 'measurementFrame':
        assert(value.length !== undefined && value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");
        value.forEach(function (vec) {
          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");
          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });
        });
        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");
        break;
    // One-of-a-kind fields
    case 'type':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'encoding':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'endian':
        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");
        line = propNRRD + ": " + value;
        break;
    case 'dataFile':
        if (value.length || (value.files && 'subdim' in value)) {
            // List of data files: skip for now
        } else {
            line = propNRRD + ": " + serializeNRRDDataFile(value);
        }
        break;
    case 'centers':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    case 'kinds':
        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");
        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + prop + ", skipping.");
    }
    return line;
}

// Parses and normalizes NRRD fields, assumes the field names are already lower case.
function parseField(identifier, descriptor) {
    switch(identifier) {
    // Literal (uninterpreted) fields
    case 'content':
    case 'number':
    case 'sampleUnits':
        break;
    // Integers
    case 'dimension':
    case 'blockSize':
    case 'lineSkip':
    case 'byteSkip':
    case 'spaceDimension':
        descriptor = parseNRRDInteger(descriptor);
        break;
    // Floats
    case 'min':
    case 'max':
    case 'oldMin':
    case 'oldMax':
        descriptor = parseNRRDFloat(descriptor);
        break;
    // Vectors
    case 'spaceOrigin':
        descriptor = parseNRRDVector(descriptor);
        break;
    // Lists of strings
    case 'labels':
    case 'units':
    case 'spaceUnits':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDQuotedString);
        break;
    // Lists of integers
    case 'sizes':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDInteger);
        break;
    // Lists of floats
    case 'spacings':
    case 'thicknesses':
    case 'axisMins':
    case 'axisMaxs':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDFloat);
        break;
    // Lists of vectors
    case 'spaceDirections':
    case 'measurementFrame':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDVector);
        break;
    // One-of-a-kind fields
    case 'type':
        descriptor = parseNRRDType(descriptor);
        break;
    case 'encoding':
        descriptor = parseNRRDEncoding(descriptor);
        break;
    case 'endian':
        descriptor = parseNRRDEndian(descriptor);
        break;
    case 'dataFile':
        descriptor = parseNRRDDataFile(descriptor);
        break;
    case 'centers':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDCenter);
        break;
    case 'kinds':
        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDKind);
        break;
    case 'space':
        descriptor = parseNRRDSpace(descriptor);
        break;
    // Something unknown
    default:
        console.warn("Unrecognized NRRD field: " + identifier);
    }
    return descriptor;
}

// This only includes names whose lower case form is different from the Javascript form.
var mapNRRDToJavascriptStatic = {
    'block size': 'blockSize',
    'blocksize': 'blockSize',
    'old min': 'oldMin',
    'oldmin': 'oldMin',
    'old max': 'oldMax',
    'oldmax': 'oldMax',
    'data file': 'dataFile',
    'datafile': 'dataFile',
    'line skip': 'lineSkip',
    'lineskip': 'lineSkip',
    'byte skip': 'byteSkip',
    'byteskip': 'byteSkip',
    'sample units': 'sampleUnits',
    'sampleunits': 'sampleUnits',
    'axis mins': 'axisMins',
    'axis maxs': 'axisMaxs',
    'centers': 'centers', // Not different, just included so it is clear why centerings maps to centers
    'centerings': 'centers',
    'space dimension': 'spaceDimension',
    'space units': 'spaceUnits',
    'space origin': 'spaceOrigin',
    'space directions': 'spaceDirections',
    'measurement frame': 'measurementFrame'
};
var mapJavascriptToNRRDStatic = function() {
  var id, m = {};
  for(id in mapNRRDToJavascriptStatic) {
    m[mapNRRDToJavascriptStatic[id]] = id;
  }
  return m;
}();
function mapNRRDToJavascript(id) {
    // In any case, use the lower case version of the id
    id = id.toLowerCase();
    // Filter out any fields for which we have an explicit Javascript name
    if (id in mapNRRDToJavascriptStatic) return mapNRRDToJavascriptStatic[id];
    // Otherwise, just return the (lower case) id
    return id;
}
function mapJavascriptToNRRD(id) {
    // Filter out any fields for which we have an explicit NRRD name
    if (id in mapJavascriptToNRRDStatic) return mapJavascriptToNRRDStatic[id];
    // Otherwise, just return the id
    return id;
}

function parseNRRDInteger(str) {
    var val = parseInt(str, 10);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD integer: " + str);
    return val;
}

function parseNRRDFloat(str) {
    str = str.toLowerCase();
    if (str.indexOf('nan')>=0) return NaN;
    if (str.indexOf('-inf')>=0) return -Infinity;
    if (str.indexOf('inf')>=0) return Infinity;
    var val = parseFloat(str);
    if (Number.isNaN(val)) throw new Error("Malformed NRRD float: " + str);
    return val;
}

function parseNRRDVector(str) {
    if (str == "none") return null;
    if (str.length<2 || str[0]!=="(" || str[str.length-1]!==")") throw new Error("Malformed NRRD vector: " + str);
    return str.slice(1, -1).split(",").map(parseNRRDFloat);
}

function parseNRRDQuotedString(str) {
    if (length<2 || str[0]!='"' || str[str.length-1]!='"') {
        throw new Error("Invalid NRRD quoted string: " + str);
    }
    return str.slice(1, -1).replace('\\"', '"');
}

function serializeNRRDQuotedString(str) {
    return '"' + str.replace('"', '\\"') + '"';
}

var whitespaceListSeparator = /[ \t]+/; // Note that this excludes other types of whitespace on purpose!
function parseNRRDWhitespaceSeparatedList(str, parseElement) {
    return str.split(whitespaceListSeparator).map(parseElement);
}

function parseNRRDType(descriptor) {
    switch(descriptor.toLowerCase()) {
    case "signed char":
    case "int8":
    case "int8_t":
        return 'int8';
    case "uchar":
    case "unsigned char":
    case "uint8":
    case "uint8_t":
        return 'uint8';
    case "short":
    case "short int":
    case "signed short":
    case "signed short int":
    case "int16":
    case "int16_t":
        return 'int16';
    case "ushort":
    case "unsigned short":
    case "unsigned short int":
    case "uint16":
    case "uint16_t":
        return 'uint16';
    case "int":
    case "signed int":
    case "int32":
    case "int32_t":
        return 'int32';
    case "uint":
    case "unsigned int":
    case "uint32":
    case "uint32_t":
        return 'uint32';
    case "longlong":
    case "long long":
    case "long long int":
    case "signed long long":
    case "signed long long int":
    case "int64":
    case "int64_t":
        return 'int64';
    case "ulonglong":
    case "unsigned long long":
    case "unsigned long long int":
    case "uint64":
    case "uint64_t":
        return 'uint64';
    case "float":
        return 'float';
    case "double":
        return 'double';
    case "block":
        return 'block';
    default:
        console.warn("Unrecognized NRRD type: " + descriptor);
        return descriptor;
    }
}

function parseNRRDEncoding(encoding) {
    switch(encoding.toLowerCase()) {
    case "raw":
        return "raw";
    case "txt":
    case "text":
    case "ascii":
        return "ascii";
    case "hex":
        return "hex";
    case "gz":
    case "gzip":
        return "gzip";
    case "bz2":
    case "bzip2":
        return "bzip2";
    default:
        console.warn("Unrecognized NRRD encoding: " + encoding);
        return encoding;
    }
}

function parseNRRDSpace(space) {
    switch(space.toLowerCase()) {
    case "right-anterior-superior":
    case "ras":
        return "right-anterior-superior";
    case "left-anterior-superior":
    case "las":
        return "left-anterior-superior";
    case "left-posterior-superior":
    case "lps":
        return "left-posterior-superior";
 	  case "right-anterior-superior-time":
 	  case "rast":
        return "right-anterior-superior-time";
    case "left-anterior-superior-time":
    case "last":
        return "left-anterior-superior-time";
    case "left-posterior-superior-time":
    case "lpst":
        return "left-posterior-superior-time";
    case "scanner-xyz":
        return "scanner-xyz";
    case "scanner-xyz-time":
        return "scanner-xyz-time";
    case "3d-right-handed":
        return "3D-right-handed";
    case "3d-left-handed":
        return "3D-left-handed";
    case "3d-right-handed-time":
        return "3D-right-handed-time";
    case "3d-left-handed-time":
        return "3D-left-handed-time";
    default:
        console.warn("Unrecognized space: " + space);
        return space;
    }
}

function parseNRRDEndian(endian) {
    switch(endian.toLowerCase()) {
    case 'little':
        return 'little';
    case 'big':
        return 'big';
    default:
        console.warn("Unrecognized NRRD endianness: " + endian);
        return endian;
    }
}

// Note that this function will never encounter the LIST data file specification format, as this is handled elsewhere.
var dataFileFormatRE = / (-?\d+) (-?\d+) (-?\d+)(?: (\d+))?$/;
function parseNRRDDataFile(dataFile) {
    var match = dataFileFormatRE.exec(dataFile);
    if (match) { // We have a format specification
        if (match.length == 5 && match[4]) { // subdim specification
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3]),
                subdim: parseNRRDInteger(match[4])
            };
        } else {
            return {
                format: dataFile.substring(0, match.index),
                min: parseNRRDInteger(match[1]),
                max: parseNRRDInteger(match[2]),
                step: parseNRRDInteger(match[3])
            };
        }
    } else { // Just a file
        return dataFile;
    }
}

function serializeNRRDDataFile(dataFile) {
    if ((typeof dataFile) == "string" || dataFile instanceof String) {
        return dataFile;
    } else if ('format' in dataFile && 'min' in dataFile && 'max' in dataFile && 'step' in dataFile) {
        if ('subdim' in dataFile) {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step + " " + dataFile.subdim;
        } else {
            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step;
        }
    } else {
        throw new Error("Unrecognized data file format!");
    }
}

function parseNRRDCenter(center) {
    switch(center.toLowerCase()) {
    case "cell":
        return "cell";
    case "node":
        return "node";
    case "???":
    case "none":
        return null;
    default:
        console.warn("Unrecognized NRRD center: " + center);
        return center;
    }
}

var NRRDKinds = {
    "domain": "domain",
    "space": "space",
    "time": "time",
    "list": "list",
    "point": "point",
    "vector": "vector",
    "covariant-vector": "covariant-vector",
    "normal": "normal",
    "stub": "stub",
    "scalar": "scalar",
    "complex": "complex",
    "2-vector": "2-vector",
    "3-color": "3-color",
    "rgb-color": "RGB-color",
    "hsv-color": "HSV-color",
    "xyz-color": "XYZ-color",
    "4-color": "4-color",
    "rgba-color": "RGBA-color",
    "3-vector": "3-vector",
    "3-gradient": "3-gradient",
    "3-normal": "3-normal",
    "4-vector": "4-vector",
    "quaternion": "quaternion",
    "2d-symmetric-matrix": "2D-symmetric-matrix",
    "2d-masked-symmetric-matrix": "2D-masked-symmetric-matrix",
    "2d-matrix": "2D-matrix",
    "2d-masked-matrix": "2D-masked-matrix",
    "3d-symmetric-matrix": "3D-symmetric-matrix",
    "3d-masked-symmetric-matrix": "3D-masked-symmetric-matrix",
    "3d-matrix": "3D-matrix",
    "3d-masked-matrix": "3D-masked-matrix",
    "???": null,
    "none": null
};
function parseNRRDKind(kind) {
    var kindLC = kind.toLowerCase();
    if (kindLC in NRRDKinds) return NRRDKinds[kindLC];
    console.warn("Unrecognized NRRD kind: " + kind);
    return kind;
}

function serializeNRRDOptional(a) {
    return a===null ? "???" : a;
}

var systemEndianness = (function() {
    var buf = new ArrayBuffer(4),
        intArr = new Uint32Array(buf),
        byteArr = new Uint8Array(buf);
    intArr[0] = 0x01020304;
    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {
        return 'big';
    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {
        return 'little';
    }
    console.warn("Unrecognized system endianness!");
    return undefined;
})();

function parseNRRDRawData(buffer, type, sizes, options) {
    var i, arr, view, totalLen = 1, endianFlag;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    if (type == 'block') {
        // Don't do anything special, just return the slice containing all blocks.
        return buffer.slice(0,totalLen*options.blockSize);
    } else if (type == 'int8' || type == 'uint8' || options.endian == systemEndianness) {
        switch(type) {
        case "int8":
            checkSize(1);
            return new Int8Array(buffer.slice(0,totalLen));
        case "uint8":
            checkSize(1);
            return new Uint8Array(buffer.slice(0,totalLen));
        case "int16":
            checkSize(2);
            return new Int16Array(buffer.slice(0,totalLen*2));
        case "uint16":
            checkSize(2);
            return new Uint16Array(buffer.slice(0,totalLen*2));
        case "int32":
            checkSize(4);
            return new Int32Array(buffer.slice(0,totalLen*4));
        case "uint32":
            checkSize(4);
            return new Uint32Array(buffer.slice(0,totalLen*4));
        //case "int64":
        //    checkSize(8);
        //    return new Int64Array(buffer.slice(0,totalLen*8));
        //case "uint64":
        //    checkSize(8);
        //    return new Uint64Array(buffer.slice(0,totalLen*8));
        case "float":
            checkSize(4);
            return new Float32Array(buffer.slice(0,totalLen*4));
        case "double":
            checkSize(8);
            return new Float64Array(buffer.slice(0,totalLen*8));
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    } else {
        switch(options.endian) {
        case 'big':
            endianFlag = false;
            break;
        case 'little':
            endianFlag = true;
            break;
        default:
            console.warn("Unsupported endianness in NRRD file: " + options.endian);
            return undefined;
        }
        view = new DataView(buffer);
        switch(type) {
        case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
            arr = new Int8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt8(i);
            }
            return arr;
        case "uint8":
            arr = new Uint8Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint8(i);
            }
            return arr;
        case "int16":
            arr = new Int16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt16(i*2);
            }
            return arr;
        case "uint16":
            arr = new Uint16Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint16(i*2);
            }
            return arr;
        case "int32":
            arr = new Int32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getInt32(i*4);
            }
            return arr;
        case "uint32":
            arr = new Uint32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getUint32(i*4);
            }
            return arr;
        //case "int64":
        //    arr = new Int64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getInt64(i*8);
        //    }
        //    return arr;
        //case "uint64":
        //    arr = new Uint64Array(totalLen);
        //    for(i=0; i<totalLen; i++) {
        //        arr[i] = view.getUint64(i*8);
        //    }
        //    return arr;
        case "float":
            arr = new Float32Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat32(i*4);
            }
            return arr;
        case "double":
            arr = new Float64Array(totalLen);
            for(i=0; i<totalLen; i++) {
                arr[i] = view.getFloat64(i*8);
            }
            return arr;
        default:
            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");
            return undefined;
        }
    }
    function checkSize(sizeOfType) {
        if (buffer.byteLength<totalLen*sizeOfType) throw new Error("NRRD file does not contain enough data!");
    }
}

var whitespaceDataValueListSeparatorRE = /[ \t\n\r\v\f]+/;
function parseNRRDTextData(buffer, type, sizes) {
    var i, buf8, str, strList, totalLen = 1;
    for(i=0; i<sizes.length; i++) {
        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");
        totalLen *= sizes[i];
    }
    buf8 = new Uint8Array(buffer);
    str = String.fromCharCode.apply(null, buf8);
    strList = str.split(whitespaceDataValueListSeparatorRE);
    if (strList.length<totalLen) {
        throw new Error("Not enough data in NRRD file!");
    } else if (strList.length>totalLen) {
        if (strList[0] === '') strList = strList.slice(1); // Strictly speaking the spec doesn't (explicitly) allow whitespace in front of the first number, but let's be lenient.
        strList = strList.slice(0, totalLen);
    }
    switch(type) {
    case "int8":
        return new Int8Array(strList.map(parseNRRDInteger));
    case "uint8":
        return new Uint8Array(strList.map(parseNRRDInteger));
    case "int16":
        return new Int16Array(strList.map(parseNRRDInteger));
    case "uint16":
        return new Uint16Array(strList.map(parseNRRDInteger));
    case "int32":
        return new Int32Array(strList.map(parseNRRDInteger));
    case "uint32":
        return new Uint32Array(strList.map(parseNRRDInteger));
    //case "int64":
    //    return new Int64Array(strList.map(parseNRRDInteger));
    //case "uint64":
    //    return new Uint64Array(strList.map(parseNRRDInteger));
    case "float":
        return new Float32Array(strList.map(parseNRRDFloat));
    case "double":
        return new Float64Array(strList.map(parseNRRDFloat));
    default:
        console.warn("Unsupported NRRD type: " + type + ".");
        return undefined;
    }
}

// This ALWAYS returns an integer, or throws an exception.
function getNRRDTypeSize(type) {
    switch(type) {
    case "int8":
        return 1;
    case "uint8":
        return 1;
    case "int16":
        return 2;
    case "uint16":
        return 2;
    case "int32":
        return 4;
    case "uint32":
        return 4;
    case "int64":
        return 8;
    case "uint64":
        return 8;
    case "float":
        return 4;
    case "double":
        return 8;
    default:
        throw new Error("Do not know the size of NRRD type: " + type);
    }
}

function checkNRRD(ret) {
    // Always necessary fields
    if (ret.dimension===undefined) {
        throw new Error("Dimension missing from NRRD file!");
    } else if (ret.type===undefined) {
        throw new Error("Type missing from NRRD file!");
    } else if (ret.encoding===undefined) {
        throw new Error("Encoding missing from NRRD file!");
    } else if (ret.sizes===undefined) {
        throw new Error("Sizes missing from NRRD file!");
    }
    
    // Sometimes necessary fields
    if (ret.type != 'block' && ret.type != 'int8' && ret.type != 'uint8' &&
          ret.encoding != 'ascii' && ret.endian === undefined) {
        throw new Error("Endianness missing from NRRD file!");
    } else if (ret.type == 'block' && ret.blockSize === undefined) {
        throw new Error("Missing block size in NRRD file!");
    }
    
    // Check dimension and per-axis field lengths
    if (ret.dimension === 0) {
        throw new Error("Zero-dimensional NRRD file?");
    } else if (ret.dimension != ret.sizes.length) {
        throw new Error("Length of 'sizes' is different from 'dimension' in an NRRD file!");
    } else if (ret.spacings && ret.dimension != ret.spacings.length) {
        throw new Error("Length of 'spacings' is different from 'dimension' in an NRRD file!");
    } else if (ret.thicknesses && ret.dimension != ret.thicknesses.length) {
        throw new Error("Length of 'thicknesses' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMins && ret.dimension != ret.axisMins.length) {
        throw new Error("Length of 'axis mins' is different from 'dimension' in an NRRD file!");
    } else if (ret.axisMaxs && ret.dimension != ret.axisMaxs.length) {
        throw new Error("Length of 'axis maxs' is different from 'dimension' in an NRRD file!");
    } else if (ret.centers && ret.dimension != ret.centers.length) {
        throw new Error("Length of 'centers' is different from 'dimension' in an NRRD file!");
    } else if (ret.labels && ret.dimension != ret.labels.length) {
        throw new Error("Length of 'labels' is different from 'dimension' in an NRRD file!");
    } else if (ret.units && ret.dimension != ret.units.length) {
        throw new Error("Length of 'units' is different from 'dimension' in an NRRD file!");
    } else if (ret.kinds && ret.dimension != ret.kinds.length) {
        throw new Error("Length of 'kinds' is different from 'dimension' in an NRRD file!");
    }
    
    // TODO: Check space/orientation fields.
    
    // We should either have inline data or external data
    if ((ret.data === undefined || ret.data.length === 0) && (ret.buffer === undefined || ret.buffer.byteLength === 0) && ret.dataFile === undefined) {
        throw new Error("NRRD file has neither inline or external data!");
    }
}

function castTypedArray(data, type) {
    switch(type) {
    case "int8":
        return new Int8Array(data);
    case "uint8":
        return new Uint8Array(data);
    case "int16":
        return new Int16Array(data);
    case "uint16":
        return new Uint16Array(data);
    case "int32":
        return new Int32Array(data);
    case "uint32":
        return new Uint32Array(data);
    //case "int64":
    //    return new Int64Array(data);
    //case "uint64":
    //    return new Uint64Array(data);
    case "float":
        return new Float32Array(data);
    case "double":
        return new Float64Array(data);
    default:
        throw new Error("Cannot cast to NRRD type: " + type);
    }
}

function serializeToBuffer(data, type, endian) {
    var i, endianFlag, view, nativeSize = getNRRDTypeSize(type), buffer = new ArrayBuffer(data.length*nativeSize);
    switch(endian) {
    case 'big':
        endianFlag = false;
        break;
    case 'little':
        endianFlag = true;
        break;
    default:
        console.warn("Unsupported endianness in NRRD file: " + endian);
        return undefined;
    }
    view = new DataView(buffer);
    switch(type) {
    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.
        for(i=0; i<data.length; i++) {
            view.setInt8(i, data[i], endianFlag);
        }
        return buffer;
    case "uint8":
        for(i=0; i<data.length; i++) {
            view.setUint8(i, data[i], endianFlag);
        }
        return buffer;
    case "int16":
        for(i=0; i<data.length; i++) {
            view.setInt16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "uint16":
        for(i=0; i<data.length; i++) {
            view.setUint16(i*2, data[i], endianFlag);
        }
        return buffer;
    case "int32":
        for(i=0; i<data.length; i++) {
            view.setInt32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "uint32":
        for(i=0; i<data.length; i++) {
            view.setUint32(i*4, data[i], endianFlag);
        }
        return buffer;
    //case "int64":
    //    for(i=0; i<data.length; i++) {
    //        view.setInt64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    //case "uint64":
    //    for(i=0; i<data.length; i++) {
    //        view.setUint64(i*8, data[i], endianFlag);
    //    }
    //    return buffer;
    case "float":
        for(i=0; i<data.length; i++) {
            view.setFloat32(i*4, data[i], endianFlag);
        }
        return buffer;
    case "double":
        for(i=0; i<data.length; i++) {
            view.setFloat64(i*8, data[i], endianFlag);
        }
        return buffer;
    default:
        console.warn("Cannot serialize NRRD type: " + type + ".");
        return undefined;
    }
}

function serializeToTextBuffer(data) {
    var i, strs = new Array(data.length), str, buffer, arr;
    for(i=0; i<data.length; i++) {
        strs[i] = '' + data[i];
    }
    str = strs.join(" ");
    buffer = new ArrayBuffer(str.length);
    arr = new Uint8Array(buffer);
    for(i=0; i<arr.length; i++) {
        arr[i] = str.charCodeAt(i);
    }
    return buffer;
}

},{"assert":3}],51:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":52,"./lib/inflate":53,"./lib/utils/common":54,"./lib/zlib/constants":57}],52:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":54,"./utils/strings":55,"./zlib/deflate":59,"./zlib/messages":64,"./zlib/zstream":66}],53:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":54,"./utils/strings":55,"./zlib/constants":57,"./zlib/gzheader":60,"./zlib/inflate":62,"./zlib/messages":64,"./zlib/zstream":66}],54:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],55:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":54}],56:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],57:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],58:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],59:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":54,"./adler32":56,"./crc32":58,"./messages":64,"./trees":65}],60:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],61:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],62:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../utils/common":54,"./adler32":56,"./crc32":58,"./inffast":61,"./inftrees":63,"dup":12}],63:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../utils/common":54,"dup":13}],64:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],65:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../utils/common":54,"dup":15}],66:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],67:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":68}],68:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],69:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],70:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],72:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":70,"./encode":71}],73:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":74,"./_stream_writable":76,"core-util-is":24,"inherits":28,"process-nextick-args":67}],74:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"./internal/streams/BufferList":77,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"isarray":78,"process-nextick-args":67,"string_decoder/":80,"util":5}],75:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":73,"core-util-is":24,"inherits":28}],76:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":73,"_process":68,"buffer":20,"buffer-shims":19,"core-util-is":24,"events":26,"inherits":28,"process-nextick-args":67,"util-deprecate":83}],77:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
},{"buffer":20,"buffer-shims":19}],78:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],79:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":75}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":82,"punycode":69,"querystring":72}],82:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],83:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],85:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],86:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":85,"_process":68,"inherits":84}],87:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// LEFT PAD //

/**
* FUNCTION: lpad( str, len[, pad] )
*	Left pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function lpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return repeat( p, n ) + str;
} // end FUNCTION lpad()


// EXPORTS //

module.exports = lpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],88:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );


// NOTES //

/**
* The algorithmic trick used in the implementation is to treat string concatenation the same as binary addition (i.e., any natural number (nonnegative integer) can be expressed as a sum of powers of two).
*
* For example,
*
*  n = 10 => 1010 => 2^3 + 2^0 + 2^1 + 2^0
*
* We can produce a 10-repeat string by "adding" the results of a 8-repeat string and a 2-repeat string.
*
* The implementation is then as follows:
*  : Let `s` be the string to be repeated and `o` be an output string.
*  0) Initialize an output string `o`.
*  1) Check the least significant bit to determine if the current `s` string should be "added" to the output "total".
*     - if the bit is a one, add
*     - otherwise, move on
*  2) Double the string `s` by adding `s` to `s`.
*  3) Right-shift the bits of `n`.
*  4) Check if we have shifted off all bits.
*     - if yes, done.
*     - otherwise, move on
*  5) Repeat 1-4.
*
* The result is that, as the string is repeated, we continually check to see if the doubled string is one which we want to add to our "total".
*
* The algorithm runs in O(log_2(n)) compared to O(n).
*/


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// REPEAT //

/**
* FUNCTION: repeat( str, n )
*	Repeats a string a specified number of times and returns the concatenated result.
*
* @param {String} str - string to repeat
* @param {Number} n - number of times to repeat the string
* @returns {String}
*/
function repeat( str, n ) {
	var rpt;
	var cnt;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( n ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + n + '`.' );
	}
	if ( str.length === 0 || n === 0 ) {
		return '';
	}
	// Check that output string will not exceed the maximum string length:
	if ( str.length * n > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	rpt = '';
	cnt = n;
	for( ; ; ) {
		// If the count is odd, append the current concatenated string:
		if ( (cnt&1) === 1 ) {
			rpt += str;
		}
		// Right-shift the bits:
		cnt >>>= 1;
		if ( cnt === 0 ) {
			break;
		}
		// Double the string:
		str += str;
	}
	return rpt;
} // end FUNCTION repeat()


// EXPORTS //

module.exports = repeat;

},{"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],89:[function(require,module,exports){
'use strict';

// MODULES //

var isString = require( 'validate.io-string-primitive' );
var isNonNegativeInteger = require( 'validate.io-nonnegative-integer' );
var ceil = require( 'math-ceil' );
var repeat = require( 'utils-repeat-string' );


// CONSTANTS //

var MAX_SAFE_INTEGER = 9007199254740991; // 2**53 - 1


// RIGHT PAD //

/**
* FUNCTION: rpad( str, len[, pad] )
*	Right pads a string such that the padded string has a length of at least `len`.
*
* @param {String} str - string to pad
* @param {Number} len - minimum string length
* @param {String} [pad=' '] - string used to pad
* @returns {String} padded string
*/
function rpad( str, len, pad ) {
	var n;
	var p;
	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a string. Value: `' + str + '`.' );
	}
	if ( !isNonNegativeInteger( len ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a nonnegative integer. Value: `' + len + '`.' );
	}
	if ( arguments.length > 2 ) {
		p = pad;
		if ( !isString( p ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a string. Value: `' + p + '`.' );
		}
		if ( p.length === 0 ) {
			throw new RangeError( 'invalid input argument. Pad string must not be an empty string.' );
		}
	} else {
		p = ' ';
	}
	if ( len > MAX_SAFE_INTEGER ) {
		throw new RangeError( 'invalid input argument. Output string length exceeds maximum allowed string length.' );
	}
	n = ( len - str.length ) / p.length;
	if ( n <= 0 ) {
		return str;
	}
	n = ceil( n );
	return str + repeat( p, n );
} // end FUNCTION rpad()


// EXPORTS //

module.exports = rpad;

},{"math-ceil":41,"utils-repeat-string":88,"validate.io-nonnegative-integer":91,"validate.io-string-primitive":93}],90:[function(require,module,exports){
/**
*
*	VALIDATE: integer
*
*
*	DESCRIPTION:
*		- Validates if a value is an integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

// MODULES //

var isNumber = require( 'validate.io-number' );


// ISINTEGER //

/**
* FUNCTION: isInteger( value )
*	Validates if a value is an integer.
*
* @param {Number} value - value to be validated
* @returns {Boolean} boolean indicating whether value is an integer
*/
function isInteger( value ) {
	return isNumber( value ) && value%1 === 0;
} // end FUNCTION isInteger()


// EXPORTS //

module.exports = isInteger;

},{"validate.io-number":92}],91:[function(require,module,exports){
/**
*
*	VALIDATE: nonnegative-integer
*
*
*	DESCRIPTION:
*		- Validates if a value is a nonnegative integer.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2015. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2015.
*
*/

'use strict';

// MODULES //

var isInteger = require( 'validate.io-integer' );


// IS NONNEGATIVE INTEGER //

/**
* FUNCTION: isNonNegativeInteger( value )
*	Validates if a value is a nonnegative integer.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating if a value is a nonnegative integer
*/
function isNonNegativeInteger( value ) {
	return isInteger( value ) && value >= 0;
} // end FUNCTION isNonNegativeInteger()


// EXPORTS //

module.exports = isNonNegativeInteger;

},{"validate.io-integer":90}],92:[function(require,module,exports){
/**
*
*	VALIDATE: number
*
*
*	DESCRIPTION:
*		- Validates if a value is a number.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isNumber( value )
*	Validates if a value is a number.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is a number
*/
function isNumber( value ) {
	return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) && value.valueOf() === value.valueOf();
} // end FUNCTION isNumber()


// EXPORTS //

module.exports = isNumber;

},{}],93:[function(require,module,exports){
'use strict';

/**
* Tests if a value is a string primitive.
*
* @param {*} value - value to test
* @returns {Boolean} boolean indicating if a value is a string primitive
*/
function isString( value ) {
	return typeof value === 'string';
} // end FUNCTION isString()


// EXPORTS //

module.exports = isString;

},{}],94:[function(require,module,exports){
module.exports={
  "name": "ami.js",
  "version": "0.0.17-dev",
  "main": "lib/ami.js",
  "keywords": [
    "ami",
    "ami.js",
    "three.js",
    "webgl",
    "dicom",
    "nifti",
    "awesome",
    "medical",
    "imaging",
    "xtk",
    "nrrd",
    "vtk",
    "stl",
    "trk"
  ],
  "author": {
    "name": "Nicolas Rannou",
    "email": "nicolas@eunate.ch",
    "url": "https://eunate.ch"
  },
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://fnndsc.github.io/ami"
  },
  "config": {
    "threeVersion": "86",
    "amiCDN": "https://cdnjs.cloudflare.com/ajax/libs/ami.js/",
    "gaKey": "UA-39303022-3",
    "transforms": "-t [babelify --presets [ es2015 ] ]"
  },
  "dependencies": {
    "dicom-parser": "1.7.3",
    "image-JPEG2000": "OHIF/image-JPEG2000#master",
    "jpeg-lossless-decoder-js": "1.2.3",
    "math-float32-to-binary-string": "^1.0.0",
    "nifti-reader-js": "v0.5.3",
    "nrrd-js": "^0.2.1",
    "pako": "1.0.1"
  },
  "scripts": {
    "dist:prepare": "node ./scripts/$npm_package_config_mode.js --dist",
    "dist:watchAmi": "watchify -d src/ami $npm_package_config_transforms --standalone AMI -o dist/build/ami.js -v",
    "dist:watch": "watchify $npm_package_config_target -d $npm_package_config_transforms -o dist/$npm_package_config_target -v",
    "dist": "npm run dist:prepare --ami.js:mode=$npm_package_config_mode && (live-server dist --open=$npm_package_config_open & npm run dist:watch --ami.js:target=$npm_package_config_target)",
    "example": "npm run clean && node ./scripts/router.js examples ",
    "lesson": "npm run clean && mkdir dist/build && touch dist/build/ami.js && node ./scripts/router.js lessons ",
    "demo": "node ./scripts/lessons.js --demo",
    "lint": "eslint **/*.js --quiet",
    "build:examples": "npm run dist:prepare --ami.js:mode=examples && find examples -name '*.js' -print0 | xargs -0 -n1 -I{} bash -c \"echo Building {}; browserify {} -d -v $npm_package_config_transforms > dist/{} \"",
    "build:ami": "browserify src/ami.js -d -v $npm_package_config_transforms --standalone AMI > build/ami.js && uglifyjs build/ami.js -o build/ami.min.js",
    "build": "npm run clean && cp index.html dist/index.html && npm run build:examples && npm run doc",
    "build-cjs": "rimraf lib && cross-env BABEL_ENV=cjs babel ./src -d lib",
    "clean": "rimraf -rf dist/*",
    "test": "karma start",
    "doc": "jsdoc -p -r -R README.md -c jsdoc.conf -d dist/doc src",
    "ami": "npm run lint && npm run demo && npm run build:ami && npm run test",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "devDependencies": {
    "babel-cli": "latest",
    "babel-plugin-add-module-exports": "^0.2.1",
    "babel-polyfill": "^6.13.0",
    "babel-preset-es2015": "^6.13.2",
    "babelify": "7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.2.3",
    "eslint": "latest",
    "eslint-config-google": "latest",
    "gh-pages": "latest",
    "glslify": "5.1.0",
    "jasmine-core": "latest",
    "jsdoc": "jsdoc3/jsdoc#master",
    "karma": "latest",
    "karma-browserify": "latest",
    "karma-jasmine": "latest",
    "karma-phantomjs-launcher": "1.0.4",
    "karma-sinon": "^1.0.5",
    "karma-spec-reporter": "latest",
    "live-server": "^1.1.0",
    "phantomjs-prebuilt": "2.1.14",
    "rimraf": "^2.6.1",
    "shelljs": "latest",
    "sinon": "^2.0.0",
    "uglify-js": "^2.7.3",
    "watchify": "3.7.0"
  },
  "engines": {
    "node": ">=6.9.0"
  },
  "browserify": {
    "transform": [
      "babelify"
    ]
  }
}

},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras/cameras');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('./controls/controls');

var _controls2 = _interopRequireDefault(_controls);

var _core = require('./core/core');

var _core2 = _interopRequireDefault(_core);

var _geometries = require('./geometries/geometries');

var _geometries2 = _interopRequireDefault(_geometries);

var _helpers = require('./helpers/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('./loaders/loaders');

var _loaders2 = _interopRequireDefault(_loaders);

var _models = require('./models/models');

var _models2 = _interopRequireDefault(_models);

var _parsers = require('./parsers/parsers');

var _parsers2 = _interopRequireDefault(_parsers);

var _shaders = require('./shaders/shaders');

var _shaders2 = _interopRequireDefault(_shaders);

var _widgets = require('./widgets/widgets');

var _widgets2 = _interopRequireDefault(_widgets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pckg = require('../package.json');

exports.default = {
  Cameras: _cameras2.default,
  Controls: _controls2.default,
  Core: _core2.default,
  Geometries: _geometries2.default,
  Helpers: _helpers2.default,
  Loaders: _loaders2.default,
  Models: _models2.default,
  Parsers: _parsers2.default,
  Shaders: _shaders2.default,
  Widgets: _widgets2.default
};


window.console.log('AMI ' + pckg.version + ' ( ThreeJS ' + pckg.config.threeVersion + ')');

},{"../package.json":94,"./cameras/cameras":96,"./controls/controls":98,"./core/core":103,"./geometries/geometries":107,"./helpers/helpers":112,"./loaders/loaders":128,"./models/models":132,"./parsers/parsers":137,"./shaders/shaders":155,"./widgets/widgets":169}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cameras = require('./cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module cameras
 */
exports.default = {
  Orthographic: _cameras2.default
};

},{"./cameras.orthographic":97}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
var CamerasOrthographic = function (_THREE$OrthographicCa) {
  _inherits(CamerasOrthographic, _THREE$OrthographicCa);

  function CamerasOrthographic(left, right, top, bottom, near, far) {
    _classCallCheck(this, CamerasOrthographic);

    var _this = _possibleConstructorReturn(this, (CamerasOrthographic.__proto__ || Object.getPrototypeOf(CamerasOrthographic)).call(this, left, right, top, bottom, near, far));

    _this._front = null;
    _this._back = null;

    _this._directions = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

    _this._directionsLabel = ['A', 'P', // TOP/BOTTOM
    'L', 'R', // LEFT/RIGHT
    'I', 'S'];

    _this._orientation = 'default';
    _this._convention = 'radio';
    _this._stackOrientation = 0;

    _this._right = null;
    _this._up = null;
    _this._direction = null;

    _this._controls = null;
    _this._box = null;
    _this._canvas = {
      width: null,
      height: null
    };

    _this._fromFront = true;
    _this._angle = 0;
    return _this;
  }

  /**
   * Initialize orthographic camera variables
   */


  _createClass(CamerasOrthographic, [{
    key: 'init',
    value: function init(xCosine, yCosine, zCosine, controls, box, canvas) {
      // DEPRECATED
      console.warn('cameras.orthographic.init(...) is deprecated.\n      Use .cosines, .controls, .box and .canvas instead.');

      //
      if (!(_core4.default.vector3(xCosine) && _core4.default.vector3(yCosine) && _core4.default.vector3(zCosine) && _core4.default.box(box) && controls)) {
        window.console.log('Invalid input provided.');

        return false;
      }

      this._right = xCosine;
      this._up = this._adjustTopDirection(xCosine, yCosine);
      this._direction = new THREE.Vector3().crossVectors(this._right, this._up);
      this._controls = controls;
      this._box = box;
      this._canvas = canvas;

      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'update',
    value: function update() {
      // http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm
      // do magics depending on orientation and convention
      // also needs a default mode

      if (this._orientation === 'default') {
        switch (this._getMaxIndex(this._directions[2])) {

          case 0:
            this._orientation = 'sagittal';
            break;

          case 1:
            this._orientation = 'coronal';
            break;

          case 2:
            this._orientation = 'axial';
            break;

          default:
            this._orientation = 'free';
            break;
        }
      }

      if (this._orientation === 'free') {
        this._right = this._directions[0];
        this._up = this._directions[1];
        this._direction = this._directions[2];
      } else {
        var leftIndex = this.leftDirection();
        var leftDirection = this._directions[leftIndex];
        var posteriorIndex = this.posteriorDirection();
        var posteriorDirection = this._directions[posteriorIndex];
        var superiorIndex = this.superiorDirection();
        var superiorDirection = this._directions[superiorIndex];

        if (this._convention === 'radio') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards superior
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards posterior
              if (posteriorDirection.y < 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;

          }
        } else if (this._convention === 'neuro') {
          switch (this._orientation) {

            case 'axial':
              // up vector is 'anterior'
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              // looking towards inferior
              if (superiorDirection.z > 0) {
                superiorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = posteriorDirection;
              this._direction = superiorDirection;
              break;

            case 'coronal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards anterior
              if (posteriorDirection.y > 0) {
                posteriorDirection.negate();
              }

              //
              this._right = leftDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = posteriorDirection;
              break;

            case 'sagittal':
              // up vector is 'superior'
              if (superiorDirection.z < 0) {
                superiorDirection.negate();
              }

              // looking towards right
              if (leftDirection.x > 0) {
                leftDirection.negate();
              }

              //
              this._right = posteriorDirection; // does not matter right/left
              this._up = superiorDirection;
              this._direction = leftDirection;

              break;

            default:
              console.warn('"' + this._orientation + '" orientation is not valid.\n                (choices: axial, coronal, sagittal)');
              break;
          }
        } else {
          console.warn(this._convention + ' is not valid (choices: radio, neuro)');
        }
      }

      // that is what determines left/right
      var ray = {
        position: this._box.center,
        direction: this._direction
      };

      var intersections = this._orderIntersections(_core2.default.rayBox(ray, this._box), this._direction);
      this._front = intersections[0];
      this._back = intersections[1];

      // set default values
      this.up.set(this._up.x, this._up.y, this._up.z);
      this._updateCanvas();
      this._updatePositionAndTarget(this._front, this._back);
      this._updateMatrices();
      this._updateDirections();
    }
  }, {
    key: 'leftDirection',
    value: function leftDirection() {
      return this._findMaxIndex(this._directions, 0);
    }
  }, {
    key: 'posteriorDirection',
    value: function posteriorDirection() {
      return this._findMaxIndex(this._directions, 1);
    }
  }, {
    key: 'superiorDirection',
    value: function superiorDirection() {
      return this._findMaxIndex(this._directions, 2);
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 2 steps:
     *   * Flip the "up" vector
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertRows',
    value: function invertRows() {
      // flip "up" vector
      // we flip up first because invertColumns update projectio matrices
      this.up.multiplyScalar(-1);
      this.invertColumns();

      this._updateDirections();
    }

    /**
     * Invert rows in the current slice.
     * Inverting rows in 1 step:
     *   * Look at the slice from the other side
     */

  }, {
    key: 'invertColumns',
    value: function invertColumns() {
      this.center();
      // rotate 180 degrees around the up vector...
      var oppositePosition = this._oppositePosition(this.position);

      // update posistion and target
      // clone is needed because this.position is overwritten in method
      this._updatePositionAndTarget(oppositePosition, this.position.clone());
      this._updateMatrices();
      this._fromFront = !this._fromFront;

      this._angle %= 360;
      this._angle = 360 - this._angle;

      this._updateDirections();
    }

    /**
     * Center slice in the camera FOV.
     * It also updates the controllers properly.
     * We can center a camera from the front or from the back.
     */

  }, {
    key: 'center',
    value: function center() {
      if (this._fromFront) {
        this._updatePositionAndTarget(this._front, this._back);
      } else {
        this._updatePositionAndTarget(this._back, this._front);
      }

      this._updateMatrices();
      this._updateDirections();
    }

    /**
     * Pi/2 rotation around the zCosine axis.
     * Clock-wise rotation from the user point of view.
     */

  }, {
    key: 'rotate',
    value: function rotate() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.center();

      var computedAngle = 90;

      var clockwise = 1;
      if (!this._fromFront) {
        clockwise = -1;
      }

      if (angle === null) {
        computedAngle *= -clockwise;
        this._angle += 90;
      } else {
        computedAngle = 360 - clockwise * (angle - this._angle);
        this._angle = angle;
      }

      this._angle %= 360;

      // Rotate the up vector around the "zCosine"
      var rotation = new THREE.Matrix4().makeRotationAxis(this._direction, computedAngle * Math.PI / 180);
      this.up.applyMatrix4(rotation);

      this._updateMatrices();
      this._updateDirections();
    }

    // dimensions[0] // width
    // dimensions[1] // height
    // direction= 0 width, 1 height, 2 best
    // factor

  }, {
    key: 'fitBox',
    value: function fitBox() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;

      //
      // if (!(dimensions && dimensions.length >= 2)) {
      //   window.console.log('Invalid dimensions container.');
      //   window.console.log(dimensions);

      //   return false;
      // }

      //
      var zoom = 1;

      // update zoom
      switch (direction) {
        case 0:
          zoom = factor * this._computeZoom(this._canvas.width, this._right);
          break;
        case 1:
          zoom = factor * this._computeZoom(this._canvas.height, this._up);
          break;
        case 2:
          zoom = factor * Math.min(this._computeZoom(this._canvas.width, this._right), this._computeZoom(this._canvas.height, this._up));
          break;
        default:
          break;
      }

      if (!zoom) {
        return false;
      }

      this.zoom = zoom;

      this.center();
    }
  }, {
    key: '_adjustTopDirection',
    value: function _adjustTopDirection(horizontalDirection, verticalDirection) {
      var vMaxIndex = this._getMaxIndex(verticalDirection);

      // should handle vMax index === 0
      if (vMaxIndex === 2 && verticalDirection.getComponent(vMaxIndex) < 0 || vMaxIndex === 1 && verticalDirection.getComponent(vMaxIndex) > 0 || vMaxIndex === 0 && verticalDirection.getComponent(vMaxIndex) > 0) {
        verticalDirection.negate();
      }

      return verticalDirection;
    }
  }, {
    key: '_getMaxIndex',
    value: function _getMaxIndex(vector) {
      // init with X value
      var maxValue = Math.abs(vector.x);
      var index = 0;

      if (Math.abs(vector.y) > maxValue) {
        maxValue = Math.abs(vector.y);
        index = 1;
      }

      if (Math.abs(vector.z) > maxValue) {
        index = 2;
      }

      return index;
    }
  }, {
    key: '_findMaxIndex',
    value: function _findMaxIndex(directions, target) {
      // get index of the most superior direction
      var maxIndices = this._getMaxIndices(directions);

      for (var i = 0; i < maxIndices.length; i++) {
        if (maxIndices[i] === target) {
          return i;
        }
      }
    }
  }, {
    key: '_getMaxIndices',
    value: function _getMaxIndices(directions) {
      var indices = [];
      indices.push(this._getMaxIndex(directions[0]));
      indices.push(this._getMaxIndex(directions[1]));
      indices.push(this._getMaxIndex(directions[2]));

      return indices;
    }
  }, {
    key: '_orderIntersections',
    value: function _orderIntersections(intersections, direction) {
      var ordered = intersections[0].dot(direction) < intersections[1].dot(direction);

      if (!ordered) {
        return [intersections[1], intersections[0]];
      }

      return intersections;
    }
  }, {
    key: '_updateCanvas',
    value: function _updateCanvas() {
      var camFactor = 2;
      this.left = -this._canvas.width / camFactor;
      this.right = this._canvas.width / camFactor;
      this.top = this._canvas.height / camFactor;
      this.bottom = -this._canvas.height / camFactor;

      this._updateMatrices();
      this.controls.handleResize();
    }
  }, {
    key: '_oppositePosition',
    value: function _oppositePosition(position) {
      var oppositePosition = position.clone();
      // center world postion around box center
      oppositePosition.sub(this._box.center);
      // rotate
      var rotation = new THREE.Matrix4().makeRotationAxis(this.up, Math.PI);

      oppositePosition.applyMatrix4(rotation);
      // translate back to world position
      oppositePosition.add(this._box.center);
      return oppositePosition;
    }
  }, {
    key: '_computeZoom',
    value: function _computeZoom(dimension, direction) {
      if (!(dimension && dimension > 0)) {
        window.console.log('Invalid dimension provided.');
        window.console.log(dimension);
        return false;
      }

      // ray
      var ray = {
        position: this._box.center.clone(),
        direction: direction
      };

      var intersections = _core2.default.rayBox(ray, this._box);
      if (intersections.length < 2) {
        window.console.log('Can not adjust the camera ( < 2 intersections).');
        window.console.log(ray);
        window.console.log(this._box);
        return false;
      }

      return dimension / intersections[0].distanceTo(intersections[1]);
    }
  }, {
    key: '_updatePositionAndTarget',
    value: function _updatePositionAndTarget(position, target) {
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
    }
  }, {
    key: '_updateMatrices',
    value: function _updateMatrices() {
      this._controls.update();
      // THEN camera
      this.updateProjectionMatrix();
      this.updateMatrixWorld();
    }
  }, {
    key: '_updateLabels',
    value: function _updateLabels() {
      this._directionsLabel = [this._vector2Label(this._up), this._vector2Label(this._up.clone().negate()), this._vector2Label(this._right), this._vector2Label(this._right.clone().negate()), this._vector2Label(this._direction), this._vector2Label(this._direction.clone().negate())];
    }
  }, {
    key: '_vector2Label',
    value: function _vector2Label(direction) {
      var index = this._getMaxIndex(direction);
      // set vector max value to 1
      var scaledDirection = direction.clone().divideScalar(Math.abs(direction.getComponent(index)));
      var delta = 0.2;
      var label = '';

      // loop through components of the vector
      for (var i = 0; i < 3; i++) {
        if (i === 0) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'L';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'R';
          }
        }

        if (i === 1) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'P';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'A';
          }
        }

        if (i === 2) {
          if (scaledDirection.getComponent(i) + delta >= 1) {
            label += 'S';
          } else if (scaledDirection.getComponent(i) - delta <= -1) {
            label += 'I';
          }
        }
      }

      return label;
    }
  }, {
    key: '_updateDirections',
    value: function _updateDirections() {
      // up is correct
      this._up = this.up.clone();

      // direction
      var pLocal = new THREE.Vector3(0, 0, -1);
      var pWorld = pLocal.applyMatrix4(this.matrixWorld);
      this._direction = pWorld.sub(this.position).normalize();

      // right
      this._right = new THREE.Vector3().crossVectors(this._direction, this.up);

      // update labels accordingly
      this._updateLabels();
    }
  }, {
    key: 'controls',
    set: function set(controls) {
      this._controls = controls;
    },
    get: function get() {
      return this._controls;
    }
  }, {
    key: 'box',
    set: function set(box) {
      this._box = box;
    },
    get: function get() {
      return this._box;
    }
  }, {
    key: 'canvas',
    set: function set(canvas) {
      this._canvas = canvas;
      this._updateCanvas();
    },
    get: function get() {
      return this._canvas;
    }
  }, {
    key: 'angle',
    set: function set(angle) {
      this.rotate(angle);
    },
    get: function get() {
      return this._angle;
    }
  }, {
    key: 'directions',
    set: function set(directions) {
      this._directions = directions;
    },
    get: function get() {
      return this._directions;
    }
  }, {
    key: 'convention',
    set: function set(convention) {
      this._convention = convention;
    },
    get: function get() {
      return this._convention;
    }
  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
    },
    get: function get() {
      return this._orientation;
    }
  }, {
    key: 'directionsLabel',
    set: function set(directionsLabel) {
      this._directionsLabel = directionsLabel;
    },
    get: function get() {
      return this._directionsLabel;
    }
  }, {
    key: 'stackOrientation',
    set: function set(stackOrientation) {
      this._stackOrientation = stackOrientation;

      if (this._stackOrientation === 0) {
        this._orientation = 'default';
      } else {
        var maxIndex = this._getMaxIndex(this._directions[(this._stackOrientation + 2) % 3]);

        if (maxIndex === 0) {
          this._orientation = 'sagittal';
        } else if (maxIndex === 1) {
          this._orientation = 'coronal';
        } else if (maxIndex === 2) {
          this._orientation = 'axial';
        }
      }
    },
    get: function get() {
      //
      if (this._orientation === 'default') {
        this._stackOrientation = 0;
      } else {
        var maxIndex = this._getMaxIndex(this._direction);

        if (maxIndex === this._getMaxIndex(this._directions[2])) {
          this._stackOrientation = 0;
        } else if (maxIndex === this._getMaxIndex(this._directions[0])) {
          this._stackOrientation = 1;
        } else if (maxIndex === this._getMaxIndex(this._directions[1])) {
          this._stackOrientation = 2;
        }
      }

      return this._stackOrientation;
    }
  }]);

  return CamerasOrthographic;
}(THREE.OrthographicCamera);

exports.default = CamerasOrthographic;

},{"../core/core.intersections":102,"../core/core.validators":106}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = require('./controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

var _controls3 = require('./controls.trackballortho');

var _controls4 = _interopRequireDefault(_controls3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Trackball: _controls2.default,
  TrackballOrtho: _controls4.default
};

},{"./controls.trackball":99,"./controls.trackballortho":100}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Original authors from THREEJS repo
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga  / http://lantiga.github.io
 */

var Trackball = function (_THREE$EventDispatche) {
  _inherits(Trackball, _THREE$EventDispatche);

  function Trackball(object, domElement) {
    _classCallCheck(this, Trackball);

    var _this2 = _possibleConstructorReturn(this, (Trackball.__proto__ || Object.getPrototypeOf(Trackball)).call(this));

    var _this = _this2;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5, CUSTOM: 99 };

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.rotateSpeed = 1.0;
    _this2.zoomSpeed = 1.2;
    _this2.panSpeed = 0.3;

    _this2.noRotate = false;
    _this2.noZoom = false;
    _this2.noPan = false;
    _this2.noCustom = false;

    _this2.forceState = -1;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.minDistance = 0;
    _this2.maxDistance = Infinity;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _movePrev = new THREE.Vector2(),
        _moveCurr = new THREE.Vector2(),
        _lastAxis = new THREE.Vector3(),
        _lastAngle = 0,
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2(),
        _customStart = new THREE.Vector2(),
        _customEnd = new THREE.Vector2();

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    var getMouseOnCircle = function () {
      var vector = new THREE.Vector2();

      return function (pageX, pageY) {
        vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width);

        return vector;
      };
    }();

    _this2.rotateCamera = function () {
      var axis = new THREE.Vector3(),
          quaternion = new THREE.Quaternion(),
          eyeDirection = new THREE.Vector3(),
          objectUpDirection = new THREE.Vector3(),
          objectSidewaysDirection = new THREE.Vector3(),
          moveDirection = new THREE.Vector3(),
          angle = void 0;

      return function () {
        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
        angle = moveDirection.length();

        if (angle) {
          _eye.copy(_this.object.position).sub(_this.target);

          eyeDirection.copy(_eye).normalize();
          objectUpDirection.copy(_this.object.up).normalize();
          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

          axis.crossVectors(moveDirection, _eye).normalize();

          angle *= _this.rotateSpeed;
          quaternion.setFromAxisAngle(axis, angle);

          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);

          _lastAxis.copy(axis);
          _lastAngle = angle;
        } else if (!_this.staticMoving && _lastAngle) {
          _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
          _eye.copy(_this.object.position).sub(_this.target);
          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
          _eye.applyQuaternion(quaternion);
          _this.object.up.applyQuaternion(quaternion);
        }

        _movePrev.copy(_moveCurr);
      };
    }();

    _this2.zoomCamera = function () {
      var factor = void 0;

      if (_state === STATE.TOUCH_ZOOM) {
        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;
        _eye.multiplyScalar(factor);
      } else {
        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (factor !== 1.0 && factor > 0.0) {
          _eye.multiplyScalar(factor);

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function () {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }
        }
      };
    }();

    _this2.checkDistances = function () {
      if (!_this.noZoom || !_this.noPan) {
        if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
        }

        if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
          _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
        }
      }
    };

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noRotate) {
        _this.rotateCamera();
      }

      if (!_this.noZoom) {
        _this.zoomCamera();
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      if (!_this.noCustom) {
        _this.custom(_customStart, _customEnd);
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.checkDistances();

      _this.object.lookAt(_this.target);

      if (lastPosition.distanceToSquared(_this.object.position) > EPS) {
        _this.dispatchEvent(changeEvent);

        lastPosition.copy(_this.object.position);
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      lastPosition.copy(_this.object.position);
    };

    _this2.setState = function (targetState) {
      _this.forceState = targetState;
      _prevState = targetState;
      _state = targetState;
    };

    _this2.custom = function (customStart, customEnd) {};

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        _movePrev.copy(_moveCurr);
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _customEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {
        _movePrev.copy(_moveCurr);
        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
      } else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.CUSTOM && !_this.noCustom) {
        _customEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        _state = STATE.NONE;
      }

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      if (_state !== STATE.CUSTOM) {
        _zoomStart.y += delta * 0.01;
      } else if (_state === STATE.CUSTOM) {
        _customStart.y += delta * 0.01;
      }

      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 2:
            _state = STATE.TOUCH_ZOOM;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panStart.copy(getMouseOnScreen(x, y));
            _panEnd.copy(_panStart);
            break;

          default:
            _state = STATE.NONE;

        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            // 1 or 2 fingers, smae behavior
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;

          case 1:
          case 4:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_ZOOM;
              var dx = event.touches[0].pageX - event.touches[1].pageX;
              var dy = event.touches[0].pageY - event.touches[1].pageY;
              _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            } else {
              _state = STATE.ZOOM;
              _zoomStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _zoomEnd.copy(_zoomStart);
            }
            break;

          case 2:
          case 5:
            if (event.touches.length >= 2) {
              _state = STATE.TOUCH_PAN;
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panStart.copy(getMouseOnScreen(x, y));
              _panEnd.copy(_panStart);
            } else {
              _state = STATE.PAN;
              _panStart.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
              _panEnd.copy(_panStart);
            }
            break;

          case 99:
            _state = STATE.CUSTOM;
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customStart.copy(getMouseOnScreen(x, y));
            _customEnd.copy(_customStart);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;
        }
      } else {
        // { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4, CUSTOM: 99 };
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
            _zoomEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _panEnd.copy(getMouseOnScreen(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 4:
            // 2 fingers!
            // TOUCH ZOOM
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            break;

          case 5:
            // 2 fingers
            // TOUCH_PAN
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            break;

          default:
            _state = STATE.NONE;

        }
      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      if (_this.forceState === -1) {
        switch (event.touches.length) {

          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 2:
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            _panStart.copy(_panEnd);
            break;

        }

        _state = STATE.NONE;
      } else {
        switch (_state) {

          case 0:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;

          case 1:
          case 2:
            break;

          case 4:
            // TOUCH ZOOM
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
            _state = STATE.ZOOM;
            break;

          case 5:
            // TOUCH ZOOM
            if (event.touches.length >= 2) {
              var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
              _panEnd.copy(getMouseOnScreen(x, y));
              _panStart.copy(_panEnd);
            }
            _state = STATE.PAN;
            break;

          case 99:
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _customEnd.copy(getMouseOnScreen(x, y));
            _customStart.copy(_customEnd);
            break;

          default:
            _state = STATE.NONE;

        }
      }

      _this.dispatchEvent(endEvent);
    }

    _this2.domElement.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    }, false);

    _this2.domElement.addEventListener('mousedown', mousedown, false);

    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('DOMMouseScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackball;
}(THREE.EventDispatcher);

exports.default = Trackball;

},{}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * @author Max Smolens / https://github.com/msmolens
 */

var Trackballortho = function (_THREE$EventDispatche) {
  _inherits(Trackballortho, _THREE$EventDispatche);

  function Trackballortho(object, domElement) {
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { NONE: -1, ROTATE: 1, ZOOM: 2, PAN: 0, SCROLL: 4, TOUCH_ROTATE: 4, TOUCH_ZOOM_PAN: 5 };

    _classCallCheck(this, Trackballortho);

    var _this2 = _possibleConstructorReturn(this, (Trackballortho.__proto__ || Object.getPrototypeOf(Trackballortho)).call(this));

    var _this = _this2;
    var STATE = state;

    _this2.object = object;
    _this2.domElement = domElement !== undefined ? domElement : document;

    // API

    _this2.enabled = true;

    _this2.screen = { left: 0, top: 0, width: 0, height: 0 };

    _this2.radius = 0;

    _this2.zoomSpeed = 1.2;

    _this2.noZoom = false;
    _this2.noPan = false;

    _this2.staticMoving = false;
    _this2.dynamicDampingFactor = 0.2;

    _this2.keys = [65 /* A*/, 83 /* S*/, 68];

    // internals

    _this2.target = new THREE.Vector3();

    var EPS = 0.000001;

    var _changed = true;

    var _state = STATE.NONE,
        _prevState = STATE.NONE,
        _eye = new THREE.Vector3(),
        _zoomStart = new THREE.Vector2(),
        _zoomEnd = new THREE.Vector2(),
        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,
        _panStart = new THREE.Vector2(),
        _panEnd = new THREE.Vector2();

    // window level fire after...

    // for reset

    _this2.target0 = _this2.target.clone();
    _this2.position0 = _this2.object.position.clone();
    _this2.up0 = _this2.object.up.clone();

    _this2.left0 = _this2.object.left;
    _this2.right0 = _this2.object.right;
    _this2.top0 = _this2.object.top;
    _this2.bottom0 = _this2.object.bottom;

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    // methods

    _this2.handleResize = function () {
      if (this.domElement === document) {
        this.screen.left = 0;
        this.screen.top = 0;
        this.screen.width = window.innerWidth;
        this.screen.height = window.innerHeight;
      } else {
        var box = this.domElement.getBoundingClientRect();
        // adjustments come from similar code in the jquery offset() function
        var d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + window.pageXOffset - d.clientLeft;
        this.screen.top = box.top + window.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
      }

      this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

      this.left0 = this.object.left;
      this.right0 = this.object.right;
      this.top0 = this.object.top;
      this.bottom0 = this.object.bottom;
    };

    _this2.handleEvent = function (event) {
      if (typeof this[event.type] == 'function') {
        this[event.type](event);
      }
    };

    var getMouseOnScreen = function () {
      var vector = new THREE.Vector2();

      return function getMouseOnScreen(pageX, pageY) {
        vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

        return vector;
      };
    }();

    _this2.zoomCamera = function () {
      if (_state === STATE.TOUCH_ZOOM_PAN) {
        var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
        _touchZoomDistanceStart = _touchZoomDistanceEnd;

        _this.object.zoom *= factor;

        _changed = true;
      } else {
        var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

        if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {
          _this.object.zoom /= factor;

          if (_this.staticMoving) {
            _zoomStart.copy(_zoomEnd);
          } else {
            _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
          }

          _changed = true;
        }
      }
    };

    _this2.panCamera = function () {
      var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();

      return function panCamera() {
        mouseChange.copy(_panEnd).sub(_panStart);

        if (mouseChange.lengthSq()) {
          // Scale movement to keep clicked/dragged position under cursor
          var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
          var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
          mouseChange.x *= scale_x;
          mouseChange.y *= scale_y;

          pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
          pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

          _this.object.position.add(pan);
          _this.target.add(pan);

          if (_this.staticMoving) {
            _panStart.copy(_panEnd);
          } else {
            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
          }

          _changed = true;
        }
      };
    }();

    _this2.update = function () {
      _eye.subVectors(_this.object.position, _this.target);

      if (!_this.noZoom) {
        _this.zoomCamera();

        if (_changed) {
          _this.object.updateProjectionMatrix();
        }
      }

      if (!_this.noPan) {
        _this.panCamera();
      }

      _this.object.position.addVectors(_this.target, _eye);

      _this.object.lookAt(_this.target);

      if (_changed) {
        _this.dispatchEvent(changeEvent);

        _changed = false;
      }
    };

    _this2.reset = function () {
      _state = STATE.NONE;
      _prevState = STATE.NONE;

      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.up.copy(_this.up0);

      _eye.subVectors(_this.object.position, _this.target);

      _this.object.left = _this.left0;
      _this.object.right = _this.right0;
      _this.object.top = _this.top0;
      _this.object.bottom = _this.bottom0;

      _this.object.lookAt(_this.target);

      _this.dispatchEvent(changeEvent);

      _changed = false;
    };

    // listeners

    function keydown(event) {
      if (_this.enabled === false) return;

      window.removeEventListener('keydown', keydown);

      _prevState = _state;

      if (_state !== STATE.NONE) {
        return;
      } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
        _state = STATE.ROTATE;
      } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
        _state = STATE.ZOOM;
      } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
        _state = STATE.PAN;
      }
    }

    function keyup(event) {
      if (_this.enabled === false) return;

      _state = _prevState;

      window.addEventListener('keydown', keydown, false);
    }

    function mousedown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.NONE) {
        _state = event.button;
      }

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _zoomEnd.copy(_zoomStart);
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
        _panEnd.copy(_panStart);
      }

      document.addEventListener('mousemove', mousemove, false);
      document.addEventListener('mouseup', mouseup, false);

      _this.dispatchEvent(startEvent);
    }

    function mousemove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      if (_state === STATE.ROTATE && !_this.noRotate) {} else if (_state === STATE.ZOOM && !_this.noZoom) {
        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      } else if (_state === STATE.PAN && !_this.noPan) {
        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
      }
    }

    function mouseup(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      _state = STATE.NONE;

      document.removeEventListener('mousemove', mousemove);
      document.removeEventListener('mouseup', mouseup);
      _this.dispatchEvent(endEvent);
    }

    function mousewheel(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      var delta = 0;

      if (event.wheelDelta) {
        // WebKit / Opera / Explorer 9

        delta = event.wheelDelta / 40;
      } else if (event.detail) {
        // Firefox

        delta = -event.detail / 3;
      }

      // FIRE SCROLL EVENT

      _this.dispatchEvent({
        type: 'OnScroll',
        delta: delta
      });

      // _zoomStart.y += delta * 0.01;
      _this.dispatchEvent(startEvent);
      _this.dispatchEvent(endEvent);
    }

    function touchstart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:
          _state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          _state = STATE.TOUCH_ZOOM_PAN;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panStart.copy(getMouseOnScreen(x, y));
          _panEnd.copy(_panStart);
          break;

        default:
          _state = STATE.NONE;

      }
      _this.dispatchEvent(startEvent);
    }

    function touchmove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          break;

        default:
          _state = STATE.NONE;

      }
    }

    function touchend(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {

        case 1:

          break;

        case 2:
          _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

          var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
          var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
          _panEnd.copy(getMouseOnScreen(x, y));
          _panStart.copy(_panEnd);
          break;

      }

      _state = STATE.NONE;
      _this.dispatchEvent(endEvent);
    }

    function contextmenu(event) {
      event.preventDefault();
    }

    _this2.dispose = function () {
      this.domElement.removeEventListener('contextmenu', contextmenu, false);
      this.domElement.removeEventListener('mousedown', mousedown, false);
      this.domElement.removeEventListener('mousewheel', mousewheel, false);
      this.domElement.removeEventListener('MozMousePixelScroll', mousewheel, false); // firefox

      this.domElement.removeEventListener('touchstart', touchstart, false);
      this.domElement.removeEventListener('touchend', touchend, false);
      this.domElement.removeEventListener('touchmove', touchmove, false);

      document.removeEventListener('mousemove', mousemove, false);
      document.removeEventListener('mouseup', mouseup, false);

      window.removeEventListener('keydown', keydown, false);
      window.removeEventListener('keyup', keyup, false);
    };

    _this2.domElement.addEventListener('contextmenu', contextmenu, false);
    _this2.domElement.addEventListener('mousedown', mousedown, false);
    _this2.domElement.addEventListener('mousewheel', mousewheel, false);
    _this2.domElement.addEventListener('MozMousePixelScroll', mousewheel, false); // firefox

    _this2.domElement.addEventListener('touchstart', touchstart, false);
    _this2.domElement.addEventListener('touchend', touchend, false);
    _this2.domElement.addEventListener('touchmove', touchmove, false);

    window.addEventListener('keydown', keydown, false);
    window.addEventListener('keyup', keyup, false);

    _this2.handleResize();

    // force an update at start
    _this2.update();
    return _this2;
  }

  return Trackballortho;
}(THREE.EventDispatcher);

exports.default = Trackballortho;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Colors utility functions
 */
var Colors = function () {
  function Colors() {
    _classCallCheck(this, Colors);
  }

  _createClass(Colors, null, [{
    key: "cielab2XYZ",


    /**
     * Convert LAB to XYZ
     * http://www.easyrgb.com/index.php?X=MATH&H=08#text8
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */
    value: function cielab2XYZ(l, a, b) {
      var refX = 95.047;
      var refY = 100.00;
      var refZ = 108.883;

      var y = (l + 16) / 116;
      var x = a / 500 + y;
      var z = y - b / 200;

      if (Math.pow(y, 3) > 0.008856) {
        y = Math.pow(y, 3);
      } else {
        y = (y - 16 / 116) / 7.787;
      }

      if (Math.pow(x, 3) > 0.008856) {
        x = Math.pow(x, 3);
      } else {
        x = (x - 16 / 116) / 7.787;
      }

      if (Math.pow(z, 3) > 0.008856) {
        z = Math.pow(z, 3);
      } else {
        z = (z - 16 / 116) / 7.787;
      }

      return [refX * x, refY * y, refZ * z];
    }

    /**
     * Convert XYZ to RGB space
     *
     * @param {*} x
     * @param {*} y
     * @param {*} z
     *
     * @return {*}
     */

  }, {
    key: "xyz2RGB",
    value: function xyz2RGB(x, y, z) {
      x /= 100;
      y /= 100;
      z /= 100;
      var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      var b = x * 0.0557 + y * -0.2040 + z * 1.0570;

      if (r > 0.0031308) {
        r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
      } else {
        r = 12.92 * r;
      }

      if (g > 0.0031308) {
        g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
      } else {
        g = 12.92 * g;
      }

      if (b > 0.0031308) {
        b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
      } else {
        b = 12.92 * b;
      }

      r = r * 255;
      g = g * 255;
      b = b * 255;

      return [r, g, b];
    }

    /**
     * Convert LAB to RGB
     *
     * @param {*} l
     * @param {*} a
     * @param {*} b
     *
     * @return {*}
     */

  }, {
    key: "cielab2RGB",
    value: function cielab2RGB() {
      var l = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (!(l >= 0 && l <= 100)) {
        return null;
      }

      var xyz = this.cielab2XYZ(l, a, b);
      return this.xyz2RGB.apply(this, _toConsumableArray(xyz));
    }
  }]);

  return Colors;
}();

exports.default = Colors;

},{}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('./core.utils');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.validators');

var _core4 = _interopRequireDefault(_core3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Compute/test intersection between different objects.
 *
 * @module core/intersections
 */

var Intersections = function () {
  function Intersections() {
    _classCallCheck(this, Intersections);
  }

  _createClass(Intersections, null, [{
    key: 'aabbPlane',


    /**
     * Compute intersection between oriented bounding box and a plane.
     *
     * Returns intersection in plane's space.
     *
     * Should return at least 3 intersections. If not, the plane and the box do not
     * intersect.
     *
     * @param {Object} aabb - Axe Aligned Bounding Box representation.
     * @param {THREE.Vector3} aabb.halfDimensions - Half dimensions of the box.
     * @param {THREE.Vector3} aabb.center - Center of the box.
     * @param {THREE.Matrix4} aabb.toAABB - Transform to go from plane space to box space.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {Array<THREE.Vector3>} List of all intersections in plane's space.
     * @returns {boolean} false is invalid input provided.
     *
     * @example
     * //Returns array with intersection N intersections
     * let aabb = {
     *   center: new THREE.Vector3(150, 150, 150),
     *   halfDimensions: new THREE.Vector3(50, 60, 70),
     *   toAABB: new THREE.Matrix4()
     * }
     * let plane = {
     *   position: new THREE.Vector3(110, 120, 130),
     *   direction: new THREE.Vector3(1, 0, 0)
     * }
     *
     * let intersections = CoreIntersections.aabbPlane(aabb, plane);
     * // intersections ==
     * //[ { x : 110, y : 90,  z : 80 },
     * //  { x : 110, y : 210, z : 220 },
     * //  { x : 110, y : 210, z : 80 },
     * //  { x : 110, y : 90,  z : 220 } ]
     *
     * //Returns empty array with 0 intersections
     * let aabb = {
     *
     * }
     * let plane = {
     *
     * }
     *
     * let intersections = VJS.Core.Validators.matrix4(new THREE.Vector3());
     *
     * //Returns false if invalid input?
     *
     */
    value: function aabbPlane(aabb, plane) {
      //
      // obb = { halfDimensions, orientation, center, toAABB }
      // plane = { position, direction }
      //
      //
      // LOGIC:
      //
      // Test intersection of each edge of the Oriented Bounding Box with the Plane
      //
      // ALL EDGES
      //
      //      .+-------+
      //    .' |     .'|
      //   +---+---+'  |
      //   |   |   |   |
      //   |  ,+---+---+
      //   |.'     | .'
      //   +-------+'
      //
      // SPACE ORIENTATION
      //
      //       +
      //     j |
      //       |
      //       |   i
      //   k  ,+-------+
      //    .'
      //   +
      //
      //
      // 1- Move Plane position and orientation in IJK space
      // 2- Test Edges/ IJK Plane intersections
      // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

      var intersections = [];

      if (!(this.validateAabb(aabb) && this.validatePlane(plane))) {
        window.console.log('Invalid aabb or plane provided.');
        return false;
      }

      // invert space matrix
      var fromAABB = new THREE.Matrix4();
      fromAABB.getInverse(aabb.toAABB);

      var t1 = plane.direction.clone().applyMatrix4(aabb.toAABB);
      var t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(aabb.toAABB);

      var planeAABB = this.posdir(plane.position.clone().applyMatrix4(aabb.toAABB), new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize());

      var bbox = _core2.default.bbox(aabb.center, aabb.halfDimensions);

      var orientation = new THREE.Vector3(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1));

      // 12 edges (i.e. ray)/plane intersection tests
      // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
      //
      //       +
      //       |
      //       |
      //       |
      //      ,+---+---+
      //    .'
      //   +

      var ray = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.y;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      ray.direction = orientation.z;
      this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE LAST CORNER
      //
      //               +
      //             .'
      //   +-------+'
      //           |
      //           |
      //           |
      //           +
      //

      var ray2 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.y;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      ray2.direction = orientation.z;
      this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE SECOND CORNER
      //
      //               +
      //               |
      //               |
      //               |
      //               +
      //             .'
      //           +'

      var ray3 = this.posdir(new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.y);
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      ray3.direction = orientation.z;
      this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE THIRD CORNER
      //
      //      .+-------+
      //    .'
      //   +
      //
      //
      //
      //

      var ray4 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      ray4.direction = orientation.z;
      this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

      // RAYS STARTING FROM THE FOURTH CORNER
      //
      //
      //
      //   +
      //   |
      //   |
      //   |
      //   +-------+

      var ray5 = this.posdir(new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z), orientation.x);
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      ray5.direction = orientation.y;
      this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

      // @todo make sure objects are unique...

      // back to original space
      intersections.map(function (element) {
        return element.applyMatrix4(fromAABB);
      });

      return intersections;
    }

    /**
     * Compute intersection between a ray and a plane.
     *
     * @memberOf this
     * @public
     *
     * @param {Object} ray - Ray representation.
     * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
     * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
     * @param {Object} plane - Plane representation
     * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
     * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
     *
     * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
     */

  }, {
    key: 'rayPlane',
    value: function rayPlane(ray, plane) {
      // ray: {position, direction}
      // plane: {position, direction}

      if (ray.direction.dot(plane.direction) !== 0) {
        //
        // not parallel, move forward
        //
        // LOGIC:
        //
        // Ray equation: P = P0 + tV
        // P = <Px, Py, Pz>
        // P0 = <ray.position.x, ray.position.y, ray.position.z>
        // V = <ray.direction.x, ray.direction.y, ray.direction.z>
        //
        // Therefore:
        // Px = ray.position.x + t*ray.direction.x
        // Py = ray.position.y + t*ray.direction.y
        // Pz = ray.position.z + t*ray.direction.z
        //
        //
        //
        // Plane equation: ax + by + cz + d = 0
        // a = plane.direction.x
        // b = plane.direction.y
        // c = plane.direction.z
        // d = -( plane.direction.x*plane.position.x +
        //        plane.direction.y*plane.position.y +
        //        plane.direction.z*plane.position.z )
        //
        //
        // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
        // 2- find t
        // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
        //
        var t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) / (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

        var intersection = new THREE.Vector3(ray.position.x + t * ray.direction.x, ray.position.y + t * ray.direction.y, ray.position.z + t * ray.direction.z);

        return intersection;
      }

      return null;
    }

    /**
     * Compute intersection between a ray and a box
     * @param {Object} ray
     * @param {Object} box
     * @return {Array}
     */

  }, {
    key: 'rayBox',
    value: function rayBox(ray, box) {
      // should also do the space transforms here
      // ray: {position, direction}
      // box: {halfDimensions, center}

      var intersections = [];

      var bbox = _core2.default.bbox(box.center, box.halfDimensions);

      // window.console.log(bbox);

      // X min
      var plane = this.posdir(new THREE.Vector3(bbox.min.x, box.center.y, box.center.z), new THREE.Vector3(-1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // X max
      plane = this.posdir(new THREE.Vector3(bbox.max.x, box.center.y, box.center.z), new THREE.Vector3(1, 0, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y min
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.min.y, box.center.z), new THREE.Vector3(0, -1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Y max
      plane = this.posdir(new THREE.Vector3(box.center.x, bbox.max.y, box.center.z), new THREE.Vector3(0, 1, 0));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z min
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.min.z), new THREE.Vector3(0, 0, -1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      // Z max
      plane = this.posdir(new THREE.Vector3(box.center.x, box.center.y, bbox.max.z), new THREE.Vector3(0, 0, 1));
      this.rayPlaneInBBox(ray, plane, bbox, intersections);

      return intersections;
    }

    /**
     * Intersection between ray and a plane that are in a box.
     * @param {*} ray
     * @param {*} planeAABB
     * @param {*} bbox
     * @param {*} intersections
     */

  }, {
    key: 'rayPlaneInBBox',
    value: function rayPlaneInBBox(ray, planeAABB, bbox, intersections) {
      var intersection = this.rayPlane(ray, planeAABB);
      // window.console.log(intersection);
      if (intersection && this.inBBox(intersection, bbox)) {
        if (!intersections.find(this.findIntersection(intersection))) {
          intersections.push(intersection);
        }
      }
    }

    /**
     * Find intersection in array
     * @param {*} myintersection
     */

  }, {
    key: 'findIntersection',
    value: function findIntersection(myintersection) {
      return function found(element, index, array) {
        if (myintersection.x === element.x && myintersection.y === element.y && myintersection.z === element.z) {
          return true;
        }

        return false;
      };
    }

    /**
     * Is point in box.
     * @param {Object} point
     * @param {Object} bbox
     * @return {Boolean}
     */

  }, {
    key: 'inBBox',
    value: function inBBox(point, bbox) {
      //
      var epsilon = 0.0001;
      if (point && point.x >= bbox.min.x - epsilon && point.y >= bbox.min.y - epsilon && point.z >= bbox.min.z - epsilon && point.x <= bbox.max.x + epsilon && point.y <= bbox.max.y + epsilon && point.z <= bbox.max.z + epsilon) {
        return true;
      }
      return false;
    }
  }, {
    key: 'posdir',
    value: function posdir(position, direction) {
      return { position: position, direction: direction };
    }
  }, {
    key: 'validatePlane',
    value: function validatePlane(plane) {
      //
      if (plane === null) {
        window.console.log('Invalid plane.');
        window.console.log(plane);

        return false;
      }

      if (!_core4.default.vector3(plane.position)) {
        window.console.log('Invalid plane.position.');
        window.console.log(plane.position);

        return false;
      }

      if (!_core4.default.vector3(plane.direction)) {
        window.console.log('Invalid plane.direction.');
        window.console.log(plane.direction);

        return false;
      }

      return true;
    }
  }, {
    key: 'validateAabb',
    value: function validateAabb(aabb) {
      //
      if (aabb === null) {
        window.console.log('Invalid aabb.');
        window.console.log(aabb);
        return false;
      }

      if (!_core4.default.matrix4(aabb.toAABB)) {
        window.console.log('Invalid aabb.toAABB: ');
        window.console.log(aabb.toAABB);

        return false;
      }

      if (!_core4.default.vector3(aabb.center)) {
        window.console.log('Invalid aabb.center.');
        window.console.log(aabb.center);

        return false;
      }

      if (!(_core4.default.vector3(aabb.halfDimensions) && aabb.halfDimensions.x >= 0 && aabb.halfDimensions.y >= 0 && aabb.halfDimensions.z >= 0)) {
        window.console.log('Invalid aabb.halfDimensions.');
        window.console.log(aabb.halfDimensions);

        return false;
      }

      return true;
    }
  }]);

  return Intersections;
}();

exports.default = Intersections;

},{"./core.utils":105,"./core.validators":106}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require('./core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('./core.intersections');

var _core4 = _interopRequireDefault(_core3);

var _core5 = require('./core.pack');

var _core6 = _interopRequireDefault(_core5);

var _core7 = require('./core.validators');

var _core8 = _interopRequireDefault(_core7);

var _core9 = require('./core.utils');

var _core10 = _interopRequireDefault(_core9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module core
 */
exports.default = {
  Colors: _core2.default,
  Intersections: _core4.default,
  Utils: _core10.default,
  Validators: _core8.default
};

},{"./core.colors":101,"./core.intersections":102,"./core.pack":104,"./core.utils":105,"./core.validators":106}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Packing functions.
 *
 * @module core/pack */

var Pack = function Pack() {
  _classCallCheck(this, Pack);
};

exports.default = Pack;

},{}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('./core.validators');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var URL = require('url');

/**
 * General purpose functions.
 *
 * @module core/utils
 */
var CoreUtils = function () {
  function CoreUtils() {
    _classCallCheck(this, CoreUtils);
  }

  _createClass(CoreUtils, null, [{
    key: 'bbox',


    /**
     * Generate a bouding box object.
     * @param {THREE.Vector3} center - Center of the box.
     * @param {THREE.Vector3} halfDimensions - Half Dimensions of the box.
     * @return {Object} The bounding box object. {Object.min} is a {THREE.Vector3}
     * containing the min bounds. {Object.max} is a {THREE.Vector3} containing the
     * max bounds.
     * @return {boolean} False input NOT valid.
     * @example
     * // Returns
     * //{ min: { x : 0, y : 0,  z : 0 },
     * //  max: { x : 2, y : 4,  z : 6 }
     * //}
     * VJS.Core.Utils.bbox(
     *   new THREE.Vector3(1, 2, 3), new THREE.Vector3(1, 2, 3));
     *
     * //Returns false
     * VJS.Core.Utils.bbox(new THREE.Vector3(), new THREE.Matrix4());
     *
     */
    value: function bbox(center, halfDimensions) {
      // make sure we have valid inputs
      if (!(_core2.default.vector3(center) && _core2.default.vector3(halfDimensions))) {
        window.console.log('Invalid center or plane halfDimensions.');
        return false;
      }

      // make sure half dimensions are >= 0
      if (!(halfDimensions.x >= 0 && halfDimensions.y >= 0 && halfDimensions.z >= 0)) {
        window.console.log('halfDimensions must be >= 0.');
        window.console.log(halfDimensions);
        return false;
      }

      // min/max bound
      var min = center.clone().sub(halfDimensions);
      var max = center.clone().add(halfDimensions);

      return {
        min: min,
        max: max
      };
    }

    /**
     * Find min/max values in an array
     * @param {Array} data
     * @return {Array}
     */

  }, {
    key: 'minMax',
    value: function minMax() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = data.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = data[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    /**
     * Check HTMLElement
     * @param {HTMLElement} obj
     * @return {boolean}
     */

  }, {
    key: 'isElement',
    value: function isElement(obj) {
      try {
        // Using W3 DOM2 (works for FF, Opera and Chrom)
        return obj instanceof HTMLElement;
      } catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have. (works on IE7)
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.nodeType === 1 && _typeof(obj.style) === 'object' && _typeof(obj.ownerDocument) === 'object';
      }
    }

    /**
     * Check string
     * @param {String} str
     * @return {Boolean}
     */

  }, {
    key: 'isString',
    value: function isString(str) {
      return typeof str === 'string' || str instanceof String;
    }

    /**
     * Parse url
     * @param {*} url
     * @return {Object}
     */

  }, {
    key: 'parseUrl',
    value: function parseUrl(url) {
      //
      var data = {};
      data.filename = '';
      data.extension = '';
      data.pathname = '';
      data.query = '';

      var parsedUrl = URL.parse(url);
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // get file name
      data.filename = data.pathname.split('/').pop();

      // find extension
      var splittedName = data.filename.split('.');
      if (splittedName.length <= 1) {
        data.extension = 'dicom';
      } else {
        data.extension = data.filename.split('.').pop();
      }

      if (!isNaN(data.extension)) {
        data.extension = 'dicom';
      }

      if (data.query && data.query.includes('contentType=application%2Fdicom')) {
        data.extension = 'dicom';
      }

      return data;
    }

    /**
     * Compute IJK to LPS tranform.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} spacing
     * @param {*} origin
     * @param {*} registrationMatrix
     *
     * @return {*}
     */

  }, {
    key: 'ijk2LPS',
    value: function ijk2LPS(xCos, yCos, zCos, spacing, origin) {
      var registrationMatrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new THREE.Matrix4();

      var ijk2LPS = new THREE.Matrix4();
      ijk2LPS.set(xCos.x * spacing.x, yCos.x * spacing.y, zCos.x * spacing.z, origin.x, xCos.y * spacing.x, yCos.y * spacing.y, zCos.y * spacing.z, origin.y, xCos.z * spacing.x, yCos.z * spacing.y, zCos.z * spacing.z, origin.z, 0, 0, 0, 1);
      ijk2LPS.premultiply(registrationMatrix);

      return ijk2LPS;
    }

    /**
     * Compute AABB to LPS transform.
     * AABB: Axe Aligned Bounding Box.
     *
     * @param {*} xCos
     * @param {*} yCos
     * @param {*} zCos
     * @param {*} origin
     *
     * @return {*}
     */

  }, {
    key: 'aabb2LPS',
    value: function aabb2LPS(xCos, yCos, zCos, origin) {
      var aabb2LPS = new THREE.Matrix4();
      aabb2LPS.set(xCos.x, yCos.x, zCos.x, origin.x, xCos.y, yCos.y, zCos.y, origin.y, xCos.z, yCos.z, zCos.z, origin.z, 0, 0, 0, 1);

      return aabb2LPS;
    }

    /**
     * Transform coordinates from world coordinate to data
     *
     * @param {*} lps2IJK
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(lps2IJK, worldCoordinates) {
      var dataCoordinate = new THREE.Vector3().copy(worldCoordinates).applyMatrix4(lps2IJK);

      // same rounding in the shaders
      dataCoordinate.addScalar(0.5).floor();

      return dataCoordinate;
    }

    /**
     * Get voxel value
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      if (coordinate.z >= 0 && coordinate.z < stack._frame.length) {
        return stack._frame[coordinate.z].value(coordinate.x, coordinate.y);
      } else {
        return null;
      }
    }

    /**
     * Apply slope/intercept to a value
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'rescaleSlopeIntercept',
    value: function rescaleSlopeIntercept(value, slope, intercept) {
      return value * slope + intercept;
    }
  }]);

  return CoreUtils;
}();

exports.default = CoreUtils;

},{"./core.validators":106,"url":81}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Validate basic structures.
 *
 * @example
 * //Returns true
 * VJS.Core.Validators.matrix4(new THREE.Matrix4());
 *
 * //Returns false
 * VJS.Core.Validators.matrix4(new THREE.Vector3());
 *
 * @module core/validators
 */

var Validators = function () {
  function Validators() {
    _classCallCheck(this, Validators);
  }

  _createClass(Validators, null, [{
    key: 'matrix4',


    /**
     * Validates a matrix as a THREEJS.Matrix4
     * link
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid Matrix4, false if NOT.
     */
    value: function matrix4(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('elements') && objectToTest.elements.length === 16 && typeof objectToTest.identity === 'function' && typeof objectToTest.copy === 'function' && typeof objectToTest.determinant === 'function')) {
        return false;
      }

      return true;
    }

    /**
    * Validates a vector as a THREEJS.Vector3
    * @param {Object} objectToTest - The object to be tested.
    * @return {boolean} True if valid Vector3, false if NOT.
    */

  }, {
    key: 'vector3',
    value: function vector3(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('x') && objectToTest.hasOwnProperty('y') && objectToTest.hasOwnProperty('z') && !objectToTest.hasOwnProperty('w'))) {
        return false;
      }

      return true;
    }

    /**
     * Validates a box.
     *
     * @example
     * // a box is defined as
     * let box = {
     *   center: THREE.Vector3,
     *   halfDimensions: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid box, false if NOT.
     */

  }, {
    key: 'box',
    value: function box(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('center') && this.vector3(objectToTest.center) && objectToTest.hasOwnProperty('halfDimensions') && this.vector3(objectToTest.halfDimensions) && objectToTest.halfDimensions.x >= 0 && objectToTest.halfDimensions.y >= 0 && objectToTest.halfDimensions.z >= 0)) {
        return false;
      }

      return true;
    }

    /**
     * Validates a ray.
     *
     * @example
     * // a ray is defined as
     * let ray = {
     *   postion: THREE.Vector3,
     *   direction: THREE.Vector3
     * }
     *
     * @param {Object} objectToTest - The object to be tested.
     * @return {boolean} True if valid ray, false if NOT.
     */

  }, {
    key: 'ray',
    value: function ray(objectToTest) {
      if (!(objectToTest !== null && typeof objectToTest !== 'undefined' && objectToTest.hasOwnProperty('position') && this.vector3(objectToTest.position) && objectToTest.hasOwnProperty('direction') && this.vector3(objectToTest.direction))) {
        return false;
      }

      return true;
    }
  }]);

  return Validators;
}();

exports.default = Validators;

},{}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _geometries = require('./geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _geometries3 = require('./geometries.voxel');

var _geometries4 = _interopRequireDefault(_geometries3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module geometries
 */

exports.default = {
  Slice: _geometries2.default,
  Voxel: _geometries4.default
};

},{"./geometries.slice":108,"./geometries.voxel":109}],108:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 *
 * It is typically used for creating an irregular 3D planar shape given a box and the cut-plane.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#geometry_slice}
 *
 * @module geometries/slice
 *
 * @param {THREE.Vector3} halfDimensions - Half-dimensions of the box to be sliced.
 * @param {THREE.Vector3} center - Center of the box to be sliced.
 * @param {THREE.Vector3<THREE.Vector3>} orientation - Orientation of the box to be sliced. (might not be necessary..?)
 * @param {THREE.Vector3} position - Position of the cutting plane.
 * @param {THREE.Vector3} direction - Cross direction of the cutting plane.
 *
 * @example
 * // Define box to be sliced
 * let halfDimensions = new THREE.Vector(123, 45, 67);
 * let center = new THREE.Vector3(0, 0, 0);
 * let orientation = new THREE.Vector3(
 *   new THREE.Vector3(1, 0, 0),
 *   new THREE.Vector3(0, 1, 0),
 *   new THREE.Vector3(0, 0, 1)
 * );
 *
 * // Define slice plane
 * let position = center.clone();
 * let direction = new THREE.Vector3(-0.2, 0.5, 0.3);
 *
 * // Create the slice geometry & materials
 * let sliceGeometry = new VJS.geometries.slice(halfDimensions, center, orientation, position, direction);
 * let sliceMaterial = new THREE.MeshBasicMaterial({
 *   'side': THREE.DoubleSide,
 *   'color': 0xFF5722
 * });
 *
 *  // Create mesh and add it to the scene
 *  let slice = new THREE.Mesh(sliceGeometry, sliceMaterial);
 *  scene.add(slice);
 */

var GeometriesSlice = function (_THREE$ShapeGeometry) {
  _inherits(GeometriesSlice, _THREE$ShapeGeometry);

  function GeometriesSlice(halfDimensions, center, position, direction) {
    var toAABB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new THREE.Matrix4();

    _classCallCheck(this, GeometriesSlice);

    //
    // prepare data for the shape!
    //
    var aabb = {
      halfDimensions: halfDimensions,
      center: center,
      toAABB: toAABB
    };

    var plane = {
      position: position,
      direction: direction
    };

    // BOOM!
    var intersections = _core2.default.aabbPlane(aabb, plane);

    // can not exist before calling the constructor
    if (intersections.length < 3) {
      window.console.log('WARNING: Less than 3 intersections between AABB and Plane.');
      window.console.log('AABB');
      window.console.log(aabb);
      window.console.log('Plane');
      window.console.log(plane);
      window.console.log('exiting...');
      // or throw error?
      throw 'geometries.slice has less than 3 intersections, can not create a valid geometry.';
    }

    var orderedIntersections = GeometriesSlice.orderIntersections(intersections, direction);
    var sliceShape = GeometriesSlice.shape(orderedIntersections);

    //
    // Generate Geometry from shape
    // It does triangulation for us!
    //

    var _this = _possibleConstructorReturn(this, (GeometriesSlice.__proto__ || Object.getPrototypeOf(GeometriesSlice)).call(this, sliceShape));

    _this.type = 'SliceGeometry';

    // update real position of each vertex! (not in 2d)
    _this.vertices = orderedIntersections;
    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesSlice, null, [{
    key: 'shape',
    value: function shape(points) {
      //
      // Create Shape
      //
      var shape = new THREE.Shape();
      // move to first point!
      shape.moveTo(points[0].xy.x, points[0].xy.y);

      // loop through all points!
      for (var l = 1; l < points.length; l++) {
        // project each on plane!
        shape.lineTo(points[l].xy.x, points[l].xy.y);
      }

      // close the shape!
      shape.lineTo(points[0].xy.x, points[0].xy.y);
      return shape;
    }

    /**
     *
     * Convenience function to extract center of mass from list of points.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of points from which we want to extract the center of mass.
     *
     * @returns {THREE.Vector3} Center of mass from given points.
     */

  }, {
    key: 'centerOfMass',
    value: function centerOfMass(points) {
      var centerOfMass = new THREE.Vector3(0, 0, 0);
      for (var i = 0; i < points.length; i++) {
        centerOfMass.x += points[i].x;
        centerOfMass.y += points[i].y;
        centerOfMass.z += points[i].z;
      }
      centerOfMass.divideScalar(points.length);

      return centerOfMass;
    }

    /**
     *
     * Order 3D planar points around a refence point.
     *
     * @private
     *
     * @param {Array<THREE.Vector3>} points - Set of planar 3D points to be ordered.
     * @param {THREE.Vector3} direction - Direction of the plane in which points and reference are sitting.
     *
     * @returns {Array<Object>} Set of object representing the ordered points.
     */

  }, {
    key: 'orderIntersections',
    value: function orderIntersections(points, direction) {
      var reference = GeometriesSlice.centerOfMass(points);
      // direction from first point to reference
      var referenceDirection = new THREE.Vector3(points[0].x - reference.x, points[0].y - reference.y, points[0].z - reference.z).normalize();

      var base = new THREE.Vector3(0, 0, 0).crossVectors(referenceDirection, direction).normalize();

      var orderedpoints = [];

      // other lines // if inter, return location + angle
      for (var j = 0; j < points.length; j++) {
        var point = new THREE.Vector3(points[j].x, points[j].y, points[j].z);
        point.direction = new THREE.Vector3(points[j].x - reference.x, points[j].y - reference.y, points[j].z - reference.z).normalize();

        var x = referenceDirection.dot(point.direction);
        var y = base.dot(point.direction);
        point.xy = { x: x, y: y };

        var theta = Math.atan2(y, x) * (180 / Math.PI);
        point.angle = theta;

        orderedpoints.push(point);
      }

      orderedpoints.sort(function (a, b) {
        return a.angle - b.angle;
      });

      var noDups = [orderedpoints[0]];
      var epsilon = 0.0001;
      for (var i = 1; i < orderedpoints.length; i++) {
        if (Math.abs(orderedpoints[i - 1].angle - orderedpoints[i].angle) > epsilon) {
          noDups.push(orderedpoints[i]);
        }
      }

      return noDups;
    }
  }]);

  return GeometriesSlice;
}(THREE.ShapeGeometry);

exports.default = GeometriesSlice;

},{"../core/core.intersections":102}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @module geometries/voxel
 */

var GeometriesVoxel = function (_THREE$BoxGeometry) {
  _inherits(GeometriesVoxel, _THREE$BoxGeometry);

  function GeometriesVoxel(dataPosition) {
    _classCallCheck(this, GeometriesVoxel);

    var _this = _possibleConstructorReturn(this, (GeometriesVoxel.__proto__ || Object.getPrototypeOf(GeometriesVoxel)).call(this, 1, 1, 1));

    _this._location = dataPosition;

    _this.applyMatrix(new THREE.Matrix4().makeTranslation(_this._location.x, _this._location.y, _this._location.z));

    _this.verticesNeedUpdate = true;
    return _this;
  }

  _createClass(GeometriesVoxel, [{
    key: "resetVertices",
    value: function resetVertices() {
      this.vertices[0].set(0.5, 0.5, 0.5);
      this.vertices[1].set(0.5, 0.5, -0.5);
      this.vertices[2].set(0.5, -0.5, 0.5);
      this.vertices[3].set(0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, 0.5, -0.5);
      this.vertices[5].set(-0.5, 0.5, 0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, 0.5);
    }
  }, {
    key: "location",
    set: function set(location) {
      this._location = location;

      // update vertices from location
      this.vertices[0].set(+0.5, +0.5, +0.5);
      this.vertices[1].set(+0.5, +0.5, -0.5);
      this.vertices[2].set(+0.5, -0.5, +0.5);
      this.vertices[3].set(+0.5, -0.5, -0.5);
      this.vertices[4].set(-0.5, +0.5, -0.5);
      this.vertices[5].set(-0.5, +0.5, +0.5);
      this.vertices[6].set(-0.5, -0.5, -0.5);
      this.vertices[7].set(-0.5, -0.5, +0.5);

      this.applyMatrix(new THREE.Matrix4().makeTranslation(this._location.x, this._location.y, this._location.z));

      this.verticesNeedUpdate = true;
    },
    get: function get() {
      return this._location;
    }
  }]);

  return GeometriesVoxel;
}(THREE.BoxGeometry);

exports.default = GeometriesVoxel;

},{}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * Imports ***/

/**
 * @module helpers/border
 */
var HelpersBorder = function (_THREE$Object3D) {
  _inherits(HelpersBorder, _THREE$Object3D);

  function HelpersBorder(helpersSlice) {
    _classCallCheck(this, HelpersBorder);

    var _this = _possibleConstructorReturn(this, (HelpersBorder.__proto__ || Object.getPrototypeOf(HelpersBorder)).call(this));
    //


    _this._helpersSlice = helpersSlice;

    _this._visible = true;
    _this._color = 0xff0000;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    _this._create();
    return _this;
  }

  _createClass(HelpersBorder, [{
    key: '_create',
    value: function _create() {
      if (!this._material) {
        this._material = new THREE.LineBasicMaterial({
          color: this._color,
          linewidth: 1
        });
      }

      //
      if (!this._helpersSlice.geometry.vertices) {
        return;
      }

      this._geometry = new THREE.Geometry();
      for (var i = 0; i < this._helpersSlice.geometry.vertices.length; i++) {
        this._geometry.vertices.push(this._helpersSlice.geometry.vertices[i]);
      }
      this._geometry.vertices.push(this._helpersSlice.geometry.vertices[0]);

      this._mesh = new THREE.Line(this._geometry, this._material);
      if (this._helpersSlice.aabbSpace === 'IJK') {
        this._mesh.applyMatrix(this._helpersSlice.stack.ijk2LPS);
      }
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: 'helpersSlice',
    set: function set(helpersSlice) {
      this._helpersSlice = helpersSlice;
      this._update();
    },
    get: function get() {
      return this._helpersSlice;
    }
  }, {
    key: 'visible',
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: 'color',
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBorder;
}(THREE.Object3D);

exports.default = HelpersBorder;

},{}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module helpers/boundingbox
 */

var HelpersBoundingBox = function (_THREE$Object3D) {
  _inherits(HelpersBoundingBox, _THREE$Object3D);

  function HelpersBoundingBox(stack) {
    _classCallCheck(this, HelpersBoundingBox);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersBoundingBox.__proto__ || Object.getPrototypeOf(HelpersBoundingBox)).call(this));
    //


    _this._stack = stack;
    _this._visible = true;
    _this._color = 0xFFFFFF;
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // create object
    _this._create();
    return _this;
  }

  // getters/setters


  _createClass(HelpersBoundingBox, [{
    key: "_create",


    // private methods
    value: function _create() {
      // Convenience vars
      var dimensions = this._stack.dimensionsIJK;
      var halfDimensions = this._stack.halfDimensionsIJK;
      var offset = new THREE.Vector3(-0.5, -0.5, -0.5);

      // Geometry
      this._geometry = new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z);
      // position bbox in image space
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(halfDimensions.x + offset.x, halfDimensions.y + offset.y, halfDimensions.z + offset.z));

      // Mesh
      var boxMesh = new THREE.Mesh(this._geometry, new THREE.MeshBasicMaterial(0xff0000));
      this._mesh = new THREE.BoxHelper(boxMesh, this._color);

      // Material
      this._material = this._mesh.material;

      // position bbox in world space
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: "_update",
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh.material.dispose();
        this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._geometry.dispose();
      this._geometry = null;
      this._material.dispose();
      this._material = null;
    }
  }, {
    key: "visible",
    set: function set(visible) {
      this._visible = visible;
      if (this._mesh) {
        this._mesh.visible = this._visible;
      }
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "color",
    set: function set(color) {
      this._color = color;
      if (this._material) {
        this._material.color.set(this._color);
      }
    },
    get: function get() {
      return this._color;
    }
  }]);

  return HelpersBoundingBox;
}(THREE.Object3D);

exports.default = HelpersBoundingBox;

},{}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpers = require('./helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('./helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('./helpers.localizer');

var _helpers6 = _interopRequireDefault(_helpers5);

var _helpers7 = require('./helpers.lut');

var _helpers8 = _interopRequireDefault(_helpers7);

var _helpers9 = require('./helpers.progressbar');

var _helpers10 = _interopRequireDefault(_helpers9);

var _helpersProgressbar = require('./helpers.progressbar.eventbased');

var _helpersProgressbar2 = _interopRequireDefault(_helpersProgressbar);

var _helpers11 = require('./helpers.slice');

var _helpers12 = _interopRequireDefault(_helpers11);

var _helpers13 = require('./helpers.stack');

var _helpers14 = _interopRequireDefault(_helpers13);

var _helpers15 = require('./helpers.volumerendering');

var _helpers16 = _interopRequireDefault(_helpers15);

var _helpers17 = require('./x/helpers.x');

var _helpers18 = _interopRequireDefault(_helpers17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module helpers
 */

exports.default = {
  Border: _helpers2.default,
  BoundingBox: _helpers4.default,
  Localizer: _helpers6.default,
  Lut: _helpers8.default,
  ProgressBar: _helpers10.default,
  ProgressBarEventBased: _helpersProgressbar2.default,
  Slice: _helpers12.default,
  Stack: _helpers14.default,
  VolumeRendering: _helpers16.default,
  X: _helpers18.default
};

},{"./helpers.border":110,"./helpers.boundingbox":111,"./helpers.localizer":113,"./helpers.lut":114,"./helpers.progressbar":117,"./helpers.progressbar.eventbased":116,"./helpers.slice":118,"./helpers.stack":119,"./helpers.volumerendering":120,"./x/helpers.x":122}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shadersLocalizer = require('../shaders/shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('../shaders/shaders.localizer.vertex');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('../shaders/shaders.localizer.fragment');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/localizer
 */

var HelpersLocalizer = function (_THREE$Object3D) {
  _inherits(HelpersLocalizer, _THREE$Object3D);

  function HelpersLocalizer(stack, geometry, referencePlane) {
    _classCallCheck(this, HelpersLocalizer);

    var _this = _possibleConstructorReturn(this, (HelpersLocalizer.__proto__ || Object.getPrototypeOf(HelpersLocalizer)).call(this));
    //


    _this._stack = stack;
    _this._referencePlane = referencePlane;
    _this._plane1 = null;
    _this._color1 = null;
    _this._plane2 = null;
    _this._color2 = null;
    _this._plane3 = null;
    _this._color3 = null;
    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._shadersFragment = _shadersLocalizer6.default;
    _this._shadersVertex = _shadersLocalizer4.default;
    _this._uniforms = _shadersLocalizer2.default.uniforms();
    _this._material = null;
    _this._geometry = geometry;

    _this._create();
    return _this;
  }

  _createClass(HelpersLocalizer, [{
    key: '_create',
    value: function _create() {
      this._prepareMaterial();
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack._ijk2LPS);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      if (!this.material) {
        // reference plane
        this._uniforms.uSlice.value = this._referencePlane;

        // localizer planes
        if (this._plane1) {
          this._uniforms.uPlane1.value = this._plane1;
          this._uniforms.uPlaneColor1.value = this._color1;
        }

        if (this._plane2) {
          this._uniforms.uPlane2.value = this._plane2;
          this._uniforms.uPlaneColor2.value = this._color2;
        }

        if (this._plane3) {
          this._uniforms.uPlane3.value = this._plane3;
          this._uniforms.uPlaneColor3.value = this._color3;
        }

        //
        this._uniforms.uCanvasWidth.value = this._canvasWidth;
        this._uniforms.uCanvasHeight.value = this._canvasHeight;

        // generate material
        var fs = new _shadersLocalizer6.default(this._uniforms);
        var vs = new _shadersLocalizer4.default();
        this._material = new THREE.ShaderMaterial({ side: THREE.DoubleSide,
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        });
        this._material.transparent = true;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'geometry',
    get: function get() {
      return this._geometry;
    },
    set: function set(geometry) {
      this._geometry = geometry;

      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'referencePlane',
    get: function get() {
      return this._referencePlane;
    },
    set: function set(referencePlane) {
      this._referencePlane = referencePlane;
      this._uniforms.uSlice.value = this._referencePlane;
    }
  }, {
    key: 'plane1',
    get: function get() {
      return this._plane1;
    },
    set: function set(plane1) {
      this._plane1 = plane1;
      this._uniforms.uPlane1.value = this._plane1;
    }
  }, {
    key: 'color1',
    get: function get() {
      return this._color1;
    },
    set: function set(color1) {
      this._color1 = color1;
      this._uniforms.uPlaneColor1.value = this._color1;
    }
  }, {
    key: 'plane2',
    get: function get() {
      return this._plane2;
    },
    set: function set(plane2) {
      this._plane2 = plane2;
      this._uniforms.uPlane2.value = this._plane2;
    }
  }, {
    key: 'color2',
    get: function get() {
      return this._color2;
    },
    set: function set(color2) {
      this._color2 = color2;
      this._uniforms.uPlaneColor2.value = this._color2;
    }
  }, {
    key: 'plane3',
    get: function get() {
      return this._plane3;
    },
    set: function set(plane3) {
      this._plane3 = plane3;
      this._uniforms.uPlane3.value = this._plane3;
    }
  }, {
    key: 'color3',
    get: function get() {
      return this._color3;
    },
    set: function set(color3) {
      this._color3 = color3;
      this._uniforms.uPlaneColor3.value = this._color3;
    }
  }, {
    key: 'canvasWidth',
    get: function get() {
      return this._canvasWidth;
    },
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    get: function get() {
      return this._canvasHeight;
    },
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    }
  }]);

  return HelpersLocalizer;
}(THREE.Object3D);

exports.default = HelpersLocalizer;

},{"../shaders/shaders.localizer.fragment":159,"../shaders/shaders.localizer.uniform":160,"../shaders/shaders.localizer.vertex":161}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/lut
 */

var HelpersLut = function () {
  function HelpersLut(containerID) {
    var lut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
    var lutO = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [[0, 0, 0, 0], [1, 1, 1, 1]];
    var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [[0, 0], [1, 1]];
    var discrete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, HelpersLut);

    // min/max (0-1 or real intensities)
    // show/hide
    // horizontal/vertical
    this._containerID = containerID;

    this._discrete = discrete;
    this._color = color;
    this._lut = lut;
    this._luts = _defineProperty({}, lut, color);

    this._opacity = opacity;
    this._lutO = lutO;
    this._lutsO = _defineProperty({}, lutO, opacity);

    this.initCanvas();
    this.paintCanvas();
  }

  _createClass(HelpersLut, [{
    key: 'initCanvas',
    value: function initCanvas() {
      // container
      this._canvasContainer = this.initCanvasContainer(this._containerID);
      // background
      this._canvasBg = this.createCanvas();
      this._canvasContainer.appendChild(this._canvasBg);
      // foreground
      this._canvas = this.createCanvas();
      this._canvasContainer.appendChild(this._canvas);
    }
  }, {
    key: 'initCanvasContainer',
    value: function initCanvasContainer(canvasContainerId) {
      var canvasContainer = document.getElementById(canvasContainerId);
      canvasContainer.style.width = '256 px';
      canvasContainer.style.height = '128 px';
      canvasContainer.style.border = '1px solid #F9F9F9';
      return canvasContainer;
    }
  }, {
    key: 'createCanvas',
    value: function createCanvas() {
      var canvas = document.createElement('canvas');
      canvas.height = 16;
      canvas.width = 256;
      return canvas;
    }
  }, {
    key: 'paintCanvas',
    value: function paintCanvas() {
      // setup context
      var ctx = this._canvas.getContext('2d');
      ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // apply color
      if (!this._discrete) {
        var color = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var i = 0; i < this._color.length; i++) {
          color.addColorStop(this._color[i][0], 'rgba( ' + Math.round(this._color[i][1] * 255) + ', ' + Math.round(this._color[i][2] * 255) + ', ' + Math.round(this._color[i][3] * 255) + ', 1)');
        }

        ctx.fillStyle = color;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      } else {
        ctx.lineWidth = 2 * this._canvas.height;

        for (var _i = 0; _i < this._color.length; _i++) {
          var currentPos = this._color[_i][0];
          var nextPos = 1;
          if (_i < this._color.length - 1) {
            nextPos = this._color[_i + 1][0];
          }
          var previousPos = 0;
          if (_i > 0) {
            previousPos = this._color[_i - 1][0];
          }

          var from = previousPos + (currentPos - previousPos) / 2;
          var to = currentPos + (nextPos - currentPos) / 2;
          var _color = this._color[_i];
          var opacity = this._opacity[_i] ? this._opacity[_i][1] : 1;

          ctx.beginPath();
          ctx.strokeStyle = 'rgba( ' + Math.round(_color[1] * 255) + ', ' + Math.round(_color[2] * 255) + ', ' + Math.round(_color[3] * 255) + ', ' + opacity + ')';
          ctx.moveTo(from * this._canvas.width, 0);
          ctx.lineTo(to * this._canvas.width, 0);
          ctx.stroke();
          ctx.closePath();
        }
      }

      if (!this._discrete) {
        // if discrete, we already took care of the opacity.
        // setup context
        ctx.globalCompositeOperation = 'destination-in';

        // apply opacity
        var _opacity = ctx.createLinearGradient(0, 0, this._canvas.width, this._canvas.height);
        for (var _i2 = 0; _i2 < this._opacity.length; _i2++) {
          _opacity.addColorStop(this._opacity[_i2][0], 'rgba(255, 255, 255, ' + this._opacity[_i2][1] + ')');
        }
        ctx.fillStyle = _opacity;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
      }
    }
  }, {
    key: 'lutsAvailable',
    value: function lutsAvailable() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'color';

      var available = [];
      var luts = this._luts;

      if (type !== 'color') {
        luts = this._lutsO;
      }

      for (var i in luts) {
        available.push(i);
      }

      return available;
    }

    // add luts to class' lut (so a user can add its own as well)

  }, {
    key: 'texture',
    get: function get() {
      var texture = new THREE.Texture(this._canvas);
      texture.mapping = THREE.UVMapping;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.magFilter = texture.minFilter = THREE.NearestFilter;
      texture.premultiplyAlpha = true;
      texture.needsUpdate = true;
      return texture;
    }
  }, {
    key: 'lut',
    set: function set(targetLUT) {
      this._color = this._luts[targetLUT];
      this._lut = targetLUT;

      this.paintCanvas();
    },
    get: function get() {
      return this._lut;
    }
  }, {
    key: 'luts',
    set: function set(newLuts) {
      this._luts = newLuts;
    },
    get: function get() {
      return this._luts;
    }
  }, {
    key: 'lutO',
    set: function set(targetLUTO) {
      this._opacity = this._lutsO[targetLUTO];
      this._lutO = targetLUTO;

      this.paintCanvas();
    },
    get: function get() {
      return this._lutO;
    }
  }, {
    key: 'lutsO',
    set: function set(newLutsO) {
      this._lutsO = newLutsO;
    },
    get: function get() {
      return this._lutsO;
    }
  }, {
    key: 'discrete',
    set: function set(discrete) {
      this._discrete = discrete;

      this.paintCanvas();
    },
    get: function get() {
      return this._discrete;
    }
  }], [{
    key: 'presetLuts',
    value: function presetLuts() {
      return {
        'default': [[0, 0, 0, 0], [1, 1, 1, 1]],
        'spectrum': [[0, 0, 0, 0], [0.1, 0, 0, 1], [0.33, 0, 1, 1], [0.5, 0, 1, 0], [0.66, 1, 1, 0], [0.9, 1, 0, 0], [1, 1, 1, 1]],
        'hot_and_cold': [[0, 0, 0, 1], [0.15, 0, 1, 1], [0.3, 0, 1, 0], [0.45, 0, 0, 0], [0.5, 0, 0, 0], [0.55, 0, 0, 0], [0.7, 1, 1, 0], [0.85, 1, 0, 0], [1, 1, 1, 1]],
        'gold': [[0, 0, 0, 0], [0.13, 0.19, 0.03, 0], [0.25, 0.39, 0.12, 0], [0.38, 0.59, 0.26, 0], [0.50, 0.80, 0.46, 0.08], [0.63, 0.99, 0.71, 0.21], [0.75, 0.99, 0.88, 0.34], [0.88, 0.99, 0.99, 0.48], [1, 0.90, 0.95, 0.61]],
        'red': [[0, 0.75, 0, 0], [0.5, 1, 0.5, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'green': [[0, 0, 0.75, 0], [0.5, 0.5, 1, 0], [0.95, 1, 1, 0], [1, 1, 1, 1]],
        'blue': [[0, 0, 0, 1], [0.5, 0, 0.5, 1], [0.95, 0, 1, 1], [1, 1, 1, 1]],
        'walking_dead': [[0, 0.1, 1, 1], [1, 1, 1, 1]],
        'random': [[0, 0, 0, 0], [0.27, 0.18, 0.18, 0.18], [0.41, 1, 1, 1], [0.7, 1, 0, 0], [1, 1, 1, 1]]
      };
    }
  }, {
    key: 'presetLutsO',
    value: function presetLutsO() {
      return {
        'linear': [[0, 0], [1, 1]],
        'lowpass': [[0, 0.8], [0.2, 0.6], [0.3, 0.1], [1, 0]],
        'bandpass': [[0, 0], [0.4, 0.8], [0.6, 0.8], [1, 0]],
        'highpass': [[0, 0], [0.7, 0.1], [0.8, 0.6], [1, 0.8]],
        'flat': [[0, .7], [1, 1]],
        'random': [[0, 0.], [0.38, 0.], [0.55, 1.], [0.72, 1.], [1, 0.05]]
      };
    }
  }]);

  return HelpersLut;
}();

exports.default = HelpersLut;

},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Helpers material mixin.
 *
 * @module helpers/material/mixin
 */

var HerlpersMaterialMixin = function HerlpersMaterialMixin(superclass) {
  return function (_superclass) {
    _inherits(_class, _superclass);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: "_createMaterial",
      value: function _createMaterial(extraOptions) {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        // material
        var globalOptions = {
          uniforms: this._uniforms,
          vertexShader: vs.compute(),
          fragmentShader: fs.compute()
        };

        var options = Object.assign(extraOptions, globalOptions);
        this._material = new THREE.ShaderMaterial(options);
        this._material.needsUpdate = true;
      }
    }, {
      key: "_updateMaterial",
      value: function _updateMaterial() {
        // generate shaders on-demand!
        var fs = new this._shadersFragment(this._uniforms);
        var vs = new this._shadersVertex();

        this._material.vertexShader = vs.compute();
        this._material.fragmentShader = fs.compute();

        this._material.needsUpdate = true;
      }
    }, {
      key: "_prepareTexture",
      value: function _prepareTexture() {
        this._textures = [];
        for (var m = 0; m < this._stack._rawData.length; m++) {
          var tex = new THREE.DataTexture(this._stack.rawData[m], this._stack.textureSize, this._stack.textureSize, this._stack.textureType, THREE.UnsignedByteType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
          tex.needsUpdate = true;
          tex.flipY = true;
          this._textures.push(tex);
        }
      }
    }]);

    return _class;
  }(superclass);
};

exports.default = HerlpersMaterialMixin;

},{}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Event Based progressbar
 * @module helpers/progressBar
 *
 * @example
 *
 * let loader = new LoadersVolume();
 * const domContainer = document.getElementById('progressbar');
 * const pb = new HelpersProgressBarEventBased(loader, domContainer);
 */

var HelpersProgressBarEventBased = function () {
  function HelpersProgressBarEventBased(emitter, domTarget) {
    _classCallCheck(this, HelpersProgressBarEventBased);

    if (!emitter || !this._isFunction(emitter.emit)) {
      console.error('please give the this._emitter instance');
      return;
    }

    if (_core2.default.isString(domTarget)) {
      this._dom = document.getElementById(domTarget);
    } else {
      this._dom = domTarget;
    }

    if (!_core2.default.isElement(this._dom)) {
      console.error('please give the id of container dom or directly a dom instance');
      return;
    }
    this._emitter = emitter;
    this.initContainerDom();
    this.initEventListenner();
    this.loaded = 0;
    this.totalFile = 0;
  }

  _createClass(HelpersProgressBarEventBased, [{
    key: '_isFunction',
    value: function _isFunction(fn) {
      return Object.prototype.toString.call(fn) === '[object Function]';
    }
  }, {
    key: 'initEventListenner',
    value: function initEventListenner() {
      var self = this;

      this._emitter.on('load-start', function (event) {
        var totalFiles = event.totalFiles;
        self.totalFile = totalFiles;
        self._domTotalFile.innerHTML = totalFiles;
      });

      this._emitter.on('fetch-start', function (event) {
        var fetchLi = document.createElement('li');

        var fileTag = document.createElement('div');
        fileTag.innerHTML = 'file: ' + event.file;
        fileTag.style.color = '#ffffff';
        fetchLi.append(fileTag);

        fetchLi.className = 'fetch-file';
        fetchLi.id = 'file-' + event.file;
        fetchLi.style.marginBottom = '7px';
        fetchLi.style.border = '1px solid #ffffff;';
        fetchLi.style.width = '60%';
        var fetchprogress = document.createElement('div');
        fetchprogress.id = 'file-fetch-' + event.file;
        fetchprogress.style.width = '0%';
        fetchLi.append(fetchprogress);
        self._domProcessList.append(fetchLi);
      });

      this._emitter.on('fetch-progress', function (event) {
        var id = 'file-fetch-' + event.file;
        var fileFetchDom = document.getElementById(id);
        fileFetchDom.style.width = event.loaded / event.total * 100 + '%';
        fileFetchDom.style.border = '1px solid red';
      });

      this._emitter.on('fetch-success', function (event) {
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'fetch-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });

      this._emitter.on('fetch-error', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-abort', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-end', function (event) {
        // console.log(event);
      });

      this._emitter.on('fetch-timeout', function (event) {
        // console.log(event);
      });

      this._emitter.on('parse-start', function (event) {
        var liParent = document.getElementById('file-' + event.file);
        var parseprogress = document.createElement('div');
        parseprogress.id = 'file-parse-' + event.file;
        parseprogress.style.width = '0%';
        liParent.append(parseprogress);
      });

      this._emitter.on('parsing', function (event) {
        var id = 'file-parse-' + event.file;
        var fileParseDom = document.getElementById(id);
        fileParseDom.style.width = event.parsed / event.total * 100 + '%';
        fileParseDom.style.border = '1px solid yellow';
      });

      this._emitter.on('parse-success', function (event) {
        self.loaded += 1;
        self._domCurrentFile.innerHTML = self.loaded;
        self._domCurrentProgress.style.width = self.loaded / self.totalFile * 100 + '%';
        // show result
        var liParent = document.getElementById('file-' + event.file);
        var result = document.createElement('div');
        result.id = 'file-result-' + event.file;
        result.innerHTML = 'parse-success';
        result.style.color = '#ffffff';
        liParent.append(result);
      });
    }
  }, {
    key: 'initContainerDom',
    value: function initContainerDom() {
      var containerDom = "<div id='ami-progress-bar-container' style='background-color: rgb(33, 33, 33); color: #ffffff;'>" + "<div>" + "<label for='progress-bar' id='progress-label' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<span id='current-file-index'>0</span>" + "/" + "<span id='total-file'>0</span>" + "</label>" + "<div id='progress-bar' style='width: 60%; border: 1px solid #ffffff; text-align: center;'>" + "<div id='current-progress' style='border: 1px solid red; width: 0%;'></div>" + "</div>" + "</div>" + "<ul id='process-list' style='list-style-type: none; padding: 0; overflow-y: auto;'>" +
      // "<li class='fetch-file'>" +
      // "<div id='file-fetch-xxxxxid'></div>" +
      // "<div id='file-parse-xxxxxid'></div>" +
      // "</li>" +
      "</ul>" + "</div>";
      var wrap = document.createElement('div');
      wrap.innerHTML = containerDom;
      this._dom.append(wrap);
      // dom interface
      this._domCurrentFile = document.getElementById('current-file-index');
      this._domTotalFile = document.getElementById('total-file');
      this._domProcessList = document.getElementById('process-list');
      this._domCurrentProgress = document.getElementById('current-progress');
    }
  }]);

  return HelpersProgressBarEventBased;
}();

exports.default = HelpersProgressBarEventBased;

},{"../core/core.utils":105}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/progressBar
 */

var HelpersProgressBar = function () {
  function HelpersProgressBar(container) {
    _classCallCheck(this, HelpersProgressBar);

    this._container = container;
    this._modes = {
      'load': {
        'name': 'load',
        'color': '#FFF56F'
      },
      'parse': {
        'name': 'parse',
        'color': '#2196F3'
      }
    };

    this.requestAnimationFrameID = null;

    this._mode = null;
    this._value = null;
    this._total = null;

    this.init();
  }

  _createClass(HelpersProgressBar, [{
    key: 'free',
    value: function free() {
      var progressContainers = this._container.getElementsByClassName('progress container');
      if (progressContainers.length > 0) {
        progressContainers[0].parentNode.removeChild(progressContainers[0]);
      }
      progressContainers = null;
      // stop rendering loop
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
  }, {
    key: 'init',
    value: function init() {
      var progressContainer = this._domContainer();

      for (var mode in this._modes) {
        if (this._modes.hasOwnProperty(mode)) {
          var bar = this._domBar(this._modes[mode]);
          progressContainer.appendChild(bar);
          bar = null;
        }
      }

      this._container.appendChild(progressContainer);
      progressContainer = null;

      // start rendering loop
      this.updateUI();
    }
  }, {
    key: 'update',
    value: function update(value, total, mode) {
      this._mode = mode;
      this._value = value;
      // depending on CDN, total return to XHTTPRequest can be 0.
      // In this case, we generate a random number to animate the progressbar
      if (total === 0) {
        this._total = value;
        this._value = Math.random() * value;
      } else {
        this._total = total;
      }
    }
  }, {
    key: 'updateUI',
    value: function updateUI() {
      var _this = this;

      this.requestAnimationFrameID = requestAnimationFrame(function () {
        _this.updateUI();
      });

      if (!(this._modes.hasOwnProperty(this._mode) && this._modes[this._mode].hasOwnProperty('name') && this._modes[this._mode].hasOwnProperty('color'))) {
        return false;
      }

      var message = '';
      var progress = Math.round(this._value / this._total * 100);
      var color = this._modes[this._mode].color;

      var progressBar = this._container.getElementsByClassName('progress ' + this._modes[this._mode].name);
      if (progressBar.length > 0) {
        progressBar[0].style.borderColor = color;
        progressBar[0].style.width = progress + '%';
      }
      progressBar = null;
    }
  }, {
    key: '_domContainer',
    value: function _domContainer() {
      var container = document.createElement('div');

      // class it
      container.classList.add('progress');
      container.classList.add('container');

      // style it
      container.style.width = '100%';
      container.style.height = '8px';
      container.style.position = 'absolute';
      container.style.backgroundColor = 'rgba(158, 158, 158, 0.5)';
      container.style.top = '0';
      container.style.zIndex = '1';

      return container;
    }
  }, {
    key: '_domBar',
    value: function _domBar(mode) {
      if (!(mode.hasOwnProperty('name') && mode.hasOwnProperty('color'))) {
        window.console.log('Invalid mode provided.');
        window.console.log(mode);

        return false;
      }

      var bar = document.createElement('div');

      // class it
      bar.classList.add(mode.name);
      bar.classList.add('progress');

      // style it
      bar.style.border = '2px solid ' + mode.color;
      bar.style.width = '0%';

      return bar;
    }
  }]);

  return HelpersProgressBar;
}();

exports.default = HelpersProgressBar;

},{}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _geometries = require('../geometries/geometries.slice');

var _geometries2 = _interopRequireDefault(_geometries);

var _shadersData = require('../shaders/shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('../shaders/shaders.data.vertex');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('../shaders/shaders.data.fragment');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/slice
 */

var HelpersSlice = function (_HelpersMaterialMixin) {
  _inherits(HelpersSlice, _HelpersMaterialMixin);

  function HelpersSlice(stack) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3(0, 0, 0);
    var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector3(0, 0, 1);
    var aabbSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'IJK';

    _classCallCheck(this, HelpersSlice);

    // private vars
    var _this = _possibleConstructorReturn(this, (HelpersSlice.__proto__ || Object.getPrototypeOf(HelpersSlice)).call(this));
    //


    _this._stack = stack;

    // image settings
    // index only used to grab window/level and intercept/slope
    _this._invert = _this._stack.invert;

    _this._lut = 'none';
    _this._lutTexture = null;
    // if auto === true, get from index
    // else from stack which holds the default values
    _this._intensityAuto = true;
    _this._interpolation = 1; // default to trilinear interpolation
    // starts at 0
    _this._index = index;
    _this._windowWidth = null;
    _this._windowCenter = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // Object3D settings
    // shape
    _this._planePosition = position;
    _this._planeDirection = direction;
    // change aaBBSpace changes the box dimensions
    // also changes the transform
    // there is also a switch to move back mesh to LPS space automatically
    _this._aaBBspace = aabbSpace; // or LPS -> different transforms, esp for the geometry/mesh
    _this._material = null;
    _this._textures = [];
    _this._shadersFragment = _shadersData6.default;
    _this._shadersVertex = _shadersData4.default;
    _this._uniforms = _shadersData2.default.uniforms();
    _this._geometry = null;
    _this._mesh = null;
    _this._visible = true;

    // update dimensions, center, etc.
    // depending on aaBBSpace
    _this._init();

    // update object
    _this._create();
    return _this;
  }

  // getters/setters

  _createClass(HelpersSlice, [{
    key: '_init',
    value: function _init() {
      if (!this._stack || !this._stack._prepared || !this._stack._packed) {
        return;
      }

      if (this._aaBBspace === 'IJK') {
        this._halfDimensions = this._stack.halfDimensionsIJK;
        this._center = new THREE.Vector3(this._stack.halfDimensionsIJK.x - 0.5, this._stack.halfDimensionsIJK.y - 0.5, this._stack.halfDimensionsIJK.z - 0.5);
        this._toAABB = new THREE.Matrix4();
      } else {
        // LPS
        var aaBBox = this._stack.AABBox();
        this._halfDimensions = aaBBox.clone().multiplyScalar(0.5);
        this._center = this._stack.centerAABBox();
        this._toAABB = this._stack.lps2AABB;
      }
    }

    // private methods

  }, {
    key: '_create',
    value: function _create() {
      if (!this._stack || !this._stack.prepared || !this._stack.packed) {
        return;
      }

      // Convenience vars
      try {
        this._geometry = new _geometries2.default(this._halfDimensions, this._center, this._planePosition, this._planeDirection, this._toAABB);
      } catch (e) {
        window.console.log(e);
        window.console.log('invalid slice geometry - exiting...');
        return;
      }

      if (!this._geometry.vertices) {
        return;
      }

      if (!this._material) {
        //
        this._uniforms.uTextureSize.value = this._stack.textureSize;
        this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
        this._uniforms.uWorldToData.value = this._stack.lps2IJK;
        this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
        this._uniforms.uPixelType.value = this._stack.pixelType;
        this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
        this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
        // compute texture if material exist
        this._prepareTexture();
        this._uniforms.uTextureContainer.value = this._textures;

        this._createMaterial({
          side: THREE.DoubleSide
        });
      }

      // update intensity related stuff
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();

      // create the mesh!
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      if (this._aaBBspace === 'IJK') {
        this._mesh.applyMatrix(this._stack.ijk2LPS);
      }

      this._mesh.visible = this._visible;

      // and add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateIntensitySettings',
    value: function updateIntensitySettings() {
      // if auto, get from frame index
      if (this._intensityAuto) {
        this.updateIntensitySetting('windowCenter');
        this.updateIntensitySetting('windowWidth');
        this.updateIntensitySetting('rescaleSlope');
        this.updateIntensitySetting('rescaleIntercept');
      } else {
        if (this._windowCenter === null) {
          this._windowCenter = this._stack.windowCenter;
        }

        if (this.__windowWidth === null) {
          this._windowWidth = this._stack.windowWidth;
        }

        if (this._rescaleSlope === null) {
          this._rescaleSlope = this._stack.rescaleSlope;
        }

        if (this._rescaleIntercept === null) {
          this._rescaleIntercept = this._stack.rescaleIntercept;
        }
      }
    }
  }, {
    key: 'updateIntensitySettingsUniforms',
    value: function updateIntensitySettingsUniforms() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset -= this._stack._minMax[0];
      }

      // set slice window center and width
      this._uniforms.uRescaleSlopeIntercept.value = [this._rescaleSlope, this._rescaleIntercept];
      this._uniforms.uWindowCenterWidth.value = [offset + this._windowCenter, this._windowWidth];

      // invert
      this._uniforms.uInvert.value = this._invert === true ? 1 : 0;

      // interpolation
      this._uniforms.uInterpolation.value = this._interpolation;

      // lut
      if (this._lut === 'none') {
        this._uniforms.uLut.value = 0;
      } else {
        this._uniforms.uLut.value = 1;
        this._uniforms.uTextureLUT.value = this._lutTexture;
      }
    }
  }, {
    key: 'updateIntensitySetting',
    value: function updateIntensitySetting(setting) {
      if (this._stack.frame[this._index] && this._stack.frame[this._index][setting]) {
        this['_' + setting] = this._stack.frame[this._index][setting];
      } else {
        this['_' + setting] = this._stack[setting];
      }
    }
  }, {
    key: '_update',
    value: function _update() {
      // update slice
      if (this._mesh) {
        this.remove(this._mesh);
        this._mesh.geometry.dispose();
        this._mesh.geometry = null;
        // we do not want to dispose the texture!
        // this._mesh.material.dispose();
        // this._mesh.material = null;
        this._mesh = null;
      }

      this._create();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      // Release memory
      for (var j = 0; j < this._textures.length; j++) {
        this._textures[j].dispose();
        this._textures[j] = null;
      }
      this._textures = null;
      this._shadersFragment = null;
      this._shadersVertex = null;

      this._uniforms = null;

      // material, geometry and mesh
      this.remove(this._mesh);
      this._mesh.geometry.dispose();
      this._mesh.geometry = null;
      this._mesh.material.dispose();
      this._mesh.material = null;
      this._mesh = null;

      this._geometry.dispose();
      this._geometry = null;
      this._material.vertexShader = null;
      this._material.fragmentShader = null;
      this._material.uniforms = null;
      this._material.dispose();
      this._material = null;

      this._stack = null;
    }
  }, {
    key: 'cartesianEquation',
    value: function cartesianEquation() {
      // Make sure we have a geometry
      if (!this._geometry || !this._geometry.vertices || this._geometry.vertices.length < 3) {
        return new THREE.Vector4();
      }

      var vertices = this._geometry.vertices;
      var dataToWorld = this._stack.ijk2LPS;
      var p1 = new THREE.Vector3(vertices[0].x, vertices[0].y, vertices[0].z).applyMatrix4(dataToWorld);
      var p2 = new THREE.Vector3(vertices[1].x, vertices[1].y, vertices[1].z).applyMatrix4(dataToWorld);
      var p3 = new THREE.Vector3(vertices[2].x, vertices[2].y, vertices[2].z).applyMatrix4(dataToWorld);
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normal = v1.subVectors(p3, p2).cross(v2.subVectors(p1, p2)).normalize();

      return new THREE.Vector4(normal.x, normal.y, normal.z, -normal.dot(p1));
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'invert',
    get: function get() {
      return this._invert;
    },
    set: function set(invert) {
      this._invert = invert;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'lut',
    get: function get() {
      return this._lut;
    },
    set: function set(lut) {
      this._lut = lut;
    }
  }, {
    key: 'lutTexture',
    get: function get() {
      return this._lutTexture;
    },
    set: function set(lutTexture) {
      this._lutTexture = lutTexture;
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'intensityAuto',
    get: function get() {
      return this._intensityAuto;
    },
    set: function set(intensityAuto) {
      this._intensityAuto = intensityAuto;
      this.updateIntensitySettings();
      this.updateIntensitySettingsUniforms();
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this.updateIntensitySettingsUniforms();
      this._updateMaterial();
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
      this._update();
    }
  }, {
    key: 'planePosition',
    set: function set(position) {
      this._planePosition = position;
      this._update();
    },
    get: function get() {
      return this._planePosition;
    }
  }, {
    key: 'planeDirection',
    set: function set(direction) {
      this._planeDirection = direction;
      this._update();
    },
    get: function get() {
      return this._planeDirection;
    }
  }, {
    key: 'halfDimensions',
    set: function set(halfDimensions) {
      this._halfDimensions = halfDimensions;
    },
    get: function get() {
      return this._halfDimensions;
    }
  }, {
    key: 'center',
    set: function set(center) {
      this._center = center;
    },
    get: function get() {
      return this._center;
    }
  }, {
    key: 'aabbSpace',
    set: function set(aabbSpace) {
      this._aaBBspace = aabbSpace;
      this._init();
    },
    get: function get() {
      return this._aaBBspace;
    }
  }, {
    key: 'mesh',
    set: function set(mesh) {
      this._mesh = mesh;
    },
    get: function get() {
      return this._mesh;
    }
  }, {
    key: 'geometry',
    set: function set(geometry) {
      this._geometry = geometry;
    },
    get: function get() {
      return this._geometry;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._uniforms.uCanvasWidth.value = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._uniforms.uCanvasHeight.value = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._uniforms.uBorderColor.value = new THREE.Color(borderColor);
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersSlice;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersSlice;

},{"../geometries/geometries.slice":108,"../helpers/helpers.material.mixin":115,"../shaders/shaders.data.fragment":152,"../shaders/shaders.data.uniform":153,"../shaders/shaders.data.vertex":154}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers/helpers.border');

var _helpers2 = _interopRequireDefault(_helpers);

var _helpers3 = require('../helpers/helpers.boundingbox');

var _helpers4 = _interopRequireDefault(_helpers3);

var _helpers5 = require('../helpers/helpers.slice');

var _helpers6 = _interopRequireDefault(_helpers5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Helper to easily display and interact with a stack.<br>
 *<br>
 * Defaults:<br>
 *   - orientation: 0 (acquisition direction)<br>
 *   - index: middle slice in acquisition direction<br>
 *<br>
 * Features:<br>
 *   - slice from the stack (in any direction)<br>
 *   - slice border<br>
 *   - stack bounding box<br>
 *<br>
 * Live demo at: {@link http://jsfiddle.net/gh/get/library/pure/fnndsc/ami/tree/master/lessons/01#run|Lesson 01}
 *
 * @example
 * let stack = new VJS.Models.Stack();
 * ... // prepare the stack
 *
 * let stackHelper = new VJS.Helpers.Stack(stack);
 * stackHelper.bbox.color = 0xF9F9F9;
 * stackHelper.border.color = 0xF9F9F9;
 *
 * let scene = new THREE.Scene();
 * scene.add(stackHelper);
 *
 * @extends THREE.Object3D
 *
 * @see module:helpers/border
 * @see module:helpers/boundingbox
 * @see module:helpers/slice
 *
 * @module helpers/stack
 */
var HelpersStack = function (_THREE$Object3D) {
  _inherits(HelpersStack, _THREE$Object3D);

  function HelpersStack(stack) {
    _classCallCheck(this, HelpersStack);

    var _this = _possibleConstructorReturn(this, (HelpersStack.__proto__ || Object.getPrototypeOf(HelpersStack)).call(this));
    //


    _this._stack = stack;
    _this._bBox = null;
    _this._slice = null;
    _this._border = null;
    _this._dummy = null;

    _this._orientation = 0;
    _this._index = 0;

    _this._uniforms = null;
    _this._autoWindowLevel = false;
    _this._outOfBounds = false;
    _this._orientationMaxIndex = 0;

    _this._canvasWidth = 0;
    _this._canvasHeight = 0;
    _this._borderColor = null;

    // this._arrow = {
    //   visible: true,
    //   color: 0xFFF336,
    //   length: 20,
    //   material: null,
    //   geometry: null,
    //   mesh: null
    // };
    _this._create();
    return _this;
  }

  //
  // PUBLIC METHODS
  //

  //
  // SETTERS/GETTERS
  //

  /**
   * Get stack.
   *
   * @type {ModelsStack}
   */


  _createClass(HelpersStack, [{
    key: '_create',


    //
    // PRIVATE METHODS
    //

    /**
     * Initial setup, including stack prepare, bbox prepare, slice prepare and
     * border prepare.
     *
     * @private
     */
    value: function _create() {
      if (this._stack) {
        // prepare sthe stack internals
        this._prepareStack();

        // prepare visual objects
        this._prepareBBox();
        this._prepareSlice();
        this._prepareBorder();
        // todo: Arrow
      } else {
        window.console.log('no stack to be prepared...');
      }
    }
  }, {
    key: '_computeOrientationMaxIndex',
    value: function _computeOrientationMaxIndex() {
      var dimensionsIJK = this._stack.dimensionsIJK;
      this._orientationMaxIndex = 0;
      switch (this._orientation) {
        case 0:
          this._orientationMaxIndex = dimensionsIJK.z - 1;
          break;
        case 1:
          this._orientationMaxIndex = dimensionsIJK.x - 1;
          break;
        case 2:
          this._orientationMaxIndex = dimensionsIJK.y - 1;
          break;
        default:
          // do nothing!
          break;
      }
    }

    /**
     * Given orientation, check if index is in/out of bounds.
     *
     * @private
     */

  }, {
    key: '_isIndexOutOfBounds',
    value: function _isIndexOutOfBounds() {
      this._computeOrientationMaxIndex();
      if (this._index >= this._orientationMaxIndex || this._index < 0) {
        this._outOfBounds = true;
      } else {
        this._outOfBounds = false;
      }
    }

    /**
     * Prepare a stack for visualization. (image to world transform, frames order,
     * pack data into 8 bits textures, etc.)
     *
     * @private
     */

  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      // make sure there is something, if not throw an error
      // compute image to workd transform, order frames, etc.
      if (!this._stack.prepared) {
        this._stack.prepare();
      }
      // pack data into 8 bits rgba texture for the shader
      // this one can be slow...
      if (!this._stack.packed) {
        this._stack.pack();
      }
    }

    /**
     * Setup bounding box helper given prepared stack and add bounding box helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBBox',
    value: function _prepareBBox() {
      this._bBox = new _helpers4.default(this._stack);
      this.add(this._bBox);
    }

    /**
     * Setup border helper given slice helper and add border helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareBorder',
    value: function _prepareBorder() {
      this._border = new _helpers2.default(this._slice);
      this.add(this._border);
    }

    /**
     * Setup slice helper given prepared stack helper and add slice helper
     * to stack helper.
     *
     * @private
     */

  }, {
    key: '_prepareSlice',
    value: function _prepareSlice() {
      var halfDimensionsIJK = this._stack.halfDimensionsIJK;
      // compute initial index given orientation
      this._index = this._prepareSliceIndex(halfDimensionsIJK);
      // compute initial position given orientation and index
      var position = this._prepareSlicePosition(halfDimensionsIJK, this._index);
      // compute initial direction orientation
      var direction = this._prepareDirection(this._orientation);

      this._slice = new _helpers6.default(this._stack, this._index, position, direction);
      this.add(this._slice);
    }

    /**
     * Compute slice index depending on orientation.
     *
     * @param {THREE.Vector3} indices - Indices in each direction.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSliceIndex',
    value: function _prepareSliceIndex(indices) {
      var index = 0;
      switch (this._orientation) {
        case 0:
          index = Math.floor(indices.z);
          break;
        case 1:
          index = Math.floor(indices.x);
          break;
        case 2:
          index = Math.floor(indices.y);
          break;
        default:
          // do nothing!
          break;
      }
      return index;
    }

    /**
     * Compute slice position depending on orientation.
     * Sets index in proper location of reference position.
     *
     * @param {THREE.Vector3} rPosition - Reference position.
     * @param {number} index - Current index.
     *
     * @returns {number} Slice index according to current orientation.
     *
     * @private
     */

  }, {
    key: '_prepareSlicePosition',
    value: function _prepareSlicePosition(rPosition, index) {
      var position = new THREE.Vector3(0, 0, 0);
      switch (this._orientation) {
        case 0:
          position = new THREE.Vector3(Math.floor(rPosition.x), Math.floor(rPosition.y), index);
          break;
        case 1:
          position = new THREE.Vector3(index, Math.floor(rPosition.y), Math.floor(rPosition.z));
          break;
        case 2:
          position = new THREE.Vector3(Math.floor(rPosition.x), index, Math.floor(rPosition.z));
          break;
        default:
          // do nothing!
          break;
      }
      return position;
    }

    /**
     * Compute slice direction depending on orientation.
     *
     * @param {number} orientation - Slice orientation.
     *
     * @returns {THREE.Vector3} Slice direction
     *
     * @private
     */

  }, {
    key: '_prepareDirection',
    value: function _prepareDirection(orientation) {
      var direction = new THREE.Vector3(0, 0, 1);
      switch (orientation) {
        case 0:
          direction = new THREE.Vector3(0, 0, 1);
          break;
        case 1:
          direction = new THREE.Vector3(1, 0, 0);
          break;
        case 2:
          direction = new THREE.Vector3(0, 1, 0);
          break;
        default:
          // do nothing!
          break;
      }

      return direction;
    }

    /**
     * Release the stack helper memory including the slice memory.
     *
     * @public
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.remove(this._slice);
      this._slice.dispose();
      this._slice = null;
      this._bBox.dispose();
      this._bBox = null;
      this._border.dispose();
      this._border = null;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }

    /**
     * Set stack.
     *
     * @type {ModelsStack}
     */
    ,
    set: function set(stack) {
      this._stack = stack;
    }

    /**
     * Get bounding box helper.
     *
     * @type {HelpersBoundingBox}
     */

  }, {
    key: 'bbox',
    get: function get() {
      return this._bBox;
    }

    /**
     * Get slice helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'slice',
    get: function get() {
      return this._slice;
    }

    /**
     * Get border helper.
     *
     * @type {HelpersSlice}
     */

  }, {
    key: 'border',
    get: function get() {
      return this._border;
    }

    /**
     * Set/get current slice index.<br>
     * Sets outOfBounds flag to know if target index is in/out stack bounding box.<br>
     * <br>
     * Internally updates the sliceHelper index and position. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;

      // update the slice
      this._slice.index = index;
      var halfDimensions = this._stack.halfDimensionsIJK;
      this._slice.planePosition = this._prepareSlicePosition(halfDimensions, this._index);

      // also update the border
      this._border.helpersSlice = this._slice;

      // update ourOfBounds flag
      this._isIndexOutOfBounds();
    }

    /**
     * Set/get current slice orientation.<br>
     * Values: <br>
     *   - 0: acquisition direction (slice normal is z_cosine)<br>
     *   - 1: next direction (slice normal is x_cosine)<br>
     *   - 2: next direction (slice normal is y_cosine)<br>
     *   - n: set orientation to 0<br>
     * <br>
     * Internally updates the sliceHelper direction. Also updates the
     * borderHelper with the updated sliceHelper.
     *
     * @type {number}
     */

  }, {
    key: 'orientation',
    set: function set(orientation) {
      this._orientation = orientation;
      this._computeOrientationMaxIndex();

      this._slice.planeDirection = this._prepareDirection(this._orientation);

      // also update the border
      this._border.helpersSlice = this._slice;
    },
    get: function get() {
      return this._orientation;
    }

    /**
     * Set/get the outOfBound flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'outOfBounds',
    set: function set(outOfBounds) {
      this._outOfBounds = outOfBounds;
    },
    get: function get() {
      return this._outOfBounds;
    }

    /**
     * Set/get the orientationMaxIndex flag.
     *
     * @type {boolean}
     */

  }, {
    key: 'orientationMaxIndex',
    set: function set(orientationMaxIndex) {
      this._orientationMaxIndex = orientationMaxIndex;
    },
    get: function get() {
      return this._orientationMaxIndex;
    }
  }, {
    key: 'canvasWidth',
    set: function set(canvasWidth) {
      this._canvasWidth = canvasWidth;
      this._slice.canvasWidth = this._canvasWidth;
    },
    get: function get() {
      return this._canvasWidth;
    }
  }, {
    key: 'canvasHeight',
    set: function set(canvasHeight) {
      this._canvasHeight = canvasHeight;
      this._slice.canvasHeight = this._canvasHeight;
    },
    get: function get() {
      return this._canvasHeight;
    }
  }, {
    key: 'borderColor',
    set: function set(borderColor) {
      this._borderColor = borderColor;
      this._border.color = borderColor;
      this._slice.borderColor = this._borderColor;
    },
    get: function get() {
      return this._borderColor;
    }
  }]);

  return HelpersStack;
}(THREE.Object3D);

exports.default = HelpersStack;

},{"../helpers/helpers.border":110,"../helpers/helpers.boundingbox":111,"../helpers/helpers.slice":118}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shadersVr = require('../shaders/shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('../shaders/shaders.vr.vertex');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('../shaders/shaders.vr.fragment');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _helpersMaterial = require('../helpers/helpers.material.mixin');

var _helpersMaterial2 = _interopRequireDefault(_helpersMaterial);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module helpers/volumerendering
 */

var HelpersVolumeRendering = function (_HelpersMaterialMixin) {
  _inherits(HelpersVolumeRendering, _HelpersMaterialMixin);

  function HelpersVolumeRendering(stack) {
    _classCallCheck(this, HelpersVolumeRendering);

    var _this = _possibleConstructorReturn(this, (HelpersVolumeRendering.__proto__ || Object.getPrototypeOf(HelpersVolumeRendering)).call(this));
    //


    _this._stack = stack;
    _this._textures = [];
    _this._shadersFragment = _shadersVr6.default;
    _this._shadersVertex = _shadersVr4.default;
    _this._uniforms = _shadersVr2.default.uniforms();
    _this._material = null;
    _this._geometry = null;

    _this._interpolation = 1; // default to trilinear interpolation

    _this._create();
    return _this;
  }

  _createClass(HelpersVolumeRendering, [{
    key: '_create',
    value: function _create() {
      this._prepareStack();
      this._prepareTexture();
      this._prepareMaterial();
      this._prepareGeometry();

      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this.add(this._mesh);
    }
  }, {
    key: '_prepareStack',
    value: function _prepareStack() {
      if (!this._stack.prepared) {
        this._stack.prepare();
      }

      if (!this._stack.packed) {
        this._stack.pack();
      }
    }
  }, {
    key: '_prepareMaterial',
    value: function _prepareMaterial() {
      // compensate for the offset to only pass > 0 values to shaders
      // models > models.stack.js : _packTo8Bits
      var offset = 0;
      if (this._stack._minMax[0] < 0) {
        offset = this._stack._minMax[0];
      }

      // uniforms
      this._uniforms = _shadersVr2.default.uniforms();
      this._uniforms.uWorldBBox.value = this._stack.worldBoundingBox();
      this._uniforms.uTextureSize.value = this._stack.textureSize;
      this._uniforms.uTextureContainer.value = this._textures;
      this._uniforms.uWorldToData.value = this._stack.lps2IJK;
      this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
      this._uniforms.uPixelType.value = this._stack.pixelType;
      this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
      this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;
      this._uniforms.uWindowCenterWidth.value = [offset + this._stack.windowCenter, this._stack.windowWidth * 0.8];
      this._uniforms.uRescaleSlopeIntercept.value = [this._stack.rescaleSlope, this._stack.rescaleIntercept];
      this._uniforms.uDataDimensions.value = [this._stack.dimensionsIJK.x, this._stack.dimensionsIJK.y, this._stack.dimensionsIJK.z];
      this._uniforms.uInterpolation.value = this._interpolation;

      this._createMaterial({
        side: THREE.FrontSide,
        transparent: true
      });
    }
  }, {
    key: '_prepareGeometry',
    value: function _prepareGeometry() {
      var worldBBox = this._stack.worldBoundingBox();
      var centerLPS = this._stack.worldCenter();

      this._geometry = new THREE.BoxGeometry(worldBBox[1] - worldBBox[0], worldBBox[3] - worldBBox[2], worldBBox[5] - worldBBox[4]);
      this._geometry.applyMatrix(new THREE.Matrix4().makeTranslation(centerLPS.x, centerLPS.y, centerLPS.z));
    }
  }, {
    key: 'uniforms',
    get: function get() {
      return this._uniforms;
    },
    set: function set(uniforms) {
      this._uniforms = uniforms;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    },
    set: function set(stack) {
      this._stack = stack;
    }
  }, {
    key: 'interpolation',
    get: function get() {
      return this._interpolation;
    },
    set: function set(interpolation) {
      this._interpolation = interpolation;
      this._uniforms.uInterpolation.value = this._interpolation;
      this._updateMaterial();
    }
  }]);

  return HelpersVolumeRendering;
}((0, _helpersMaterial2.default)(THREE.Object3D));

exports.default = HelpersVolumeRendering;

},{"../helpers/helpers.material.mixin":115,"../shaders/shaders.vr.fragment":162,"../shaders/shaders.vr.uniform":163,"../shaders/shaders.vr.vertex":164}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/x/interactor
 */
var Interactor = function () {
  function Interactor() {
    _classCallCheck(this, Interactor);
  }

  // private methods


  _createClass(Interactor, [{
    key: "_create",
    value: function _create() {}
  }, {
    key: "_update",
    value: function _update() {}
  }]);

  return Interactor;
}();

exports.default = Interactor;

},{}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpersX = require('./helpers.x.interactor');

var _helpersX2 = _interopRequireDefault(_helpersX);

var _helpersX3 = require('./helpers.x.mesh');

var _helpersX4 = _interopRequireDefault(_helpersX3);

var _helpersX5 = require('./helpers.x.renderer3d');

var _helpersX6 = _interopRequireDefault(_helpersX5);

var _helpersX7 = require('./helpers.x.renderer2d');

var _helpersX8 = _interopRequireDefault(_helpersX7);

var _helpersX9 = require('./helpers.x.volume');

var _helpersX10 = _interopRequireDefault(_helpersX9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module helpers
 */

exports.default = {
  Interactor: _helpersX2.default,
  Mesh: _helpersX4.default,
  Renderer3D: _helpersX6.default,
  Renderer2D: _helpersX8.default,
  Volume: _helpersX10.default
};

},{"./helpers.x.interactor":121,"./helpers.x.mesh":123,"./helpers.x.renderer2d":124,"./helpers.x.renderer3d":125,"./helpers.x.volume":126}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module helpers/x/mesh
 */
var _class = function () {
  function _class() {
    _classCallCheck(this, _class);

    this._file = null;

    this._3jsVTK_loader = new THREE.VTKLoader();
    this._mesh = null;
    this._materialColor = 0xE91E63;
    this._RAStoLPS = null;
    this._material = new THREE.MeshLambertMaterial({
      shading: THREE.SmoothShading,
      color: this._materialColor,
      side: THREE.DoubleSide });
  }

  // accessor properties


  _createClass(_class, [{
    key: "load",


    // load function
    value: function load() {
      var _this = this;

      if (this.file) {
        return new Promise(function (resolve, reject) {
          _this._3jsVTK_loader.load(_this.file, function (geometry) {
            geometry.computeVertexNormals();
            _this._mesh = new THREE.Mesh(geometry, _this._material);
            _this._RAStoLPS = new THREE.Matrix4();
            _this._RAStoLPS.set(-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            _this._mesh.applyMatrix(_this._RAStoLPS);
            // resolve the promise and return the mesh
            resolve(_this._mesh);
          }, function () {}, function (error) {
            console.log(error);
            reject({
              message: "Couldn't load file: " + _this.file + ".",
              error: error
            });
          });
        });
      }

      return Promise.reject({ message: "File is not defined: " + this.file + "." });
    }
  }, {
    key: "file",
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: "materialColor",
    get: function get() {
      return this._materialColor;
    },
    set: function set(color) {
      this._materialColor = color;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module helpers/x/renderer2d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _cameras = require('../../cameras/cameras.orthographic');

var _cameras2 = _interopRequireDefault(_cameras);

var _controls = require('../../controls/controls.trackballortho');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r2d';
    var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._orientation = orientation;
    this._scene = null;
    this._object = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onScroll = this._onScroll.bind(this);
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(object) {
      this._object = object;
      this._scene.add(this._object);

      this._setupCamera(this._object.stack);
      this._orientCamera(this._object, this._orientation);

      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._controls.addEventListener('OnScroll', this._onScroll, false);
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._controls.removeEventListener('OnScroll', this._onScroll, false);
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x212121, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new _cameras2.default(this._container.clientWidth / -2, this._container.clientWidth / 2, this._container.clientHeight / 2, this._container.clientHeight / -2, 1, 1000);
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      this._scene = new THREE.Scene();
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.staticMoving = true;
      this._controls.noRotate = true;
      this._camera.controls = this._controls;
    }
  }, {
    key: '_setupCamera',
    value: function _setupCamera(stack) {
      // set camera
      var worldbb = stack.worldBoundingBox();
      var lpsDims = new THREE.Vector3(worldbb[1] - worldbb[0], worldbb[3] - worldbb[2], worldbb[5] - worldbb[4]);

      // box: {halfDimensions, center}
      var box = {
        center: stack.worldCenter().clone(),
        halfDimensions: new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10)
      };

      // init and zoom
      var canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };

      this._camera.directions = [stack.xCosine, stack.yCosine, stack.zCosine];
      this._camera.box = box;
      this._camera.canvas = canvas;
      this._camera.update();
      this._camera.fitBox(2);
    }
  }, {
    key: '_orientCamera',
    value: function _orientCamera(target) {
      var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._camera.orientation = orientation;
      this._camera.update();
      this._camera.fitBox(2);
      target.orientation = this._camera.stackOrientation;
    }
  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.canvas = {
        width: this._container.clientWidth,
        height: this._container.clientHeight
      };
      this._camera.fitBox(2);
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._object.canvasWidth = this._container.clientWidth;
      this._object.canvasHeight = this._container.clientHeight;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      if (event.delta > 0) {
        if (this._object.index >= this._object.orientationMaxIndex) {
          return false;
        }
        this._object.index += 1;
      } else {
        if (this._object.index <= 0) {
          return false;
        }
        this._object.index -= 1;
      }
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../cameras/cameras.orthographic":97,"../../controls/controls.trackballortho":100}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module helpers/x/renderer3d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _controls = require('../../controls/controls.trackball');

var _controls2 = _interopRequireDefault(_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
  function _class() {
    var containerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'r3d';

    _classCallCheck(this, _class);

    this._container = null;
    this._renderer = null;
    this._camera = null;
    this._controls = null;
    this._scene = null;

    this._initRenderer(containerId);
    this._initCamera();
    this._initScene();
    this._initControls();

    // setup event listeners
    this._onWindowResize = this._onWindowResize.bind(this);
    this.addEventListeners();
  }

  _createClass(_class, [{
    key: 'add',
    value: function add(obj) {
      this._scene.add(obj);
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      window.addEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      window.removeEventListener('resize', this._onWindowResize, false);
    }
  }, {
    key: 'center',
    value: function center(worldPosition) {
      // update camrea's and control's target
      this._camera.lookAt(worldPosition.x, worldPosition.y, worldPosition.z);
      this._camera.updateProjectionMatrix();
      this._controls.target.set(worldPosition.x, worldPosition.y, worldPosition.z);
    }
  }, {
    key: 'animate',
    value: function animate() {
      this._controls.update();
      this._renderer.render(this._scene, this._camera);

      // request new frame
      requestAnimationFrame(this.animate.bind(this));
    }

    // private methods

  }, {
    key: '_onWindowResize',
    value: function _onWindowResize() {
      this._camera.aspect = this._container.clientWidth / this._container.clientHeight;
      this._camera.updateProjectionMatrix();

      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
    }
  }, {
    key: '_initRenderer',
    value: function _initRenderer(containerId) {
      // renderer
      this._container = document.getElementById(containerId);
      this._renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);
      this._renderer.setClearColor(0x424242, 1);
      this._renderer.setPixelRatio(window.devicePixelRatio);
      this._container.appendChild(this._renderer.domElement);
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      this._camera = new THREE.PerspectiveCamera(45, this._container.clientWidth / this._container.clientHeight, 1, 10000000);
      this._camera.position.x = 250;
      this._camera.position.y = 250;
      this._camera.position.z = 250;
    }
  }, {
    key: '_initScene',
    value: function _initScene() {
      // add some lights to the scene by default
      this._scene = new THREE.Scene();

      // ambient
      this._scene.add(new THREE.AmbientLight(0x353535));

      // directional 1
      var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(200, 200, 1000).normalize();
      this._scene.add(directionalLight);

      // directional 2
      var directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight2.position.set(-200, -200, -1000).normalize();
      this._scene.add(directionalLight2);
    }
  }, {
    key: '_initControls',
    value: function _initControls() {
      // controls
      this._controls = new _controls2.default(this._camera, this._container);
      this._controls.rotateSpeed = 1.4;
      this._controls.zoomSpeed = 1.2;
      this._controls.panSpeed = 0.8;
    }
  }, {
    key: 'container',
    set: function set(container) {
      this._container = container;
    },
    get: function get() {
      return this._container;
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"../../controls/controls.trackball":99}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers.stack');

var _helpers2 = _interopRequireDefault(_helpers);

var _loaders = require('../../loaders/loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module helpers/x/volume
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _class = function (_THREE$Object3D) {
  _inherits(_class, _THREE$Object3D);

  function _class() {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

    _this._file = null;
    _this._progressbarContainer = null;
    _this._stack = null;
    _this._centerLPS = null;
    _this._xSlice = null;
    _this._ySlice = null;
    _this._zSlice = null;
    return _this;
  }

  // accessor properties


  _createClass(_class, [{
    key: '_createSlice',


    // private methods
    value: function _createSlice(orientation) {
      if (this._stack) {
        var stackHelper = new _helpers2.default(this._stack);
        stackHelper.orientation = orientation;

        if (orientation === 0) {
          stackHelper.border.color = 0xF44336;
          this._xSlice = stackHelper;
        } else if (orientation === 1) {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x4CAF50;
          this._ySlice = stackHelper;
        } else {
          stackHelper.bbox.visible = false;
          stackHelper.border.color = 0x2196F3;
          this._zSlice = stackHelper;
        }

        this._centerLPS = stackHelper.stack.worldCenter();
      }
    }

    // public methods

  }, {
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this.file) {
        // instantiate the loader
        // it loads and parses the dicom image
        var loader = new _loaders2.default(this._progressbarContainer);
        return loader.load(this.file).then(function () {
          return new Promise(function (resolve, reject) {
            if (loader.data.length <= 0) {
              return reject({ message: 'No data loaded: ' + loader.data + '.' });
            }

            // create the three slices when all files have been loaded
            var series = loader.data[0].mergeSeries(loader.data)[0];
            loader.free();

            _this2._stack = series.stack[0];
            _this2._createSlice(0);
            _this2.add(_this2._xSlice);
            _this2._createSlice(1);
            _this2.add(_this2._ySlice);
            _this2._createSlice(2);
            _this2.add(_this2._zSlice);

            return resolve(_this2);
          });
        }).catch(function (error) {
          loader.free();
          window.console.log('Something went wrong loading the volume...');
          window.console.log(error);
        });
      }

      return Promise.reject({ message: 'File not defined: ' + this.file + '.' });
    }
  }, {
    key: 'file',
    get: function get() {
      return this._file;
    },
    set: function set(fname) {
      this._file = fname;
    }
  }, {
    key: 'progressbarContainer',
    set: function set(container) {
      this._progressbarContainer = container;
    }
  }, {
    key: 'centerLPS',
    get: function get() {
      return this._centerLPS;
    }
  }, {
    key: 'stack',
    get: function get() {
      return this._stack;
    }
  }]);

  return _class;
}(THREE.Object3D);

exports.default = _class;

},{"../../loaders/loaders.volume":129,"../helpers.stack":119}],127:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helpers = require('../helpers/helpers.progressbar');

var _helpers2 = _interopRequireDefault(_helpers);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** Imports **/


/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/base
 * @extends EventEmitter
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersBase = function (_EventEmitter) {
  _inherits(LoadersBase, _EventEmitter);

  /**
   * Create a Loader.
   * @param {dom} container - The dom container of loader.
   * @param {object} ProgressBar - The progressbar of loader.
   */
  function LoadersBase() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var ProgressBar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _helpers2.default;

    _classCallCheck(this, LoadersBase);

    var _this = _possibleConstructorReturn(this, (LoadersBase.__proto__ || Object.getPrototypeOf(LoadersBase)).call(this));

    _this._loaded = -1;
    _this._totalLoaded = -1;
    _this._parsed = -1;
    _this._totalParsed = -1;

    _this._data = [];

    _this._container = container;
    _this._progressBar = null;
    if (_this._container && ProgressBar) {
      _this._progressBar = new ProgressBar(_this._container);
    }
    return _this;
  }

  /**
   * free the reference.
   */


  _createClass(LoadersBase, [{
    key: 'free',
    value: function free() {
      this._container = null;
      // this._helpersProgressBar = null;

      if (this._progressBar) {
        this._progressBar.free();
        this._progressBar = null;
      }
    }

    /**
     * load the resource by url.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'fetch',
    value: function fetch(url) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url);
        request.crossOrigin = true;
        request.responseType = 'arraybuffer';

        request.onloadstart = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-start', {
            file: url,
            time: new Date()
          });
        };

        request.onload = function (event) {
          if (request.status === 200) {
            _this2._loaded = event.loaded;
            _this2._totalLoaded = event.total;

            // will be removed after eventer set up
            if (_this2._progressBar) {
              _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
            }

            var buffer = request.response;
            var response = {
              url: url,
              buffer: buffer
            };

            // emit 'fetch-success' event
            _this2.emit('fetch-success', {
              file: url,
              time: new Date(),
              totalLoaded: event.total
            });

            resolve(response);
          } else {
            reject(request.statusText);
          }
        };

        request.onerror = function () {
          // emit 'fetch-error' event
          _this2.emit('fetch-error', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onabort = function (event) {
          // emit 'fetch-start' event
          _this2.emit('fetch-abort', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.ontimeout = function () {
          // emit 'fetch-timeout' event
          _this2.emit('fetch-timeout', {
            file: url,
            time: new Date()
          });

          reject(request.statusText);
        };

        request.onprogress = function (event) {
          _this2._loaded = event.loaded;
          _this2._totalLoaded = event.total;
          // emit 'fetch-progress' event
          _this2.emit('fetch-progress', {
            file: url,
            total: event.total,
            loaded: event.loaded,
            time: new Date()
          });
          // will be removed after eventer set up
          if (_this2._progressBar) {
            _this2._progressBar.update(_this2._loaded, _this2._totalLoaded, 'load');
          }
        };

        request.onloadend = function (event) {
          // emit 'fetch-end' event
          _this2.emit('fetch-end', {
            file: url,
            time: new Date()
          });
          // just use onload when success and onerror when failure, etc onabort
          // reject(request.statusText);
        };

        request.send();
      });
    }

    /**
     * parse the data loaded
     * SHOULD BE implementd by detail loader.
     * @param {object} response - loaded data.
     * @return {promise} promise.
     */

  }, {
    key: 'parse',
    value: function parse(response) {
      return new Promise(function (resolve, reject) {
        resolve(response);
      });
    }

    /**
     * default load sequence group promise.
     * @param {array} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequenceGroup',
    value: function loadSequenceGroup(url) {
      var _this3 = this;

      var fetchSequence = [];

      url.forEach(function (file) {
        fetchSequence.push(_this3.fetch(file));
      });

      return Promise.all(fetchSequence).then(function (rawdata) {
        return _this3.parse(rawdata);
      }).then(function (data) {
        _this3._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * default load sequence promise.
     * @param {string} url - resource url.
     * @return {promise} promise.
     */

  }, {
    key: 'loadSequence',
    value: function loadSequence(url) {
      var _this4 = this;

      return this.fetch(url).then(function (rawdata) {
        return _this4.parse(rawdata);
      }).then(function (data) {
        _this4._data.push(data);
        return data;
      }).catch(function (error) {
        window.console.log('oops... something went wrong...');
        window.console.log(error);
      });
    }

    /**
     * load the data by url(urls)
     * @param {string|array} url - resource url.
     * @return {promise} promise
     */

  }, {
    key: 'load',
    value: function load(url) {
      var _this5 = this;

      // if we load a single file, convert it to an array
      if (!Array.isArray(url)) {
        url = [url];
      }

      // emit 'load-start' event
      this.emit('load-start', {
        files: url,
        time: new Date()
      });

      var loadSequences = [];
      url.forEach(function (file) {
        if (!Array.isArray(file)) {
          loadSequences.push(_this5.loadSequence(file));
        } else {
          loadSequences.push(_this5.loadSequenceGroup(file));
        }
      });
      return Promise.all(loadSequences);
    }

    /**
     * Set data
     * @param {array} data
     */

  }, {
    key: 'data',
    set: function set(data) {
      this._data = data;
    }

    /**
     * Get data
     * @return {array} data loaded
     */
    ,
    get: function get() {
      return this._data;
    }
  }]);

  return LoadersBase;
}(_events2.default);

exports.default = LoadersBase;

},{"../helpers/helpers.progressbar":117,"events":26}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loaders = require('./loaders.volume');

var _loaders2 = _interopRequireDefault(_loaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module loaders
 */

exports.default = {
  Volume: _loaders2.default
};

},{"./loaders.volume":129}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _loaders = require('./loaders.base');

var _loaders2 = _interopRequireDefault(_loaders);

var _core = require('../core/core.utils');

var _core2 = _interopRequireDefault(_core);

var _models = require('../models/models.series');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('../models/models.frame');

var _models6 = _interopRequireDefault(_models5);

var _parsers = require('../parsers/parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('../parsers/parsers.mhd');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('../parsers/parsers.nifti');

var _parsers6 = _interopRequireDefault(_parsers5);

var _parsers7 = require('../parsers/parsers.nrrd');

var _parsers8 = _interopRequireDefault(_parsers7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** * Imports ***/
var PAKO = require('pako');

/**
 *
 * It is typically used to load a DICOM image. Use loading manager for
 * advanced usage, such as multiple files handling.
 *
 * Demo: {@link https://fnndsc.github.io/vjs#loader_dicom}
 *
 * @module loaders/volumes
 * @extends LoadersBase
 * @example
 * var files = ['/data/dcm/fruit'];
 *
 * // Instantiate a dicom loader
 * var lDicomoader = new dicom();
 *
 * // load a resource
 * loader.load(
 *   // resource URL
 *   files[0],
 *   // Function when resource is loaded
 *   function(object) {
 *     //scene.add( object );
 *     window.console.log(object);
 *   }
 * );
 */
var LoadersVolumes = function (_LoadersBase) {
  _inherits(LoadersVolumes, _LoadersBase);

  function LoadersVolumes() {
    _classCallCheck(this, LoadersVolumes);

    return _possibleConstructorReturn(this, (LoadersVolumes.__proto__ || Object.getPrototypeOf(LoadersVolumes)).apply(this, arguments));
  }

  _createClass(LoadersVolumes, [{
    key: 'parse',


    /**
     * Parse response.
     * response is formated as:
     *    {
     *      url: 'resource url',
     *      buffer: xmlresponse,
     *    }
     * @param {object} response - response
     * @return {promise} promise
     */
    value: function parse(response) {
      var _this2 = this;

      // emit 'parse-start' event
      this.emit('parse-start', {
        file: response.url,
        time: new Date()
      });
      // give a chance to the UI to update because
      // after the rendering will be blocked with intensive JS
      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(0, 100, 'parse');
      }

      return new Promise(function (resolve, reject) {
        window.setTimeout(function () {
          resolve(new Promise(function (resolve, reject) {
            var data = response;

            if (!Array.isArray(data)) {
              data = [data];
            }

            data.forEach(function (dataset) {
              _this2._preprocess(dataset);
            });

            if (data.length === 1) {
              data = data[0];
            } else {
              // if raw/mhd pair
              var mhdFile = data.filter(_this2._filterByExtension.bind(null, 'MHD'));
              var rawFile = data.filter(_this2._filterByExtension.bind(null, 'RAW'));
              if (data.length === 2 && mhdFile.length === 1 && rawFile.length === 1) {
                data.url = mhdFile[0].url;
                data.extension = mhdFile[0].extension;
                data.mhdBuffer = mhdFile[0].buffer;
                data.rawBuffer = rawFile[0].buffer;
              }
            }

            var Parser = _this2._parser(data.extension);
            if (!Parser) {
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: data.filename + 'can not be parsed.'
              });
              reject(data.filename + ' can not be parsed.');
            }

            // check extension
            var volumeParser = null;
            try {
              volumeParser = new Parser(data, 0);
            } catch (e) {
              window.console.log(e);
              // emit 'parse-error' event
              _this2.emit('parse-error', {
                file: response.url,
                time: new Date(),
                error: e
              });
              reject(e);
            }

            // create a series
            var series = new _models2.default();
            // global information
            series.seriesInstanceUID = volumeParser.seriesInstanceUID();
            series.transferSyntaxUID = volumeParser.transferSyntaxUID();
            series.seriesDescription = volumeParser.seriesDescription();
            series.studyDescription = volumeParser.studyDescription();
            series.numberOfFrames = volumeParser.numberOfFrames();
            if (!series.numberOfFrames) {
              series.numberOfFrames = 1;
            }
            series.numberOfChannels = volumeParser.numberOfChannels();
            series.modality = volumeParser.modality();
            // if it is a segmentation, attach extra information
            if (series.modality === 'SEG') {
              // colors
              // labels
              // etc.
              series.segmentationType = volumeParser.segmentationType();
              series.segmentationSegments = volumeParser.segmentationSegments();
            }
            // patient information
            series.patientID = volumeParser.patientID();
            series.patientName = volumeParser.patientName();
            series.patientAge = volumeParser.patientAge();
            series.patientBirthdate = volumeParser.patientBirthdate();
            series.patientSex = volumeParser.patientSex();

            // just create 1 dummy stack for now
            var stack = new _models4.default();
            stack.numberOfChannels = volumeParser.numberOfChannels();
            stack.pixelRepresentation = volumeParser.pixelRepresentation();
            stack.pixelType = volumeParser.pixelType();
            stack.invert = volumeParser.invert();
            stack.spacingBetweenSlices = volumeParser.spacingBetweenSlices();
            stack.modality = series.modality;
            // if it is a segmentation, attach extra information
            if (stack.modality === 'SEG') {
              // colors
              // labels
              // etc.
              stack.segmentationType = series.segmentationType;
              stack.segmentationSegments = series.segmentationSegments;
            }
            series.stack.push(stack);
            // recursive call for each frame
            // better than for loop to be able
            // to update dom with "progress" callback
            setTimeout(_this2.parseFrame(series, stack, response.url, 0, volumeParser, resolve, reject), 0);
          }));
        }, 10);
      });
    }

    /**
     * recursive parse frame
     * @param {ModelsSeries} series - data series
     * @param {ModelsStack} stack - data stack
     * @param {string} url - resource url
     * @param {number} i - frame index
     * @param {parser} dataParser - selected parser
     * @param {promise.resolve} resolve - promise resolve args
     * @param {promise.reject} reject - promise reject args
     */

  }, {
    key: 'parseFrame',
    value: function parseFrame(series, stack, url, i, dataParser, resolve, reject) {
      var frame = new _models6.default();
      frame.sopInstanceUID = dataParser.sopInstanceUID(i);
      frame.url = url;
      frame.index = i;
      frame.rows = dataParser.rows(i);
      frame.columns = dataParser.columns(i);
      frame.numberOfChannels = stack.numberOfChannels;
      frame.pixelRepresentation = stack.pixelRepresentation;
      frame.pixelType = stack.pixelType;
      frame.pixelData = dataParser.extractPixelData(i);
      frame.pixelSpacing = dataParser.pixelSpacing(i);
      frame.spacingBetweenSlices = dataParser.spacingBetweenSlices(i);
      frame.sliceThickness = dataParser.sliceThickness(i);
      frame.imageOrientation = dataParser.imageOrientation(i);
      frame.rightHanded = dataParser.rightHanded();
      stack.rightHanded = frame.rightHanded;
      if (frame.imageOrientation === null) {
        frame.imageOrientation = [1, 0, 0, 0, 1, 0];
      }
      frame.imagePosition = dataParser.imagePosition(i);
      if (frame.imagePosition === null) {
        frame.imagePosition = [0, 0, i];
      }
      frame.dimensionIndexValues = dataParser.dimensionIndexValues(i);
      frame.bitsAllocated = dataParser.bitsAllocated(i);
      frame.instanceNumber = dataParser.instanceNumber(i);
      frame.windowCenter = dataParser.windowCenter(i);
      frame.windowWidth = dataParser.windowWidth(i);
      frame.rescaleSlope = dataParser.rescaleSlope(i);
      frame.rescaleIntercept = dataParser.rescaleIntercept(i);
      // should pass frame index for consistency...
      frame.minMax = dataParser.minMaxPixelData(frame.pixelData);

      // if series.mo
      if (series.modality === 'SEG') {
        frame.referencedSegmentNumber = dataParser.referencedSegmentNumber(i);
      }

      stack.frame.push(frame);

      // update status
      this._parsed = i + 1;
      this._totalParsed = series.numberOfFrames;

      // will be removed after eventer set up
      if (this._progressBar) {
        this._progressBar.update(this._parsed, this._totalParsed, 'parse');
      }

      // emit 'parsing' event
      this.emit('parsing', {
        file: url,
        total: this._totalParsed,
        parsed: this._parsed,
        time: new Date()
      });

      if (this._parsed === this._totalParsed) {
        // emit 'parse-success' event
        this.emit('parse-success', {
          file: url,
          total: this._totalParsed,
          parsed: this._parsed,
          time: new Date()
        });

        resolve(series);
      } else {
        setTimeout(this.parseFrame(series, stack, url, this._parsed, dataParser, resolve, reject), 0);
      }
    }

    /**
     * Return parser given an extension
     * @param {string} extension - extension
     * @return {parser} selected parser
     */

  }, {
    key: '_parser',
    value: function _parser(extension) {
      var Parser = null;

      switch (extension.toUpperCase()) {
        case 'NII':
        case 'NII_':
          Parser = _parsers6.default;
          break;
        case 'DCM':
        case 'DICOM':
        case 'IMA':
        case '':
          Parser = _parsers2.default;
          break;
        case 'MHD':
          Parser = _parsers4.default;
          break;
        case 'NRRD':
          Parser = _parsers8.default;
          break;
        default:
          window.console.log('unsupported extension: ' + extension);
          return false;
      }
      return Parser;
    }

    /**
     * Pre-process data to be parsed (find data type and de-compress)
     * @param {*} data
     */

  }, {
    key: '_preprocess',
    value: function _preprocess(data) {
      var parsedUrl = _core2.default.parseUrl(data.url);
      // update data
      data.filename = parsedUrl.filename;
      data.extension = parsedUrl.extension;
      data.pathname = parsedUrl.pathname;
      data.query = parsedUrl.query;

      // unzip if extension is '.gz'
      if (data.extension === 'gz') {
        data.gzcompressed = true;
        data.extension = data.filename.split('.gz').shift().split('.').pop();
        var decompressedData = PAKO.inflate(data.buffer);
        data.buffer = decompressedData.buffer;
      } else {
        data.gzcompressed = false;
      }
    }

    /**
     * Filter data by extension
     * @param {*} extension
     * @param {*} item
     * @returns Boolean
     */

  }, {
    key: '_filterByExtension',
    value: function _filterByExtension(extension, item) {
      if (item.extension.toUpperCase() === extension.toUpperCase()) {
        return true;
      }
      return false;
    }
  }]);

  return LoadersVolumes;
}(_loaders2.default);

exports.default = LoadersVolumes;

},{"../core/core.utils":105,"../models/models.frame":131,"../models/models.series":133,"../models/models.stack":134,"../parsers/parsers.dicom":136,"../parsers/parsers.mhd":138,"../parsers/parsers.nifti":139,"../parsers/parsers.nrrd":140,"./loaders.base":127,"pako":51}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base object.
 *
 * @module models/base
 */

var ModelsBase = function () {
  function ModelsBase() {
    _classCallCheck(this, ModelsBase);

    this._id = -1;
  }
  /**
   * Merge 2 arrays of models.
   * Merge the target array into the reference array.
   *
   * @param {Array.<Models>} referenceArray - Array to be merge against
   * @param {Array.<Models>} targetArray - Array to be merged against reference.
   *
   * @return {boolean} True if merge was sucessful. False if something went wrong.
   */


  _createClass(ModelsBase, [{
    key: 'mergeModels',
    value: function mergeModels(referenceArray, targetArray) {
      if (!(this._validateModelArray(referenceArray) && this._validateModelArray(targetArray))) {
        window.console.log('invalid inputs provided.');
        return false;
      }

      for (var i = 0; i < targetArray.length; i++) {
        // test targetArray against existing targetArray
        for (var j = 0; j < referenceArray.length; j++) {
          if (referenceArray[j].merge(targetArray[i])) {
            // merged successfully
            break;
          } else if (j === referenceArray.length - 1) {
            // last merge was not successful
            // this is a new targetArray
            referenceArray.push(targetArray[i]);
          }
        }
      }

      return true;
    }

    /**
     * Merge model against current model.
     */

  }, {
    key: 'merge',
    value: function merge(model) {
      // make sure model is valid
      if (!this.validate(model)) {
        return false;
      }

      // they can be merged if they match
      if (this._id === model._id) {
        return true;
      }
      return false;
    }

    /**
     * Validate a model.
     *
     * @return {boolean} True if model is valid. False if not.
     */

  }, {
    key: 'validate',
    value: function validate(model) {
      if (!(model && model !== null && typeof model.merge === 'function')) {
        return false;
      }

      return true;
    }

    /**
     * Validate array of models.
     *
     * @param {Array.<Models>} modelArray - Array containing models.
     *
     * @return {boolean} True if array is valid. False if not.
     */

  }, {
    key: '_validateModelArray',
    value: function _validateModelArray(modelArray) {
      if (!(modelArray !== null && Array === modelArray.constructor)) {
        window.console.log('invalid model array provided.');
        return false;
      }

      for (var i = 0; i < modelArray.length; i++) {
        if (!(modelArray[i] && modelArray[i] !== null && typeof modelArray[i].validate === 'function' && modelArray[i].validate(modelArray[i]))) {
          return false;
        }
      }

      return true;
    }
  }]);

  return ModelsBase;
}();

exports.default = ModelsBase;

},{}],131:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Frame object.
 *
 * @module models/frame
 */
var ModelsFrame = function (_ModelsBase) {
  _inherits(ModelsFrame, _ModelsBase);

  /**
   * Constructor
   */
  function ModelsFrame() {
    _classCallCheck(this, ModelsFrame);

    var _this = _possibleConstructorReturn(this, (ModelsFrame.__proto__ || Object.getPrototypeOf(ModelsFrame)).call(this));

    _this._sopInstanceUID = null;
    _this._url = null;
    _this._stackID = -1;
    _this._rows = 0;
    _this._columns = 0;
    _this._dimensionIndexValues = [];
    _this._imagePosition = null;
    _this._imageOrientation = null;
    _this._rightHanded = true;
    _this._sliceThickness = 1;
    _this._spacingBetweenSlices = null;
    _this._pixelRepresentation = 0;
    _this._pixelType = 0;
    _this._pixelSpacing = null;
    _this._pixelAspectRatio = null;
    _this._pixelData = null;

    _this._instanceNumber = null;
    _this._windowCenter = null;
    _this._windowWidth = null;
    _this._rescaleSlope = null;
    _this._rescaleIntercept = null;

    _this._bitsAllocated = 8;

    _this._minMax = null;
    _this._dist = null;

    _this._index = -1;

    _this._referencedSegmentNumber = -1;
    return _this;
  }

  /**
   * Validate the frame.
   *
   * @param {*} model
   *
   * @return {*}
   */


  _createClass(ModelsFrame, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsFrame.prototype.__proto__ || Object.getPrototypeOf(ModelsFrame.prototype), 'validate', this).call(this, model) && typeof model.cosines === 'function' && typeof model.spacingXY === 'function' && model.hasOwnProperty('_sopInstanceUID') && model.hasOwnProperty('_dimensionIndexValues') && model.hasOwnProperty('_imageOrientation') && model.hasOwnProperty('_imagePosition'))) {
        return false;
      }

      return true;
    }

    /**
     * Merge current frame with provided frame.
     *
     * Frames can be merged (i.e. are identical) if following are equals:
     *  - dimensionIndexValues
     *  - imageOrientation
     *  - imagePosition
     *  - instanceNumber
     *  - sopInstanceUID
     *
     * @param {*} frame
     *
     * @return {boolean} True if frames could be merge. False if not.
     */

  }, {
    key: 'merge',
    value: function merge(frame) {
      if (!this.validate(frame)) {
        return false;
      }

      if (this._compareArrays(this._dimensionIndexValues, frame.dimensionIndexValues) && this._compareArrays(this._imageOrientation, frame.imageOrientation) && this._compareArrays(this._imagePosition, frame.imagePosition) && this._instanceNumber === frame.instanceNumber && this._sopInstanceUID === frame.sopInstanceUID) {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Generate X, y and Z cosines from image orientation
     * Returns default orientation if _imageOrientation was invalid.
     *
     * @returns {array} Array[3] containing cosinesX, Y and Z.
     */

  }, {
    key: 'cosines',
    value: function cosines() {
      var cosines = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];

      if (this._imageOrientation && this._imageOrientation.length === 6) {
        var xCos = new THREE.Vector3(this._imageOrientation[0], this._imageOrientation[1], this._imageOrientation[2]);
        var yCos = new THREE.Vector3(this._imageOrientation[3], this._imageOrientation[4], this._imageOrientation[5]);

        if (xCos.length() > 0 && yCos.length() > 0) {
          cosines[0] = xCos;
          cosines[1] = yCos;
          cosines[2] = new THREE.Vector3(0, 0, 0).crossVectors(cosines[0], cosines[1]).normalize();
        }
      } else {
        window.console.log('No valid image orientation for frame');
        window.console.log(this);
        window.console.log('Returning default orientation.');
      }

      if (!this._rightHanded) {
        cosines[2].negate();
      }

      return cosines;
    }

    /**
     * Get x/y spacing of a frame.
     *
     * @return {*}
     */

  }, {
    key: 'spacingXY',
    value: function spacingXY() {
      var spacingXY = [1.0, 1.0];

      if (this.pixelSpacing) {
        spacingXY[0] = this.pixelSpacing[0];

        spacingXY[1] = this.pixelSpacing[1];
      } else if (this.pixelAspectRatio) {
        spacingXY[0] = 1.0;
        spacingXY[1] = 1.0 * this.pixelAspectRatio[1] / this.pixelAspectRatio[0];
      }

      return spacingXY;
    }

    /**
     * Get data value
     *
     * @param {*} column
     * @param {*} row
     *
     * @return {*}
     */

  }, {
    key: 'value',
    value: function value(column, row) {
      return this.pixelData[column + this._columns * row];
    }

    /**
     * Compare 2 arrays.
     *
     * 2 null arrays return true.
     * Do no perform strict type checking.
     *
     * @param {*} reference
     * @param {*} target
     *
     * @return {boolean} True if arrays are identicals. False if not.
     */

  }, {
    key: '_compareArrays',
    value: function _compareArrays(reference, target) {
      // could both be null
      if (reference === target) {
        return true;
      }

      // if not null....
      if (reference && target && reference.join() === target.join()) {
        return true;
      }

      return false;
    }
  }, {
    key: 'rows',
    get: function get() {
      return this._rows;
    },
    set: function set(rows) {
      this._rows = rows;
    }
  }, {
    key: 'columns',
    get: function get() {
      return this._columns;
    },
    set: function set(columns) {
      this._columns = columns;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'sliceThickness',
    get: function get() {
      return this._sliceThickness;
    },
    set: function set(sliceThickness) {
      this._sliceThickness = sliceThickness;
    }
  }, {
    key: 'imagePosition',
    get: function get() {
      return this._imagePosition;
    },
    set: function set(imagePosition) {
      this._imagePosition = imagePosition;
    }
  }, {
    key: 'imageOrientation',
    get: function get() {
      return this._imageOrientation;
    },
    set: function set(imageOrientation) {
      this._imageOrientation = imageOrientation;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'bitsAllocated',
    get: function get() {
      return this._bitsAllocated;
    },
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    }
  }, {
    key: 'dist',
    get: function get() {
      return this._dist;
    },
    set: function set(dist) {
      this._dist = dist;
    }
  }, {
    key: 'pixelSpacing',
    get: function get() {
      return this._pixelSpacing;
    },
    set: function set(pixelSpacing) {
      this._pixelSpacing = pixelSpacing;
    }
  }, {
    key: 'pixelAspectRatio',
    get: function get() {
      return this._pixelAspectRatio;
    },
    set: function set(pixelAspectRatio) {
      this._pixelAspectRatio = pixelAspectRatio;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'dimensionIndexValues',
    get: function get() {
      return this._dimensionIndexValues;
    },
    set: function set(dimensionIndexValues) {
      this._dimensionIndexValues = dimensionIndexValues;
    }
  }, {
    key: 'instanceNumber',
    get: function get() {
      return this._instanceNumber;
    },
    set: function set(instanceNumber) {
      this._instanceNumber = instanceNumber;
    }
  }, {
    key: 'pixelData',
    get: function get() {
      return this._pixelData;
    },
    set: function set(pixelData) {
      this._pixelData = pixelData;
    }
  }, {
    key: 'sopInstanceUID',
    set: function set(sopInstanceUID) {
      this._sopInstanceUID = sopInstanceUID;
    },
    get: function get() {
      return this._sopInstanceUID;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'url',
    get: function get() {
      return this._url;
    },
    set: function set(url) {
      this._url = url;
    }
  }, {
    key: 'referencedSegmentNumber',
    get: function get() {
      return this._referencedSegmentNumber;
    },
    set: function set(referencedSegmentNumber) {
      this._referencedSegmentNumber = referencedSegmentNumber;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    },
    set: function set(index) {
      this._index = index;
    }
  }]);

  return ModelsFrame;
}(_models2.default);

exports.default = ModelsFrame;

},{"../models/models.base":130}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _models = require('./models.frame');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('./models.stack');

var _models4 = _interopRequireDefault(_models3);

var _models5 = require('./models.series');

var _models6 = _interopRequireDefault(_models5);

var _models7 = require('./models.voxel');

var _models8 = _interopRequireDefault(_models7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module models
 */

exports.default = {
  Frame: _models2.default,
  Stack: _models4.default,
  Series: _models6.default,
  Voxel: _models8.default
};

},{"./models.frame":131,"./models.series":133,"./models.stack":134,"./models.voxel":135}],133:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * Series object.
 *
 * @module models/series
 */
var ModelsSeries = function (_ModelsBase) {
  _inherits(ModelsSeries, _ModelsBase);

  /**
   * Models series constructor
   */
  function ModelsSeries() {
    _classCallCheck(this, ModelsSeries);

    var _this = _possibleConstructorReturn(this, (ModelsSeries.__proto__ || Object.getPrototypeOf(ModelsSeries)).call(this));

    _this._concatenationUID = -1;
    _this._seriesInstanceUID = -1;
    _this._transferSyntaxUID = '';
    _this._seriesNumber = -1;
    _this._seriesDescription = '';
    _this._studyDescription = '';
    _this._modality = 'Modality not set';
    _this._dimensionIndexSequence = [];
    // it is used in the loader in case a dicom/nifti contains multiple frames
    // should be updated after merge or renamed
    _this._numberOfFrames = 0;
    _this._numberOfChannels = 1;

    // patient information
    _this._patientID = '';
    _this._patientName = '';
    _this._patientAge = '';
    _this._patientBirthdate = '';
    _this._patientSex = '';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];

    // STACK
    _this._stack = [];
    return _this;
  }

  /**
   * Validate a series.
   *
   * Requirements:
   *   - mergeSeries method
   *   - _seriesInstanceUID
   *   - _numberOfFrames
   *   - _numberOfChannels
   *   _ _stack
   *
   * @param {ModelsSeries} model - Model to be validated as series.
   *
   * @return {boolean} True if series is valid. False if not.
   *
   * @override
   */


  _createClass(ModelsSeries, [{
    key: 'validate',
    value: function validate(model) {
      if (!(_get(ModelsSeries.prototype.__proto__ || Object.getPrototypeOf(ModelsSeries.prototype), 'validate', this).call(this, model) && typeof model.mergeSeries === 'function' && model.hasOwnProperty('_seriesInstanceUID') && model.hasOwnProperty('_numberOfFrames') && model.hasOwnProperty('_numberOfChannels') && model.hasOwnProperty('_stack') && typeof model._stack !== 'undefined' && Array === model._stack.constructor)) {
        return false;
      }

      return true;
    }

    /**
     * Merge current series with provided series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {ModelsSeries} series - Series to be merged against current series.
     *
     * @return {boolean} True if series could be merge. False if not.
     *
     * @override
     */

  }, {
    key: 'merge',
    value: function merge(series) {
      if (!this.validate(series)) {
        return false;
      }

      if (this._seriesInstanceUID === series.seriesInstanceUID) {
        return this.mergeModels(this._stack, series.stack);
      } else {
        return false;
      }
    }

    /**
     * Merge current series with provided array of series.
     * 2 series can ONLY be merge if they have the same SeriesInstanceUID.
     *
     * Also merges the stacks inside a series.
     *
     * @param {Array.<ModelsSeries>} target - Series to be merged against current series.
     *
     * @return {Array.<ModelsSeries>} Array of series properly merged.
     */

  }, {
    key: 'mergeSeries',
    value: function mergeSeries(target) {
      var seriesContainer = [this];
      this.mergeModels(seriesContainer, target);
      return seriesContainer;
    }

    /**
     * Series instance UID setter
     *
     * @param {*} seriesInstanceUID
     */

  }, {
    key: 'seriesInstanceUID',
    set: function set(seriesInstanceUID) {
      this._seriesInstanceUID = seriesInstanceUID;
    }

    /**
     * Series instace UID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._seriesInstanceUID;
    }

    /**
     * Transfer syntax UID setter
     *
     * @param {*} transferSyntaxUID
     */

  }, {
    key: 'transferSyntaxUID',
    set: function set(transferSyntaxUID) {
      this._transferSyntaxUID = transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._transferSyntaxUID;
    }

    /**
     * Transfer syntax UID getter
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUIDLabel',
    get: function get() {
      switch (this._transferSyntaxUID) {
        case '1.2.840.10008.1.2.4.90':
          return 'JPEG 2000 Lossless';
        case '1.2.840.10008.1.2.4.91':
          return 'JPEG 2000 Lossy';
        case '1.2.840.10008.1.2.4.57':
          return 'JPEG Lossless, Nonhierarchical (Processes 14)';
        case '1.2.840.10008.1.2.4.70':
          return 'JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])';
        case '1.2.840.10008.1.2.4.50':
          return 'JPEG Baseline lossy process 1 (8 bit)';
        case '1.2.840.10008.1.2.4.51':
          return 'JPEG Baseline lossy process 2 & 4 (12 bit)';
        case '1.2.840.10008.1.2':
          return 'Implicit VR Little Endian';
        case '1.2.840.10008.1.2.1':
          return 'Explicit VR Little Endian';
        case '1.2.840.10008.1.2.2':
          return 'Explicit VR Big Endian';
        default:
          return 'Unknown transfersyntax: ' + this._transferSyntaxUID;
      }
    }

    /**
     * Study descripition setter
     *
     * @param {*} studyDescription
     */

  }, {
    key: 'studyDescription',
    set: function set(studyDescription) {
      this._studyDescription = studyDescription;
    }

    /**
     * Study description getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._studyDescription;
    }

    /**
     * Series descripition setter
     *
     * @param {*} seriesDescription
     */

  }, {
    key: 'seriesDescription',
    set: function set(seriesDescription) {
      this._seriesDescription = seriesDescription;
    }

    /**
     * Series description getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._seriesDescription;
    }

    /**
     * Patient ID setter
     *
     * @param {*} patientID
     */

  }, {
    key: 'patientID',
    set: function set(patientID) {
      this._patientID = patientID;
    }

    /**
     * Patient ID getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientID;
    }

    /**
     * Patient name setter
     *
     * @param {*} patientName
     */

  }, {
    key: 'patientName',
    set: function set(patientName) {
      this._patientName = patientName;
    }

    /**
     * Patient name getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientName;
    }

    /**
     * Patient age setter
     *
     * @param {*} patientAge
     */

  }, {
    key: 'patientAge',
    set: function set(patientAge) {
      this._patientAge = patientAge;
    }

    /**
     * Patient age getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientAge;
    }

    /**
     * Patient birthdate setter
     *
     * @param {*} patientBirthdate
     */

  }, {
    key: 'patientBirthdate',
    set: function set(patientBirthdate) {
      this._patientBirthdate = patientBirthdate;
    }

    /**
     * Patient birthdate getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientBirthdate;
    }

    /**
     * Patient sex setter
     *
     * @param {*} patientSex
     */

  }, {
    key: 'patientSex',
    set: function set(patientSex) {
      this._patientSex = patientSex;
    }

    /**
     * Patient sex getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._patientSex;
    }

    /**
     * Number of frames setter
     *
     * @param {*} numberOfFrames
     */

  }, {
    key: 'numberOfFrames',
    set: function set(numberOfFrames) {
      this._numberOfFrames = numberOfFrames;
    }

    /**
     * Number of frames getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._numberOfFrames;
    }

    /**
     * Number of channels setter
     *
     * @param {*} numberOfChannels
     */

  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    }

    /**
     * Number of channels getter
     *
     * @return {*}
     */
    ,
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'stack',
    set: function set(stack) {
      this._stack = stack;
    },
    get: function get() {
      return this._stack;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }]);

  return ModelsSeries;
}(_models2.default);

exports.default = ModelsSeries;

},{"../models/models.base":130}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = require('../core/core.colors');

var _core2 = _interopRequireDefault(_core);

var _core3 = require('../core/core.utils');

var _core4 = _interopRequireDefault(_core3);

var _models = require('../models/models.base');

var _models2 = _interopRequireDefault(_models);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


var binaryString = require('math-float32-to-binary-string');

/**
 * Stack object.
 *
 * @module models/stack
 */

var ModelsStack = function (_ModelsBase) {
  _inherits(ModelsStack, _ModelsBase);

  /**
   * Models Stack constructor
   */
  function ModelsStack() {
    _classCallCheck(this, ModelsStack);

    var _this = _possibleConstructorReturn(this, (ModelsStack.__proto__ || Object.getPrototypeOf(ModelsStack)).call(this));

    _this._uid = null;
    _this._stackID = -1;

    _this._frame = [];
    _this._numberOfFrames = 0;

    _this._rows = 0;
    _this._columns = 0;
    _this._numberOfChannels = 1;
    _this._bitsAllocated = 8;
    _this._pixelType = 0;
    _this._pixelRepresentation = 0;

    _this._textureSize = 4096;
    _this._nbTextures = 7;
    _this._rawData = [];

    _this._windowCenter = 0;
    _this._windowWidth = 0;

    _this._rescaleSlope = 1;
    _this._rescaleIntercept = 0;

    _this._minMax = [65535, -32768];

    // TRANSFORMATION MATRICES
    _this._regMatrix = new THREE.Matrix4();

    _this._ijk2LPS = null;
    _this._lps2IJK = null;

    _this._aabb2LPS = null;
    _this._lps2AABB = null;

    //
    // IJK dimensions
    _this._dimensionsIJK = null;
    _this._halfDimensionsIJK = null;
    _this._spacing = new THREE.Vector3(1, 1, 1);
    _this._spacingBetweenSlices = 0;
    _this._sliceThickness = 0;
    _this._origin = null;
    _this._rightHanded = true;
    _this._xCosine = new THREE.Vector3(1, 0, 0);
    _this._yCosine = new THREE.Vector3(0, 1, 0);
    _this._zCosine = new THREE.Vector3(0, 0, 1);

    // convenience vars
    _this._prepared = false;
    _this._packed = false;
    _this._packedPerPixel = 1;

    //
    _this._modality = 'Modality not set';

    // SEGMENTATION STUFF
    _this._segmentationType = null;
    _this._segmentationSegments = [];
    _this._segmentationDefaultColor = [63, 174, 128];
    _this._frameSegment = [];
    _this._segmentationLUT = [];
    _this._segmentationLUTO = [];

    // photometricInterpretation Monochrome1 VS Monochrome2
    _this._invert = false;
    return _this;
  }

  /**
   * Prepare segmentation stack.
   * A segmentation stack can hold x frames that are at the same location
   * but segmentation specific information:
   * - Frame X contains voxels for segmentation A.
   * - Frame Y contains voxels for segmenttation B.
   * - Frame X and Y are at the same location.
   *
   * We currently merge overlaping frames into 1.
   */


  _createClass(ModelsStack, [{
    key: 'prepareSegmentation',
    value: function prepareSegmentation() {
      // store frame and do special pre-processing
      this._frameSegment = this._frame;
      var mergedFrames = [];

      // order frames
      this.computeCosines();
      this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
      this._frame.sort(this._sortDistanceArraySort);

      // merge frames
      var prevIndex = -1;
      for (var i = 0; i < this._frame.length; i++) {
        if (!mergedFrames[prevIndex] || mergedFrames[prevIndex]._dist != this._frame[i]._dist) {
          mergedFrames.push(this._frame[i]);
          prevIndex++;

          // Scale frame
          // by default each frame contains binary data about a segmentation.
          // we scale it by the referenceSegmentNumber in order to have a
          // segmentation specific voxel value rather than 0 or 1.
          // That allows us to merge frames later on.
          // If we merge frames without scaling, then we can not differenciate
          // voxels from segmentation A or B as the value is 0 or 1 in both cases.
          for (var k = 0; k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; k++) {
            mergedFrames[prevIndex]._pixelData[k] *= this._frame[i]._referencedSegmentNumber;
          }
        } else {
          // frame already exsits at this location.
          // merge data from this segmentation into existing frame
          for (var _k = 0; _k < mergedFrames[prevIndex]._rows * mergedFrames[prevIndex]._columns; _k++) {
            mergedFrames[prevIndex]._pixelData[_k] += this._frame[i].pixelData[_k] * this._frame[i]._referencedSegmentNumber;
          }
        }

        mergedFrames[prevIndex].minMax = _core4.default.minMax(mergedFrames[prevIndex]._pixelData);
      }

      // get information about segments
      var dict = {};
      var max = 0;
      for (var _i = 0; _i < this._segmentationSegments.length; _i++) {
        max = Math.max(max, parseInt(this._segmentationSegments[_i].segmentNumber, 10));

        var color = this._segmentationSegments[_i].recommendedDisplayCIELab;
        if (color === null) {
          dict[this._segmentationSegments[_i].segmentNumber] = this._segmentationDefaultColor;
        } else {
          dict[this._segmentationSegments[_i].segmentNumber] = _core2.default.cielab2RGB.apply(_core2.default, _toConsumableArray(color));
        }
      }

      // generate LUTs
      for (var _i2 = 0; _i2 <= max; _i2++) {
        var index = _i2 / max;
        var opacity = _i2 ? 1 : 0;
        var rgb = [0, 0, 0];
        if (dict.hasOwnProperty(_i2.toString())) {
          rgb = dict[_i2.toString()];
        }

        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;

        this._segmentationLUT.push([index].concat(_toConsumableArray(rgb)));
        this._segmentationLUTO.push([index, opacity]);
      }

      this._frame = mergedFrames;
    }

    /**
     * Compute cosines
     * Order frames
     * computeSpacing
     * sanityCheck
     * init some vars
     * compute min/max
     * compute transformation matrices
     *
     * @return {*}
     */

  }, {
    key: 'prepare',
    value: function prepare() {
      // if segmentation, merge some frames...
      if (this._modality === 'SEG') {
        this.prepareSegmentation();
      }

      // we need at least 1 frame
      if (this._frame && this._frame.length > 0) {
        this._numberOfFrames = this._frame.length;
      } else {
        window.console.log('_frame doesn\'t contain anything....');
        window.console.log(this._frame);
        return false;
      }

      // pass parameters from frame to stack
      this._rows = this._frame[0].rows;
      this._columns = this._frame[0].columns;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
      this._spacingBetweenSlices = this._frame[0].spacingBetweenSlices;
      this._sliceThickness = this._frame[0].sliceThickness;

      // compute direction cosines
      this.computeCosines();

      // order the frames
      this.orderFrames();

      // compute/guess spacing
      this.computeSpacing();
      // set extra vars if nulls
      // do it now because before we would think image position/orientation
      // are defined and we would use it to compute spacing.
      if (!this._frame[0].imagePosition) {
        this._frame[0].imagePosition = [0, 0, 0];
      }
      if (!this._frame[0].imageOrientation) {
        this._frame[0].imageOrientation = [1, 0, 0, 0, 1, 0];
      }

      this._origin = this._arrayToVector3(this._frame[0].imagePosition, 0);

      // compute transforms
      this.computeIJK2LPS();

      this.computeLPS2AABB();
      // this.packEchos();

      this._rescaleSlope = this._frame[0].rescaleSlope || 1;
      this._rescaleIntercept = this._frame[0].rescaleIntercept || 0;

      // rescale/slope min max
      this.computeMinMaxIntensities();
      this._minMax[0] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[0], this._rescaleSlope, this._rescaleIntercept);
      this._minMax[1] = ModelsStack.valueRescaleSlopeIntercept(this._minMax[1], this._rescaleSlope, this._rescaleIntercept);

      var width = this._frame[0].windowWidth || this._minMax[1] - this._minMax[0];
      this._windowWidth = this._rescaleSlope * width + this._rescaleIntercept;

      var center = this._frame[0].windowCenter || this._minMax[0] + width / 2;
      this._windowCenter = this._rescaleSlope * center + this._rescaleIntercept;

      this._bitsAllocated = this._frame[0].bitsAllocated;
      this._prepared = true;
    }
  }, {
    key: 'packEchos',
    value: function packEchos() {
      // 4 echo times...
      var echos = 4;
      var packedEcho = [];
      for (var i = 0; i < this._frame.length; i += echos) {
        var frame = this._frame[i];
        for (var k = 0; k < this._rows * this._columns; k++) {
          for (var j = 1; j < echos; j++) {
            frame.pixelData[k] += this._frame[i + j].pixelData[k];
          }
          frame.pixelData[k] /= echos;
        }
        packedEcho.push(frame);
      }
      this._frame = packedEcho;
      this._numberOfFrames = this._frame.length;
      this._dimensionsIJK = new THREE.Vector3(this._columns, this._rows, this._numberOfFrames);
      this._halfDimensionsIJK = new THREE.Vector3(this._dimensionsIJK.x / 2, this._dimensionsIJK.y / 2, this._dimensionsIJK.z / 2);
    }

    // frame.cosines - returns array [x, y, z]

  }, {
    key: 'computeCosines',
    value: function computeCosines() {
      if (this._frame && this._frame[0]) {
        var cosines = this._frame[0].cosines();
        this._xCosine = cosines[0];
        this._yCosine = cosines[1];
        this._zCosine = cosines[2];
      }
    }
  }, {
    key: 'orderFrames',
    value: function orderFrames() {
      // order the frames based on theirs dimension indices
      // first index is the most important.
      // 1,1,1,1 willl be first
      // 1,1,2,1 will be next
      // 1,1,2,3 will be next
      // 1,1,3,1 wil be next
      if (this._frame[0].dimensionIndexValues) {
        this._frame.sort(this._orderFrameOnDimensionIndicesArraySort);

        // else order with image position and orientation
      } else if (this._frame[0].imagePosition && this._frame[0].imageOrientation && this._frame[1] && this._frame[1].imagePosition && this._frame[1].imageOrientation && this._frame[0].imagePosition.join() !== this._frame[1].imagePosition.join()) {
        // compute and sort by dist in this series
        this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));
        this._frame.sort(this._sortDistanceArraySort);
      } else if (this._frame[0].instanceNumber !== null && this._frame[1] && this._frame[1].instanceNumber !== null && this._frame[0].instanceNumber !== this._frame[1].instanceNumber) {
        this._frame.sort(this._sortInstanceNumberArraySort);
      } else if (this._frame[0].sopInstanceUID && this._frame[1] && this._frame[1].sopInstanceUID && this._frame[0].sopInstanceUID !== this._frame[1].sopInstanceUID) {
        this._frame.sort(this._sortSopInstanceUIDArraySort);
      } else {
        // window.console.log(this._frame[0]);
        // window.console.log(this._frame[1]);
        // window.console.log(this._frame[0].instanceNumber !== null && true);
        // window.console.log(
        // this._frame[0].instanceNumber !== this._frame[1].instanceNumber);
        window.console.log('do not know how to order the frames...');
        // else slice location
        // image number
        // ORDERING BASED ON instance number
        // _ordering = 'instance_number';
        // first_image.sort(function(a,b){
        // return a["instance_number"]-b["instance_number"]});
      }
    }
  }, {
    key: 'computeSpacing',
    value: function computeSpacing() {
      this.xySpacing();
      this.zSpacing();
    }

    /**
     * Compute stack z spacing
     */

  }, {
    key: 'zSpacing',
    value: function zSpacing() {
      if (this._numberOfFrames > 1) {
        if (this._frame[0].pixelSpacing && this._frame[0].pixelSpacing[2]) {
          this._spacing.z = this._frame[0].pixelSpacing[2];
        } else {
          // compute and sort by dist in this series
          this._frame.map(this._computeDistanceArrayMap.bind(null, this._zCosine));

          // if distances are different, re-sort array
          if (this._frame[1].dist !== this._frame[0].dist) {
            this._frame.sort(this._sortDistanceArraySort);
            this._spacing.z = this._frame[1].dist - this._frame[0].dist;
          } else if (this._spacingBetweenSlices) {
            this._spacing.z = this._spacingBetweenSlices;
          } else if (this._frame[0].sliceThickness) {
            this._spacing.z = this._frame[0].sliceThickness;
          }
        }
      }

      // Spacing
      // can not be 0 if not matrix can not be inverted.
      if (this._spacing.z === 0) {
        this._spacing.z = 1;
      }
    }

    /**
     *  FRAME CAN DO IT
     */

  }, {
    key: 'xySpacing',
    value: function xySpacing() {
      if (this._frame && this._frame[0]) {
        var spacingXY = this._frame[0].spacingXY();
        this._spacing.x = spacingXY[0];
        this._spacing.y = spacingXY[1];
      }
    }

    /**
     * Find min and max intensities among all frames.
     */

  }, {
    key: 'computeMinMaxIntensities',
    value: function computeMinMaxIntensities() {
      // what about colors!!!!?
      for (var i = 0; i < this._frame.length; i++) {
        // get min/max
        this._minMax[0] = Math.min(this._minMax[0], this._frame[i].minMax[0]);
        this._minMax[1] = Math.max(this._minMax[1], this._frame[i].minMax[1]);
      }
    }

    /**
     * Compute IJK to LPS and invert transforms
     */

  }, {
    key: 'computeIJK2LPS',
    value: function computeIJK2LPS() {
      // ijk to lps
      this._ijk2LPS = _core4.default.ijk2LPS(this._xCosine, this._yCosine, this._zCosine, this._spacing, this._origin, this._regMatrix);

      // lps 2 ijk
      this._lps2IJK = new THREE.Matrix4();
      this._lps2IJK.getInverse(this._ijk2LPS);
    }

    /**
     * Compute LPS to AABB and invert transforms
     */

  }, {
    key: 'computeLPS2AABB',
    value: function computeLPS2AABB() {
      this._aabb2LPS = _core4.default.aabb2LPS(this._xCosine, this._yCosine, this._zCosine, this._origin);

      this._lps2AABB = new THREE.Matrix4();
      this._lps2AABB.getInverse(this._aabb2LPS);
    }

    /**
     * Merge stacks
     *
     * @param {*} stack
     *
     * @return {*}
     */

  }, {
    key: 'merge',
    value: function merge(stack) {
      // also make sure x/y/z cosines are a match!
      if (this._stackID === stack.stackID) {
        return this.mergeModels(this._frame, stack.frame);
      } else {
        return false;
      }
    }

    /**
     * Pack current stack pixel data into 8 bits array buffers
     */

  }, {
    key: 'pack',
    value: function pack() {
      // Get total number of voxels
      var nbVoxels = this._dimensionsIJK.x * this._dimensionsIJK.y * this._dimensionsIJK.z;

      // Packing style
      if (this._bitsAllocated === 16 && this._numberOfChannels === 1) {
        this._packedPerPixel = 2;
      }

      // Loop through all the textures we need
      var textureDimension = this._textureSize * this._textureSize;
      var requiredTextures = Math.ceil(nbVoxels / (textureDimension * this._packedPerPixel));
      var voxelIndexStart = 0;
      var voxelIndexStop = this._packedPerPixel * textureDimension;
      if (voxelIndexStop > nbVoxels) {
        voxelIndexStop = nbVoxels;
      }

      for (var ii = 0; ii < requiredTextures; ii++) {
        var packed = this._packTo8Bits(this._numberOfChannels, this._frame, this._textureSize, voxelIndexStart, voxelIndexStop);
        this._textureType = packed.textureType;
        this._rawData.push(packed.data);

        voxelIndexStart += this._packedPerPixel * textureDimension;
        voxelIndexStop += this._packedPerPixel * textureDimension;
        if (voxelIndexStop > nbVoxels) {
          voxelIndexStop = nbVoxels;
        }
      }

      this._packed = true;
    }

    /**
     * Pack frame data to 32 bits texture
     * @param {*} channels
     * @param {*} frame
     * @param {*} textureSize
     * @param {*} startVoxel
     * @param {*} stopVoxel
     */

  }, {
    key: '_packTo8Bits',
    value: function _packTo8Bits(channels, frame, textureSize, startVoxel, stopVoxel) {
      var packed = {
        textureType: null,
        data: null
      };

      var bitsAllocated = frame[0].bitsAllocated;
      var pixelType = frame[0].pixelType;

      // transform signed to unsigned for convenience
      var offset = 0;
      if (this._minMax[0] < 0) {
        offset -= this._minMax[0];
      }

      var packIndex = 0;
      var frameIndex = 0;
      var inFrameIndex = 0;
      // frame should return it!
      var frameDimension = frame[0].rows * frame[0].columns;

      if (bitsAllocated === 8 && channels === 1 || bitsAllocated === 1) {
        var data = new Uint8Array(textureSize * textureSize * 1);
        for (var i = startVoxel; i < stopVoxel; i++) {
          frameIndex = ~~(i / frameDimension);
          inFrameIndex = i % frameDimension;

          data[packIndex] = offset + frame[frameIndex].pixelData[inFrameIndex];
          packIndex++;
        }
        packed.textureType = THREE.LuminanceFormat;
        packed.data = data;
      } else if (bitsAllocated === 16 && channels === 1) {
        var _data = new Uint8Array(textureSize * textureSize * 4);
        var coordinate = 0;
        var channelOffset = 0;

        for (var _i3 = startVoxel; _i3 < stopVoxel; _i3++) {
          frameIndex = ~~(_i3 / frameDimension);
          inFrameIndex = _i3 % frameDimension;

          var raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data[4 * coordinate + 2 * channelOffset] = raw & 0x00FF;
          _data[4 * coordinate + 2 * channelOffset + 1] = raw >>> 8 & 0x00FF;

          packIndex++;
          coordinate = Math.floor(packIndex / 2);
          channelOffset = packIndex % 2;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 0) {
        var _data2 = new Uint8Array(textureSize * textureSize * 4);
        for (var _i4 = startVoxel; _i4 < stopVoxel; _i4++) {
          frameIndex = ~~(_i4 / frameDimension);
          inFrameIndex = _i4 % frameDimension;

          var _raw = offset + frame[frameIndex].pixelData[inFrameIndex];
          _data2[4 * packIndex] = _raw & 0x000000FF;
          _data2[4 * packIndex + 1] = _raw >>> 8 & 0x000000FF;
          _data2[4 * packIndex + 2] = _raw >>> 16 & 0x000000FF;
          _data2[4 * packIndex + 3] = _raw >>> 24 & 0x000000FF;

          packIndex++;
        }
        packed.textureType = THREE.RGBAFormat;
        packed.data = _data2;
      } else if (bitsAllocated === 32 && channels === 1 && pixelType === 1) {
        var _data3 = new Uint8Array(textureSize * textureSize * 4);

        for (var _i5 = startVoxel; _i5 < stopVoxel; _i5++) {
          frameIndex = ~~(_i5 / frameDimension);
          inFrameIndex = _i5 % frameDimension;

          var _raw2 = offset + frame[frameIndex].pixelData[inFrameIndex];
          var bitString = binaryString(_raw2);
          var bitStringArray = bitString.match(/.{1,8}/g);

          _data3[4 * packIndex] = parseInt(bitStringArray[0], 2);
          _data3[4 * packIndex + 1] = parseInt(bitStringArray[1], 2);
          _data3[4 * packIndex + 2] = parseInt(bitStringArray[2], 2);
          _data3[4 * packIndex + 3] = parseInt(bitStringArray[3], 2);

          packIndex++;
        }

        packed.textureType = THREE.RGBAFormat;
        packed.data = _data3;
      } else if (bitsAllocated === 8 && channels === 3) {
        var _data4 = new Uint8Array(textureSize * textureSize * 3);

        for (var _i6 = startVoxel; _i6 < stopVoxel; _i6++) {
          frameIndex = ~~(_i6 / frameDimension);
          inFrameIndex = _i6 % frameDimension;

          _data4[3 * packIndex] = frame[frameIndex].pixelData[3 * inFrameIndex];
          _data4[3 * packIndex + 1] = frame[frameIndex].pixelData[3 * inFrameIndex + 1];
          _data4[3 * packIndex + 2] = frame[frameIndex].pixelData[3 * inFrameIndex + 2];
          packIndex++;
        }

        packed.textureType = THREE.RGBFormat;
        packed.data = _data4;
      }

      return packed;
    }

    /**
     * Get the stack world center
     *
     *@return {*}
     */

  }, {
    key: 'worldCenter',
    value: function worldCenter() {
      var center = this._halfDimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS);
      return center;
    }

    /**
     * Get the stack world bounding box
     * @return {*}
     */

  }, {
    key: 'worldBoundingBox',
    value: function worldBoundingBox() {
      var bbox = [Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_VALUE, Number.MIN_VALUE];

      var dims = this._dimensionsIJK;

      for (var i = 0; i <= dims.x; i += dims.x) {
        for (var j = 0; j <= dims.y; j += dims.y) {
          for (var k = 0; k <= dims.z; k += dims.z) {
            var world = new THREE.Vector3(i, j, k).applyMatrix4(this._ijk2LPS);
            bbox = [Math.min(bbox[0], world.x), Math.max(bbox[1], world.x), // x min/max
            Math.min(bbox[2], world.y), Math.max(bbox[3], world.y), Math.min(bbox[4], world.z), Math.max(bbox[5], world.z)];
          }
        }
      }

      return bbox;
    }

    /**
     * Get AABB size in LPS space.
     *
     * @return {*}
     */

  }, {
    key: 'AABBox',
    value: function AABBox() {
      var world0 = new THREE.Vector3().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var world7 = this._dimensionsIJK.clone().addScalar(-0.5).applyMatrix4(this._ijk2LPS).applyMatrix4(this._lps2AABB);

      var minBBox = new THREE.Vector3(Math.abs(world0.x - world7.x), Math.abs(world0.y - world7.y), Math.abs(world0.z - world7.z));

      return minBBox;
    }

    /**
     * Get AABB center in LPS space
     */

  }, {
    key: 'centerAABBox',
    value: function centerAABBox() {
      var centerBBox = this.worldCenter();
      centerBBox.applyMatrix4(this._lps2AABB);
      return centerBBox;
    }
  }, {
    key: '_arrayToVector3',
    value: function _arrayToVector3(array, index) {
      return new THREE.Vector3(array[index], array[index + 1], array[index + 2]);
    }
  }, {
    key: '_orderFrameOnDimensionIndicesArraySort',
    value: function _orderFrameOnDimensionIndicesArraySort(a, b) {
      if ('dimensionIndexValues' in a && Object.prototype.toString.call(a.dimensionIndexValues) === '[object Array]' && 'dimensionIndexValues' in b && Object.prototype.toString.call(b.dimensionIndexValues) === '[object Array]') {
        for (var i = 0; i < a.dimensionIndexValues.length; i++) {
          if (parseInt(a.dimensionIndexValues[i], 10) > parseInt(b.dimensionIndexValues[i], 10)) {
            return 1;
          }
          if (parseInt(a.dimensionIndexValues[i], 10) < parseInt(b.dimensionIndexValues[i], 10)) {
            return -1;
          }
        }
      } else {
        window.console.log('One of the frames doesn\'t have a dimensionIndexValues array.');
        window.console.log(a);
        window.console.log(b);
      }

      return 0;
    }
  }, {
    key: '_computeDistanceArrayMap',
    value: function _computeDistanceArrayMap(normal, frame) {
      frame.dist = frame.imagePosition[0] * normal.x + frame.imagePosition[1] * normal.y + frame.imagePosition[2] * normal.z;
      return frame;
    }
  }, {
    key: '_sortDistanceArraySort',
    value: function _sortDistanceArraySort(a, b) {
      return a.dist - b.dist;
    }
  }, {
    key: '_sortInstanceNumberArraySort',
    value: function _sortInstanceNumberArraySort(a, b) {
      return a.instanceNumber - b.instanceNumber;
    }
  }, {
    key: '_sortSopInstanceUIDArraySort',
    value: function _sortSopInstanceUIDArraySort(a, b) {
      return a.sopInstanceUID - b.sopInstanceUID;
    }
  }, {
    key: 'numberOfChannels',
    set: function set(numberOfChannels) {
      this._numberOfChannels = numberOfChannels;
    },
    get: function get() {
      return this._numberOfChannels;
    }
  }, {
    key: 'frame',
    set: function set(frame) {
      this._frame = frame;
    },
    get: function get() {
      return this._frame;
    }
  }, {
    key: 'prepared',
    set: function set(prepared) {
      this._prepared = prepared;
    },
    get: function get() {
      return this._prepared;
    }
  }, {
    key: 'packed',
    set: function set(packed) {
      this._packed = packed;
    },
    get: function get() {
      return this._packed;
    }
  }, {
    key: 'packedPerPixel',
    set: function set(packedPerPixel) {
      this._packedPerPixel = packedPerPixel;
    },
    get: function get() {
      return this._packedPerPixel;
    }
  }, {
    key: 'dimensionsIJK',
    set: function set(dimensionsIJK) {
      this._dimensionsIJK = dimensionsIJK;
    },
    get: function get() {
      return this._dimensionsIJK;
    }
  }, {
    key: 'halfDimensionsIJK',
    set: function set(halfDimensionsIJK) {
      this._halfDimensionsIJK = halfDimensionsIJK;
    },
    get: function get() {
      return this._halfDimensionsIJK;
    }
  }, {
    key: 'regMatrix',
    set: function set(regMatrix) {
      this._regMatrix = regMatrix;
    },
    get: function get() {
      return this._regMatrix;
    }
  }, {
    key: 'ijk2LPS',
    set: function set(ijk2LPS) {
      this._ijk2LPS = ijk2LPS;
    },
    get: function get() {
      return this._ijk2LPS;
    }
  }, {
    key: 'lps2IJK',
    set: function set(lps2IJK) {
      this._lps2IJK = lps2IJK;
    },
    get: function get() {
      return this._lps2IJK;
    }
  }, {
    key: 'lps2AABB',
    set: function set(lps2AABB) {
      this._lps2AABB = lps2AABB;
    },
    get: function get() {
      return this._lps2AABB;
    }
  }, {
    key: 'textureSize',
    set: function set(textureSize) {
      this._textureSize = textureSize;
    },
    get: function get() {
      return this._textureSize;
    }
  }, {
    key: 'textureType',
    set: function set(textureType) {
      this._textureType = textureType;
    },
    get: function get() {
      return this._textureType;
    }
  }, {
    key: 'bitsAllocated',
    set: function set(bitsAllocated) {
      this._bitsAllocated = bitsAllocated;
    },
    get: function get() {
      return this._bitsAllocated;
    }
  }, {
    key: 'rawData',
    set: function set(rawData) {
      this._rawData = rawData;
    },
    get: function get() {
      return this._rawData;
    }
  }, {
    key: 'windowWidth',
    get: function get() {
      return this._windowWidth;
    },
    set: function set(windowWidth) {
      this._windowWidth = windowWidth;
    }
  }, {
    key: 'windowCenter',
    get: function get() {
      return this._windowCenter;
    },
    set: function set(windowCenter) {
      this._windowCenter = windowCenter;
    }
  }, {
    key: 'rescaleSlope',
    get: function get() {
      return this._rescaleSlope;
    },
    set: function set(rescaleSlope) {
      this._rescaleSlope = rescaleSlope;
    }
  }, {
    key: 'rescaleIntercept',
    get: function get() {
      return this._rescaleIntercept;
    },
    set: function set(rescaleIntercept) {
      this._rescaleIntercept = rescaleIntercept;
    }
  }, {
    key: 'xCosine',
    get: function get() {
      return this._xCosine;
    },
    set: function set(xCosine) {
      this._xCosine = xCosine;
    }
  }, {
    key: 'yCosine',
    get: function get() {
      return this._yCosine;
    },
    set: function set(yCosine) {
      this._yCosine = yCosine;
    }
  }, {
    key: 'zCosine',
    get: function get() {
      return this._zCosine;
    },
    set: function set(zCosine) {
      this._zCosine = zCosine;
    }
  }, {
    key: 'minMax',
    get: function get() {
      return this._minMax;
    },
    set: function set(minMax) {
      this._minMax = minMax;
    }
  }, {
    key: 'stackID',
    get: function get() {
      return this._stackID;
    },
    set: function set(stackID) {
      this._stackID = stackID;
    }
  }, {
    key: 'pixelType',
    get: function get() {
      return this._pixelType;
    },
    set: function set(pixelType) {
      this._pixelType = pixelType;
    }
  }, {
    key: 'pixelRepresentation',
    get: function get() {
      return this._pixelRepresentation;
    },
    set: function set(pixelRepresentation) {
      this._pixelRepresentation = pixelRepresentation;
    }
  }, {
    key: 'invert',
    set: function set(invert) {
      this._invert = invert;
    },
    get: function get() {
      return this._invert;
    }
  }, {
    key: 'modality',
    set: function set(modality) {
      this._modality = modality;
    },
    get: function get() {
      return this._modality;
    }
  }, {
    key: 'rightHanded',
    get: function get() {
      return this._rightHanded;
    },
    set: function set(rightHanded) {
      this._rightHanded = rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    get: function get() {
      return this._spacingBetweenSlices;
    },
    set: function set(spacingBetweenSlices) {
      this._spacingBetweenSlices = spacingBetweenSlices;
    }
  }, {
    key: 'segmentationSegments',
    set: function set(segmentationSegments) {
      this._segmentationSegments = segmentationSegments;
    },
    get: function get() {
      return this._segmentationSegments;
    }
  }, {
    key: 'segmentationType',
    set: function set(segmentationType) {
      this._segmentationType = segmentationType;
    },
    get: function get() {
      return this._segmentationType;
    }
  }, {
    key: 'segmentationLUT',
    set: function set(segmentationLUT) {
      this._segmentationLUT = segmentationLUT;
    },
    get: function get() {
      return this._segmentationLUT;
    }
  }, {
    key: 'segmentationLUTO',
    set: function set(segmentationLUTO) {
      this._segmentationLUTO = segmentationLUTO;
    },
    get: function get() {
      return this._segmentationLUTO;
    }

    // DEPRECATED FUNCTION

    /**
     * @deprecated for core.utils.value
     *
     * Get voxel value.
     *
     * @param {*} stack
     * @param {*} coordinate
     *
     * @return {*}
     */

  }], [{
    key: 'indexInDimensions',
    value: function indexInDimensions(index, dimensions) {
      if (index.x >= 0 && index.y >= 0 && index.z >= 0 && index.x < dimensions.x && index.y < dimensions.y && index.z < dimensions.z) {
        return true;
      }

      return false;
    }
  }, {
    key: 'value',
    value: function value(stack, coordinate) {
      console.warn('models.stack.value is deprecated.\n       Please use core.utils.value instead.');
      return _core4.default.value(stack, coordinate);
    }

    /**
     * @deprecated for core.utils.rescaleSlopeIntercept
     *
     * Apply slope/intercept to a value.
     *
     * @param {*} value
     * @param {*} slope
     * @param {*} intercept
     *
     * @return {*}
     */

  }, {
    key: 'valueRescaleSlopeIntercept',
    value: function valueRescaleSlopeIntercept(value, slope, intercept) {
      console.warn('models.stack.valueRescaleSlopeIntercept is deprecated.\n       Please use core.utils.rescaleSlopeIntercept instead.');
      return _core4.default.rescaleSlopeIntercept(value, slope, intercept);
    }

    /**
     * @deprecated for core.utils.worldToData
     *
     * Transform coordinates from world coordinate to data
     *
     * @param {*} stack
     * @param {*} worldCoordinates
     *
     * @return {*}
     */

  }, {
    key: 'worldToData',
    value: function worldToData(stack, worldCoordinates) {
      console.warn('models.stack.worldToData is deprecated.\n       Please use core.utils.worldToData instead.');

      return _core4.default.worldToData(stack._lps2IJK, worldCoordinates);
    }
  }]);

  return ModelsStack;
}(_models2.default);

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }


exports.default = ModelsStack;

},{"../core/core.colors":101,"../core/core.utils":105,"../models/models.base":130,"math-float32-to-binary-string":43}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module models/voxel
 */

var ModelsVoxel = function () {
  function ModelsVoxel() {
    _classCallCheck(this, ModelsVoxel);

    this._id = -1;
    this._worldCoordinates = null;
    this._dataCoordinates = null;
    this._screenCoordinates = null;
    this._value = null;
  }

  _createClass(ModelsVoxel, [{
    key: "worldCoordinates",
    set: function set(worldCoordinates) {
      this._worldCoordinates = worldCoordinates;
    },
    get: function get() {
      return this._worldCoordinates;
    }
  }, {
    key: "dataCoordinates",
    set: function set(dataCoordinates) {
      this._dataCoordinates = dataCoordinates;
    },
    get: function get() {
      return this._dataCoordinates;
    }
  }, {
    key: "screenCoordinates",
    set: function set(screenCoordinates) {
      this._screenCoordinates = screenCoordinates;
    },
    get: function get() {
      return this._screenCoordinates;
    }
  }, {
    key: "value",
    set: function set(value) {
      this._value = value;
    },
    get: function get() {
      return this._value;
    }
  }, {
    key: "id",
    set: function set(id) {
      this._id = id;
    },
    get: function get() {
      return this._id;
    }
  }]);

  return ModelsVoxel;
}();

exports.default = ModelsVoxel;

},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ftp://medical.nema.org/MEDICAL/Dicom/2014c/output/chtml/part05/sect_6.2.html/

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

/** * Imports ***/


var DicomParser = require('dicom-parser');
var Jpeg = require('jpeg-lossless-decoder-js');
var JpegBaseline = require('../../external/scripts/jpeg');
var Jpx = require('../../external/scripts/jpx');

/**
 * Dicom parser is a combination of utilities to get a VJS image from dicom files.
 *scripts
 * Relies on dcmjs, jquery, HTML5 fetch API, HTML5 promise API.
 *
 * @module parsers/dicom
 *
 * @param arrayBuffer {arraybuffer} - List of files to be parsed. It is urls from which
 * VJS.parsers.dicom can pull the data from.
 */

var ParsersDicom = function (_ParsersVolume) {
  _inherits(ParsersDicom, _ParsersVolume);

  function ParsersDicom(data, id) {
    _classCallCheck(this, ParsersDicom);

    var _this = _possibleConstructorReturn(this, (ParsersDicom.__proto__ || Object.getPrototypeOf(ParsersDicom)).call(this));

    _this._id = id;

    _this._arrayBuffer = data.buffer;

    var byteArray = new Uint8Array(_this._arrayBuffer);

    // catch error
    // throw error if any!
    _this._dataSet = null;

    try {
      _this._dataSet = DicomParser.parseDicom(byteArray);
    } catch (e) {
      window.console.log(e);
      throw 'parsers.dicom could not parse the file';
    }
    return _this;
  }

  // image/frame specific


  _createClass(ParsersDicom, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      return this._dataSet.string('x0020000e');
    }
  }, {
    key: 'studyInstanceUID',
    value: function studyInstanceUID() {
      return this._dataSet.string('x0020000d');
    }
  }, {
    key: 'modality',
    value: function modality() {
      return this._dataSet.string('x00080060');
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return this._dataSet.string('x00620001');
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      var segmentationSegments = [];
      var segmentSequence = this._dataSet.elements.x00620002;

      if (!segmentSequence) {
        return segmentationSegments;
      }

      for (var i = 0; i < segmentSequence.items.length; i++) {
        var recommendedDisplayCIELab = this._recommendedDisplayCIELab(segmentSequence.items[i]);
        var segmentationCode = this._segmentationCode(segmentSequence.items[i]);
        var segmentNumber = segmentSequence.items[i].dataSet.uint16('x00620004');
        var segmentLabel = segmentSequence.items[i].dataSet.string('x00620005');
        var segmentAlgorithmType = segmentSequence.items[i].dataSet.string('x00620008');

        segmentationSegments.push({
          recommendedDisplayCIELab: recommendedDisplayCIELab,
          segmentationCodeDesignator: segmentationCode['segmentationCodeDesignator'],
          segmentationCodeValue: segmentationCode['segmentationCodeValue'],
          segmentationCodeMeaning: segmentationCode['segmentationCodeMeaning'],
          segmentNumber: segmentNumber,
          segmentLabel: segmentLabel,
          segmentAlgorithmType: segmentAlgorithmType
        });
      }

      return segmentationSegments;
    }
  }, {
    key: '_segmentationCode',
    value: function _segmentationCode(segment) {
      var segmentationCodeDesignator = 'unknown';
      var segmentationCodeValue = 'unknown';
      var segmentationCodeMeaning = 'unknown';
      var element = segment.dataSet.elements.x00082218;

      if (element && element.items && element.items.length > 0) {
        segmentationCodeDesignator = element.items[0].dataSet.string('x00080102');
        segmentationCodeValue = element.items[0].dataSet.string('x00080100');
        segmentationCodeMeaning = element.items[0].dataSet.string('x00080104');
      }

      return {
        segmentationCodeDesignator: segmentationCodeDesignator,
        segmentationCodeValue: segmentationCodeValue,
        segmentationCodeMeaning: segmentationCodeMeaning
      };
    }
  }, {
    key: '_recommendedDisplayCIELab',
    value: function _recommendedDisplayCIELab(segment) {
      if (!segment.dataSet.elements.x0062000d) {
        return null;
      }

      var offset = segment.dataSet.elements.x0062000d.dataOffset;
      var length = segment.dataSet.elements.x0062000d.length;
      var byteArray = segment.dataSet.byteArray.slice(offset, offset + length);

      // https://www.dabsoft.ch/dicom/3/C.10.7.1.1/
      var CIELabScaled = new Uint16Array(length / 2);
      for (var i = 0; i < length / 2; i++) {
        CIELabScaled[i] = (byteArray[2 * i + 1] << 8) + byteArray[2 * i];
      }

      var CIELabNormalized = [CIELabScaled[0] / 65535 * 100, CIELabScaled[1] / 65535 * 255 - 128, CIELabScaled[2] / 65535 * 255 - 128];

      return CIELabNormalized;
    }

    /**
     * SOP Instance UID
     *
     * @param {*} frameIndex
     *
     * @return {*}
     */

  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var sopInstanceUID = this._findStringEverywhere('x2005140f', 'x00080018', frameIndex);
      return sopInstanceUID;
    }

    /**
     * Transfer syntax UID
     *
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return this._dataSet.string('x00020010');
    }

    /**
     * Study description
     *
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return this._dataSet.string('x00081030');
    }

    /**
     * Series description
     *
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return this._dataSet.string('x0008103e');
    }

    /**
     * Patient name
     *
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return this._dataSet.string('x00100010');
    }

    /**
     * Patient ID
     *
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return this._dataSet.string('x00100020');
    }

    /**
     * Patient birthdate
     *
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return this._dataSet.string('x00100030');
    }

    /**
     * Patient sex
     *
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return this._dataSet.string('x00100040');
    }

    /**
     * Patient age
     *
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return this._dataSet.string('x00101010');
    }

    /**
     * Photometric interpretation
     *
     * @return {*}
     */

  }, {
    key: 'photometricInterpretation',
    value: function photometricInterpretation() {
      return this._dataSet.string('x00280004');
    }
  }, {
    key: 'planarConfiguration',
    value: function planarConfiguration() {
      var planarConfiguration = this._dataSet.uint16('x00280006');

      if (typeof planarConfiguration === 'undefined') {
        planarConfiguration = null;
      }

      return planarConfiguration;
    }
  }, {
    key: 'samplesPerPixel',
    value: function samplesPerPixel() {
      return this._dataSet.uint16('x00280002');
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      var numberOfFrames = this._dataSet.intString('x00280008');

      // need something smarter!
      if (typeof numberOfFrames === 'undefined') {
        numberOfFrames = null;
      }

      return numberOfFrames;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      var photometricInterpretation = this.photometricInterpretation();

      if (!(photometricInterpretation !== 'RGB' && photometricInterpretation !== 'PALETTE COLOR' && photometricInterpretation !== 'YBR_FULL' && photometricInterpretation !== 'YBR_FULL_422' && photometricInterpretation !== 'YBR_PARTIAL_422' && photometricInterpretation !== 'YBR_PARTIAL_420' && photometricInterpretation !== 'YBR_RCT')) {
        numberOfChannels = 3;
      }

      // make sure we return a number! (not a string!)
      return numberOfChannels;
    }
  }, {
    key: 'invert',
    value: function invert() {
      var photometricInterpretation = this.photometricInterpretation();

      return photometricInterpretation === 'MONOCHROME1' ? true : false;
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var imageOrientation = this._findStringEverywhere('x00209116', 'x00200037', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imageOrientation) {
        // make sure we return a number! (not a string!)
        // might not need to split (floatString + index)
        imageOrientation = imageOrientation.split('\\').map(Number);
      }

      return imageOrientation;
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var referencedSegmentNumber = -1;
      var referencedSegmentNumberElement = this._findInGroupSequence('x52009230', 'x0062000a', frameIndex);

      if (referencedSegmentNumberElement !== null) {
        referencedSegmentNumber = referencedSegmentNumberElement.uint16('x0062000b');
      }

      return referencedSegmentNumber;
    }
  }, {
    key: 'pixelAspectRatio',
    value: function pixelAspectRatio() {
      var pixelAspectRatio = [this._dataSet.intString('x00280034', 0), this._dataSet.intString('x00280034', 1)];

      // need something smarter!
      if (typeof pixelAspectRatio[0] === 'undefined') {
        pixelAspectRatio = null;
      }

      // make sure we return a number! (not a string!)
      return pixelAspectRatio;
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var imagePosition = this._findStringEverywhere('x00209113', 'x00200032', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      if (imagePosition) {
        // make sure we return a number! (not a string!)
        imagePosition = imagePosition.split('\\').map(Number);
      }

      return imagePosition;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var instanceNumber = null;
      // first look for frame!
      // per frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        if (perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f) {
          var planeOrientationSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x2005140f.items[0].dataSet;
          instanceNumber = planeOrientationSequence.intString('x00200013');
        } else {
          instanceNumber = this._dataSet.intString('x00200013');

          if (typeof instanceNumber === 'undefined') {
            instanceNumber = null;
          }
        }
      } else {
        // should we default to undefined??
        // default orientation
        instanceNumber = this._dataSet.intString('x00200013');

        if (typeof instanceNumber === 'undefined') {
          instanceNumber = null;
        }
      }

      return instanceNumber;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var pixelSpacing = this._findStringEverywhere('x00289110', 'x00280030', frameIndex);

      // format image orientation ('1\0\0\0\1\0') to array containing 6 numbers
      // should we default to undefined??
      if (pixelSpacing) {
        // make sure we return array of numbers! (not strings!)
        pixelSpacing = pixelSpacing.split('\\').map(Number);
      }

      return pixelSpacing;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var rows = this._dataSet.uint16('x00280010');

      if (typeof rows === 'undefined') {
        rows = null;
        // print warning at least...
      }

      return rows;
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var columns = this._dataSet.uint16('x00280011');

      if (typeof columns === 'undefined') {
        columns = null;
        // print warning at least...
      }

      return columns;
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 integer, 1 float
      // dicom only support integers
      return 0;
    }
  }, {
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this._dataSet.uint16('x00280103');
      return pixelRepresentation;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var bitsAllocated = this._dataSet.uint16('x00280100');
      return bitsAllocated;
    }
  }, {
    key: 'highBit',
    value: function highBit() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // expect frame index to start at 0!
      var highBit = this._dataSet.uint16('x00280102');
      return highBit;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281052', frameIndex);
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289145', 'x00281053', frameIndex);
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281050', frameIndex);
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289132', 'x00281051', frameIndex);
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._findFloatStringInFrameGroupSequence('x00289110', 'x00180050', frameIndex);
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var spacing = this._dataSet.intString('x00180088');

      if (typeof spacing === 'undefined') {
        spacing = null;
      }

      return spacing;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var dimensionIndexValues = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        var frameContentSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111;
        if (frameContentSequence !== undefined && frameContentSequence !== null) {
          frameContentSequence = frameContentSequence.items[0].dataSet;
          var dimensionIndexValuesElt = frameContentSequence.elements.x00209157;
          if (dimensionIndexValuesElt !== undefined && dimensionIndexValuesElt !== null) {
            // /4 because UL
            var nbValues = dimensionIndexValuesElt.length / 4;
            dimensionIndexValues = [];

            for (var i = 0; i < nbValues; i++) {
              dimensionIndexValues.push(frameContentSequence.uint32('x00209157', i));
            }
          }
        }
      }

      return dimensionIndexValues;
    }
  }, {
    key: 'inStackPositionNumber',
    value: function inStackPositionNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var inStackPositionNumber = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        inStackPositionNumber = philipsPrivateSequence.uint32('x00209057');
      } else {
        inStackPositionNumber = null;
      }

      console.log('instack position ' + inStackPositionNumber);

      return inStackPositionNumber;
    }
  }, {
    key: 'stackID',
    value: function stackID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var stackID = null;

      // try to get it from enhanced MR images
      // per-frame functionnal group sequence
      var perFrameFunctionnalGroupSequence = this._dataSet.elements.x52009230;

      if (typeof perFrameFunctionnalGroupSequence !== 'undefined') {
        // NOT A PHILIPS TRICK!
        var philipsPrivateSequence = perFrameFunctionnalGroupSequence.items[frameIndex].dataSet.elements.x00209111.items[0].dataSet;
        stackID = philipsPrivateSequence.intString('x00209056');
      } else {
        stackID = null;
      }

      return stackID;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // decompress
      var decompressedData = this._decodePixelData(frameIndex);

      var numberOfChannels = this.numberOfChannels();

      if (numberOfChannels > 1) {
        return this._convertColorSpace(decompressedData);
      } else {
        return decompressedData;
      }
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;

      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }

    //
    // private methods
    //

  }, {
    key: '_findInGroupSequence',
    value: function _findInGroupSequence(sequence, subsequence, index) {
      var functionalGroupSequence = this._dataSet.elements[sequence];

      if (typeof functionalGroupSequence !== 'undefined') {
        var inSequence = functionalGroupSequence.items[index].dataSet.elements[subsequence];

        if (typeof inSequence !== 'undefined') {
          return inSequence.items[0].dataSet;
        }
      }

      return null;
    }
  }, {
    key: '_findStringInGroupSequence',
    value: function _findStringInGroupSequence(sequence, subsequence, tag, index) {
      // index = 0 if shared!!!
      var dataSet = this._findInGroupSequence(sequence, subsequence, index);

      if (dataSet !== null) {
        return dataSet.string(tag);
      }

      return null;
    }
  }, {
    key: '_findStringInFrameGroupSequence',
    value: function _findStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_findStringEverywhere',
    value: function _findStringEverywhere(subsequence, tag, index) {
      var targetString = this._findStringInFrameGroupSequence(subsequence, tag, index);

      if (targetString === null) {
        targetString = this._dataSet.string(tag);
      }

      if (typeof targetString === 'undefined') {
        targetString = null;
      }

      return targetString;
    }
  }, {
    key: '_findFloatStringInGroupSequence',
    value: function _findFloatStringInGroupSequence(sequence, subsequence, tag, index) {
      var dataInGroupSequence = this._dataSet.floatString(tag);

      // try to get it from enhanced MR images
      // per-frame functionnal group
      if (typeof dataInGroupSequence === 'undefined') {
        dataInGroupSequence = this._findInGroupSequence(sequence, subsequence, index);

        if (dataInGroupSequence !== null) {
          return dataInGroupSequence.floatString(tag);
        } else {
          return null;
        }
      }

      return dataInGroupSequence;
    }
  }, {
    key: '_findFloatStringInFrameGroupSequence',
    value: function _findFloatStringInFrameGroupSequence(subsequence, tag, index) {
      return this._findFloatStringInGroupSequence('x52009229', subsequence, tag, 0) || this._findFloatStringInGroupSequence('x52009230', subsequence, tag, index);
    }
  }, {
    key: '_decodePixelData',
    value: function _decodePixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // if compressed..?
      var transferSyntaxUID = this.transferSyntaxUID();

      // find compression scheme
      if (transferSyntaxUID === '1.2.840.10008.1.2.4.90' ||
      // JPEG 2000 Lossless
      transferSyntaxUID === '1.2.840.10008.1.2.4.91') {
        // JPEG 2000 Lossy
        return this._decodeJ2K(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.57' ||
      // JPEG Lossless, Nonhierarchical (Processes 14)
      transferSyntaxUID === '1.2.840.10008.1.2.4.70') {
        // JPEG Lossless, Nonhierarchical (Processes 14 [Selection 1])
        return this._decodeJPEGLossless(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.4.50' ||
      // JPEG Baseline lossy process 1 (8 bit)
      transferSyntaxUID === '1.2.840.10008.1.2.4.51') {
        // JPEG Baseline lossy process 2 & 4 (12 bit)
        return this._decodeJPEGBaseline(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2' ||
      // Implicit VR Little Endian
      transferSyntaxUID === '1.2.840.10008.1.2.1') {
        // Explicit VR Little Endian
        return this._decodeUncompressed(frameIndex);
      } else if (transferSyntaxUID === '1.2.840.10008.1.2.2') {
        // Explicit VR Big Endian
        var frame = this._decodeUncompressed(frameIndex);
        // and sawp it!
        return this._swapFrame(frame);
      } else {
        throw {
          error: 'no decoder for transfer syntax ' + transferSyntaxUID
        };
      }
    }
  }, {
    key: '_decodeJ2K',
    value: function _decodeJ2K() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      // let pixelDataElement = this._dataSet.elements.x7fe00010;
      // let pixelData = new Uint8Array(this._dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
      var jpxImage = new Jpx();
      // https://github.com/OHIF/image-JPEG2000/issues/6
      // It currently returns either Int16 or Uint16 based on whether the codestream is signed or not.
      jpxImage.parse(encodedPixelData);

      // let j2kWidth = jpxImage.width;
      // let j2kHeight = jpxImage.height;

      var componentsCount = jpxImage.componentsCount;
      if (componentsCount !== 1) {
        throw 'JPEG2000 decoder returned a componentCount of ${componentsCount}, when 1 is expected';
      }
      var tileCount = jpxImage.tiles.length;

      if (tileCount !== 1) {
        throw 'JPEG2000 decoder returned a tileCount of ${tileCount}, when 1 is expected';
      }

      var tileComponents = jpxImage.tiles[0];
      var pixelData = tileComponents.items;

      // window.console.log(j2kWidth, j2kHeight);

      return pixelData;
    }

    // from cornerstone

  }, {
    key: '_decodeJPEGLossless',
    value: function _decodeJPEGLossless() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var byteOutput = bitsAllocated <= 8 ? 1 : 2;
      var decoder = new Jpeg.lossless.Decoder();
      var decompressedData = decoder.decode(encodedPixelData.buffer, encodedPixelData.byteOffset, encodedPixelData.length, byteOutput);

      if (pixelRepresentation === 0) {
        if (byteOutput === 2) {
          return new Uint16Array(decompressedData.buffer);
        } else {
          // untested!
          return new Uint8Array(decompressedData.buffer);
        }
      } else {
        return new Int16Array(decompressedData.buffer);
      }
    }
  }, {
    key: '_decodeJPEGBaseline',
    value: function _decodeJPEGBaseline() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var encodedPixelData = DicomParser.readEncapsulatedPixelData(this._dataSet, this._dataSet.elements.x7fe00010, frameIndex);
      var rows = this.rows(frameIndex);
      var columns = this.columns(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var jpegBaseline = new JpegBaseline();
      jpegBaseline.parse(encodedPixelData);

      if (bitsAllocated === 8) {
        return jpegBaseline.getData(columns, rows);
      } else if (bitsAllocated === 16) {
        return jpegBaseline.getData16(columns, rows);
      }
    }
  }, {
    key: '_decodeUncompressed',
    value: function _decodeUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var pixelRepresentation = this.pixelRepresentation(frameIndex);
      var bitsAllocated = this.bitsAllocated(frameIndex);
      var pixelDataElement = this._dataSet.elements.x7fe00010;
      var pixelDataOffset = pixelDataElement.dataOffset;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      var frameOffset = 0;
      var buffer = this._dataSet.byteArray.buffer;

      if (pixelRepresentation === 0 && bitsAllocated === 8) {
        // unsigned 8 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 16) {
        // unsigned 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 1 && bitsAllocated === 16) {
        // signed 16 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 32) {
        // unsigned 32 bit
        frameOffset = pixelDataOffset + frameIndex * numPixels * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (pixelRepresentation === 0 && bitsAllocated === 1) {
        var newBuffer = new ArrayBuffer(numPixels);
        var newArray = new Uint8Array(newBuffer);

        frameOffset = pixelDataOffset + frameIndex * numPixels;
        var index = 0;

        var bitStart = frameIndex * numPixels;
        var bitEnd = frameIndex * numPixels + numPixels;

        var byteStart = Math.floor(bitStart / 8);
        var bitStartOffset = bitStart - byteStart * 8;
        var byteEnd = Math.ceil(bitEnd / 8);

        var targetBuffer = new Uint8Array(buffer, pixelDataOffset);

        for (var i = byteStart; i <= byteEnd; i++) {
          while (bitStartOffset < 8) {
            switch (bitStartOffset) {
              case 0:
                newArray[index] = targetBuffer[i] & 0x0001;
                break;
              case 1:
                newArray[index] = targetBuffer[i] >>> 1 & 0x0001;
                break;
              case 2:
                newArray[index] = targetBuffer[i] >>> 2 & 0x0001;
                break;
              case 3:
                newArray[index] = targetBuffer[i] >>> 3 & 0x0001;
                break;
              case 4:
                newArray[index] = targetBuffer[i] >>> 4 & 0x0001;
                break;
              case 5:
                newArray[index] = targetBuffer[i] >>> 5 & 0x0001;
                break;
              case 6:
                newArray[index] = targetBuffer[i] >>> 6 & 0x0001;
                break;
              case 7:
                newArray[index] = targetBuffer[i] >>> 7 & 0x0001;
                break;
              default:
                break;
            }

            bitStartOffset++;
            index++;
            // if return..
            if (index >= numPixels) {
              return newArray;
            }
          }
          bitStartOffset = 0;
        }
      }
    }
  }, {
    key: '_convertColorSpace',
    value: function _convertColorSpace(uncompressedData) {
      var rgbData = null;
      var photometricInterpretation = this.photometricInterpretation();
      var planarConfiguration = this.planarConfiguration();

      if (photometricInterpretation === 'RGB' && planarConfiguration === 0) {
        // ALL GOOD, ALREADY ORDERED
        // planar or non planar planarConfiguration
        rgbData = uncompressedData;
      } else if (photometricInterpretation === 'RGB' && planarConfiguration === 1) {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        var numPixels = uncompressedData.length / 3;
        var rgbaIndex = 0;
        var rIndex = 0;
        var gIndex = numPixels;
        var bIndex = numPixels * 2;
        for (var i = 0; i < numPixels; i++) {
          rgbData[rgbaIndex++] = uncompressedData[rIndex++]; // red
          rgbData[rgbaIndex++] = uncompressedData[gIndex++]; // green
          rgbData[rgbaIndex++] = uncompressedData[bIndex++]; // blue
        }
      } else if (photometricInterpretation === 'YBR_FULL') {
        if (uncompressedData instanceof Int8Array) {
          rgbData = new Int8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint8Array) {
          rgbData = new Uint8Array(uncompressedData.length);
        } else if (uncompressedData instanceof Int16Array) {
          rgbData = new Int16Array(uncompressedData.length);
        } else if (uncompressedData instanceof Uint16Array) {
          rgbData = new Uint16Array(uncompressedData.length);
        } else {
          throw 'unsuported typed array: ${uncompressedData}';
        }

        // https://github.com/chafey/cornerstoneWADOImageLoader/blob/master/src/decodeYBRFull.js
        var nPixels = uncompressedData.length / 3;
        var ybrIndex = 0;
        var _rgbaIndex = 0;
        for (var _i = 0; _i < nPixels; _i++) {
          var y = uncompressedData[ybrIndex++];
          var cb = uncompressedData[ybrIndex++];
          var cr = uncompressedData[ybrIndex++];
          rgbData[_rgbaIndex++] = y + 1.40200 * (cr - 128); // red
          rgbData[_rgbaIndex++] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128); // green
          rgbData[_rgbaIndex++] = y + 1.77200 * (cb - 128); // blue
          // rgbData[rgbaIndex++] = 255; //alpha
        }
      } else {
        throw 'photometric interpolation not supported: ${photometricInterpretation}';
      }

      return rgbData;
    }

    /**
     * Swap bytes in frame.
     */

  }, {
    key: '_swapFrame',
    value: function _swapFrame(frame) {
      // swap bytes ( if 8bits (1byte), nothing to swap)
      var bitsAllocated = this.bitsAllocated();

      if (bitsAllocated === 16) {
        for (var i = 0; i < frame.length; i++) {
          frame[i] = this._swap16(frame[i]);
        }
      } else if (bitsAllocated === 32) {
        for (var _i2 = 0; _i2 < frame.length; _i2++) {
          frame[_i2] = this._swap32(frame[_i2]);
        }
      }

      return frame;
    }
  }]);

  return ParsersDicom;
}(_parsers2.default);

// VJS.parsers.dicom.prototype.frameOfReferenceUID = function(imageJqueryDom) {
//   // try to access frame of reference UID through its DICOM tag
//   let seriesNumber = imageJqueryDom.find('[tag="00200052"] Value').text();

//   // if not available, assume we only have 1 frame
//   if (seriesNumber === '') {
//     seriesNumber = 1;
//   }
//   return seriesNumber;
// };

//
// ENDIAN NESS NOT TAKEN CARE OF
// http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-letiable-in-javascript
// http://www.barre.nom.fr/medical/samples/
//
//


exports.default = ParsersDicom;

},{"../../external/scripts/jpeg":1,"../../external/scripts/jpx":2,"./parsers.volume":141,"dicom-parser":25,"jpeg-lossless-decoder-js":35}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parsers = require('./parsers.dicom');

var _parsers2 = _interopRequireDefault(_parsers);

var _parsers3 = require('./parsers.nifti');

var _parsers4 = _interopRequireDefault(_parsers3);

var _parsers5 = require('./parsers.nrrd');

var _parsers6 = _interopRequireDefault(_parsers5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module parsers
 */

exports.default = {
  Dicom: _parsers2.default,
  Nifti: _parsers4.default,
  Nrrd: _parsers6.default
};

},{"./parsers.dicom":136,"./parsers.nifti":139,"./parsers.nrrd":140}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** * Imports ***/


/**
 * @module parsers/mhd
 */
var ParsersMHD = function (_ParsersVolume) {
  _inherits(ParsersMHD, _ParsersVolume);

  function ParsersMHD(data, id) {
    _classCallCheck(this, ParsersMHD);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersMHD.__proto__ || Object.getPrototypeOf(ParsersMHD)).call(this));

    _this._id = id;
    _this._url = data.url;
    _this._header = {};
    _this._buffer = null;

    try {
      // parse header (mhd) data
      var lines = new TextDecoder().decode(data.mhdBuffer).split('\n');
      lines.forEach(function (line) {
        var keyvalue = line.split('=');
        if (keyvalue.length === 2) {
          _this._header[keyvalue[0].trim()] = keyvalue[1].trim();
        }
      });

      _this._header.DimSize = _this._header.DimSize.split(' ');
      _this._header.ElementSpacing = _this._header.ElementSpacing.split(' ');
      _this._header.TransformMatrix = _this._header.TransformMatrix.split(' ');
      _this._header.Offset = _this._header.Offset.split(' ');
      //
      _this._buffer = data.rawBuffer;
    } catch (error) {
      window.console.log('ooops... :(');
    }
    return _this;
  }

  _createClass(ParsersMHD, [{
    key: 'rightHanded',
    value: function rightHanded() {
      var anatomicalOrientation = this._header.AnatomicalOrientation;
      if (anatomicalOrientation === 'RAS' || anatomicalOrientation === 'RPI' || anatomicalOrientation === 'LPS' || anatomicalOrientation === 'LAI') {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return parseInt(this._header.DimSize[2], 10);
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[1], 10);
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return parseInt(this._header.DimSize[0], 10);
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      return 0;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._header.ElementType === 'MET_UCHAR' || this._header.ElementType === 'MET_CHAR') {
        bitsAllocated = 8;
      } else if (this._header.ElementType === 'MET_USHORT' || this._header.ElementType === 'MET_SHORT') {
        bitsAllocated = 16;
      } else if (this._header.ElementType === 'MET_UFLOAT' || this._header.ElementType === 'MET_FLOAT') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = parseFloat(this._header.ElementSpacing[0], 10);
      var y = parseFloat(this._header.ElementSpacing[1], 10);
      var z = parseFloat(this._header.ElementSpacing[2], 10);
      return [x, y, z];
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._header.AnatomicalOrientation.match(/L/) ? -1 : 1;
      var invertY = this._header.AnatomicalOrientation.match(/P/) ? -1 : 1;

      var x = new THREE.Vector3(parseFloat(this._header.TransformMatrix[0]) * invertX, parseFloat(this._header.TransformMatrix[1]) * invertY, parseFloat(this._header.TransformMatrix[2]));
      x.normalize();

      var y = new THREE.Vector3(parseFloat(this._header.TransformMatrix[3]) * invertX, parseFloat(this._header.TransformMatrix[4]) * invertY, parseFloat(this._header.TransformMatrix[5]));
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [parseFloat(this._header.Offset[0]), parseFloat(this._header.Offset[1]), parseFloat(this._header.Offset[2])];
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      if (this._header.ElementType === 'MET_CHAR') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_UCHAR') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_SHORT') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_USHORT') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._header.ElementType === 'MET_FLOAT') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersMHD;
}(_parsers2.default);

exports.default = ParsersMHD;

},{"./parsers.volume":141}],139:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/


var NiftiReader = require('nifti-reader-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._niftiHeader = null;
    _this._niftiImage = null;
    _this._ordered = true;
    _this._orderedData = null;

    //
    _this._qfac = 1.0;

    if (NiftiReader.isNIFTI(_this._arrayBuffer)) {
      _this._dataSet = NiftiReader.readHeader(_this._arrayBuffer);
      _this._niftiImage = NiftiReader.readImage(_this._dataSet, _this._arrayBuffer);
    } else {
      throw 'parsers.nifti could not parse the file';
    }
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.dims[3];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;

      // can dims[0] >= 5 and not multi channels with RGB datatypecode?

      if (this._dataSet.dims[0] >= 5) {
        numberOfChannels = this._dataSet.dims[5];
        this._ordered = false;
      } else if (this._dataSet.datatypeCode === 128) {
        numberOfChannels = 3;
      } else if (this._dataSet.datatypeCode === 2304) {
        numberOfChannels = 4;
      }

      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[2];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.dims[1];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      // 0 integer, 1 float

      var pixelType = 0;
      if (this._dataSet.datatypeCode === 16 || this._dataSet.datatypeCode === 64 || this._dataSet.datatypeCode === 1536) {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.numBitsPerVoxel;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.pixDims[1], this._dataSet.pixDims[2], this._dataSet.pixDims[3]];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // window.console.log(this._dataSet);
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
      // http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c
      if (this._dataSet.qform_code > 0) {
        // https://github.com/Kitware/ITK/blob/master/Modules/IO/NIFTI/src/itkNiftiImageIO.cxx
        var a = 0.0;
        var b = this._dataSet.quatern_b;
        var c = this._dataSet.quatern_c;
        var d = this._dataSet.quatern_d;
        // compute a
        a = 1.0 - (b * b + c * c + d * d);
        if (a < 0.0000001) {
          /* special case */

          a = 1.0 / Math.sqrt(b * b + c * c + d * d);
          b *= a;c *= a;d *= a; /* normalize (b,c,d) vector */
          a = 0.0; /* a = 0 ==> 180 degree rotation */
        } else {
          a = Math.sqrt(a); /* angle = 2*arccos(a) */
        }

        if (this._dataSet.pixDims[0] < 0.0) {
          this._rightHanded = false;
        }

        return [-(a * a + b * b - c * c - d * d), -2 * (b * c + a * d), 2 * (b * d - a * c), -2 * (b * c - a * d), -(a * a + c * c - b * b - d * d), 2 * (c * d + a * b)];
      } else if (this._dataSet.sform_code > 0) {
        console.log('sform > 0');

        var sx = this._dataSet.srow_x;
        var sy = this._dataSet.srow_y;
        var sz = this._dataSet.srow_z;
        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, sx[0], sx[1], sx[2], sx[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, sy[0], sy[1], sy[2], sy[3]);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, sz[0], sz[1], sz[2], sz[3]);
      } else if (this._dataSet.qform_code === 0) {
        console.log('qform === 0');

        // fill IJKToRAS
        // goog.vec.Mat4.setRowValues(IJKToRAS, 0, MRI.pixdim[1], 0, 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 1, 0, MRI.pixdim[2], 0, 0);
        // goog.vec.Mat4.setRowValues(IJKToRAS, 2, 0, 0, MRI.pixdim[3], 0);
      }
      return [1, 0, 0, 0, 1, 0];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // qoffset is RAS
      return [-this._dataSet.qoffset_x, -this._dataSet.qoffset_y, this._dataSet.qoffset_z];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
      // let buffer = this._dataSet.imageData;
      // if (this._dataSet.compressed) {
      // let buffer = this._dataSet.rawData[0];
      // try {
      //   let data = pako.inflate(new Uint8Array(buffer));
      //   buffer = data.buffer;
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(buffer);
      // }

      // is it compressed?
      // yes/no

      //     try {
      //   var result = pako.inflate(compressed);
      // } catch (err) {
      //   console.log(err);
      // }

      // window.console.log(this);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // papaya.volume.nifti.NIFTI_TYPE_UINT8           = 2;
      // papaya.volume.nifti.NIFTI_TYPE_INT16           = 4;
      // papaya.volume.nifti.NIFTI_TYPE_INT32           = 8;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT32        = 16;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX64      = 32;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT64        = 64;
      // papaya.volume.nifti.NIFTI_TYPE_RGB24         = 128;
      // papaya.volume.nifti.NIFTI_TYPE_INT8          = 256;
      // papaya.volume.nifti.NIFTI_TYPE_UINT16        = 512;
      // papaya.volume.nifti.NIFTI_TYPE_UINT32        = 768;
      // papaya.volume.nifti.NIFTI_TYPE_INT64        = 1024;
      // papaya.volume.nifti.NIFTI_TYPE_UINT64       = 1280;
      // papaya.volume.nifti.NIFTI_TYPE_FLOAT128     = 1536;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX128   = 1792;
      // papaya.volume.nifti.NIFTI_TYPE_COMPLEX256   = 2048;

      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      // if( !this.rightHanded() ){
      //   frameIndex = this.numberOfFrames() - 1 - frameIndex;
      // }
      var frameOffset = frameIndex * numPixels;
      var buffer = this._niftiImage;

      // use bits allocated && pixel reprensentation too
      if (!this._ordered && this._orderedData === null) {
        // order then
        this._reorderData();
      }

      if (this._orderedData !== null) {
        // just a slice...
        return this._orderedData.slice(frameOffset, frameOffset + numPixels);
      } else if (this._dataSet.datatypeCode === 2) {
        // unsigned int 8 bit
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed int 8 bit
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 512) {
        // unsigned int 16 bit
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 4) {
        // signed int 16 bit
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 8) {
        // signed int 32 bit
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.datatypeCode === 16) {
        // signed float 32 bit
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      } else {
        console.log('Unknown data type: datatypeCode : ' + this._dataSet.datatypeCode);
      }
    }
  }, {
    key: '_reorderData',
    value: function _reorderData() {
      window.console.log('re-order');
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows() * this.columns() * numberOfChannels;
      var buffer = this._niftiImage;

      var totalNumPixels = numPixels * this.numberOfFrames();
      var tmp = null;
      this._orderedData = null;

      if (this._dataSet.datatypeCode === 2) {
        // unsigned 8 bit
        tmp = new Uint8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 256) {
        // signed 8 bit
        tmp = new Int8Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int8Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 512) {
        tmp = new Uint16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Uint16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 4) {
        tmp = new Int16Array(buffer, 0, totalNumPixels);
        this._orderedData = new Int16Array(tmp.length);
      } else if (this._dataSet.datatypeCode === 16) {
        tmp = new Float32Array(buffer, 0, totalNumPixels);
        this._orderedData = new Float32Array(tmp.length);
      }

      // re-order pixels...
      var numPixels2 = tmp.length / 3;
      var rgbaIndex = 0;
      var rIndex = 0;
      var gIndex = numPixels2;
      var bIndex = numPixels2 * 2;

      for (var i = 0; i < numPixels2; i++) {
        this._orderedData[rgbaIndex++] = tmp[rIndex++]; // red
        this._orderedData[rgbaIndex++] = tmp[gIndex++]; // green
        this._orderedData[rgbaIndex++] = tmp[bIndex++]; // blue
      }

      this._ordered = true;
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nifti-reader-js":46}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parsers = require('./parsers.volume');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // use nifti-js and just parse header.???

// Slicer way to handle images
// should follow it...
// 897   if ( (this->IndexSeriesInstanceUIDs[k] != idxSeriesInstanceUID && this->IndexSeriesInstanceUIDs[k] >= 0 && idxSeriesInstanceUID >= 0) ||
// 898        (this->IndexContentTime[k] != idxContentTime && this->IndexContentTime[k] >= 0 && idxContentTime >= 0) ||
// 899        (this->IndexTriggerTime[k] != idxTriggerTime && this->IndexTriggerTime[k] >= 0 && idxTriggerTime >= 0) ||
// 900        (this->IndexEchoNumbers[k] != idxEchoNumbers && this->IndexEchoNumbers[k] >= 0 && idxEchoNumbers >= 0) ||
// 901        (this->IndexDiffusionGradientOrientation[k] != idxDiffusionGradientOrientation  && this->IndexDiffusionGradientOrientation[k] >= 0 && idxDiffusionGradientOrientation >= 0) ||
// 902        (this->IndexSliceLocation[k] != idxSliceLocation && this->IndexSliceLocation[k] >= 0 && idxSliceLocation >= 0) ||
// 903        (this->IndexImageOrientationPatient[k] != idxImageOrientationPatient && this->IndexImageOrientationPatient[k] >= 0 && idxImageOrientationPatient >= 0) )
// 904     {
// 905       continue;
// 906     }

// http://brainder.org/2012/09/23/the-nifti-file-format/

/** * Imports ***/


var pako = require('pako');
var NrrdReader = require('nrrd-js');
/**
 * @module parsers/nifti
 */

var ParsersNifti = function (_ParsersVolume) {
  _inherits(ParsersNifti, _ParsersVolume);

  function ParsersNifti(data, id) {
    _classCallCheck(this, ParsersNifti);

    /**
      * @member
      * @type {arraybuffer}
    */
    var _this = _possibleConstructorReturn(this, (ParsersNifti.__proto__ || Object.getPrototypeOf(ParsersNifti)).call(this));

    _this._id = id;
    _this._arrayBuffer = data.buffer;
    _this._url = data.url;
    _this._dataSet = null;
    _this._unpackedData = null;

    try {
      _this._dataSet = NrrdReader.parse(_this._arrayBuffer);
      console.log(_this._dataSet);
    } catch (error) {
      window.console.log('ooops... :(');
    }

    window.console.log(_this._dataSet);
    return _this;
  }

  _createClass(ParsersNifti, [{
    key: 'rightHanded',
    value: function rightHanded() {
      if (this._dataSet.space.match(/^right-anterior-superior/) || this._dataSet.space.match(/^left-posterior-superior/)) {
        this._rightHanded = true;
      } else {
        this._rightHanded = false;
      }

      return this._rightHanded;
    }
  }, {
    key: 'seriesInstanceUID',
    value: function seriesInstanceUID() {
      // use filename + timestamp..?
      return this._url;
    }
  }, {
    key: 'numberOfFrames',
    value: function numberOfFrames() {
      return this._dataSet.sizes[2];
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      var numberOfChannels = 1;
      return numberOfChannels;
    }
  }, {
    key: 'sopInstanceUID',
    value: function sopInstanceUID() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'rows',
    value: function rows() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[1];
    }
  }, {
    key: 'columns',
    value: function columns() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._dataSet.sizes[0];
    }
  }, {
    key: 'pixelType',
    value: function pixelType() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // 0 - int
      // 1 - float
      var pixelType = 0;
      if (this._dataSet.type === 'float') {
        pixelType = 1;
      }
      return pixelType;
    }
  }, {
    key: 'bitsAllocated',
    value: function bitsAllocated() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var bitsAllocated = 1;

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'uint8' || this._dataSet.type === 'char') {
        bitsAllocated = 8;
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'uint16' || this._dataSet.type === 'short') {
        bitsAllocated = 16;
      } else if (this._dataSet.type === 'int32' || this._dataSet.type === 'uint32' || this._dataSet.type === 'float') {
        bitsAllocated = 32;
      }

      return bitsAllocated;
    }
  }, {
    key: 'pixelSpacing',
    value: function pixelSpacing() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0], this._dataSet.spaceDirections[0][1], this._dataSet.spaceDirections[0][2]);

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0], this._dataSet.spaceDirections[1][1], this._dataSet.spaceDirections[1][2]);

      var z = new THREE.Vector3(this._dataSet.spaceDirections[2][0], this._dataSet.spaceDirections[2][1], this._dataSet.spaceDirections[2][2]);

      return [x.length(), y.length(), z.length()];
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      // should be a string...
      return null; // this._dataSet.pixDims[3].toString();
    }
  }, {
    key: 'imageOrientation',
    value: function imageOrientation() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var invertX = this._dataSet.space.match(/right/) ? -1 : 1;
      var invertY = this._dataSet.space.match(/anterior/) ? -1 : 1;

      var x = new THREE.Vector3(this._dataSet.spaceDirections[0][0] * invertX, this._dataSet.spaceDirections[0][1] * invertY, this._dataSet.spaceDirections[0][2]);
      x.normalize();

      var y = new THREE.Vector3(this._dataSet.spaceDirections[1][0] * invertX, this._dataSet.spaceDirections[1][1] * invertY, this._dataSet.spaceDirections[1][2]);
      y.normalize();

      return [x.x, x.y, x.z, y.x, y.y, y.z];
    }
  }, {
    key: 'imagePosition',
    value: function imagePosition() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return [this._dataSet.spaceOrigin[0], this._dataSet.spaceOrigin[1], this._dataSet.spaceOrigin[2]];
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // calc min and calc max
      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1; // this._dataSet.scl_slope;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0; // this._dataSet.scl_intercept;
    }
  }, {
    key: 'minMaxPixelData',
    value: function minMaxPixelData() {
      var pixelData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var minMax = [65535, -32768];
      var numPixels = pixelData.length;
      for (var index = 0; index < numPixels; index++) {
        var spv = pixelData[index];
        minMax[0] = Math.min(minMax[0], spv);
        minMax[1] = Math.max(minMax[1], spv);
      }

      return minMax;
    }
  }, {
    key: 'extractPixelData',
    value: function extractPixelData() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this._decompressUncompressed(frameIndex);
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var buffer = this._dataSet.buffer;
      var numberOfChannels = this.numberOfChannels();
      var numPixels = this.rows(frameIndex) * this.columns(frameIndex) * numberOfChannels;
      if (!this.rightHanded()) {
        frameIndex = this.numberOfFrames() - 1 - frameIndex;
      }
      var frameOffset = frameIndex * numPixels;

      // unpack data if needed
      if (this._unpackedData === null && this._dataSet.encoding === 'gzip') {
        var unpackedData = pako.inflate(this._dataSet.buffer);
        this._unpackedData = unpackedData.buffer;
        buffer = this._unpackedData;
      } else if (this._dataSet.encoding === 'gzip') {
        buffer = this._unpackedData;
      }

      if (this._dataSet.type === 'int8' || this._dataSet.type === 'char') {
        frameOffset = frameOffset;
        return new Int8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint8') {
        frameOffset = frameOffset;
        return new Uint8Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int16' || this._dataSet.type === 'short') {
        frameOffset = frameOffset * 2;
        return new Int16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint16') {
        frameOffset = frameOffset * 2;
        return new Uint16Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'int32') {
        frameOffset = frameOffset * 4;
        return new Int32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'uint32') {
        frameOffset = frameOffset * 4;
        return new Uint32Array(buffer, frameOffset, numPixels);
      } else if (this._dataSet.type === 'float') {
        frameOffset = frameOffset * 4;
        return new Float32Array(buffer, frameOffset, numPixels);
      }
    }
  }]);

  return ParsersNifti;
}(_parsers2.default);

exports.default = ParsersNifti;

},{"./parsers.volume":141,"nrrd-js":50,"pako":51}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module parsers/volume
 */
var ParsersVolume = function () {
  function ParsersVolume() {
    _classCallCheck(this, ParsersVolume);

    this._rightHanded = true;
  }

  _createClass(ParsersVolume, [{
    key: 'pixelRepresentation',
    value: function pixelRepresentation() {
      return 0;
    }
  }, {
    key: 'modality',
    value: function modality() {
      return 'unknown';
    }
  }, {
    key: 'segmentationType',
    value: function segmentationType() {
      return 'unknown';
    }
  }, {
    key: 'segmentationSegments',
    value: function segmentationSegments() {
      return [];
    }
  }, {
    key: 'referencedSegmentNumber',
    value: function referencedSegmentNumber(frameIndex) {
      return -1;
    }
  }, {
    key: 'rightHanded',
    value: function rightHanded() {
      return this._rightHanded;
    }
  }, {
    key: 'spacingBetweenSlices',
    value: function spacingBetweenSlices() {
      return null;
    }
  }, {
    key: 'numberOfChannels',
    value: function numberOfChannels() {
      return 1;
    }
  }, {
    key: 'sliceThickness',
    value: function sliceThickness() {
      return null;
    }
  }, {
    key: 'dimensionIndexValues',
    value: function dimensionIndexValues() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'instanceNumber',
    value: function instanceNumber() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return frameIndex;
    }
  }, {
    key: 'windowCenter',
    value: function windowCenter() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'windowWidth',
    value: function windowWidth() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return null;
    }
  }, {
    key: 'rescaleSlope',
    value: function rescaleSlope() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 1;
    }
  }, {
    key: 'rescaleIntercept',
    value: function rescaleIntercept() {
      var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return 0;
    }
  }, {
    key: '_decompressUncompressed',
    value: function _decompressUncompressed() {}

    // http://stackoverflow.com/questions/5320439/how-do-i-swap-endian-ness-byte-order-of-a-variable-in-javascript

  }, {
    key: '_swap16',
    value: function _swap16(val) {
      return (val & 0xFF) << 8 | val >> 8 & 0xFF;
    }
  }, {
    key: '_swap32',
    value: function _swap32(val) {
      return (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;
    }
  }, {
    key: 'invert',
    value: function invert() {
      return false;
    }

    /**
     * Get the transfer syntax UID.
     * @return {*}
     */

  }, {
    key: 'transferSyntaxUID',
    value: function transferSyntaxUID() {
      return 'no value provided';
    }

    /**
     * Get the study desciption.
     * @return {*}
     */

  }, {
    key: 'studyDescription',
    value: function studyDescription() {
      return 'no value provided';
    }

    /**
     * Get the series desciption.
     * @return {*}
     */

  }, {
    key: 'seriesDescription',
    value: function seriesDescription() {
      return 'no value provided';
    }

    /**
     * Get the patient ID.
     * @return {*}
     */

  }, {
    key: 'patientID',
    value: function patientID() {
      return 'no value provided';
    }

    /**
     * Get the patient name.
     * @return {*}
     */

  }, {
    key: 'patientName',
    value: function patientName() {
      return 'no value provided';
    }

    /**
     * Get the patient age.
     * @return {*}
     */

  }, {
    key: 'patientAge',
    value: function patientAge() {
      return 'no value provided';
    }

    /**
     * Get the patient birthdate.
     * @return {*}
     */

  }, {
    key: 'patientBirthdate',
    value: function patientBirthdate() {
      return 'no value provided';
    }

    /**
     * Get the patient sex.
     * @return {*}
     */

  }, {
    key: 'patientSex',
    value: function patientSex() {
      return 'no value provided';
    }
  }]);

  return ParsersVolume;
}();

exports.default = ParsersVolume;

},{}],142:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IntersectBox = function (_ShadersBase) {
  _inherits(IntersectBox, _ShadersBase);

  function IntersectBox() {
    _classCallCheck(this, IntersectBox);

    var _this = _possibleConstructorReturn(this, (IntersectBox.__proto__ || Object.getPrototypeOf(IntersectBox)).call(this));

    _this.name = 'intersectBox';

    // default properties names
    _this._rayOrigin = 'rayOrigin';
    _this._rayDirection = 'rayDirection';
    _this._aabbMin = 'aabbMin';
    _this._aabbMax = 'aabbMax';
    _this._tNear = 'tNear';
    _this._tFar = 'tFar';
    _this._intersect = 'intersect';
    return _this;
  }

  _createClass(IntersectBox, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var rayOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._rayOrigin;
      var rayDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._rayDirection;
      var aabbMin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._aabbMin;
      var aabbMax = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._aabbMax;
      var tNear = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this._tNear;
      var tFar = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._tFar;
      var intersect = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this._intersect;

      this._base = baseFragment;
      return this.compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect);
    }
  }, {
    key: 'compute',
    value: function compute(rayOrigin, rayDirection, aabbMin, aabbMax, tNear, tFar, intersect) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + rayOrigin + ', ' + rayDirection + ', ' + aabbMin + ', ' + aabbMax + ', ' + tNear + ', ' + tFar + ', ' + intersect + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(vec3 rayOrigin, vec3 rayDirection, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar, out bool intersect){\n  // compute intersection of ray with all six bbox planes\n  vec3 invRay = vec3(1.) / rayDirection;\n  vec3 tBot = invRay * (boxMin - rayOrigin);\n  vec3 tTop = invRay * (boxMax - rayOrigin);\n  // re-order intersections to find smallest and largest on each axis\n  vec3 tMin = min(tTop, tBot);\n  vec3 tMax = max(tTop, tBot);\n  // find the largest tMin and the smallest tMax\n  float largest_tMin = max(max(tMin.x, tMin.y), max(tMin.x, tMin.z));\n  float smallest_tMax = min(min(tMax.x, tMax.y), min(tMax.x, tMax.z));\n  tNear = largest_tMin;\n  tFar = smallest_tMax;\n  intersect = smallest_tMax > largest_tMin;\n}\n\n    ';
    }
  }]);

  return IntersectBox;
}(_shaders2.default);

exports.default = new IntersectBox();

},{"../shaders.base":148}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Texture3d = function (_ShadersBase) {
  _inherits(Texture3d, _ShadersBase);

  function Texture3d() {
    _classCallCheck(this, Texture3d);

    var _this = _possibleConstructorReturn(this, (Texture3d.__proto__ || Object.getPrototypeOf(Texture3d)).call(this));

    _this.name = 'texture3d';

    // default properties names
    _this._dataCoordinates = 'dataCoordinates';
    _this._dataValue = 'dataValue';
    _this._offset = 'offset';
    return _this;
  }

  _createClass(Texture3d, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var dataCoordinates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataCoordinates;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._offset;

      this._base = baseFragment;
      return this.compute(dataCoordinates, dataValue, offset);
    }
  }, {
    key: 'compute',
    value: function compute(dataCoordinates, dataValue, offset) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + dataCoordinates + ', ' + dataValue + ', ' + offset + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in ivec3 dataCoordinates, out vec4 dataValue, out int offset){\n    \n  int index = dataCoordinates.x\n            + dataCoordinates.y * uDataDimensions.x\n            + dataCoordinates.z * uDataDimensions.y * uDataDimensions.x;\n  int indexP = int(index/uPackedPerPixel);\n  offset = index - 2*indexP;\n\n  // Map data index to right sampler2D texture\n  int voxelsPerTexture = uTextureSize*uTextureSize;\n  int textureIndex = int(floor(float(indexP) / float(voxelsPerTexture)));\n  // modulo seems incorrect sometimes...\n  // int inTextureIndex = int(mod(float(index), float(textureSize*textureSize)));\n  int inTextureIndex = indexP - voxelsPerTexture*textureIndex;\n\n  // Get row and column in the texture\n  int colIndex = int(mod(float(inTextureIndex), float(uTextureSize)));\n  int rowIndex = int(floor(float(inTextureIndex)/float(uTextureSize)));\n\n  // Map row and column to uv\n  vec2 uv = vec2(0,0);\n  uv.x = (0.5 + float(colIndex)) / float(uTextureSize);\n  uv.y = 1. - (0.5 + float(rowIndex)) / float(uTextureSize);\n\n  //\n  if(textureIndex == 0){ dataValue = texture2D(uTextureContainer[0], uv); }\n  else if(textureIndex == 1){dataValue = texture2D(uTextureContainer[1], uv);}\n  else if(textureIndex == 2){ dataValue = texture2D(uTextureContainer[2], uv); }\n  else if(textureIndex == 3){ dataValue = texture2D(uTextureContainer[3], uv); }\n  else if(textureIndex == 4){ dataValue = texture2D(uTextureContainer[4], uv); }\n  else if(textureIndex == 5){ dataValue = texture2D(uTextureContainer[5], uv); }\n  else if(textureIndex == 6){ dataValue = texture2D(uTextureContainer[6], uv); }\n\n}\n    ';
    }
  }]);

  return Texture3d;
}(_shaders2.default);

exports.default = new Texture3d();

},{"../shaders.base":148}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Unpack = function (_ShadersBase) {
  _inherits(Unpack, _ShadersBase);

  function Unpack() {
    _classCallCheck(this, Unpack);

    var _this = _possibleConstructorReturn(this, (Unpack.__proto__ || Object.getPrototypeOf(Unpack)).call(this));

    _this.name = 'unpack';

    // default properties names
    _this._packedData = 'packedData';
    _this._offset = 'offset';
    _this._unpackedData = 'unpackedData';

    _this._base._uniforms = {
      uNumberOfChannels: {
        value: 1
      },
      uBitsAllocated: {
        value: 16
      },
      uPixelType: {
        value: 0
      }
    };
    return _this;
  }

  _createClass(Unpack, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var packedData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._packedData;
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._offset;
      var unpackedData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._unpackedData;

      this._base = baseFragment;
      return this.compute(packedData, offset, unpackedData);
    }
  }, {
    key: 'compute',
    value: function compute(packedData, offset, unpackedData) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + packedData + ', ' + offset + ', ' + unpackedData + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      // fun stuff
      var content = '';
      if (this._base._uniforms.uNumberOfChannels.value === 1) {
        switch (this._base._uniforms.uBitsAllocated.value) {

          case 1:
          case 8:
            content = this.upack8();
            break;

          case 16:
            content = this.upack16();
            break;

          case 32:
            content = this.upack32();
            break;

          default:
            content = this.upackDefault();
            break;

        }
      } else {
        content = this.upackIdentity();
      }

      this._definition = '\nvoid ' + this._name + '(in vec4 packedData, in int offset, out vec4 unpackedData){\n\n' + content + '\n\n}  \n    ';
    }
  }, {
    key: 'upack8',
    value: function upack8() {
      this._base._functions['uInt8'] = this.uInt8();

      return '\nuInt8(\n  packedData.r,\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack16',
    value: function upack16() {
      this._base._functions['uInt16'] = this.uInt16();

      return '\nuInt16(\n  packedData.r * float( 1 - offset) + packedData.b * float(offset),\n  packedData.g * float( 1 - offset) + packedData.a * float(offset),\n  unpackedData.x);\n    ';
    }
  }, {
    key: 'upack32',
    value: function upack32() {
      if (this._base._uniforms.uPixelType.value === 0) {
        this._base._functions['uInt32'] = this.uInt32();

        return '\nuInt32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      } else {
        this._base._functions['uFloat32'] = this.uFloat32();

        return '\nuFloat32(\n  packedData.r,\n  packedData.g,\n  packedData.b,\n  packedData.a,\n  unpackedData.x);\n      ';
      }
    }
  }, {
    key: 'upackIdentity',
    value: function upackIdentity() {
      return '\n\nunpackedData = packedData;\n\n      ';
    }
  }, {
    key: 'uInt8',
    value: function uInt8() {
      return '\nvoid uInt8(in float r, out float value){\n  value = r * 256.;\n}\n    ';
    }
  }, {
    key: 'uInt16',
    value: function uInt16() {
      return '\nvoid uInt16(in float r, in float a, out float value){\n  value = r * 256. + a * 65536.;\n}\n    ';
    }
  }, {
    key: 'uInt32',
    value: function uInt32() {
      return '\nvoid uInt32(in float r, in float g, in float b, in float a, out float value){\n  value = r * 256. + g * 65536. + b * 16777216. + a * 4294967296.;\n}\n    ';
    }
  }, {
    key: 'uFloat32',
    value: function uFloat32() {
      return '\nvoid uFloat32(in float r, in float g, in float b, in float a, out float value){\n\n  // create arrays containing bits for rgba values\n  // value between 0 and 255\n  value = r * 255.;\n  int bytemeR[8];\n  bytemeR[0] = int(floor(value / 128.));\n  value -= float(bytemeR[0] * 128);\n  bytemeR[1] = int(floor(value / 64.));\n  value -= float(bytemeR[1] * 64);\n  bytemeR[2] = int(floor(value / 32.));\n  value -= float(bytemeR[2] * 32);\n  bytemeR[3] = int(floor(value / 16.));\n  value -= float(bytemeR[3] * 16);\n  bytemeR[4] = int(floor(value / 8.));\n  value -= float(bytemeR[4] * 8);\n  bytemeR[5] = int(floor(value / 4.));\n  value -= float(bytemeR[5] * 4);\n  bytemeR[6] = int(floor(value / 2.));\n  value -= float(bytemeR[6] * 2);\n  bytemeR[7] = int(floor(value));\n\n  value = g * 255.;\n  int bytemeG[8];\n  bytemeG[0] = int(floor(value / 128.));\n  value -= float(bytemeG[0] * 128);\n  bytemeG[1] = int(floor(value / 64.));\n  value -= float(bytemeG[1] * 64);\n  bytemeG[2] = int(floor(value / 32.));\n  value -= float(bytemeG[2] * 32);\n  bytemeG[3] = int(floor(value / 16.));\n  value -= float(bytemeG[3] * 16);\n  bytemeG[4] = int(floor(value / 8.));\n  value -= float(bytemeG[4] * 8);\n  bytemeG[5] = int(floor(value / 4.));\n  value -= float(bytemeG[5] * 4);\n  bytemeG[6] = int(floor(value / 2.));\n  value -= float(bytemeG[6] * 2);\n  bytemeG[7] = int(floor(value));\n\n  value = b * 255.;\n  int bytemeB[8];\n  bytemeB[0] = int(floor(value / 128.));\n  value -= float(bytemeB[0] * 128);\n  bytemeB[1] = int(floor(value / 64.));\n  value -= float(bytemeB[1] * 64);\n  bytemeB[2] = int(floor(value / 32.));\n  value -= float(bytemeB[2] * 32);\n  bytemeB[3] = int(floor(value / 16.));\n  value -= float(bytemeB[3] * 16);\n  bytemeB[4] = int(floor(value / 8.));\n  value -= float(bytemeB[4] * 8);\n  bytemeB[5] = int(floor(value / 4.));\n  value -= float(bytemeB[5] * 4);\n  bytemeB[6] = int(floor(value / 2.));\n  value -= float(bytemeB[6] * 2);\n  bytemeB[7] = int(floor(value));\n\n  value = a * 255.;\n  int bytemeA[8];\n  bytemeA[0] = int(floor(value / 128.));\n  value -= float(bytemeA[0] * 128);\n  bytemeA[1] = int(floor(value / 64.));\n  value -= float(bytemeA[1] * 64);\n  bytemeA[2] = int(floor(value / 32.));\n  value -= float(bytemeA[2] * 32);\n  bytemeA[3] = int(floor(value / 16.));\n  value -= float(bytemeA[3] * 16);\n  bytemeA[4] = int(floor(value / 8.));\n  value -= float(bytemeA[4] * 8);\n  bytemeA[5] = int(floor(value / 4.));\n  value -= float(bytemeA[5] * 4);\n  bytemeA[6] = int(floor(value / 2.));\n  value -= float(bytemeA[6] * 2);\n  bytemeA[7] = int(floor(value));\n\n  // compute float32 value from bit arrays\n\n  // sign\n  int issigned = 1 - 2 * bytemeR[0];\n  //   issigned = int(pow(-1., float(bytemeR[0])));\n\n  // exponent\n  int exponent = 0;\n\n  exponent += bytemeR[1] * int(pow(2., 7.));\n  exponent += bytemeR[2] * int(pow(2., 6.));\n  exponent += bytemeR[3] * int(pow(2., 5.));\n  exponent += bytemeR[4] * int(pow(2., 4.));\n  exponent += bytemeR[5] * int(pow(2., 3.));\n  exponent += bytemeR[6] * int(pow(2., 2.));\n  exponent += bytemeR[7] * int(pow(2., 1.));\n\n  exponent += bytemeG[0];\n\n\n  // fraction\n  float fraction = 0.;\n\n  fraction = float(bytemeG[1]) * pow(2., -1.);\n  fraction += float(bytemeG[2]) * pow(2., -2.);\n  fraction += float(bytemeG[3]) * pow(2., -3.);\n  fraction += float(bytemeG[4]) * pow(2., -4.);\n  fraction += float(bytemeG[5]) * pow(2., -5.);\n  fraction += float(bytemeG[6]) * pow(2., -6.);\n  fraction += float(bytemeG[7]) * pow(2., -7.);\n\n  fraction += float(bytemeB[0]) * pow(2., -8.);\n  fraction += float(bytemeB[1]) * pow(2., -9.);\n  fraction += float(bytemeB[2]) * pow(2., -10.);\n  fraction += float(bytemeB[3]) * pow(2., -11.);\n  fraction += float(bytemeB[4]) * pow(2., -12.);\n  fraction += float(bytemeB[5]) * pow(2., -13.);\n  fraction += float(bytemeB[6]) * pow(2., -14.);\n  fraction += float(bytemeB[7]) * pow(2., -15.);\n\n  fraction += float(bytemeA[0]) * pow(2., -16.);\n  fraction += float(bytemeA[1]) * pow(2., -17.);\n  fraction += float(bytemeA[2]) * pow(2., -18.);\n  fraction += float(bytemeA[3]) * pow(2., -19.);\n  fraction += float(bytemeA[4]) * pow(2., -20.);\n  fraction += float(bytemeA[5]) * pow(2., -21.);\n  fraction += float(bytemeA[6]) * pow(2., -22.);\n  fraction += float(bytemeA[7]) * pow(2., -23.);\n\n  value = float(issigned) * pow( 2., float(exponent - 127)) * (1. + fraction);\n}\n    ';
    }
  }]);

  return Unpack;
}(_shaders2.default);

exports.default = new Unpack();

},{"../shaders.base":148}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('../helpers/shaders.helpers.unpack');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

var _shadersHelpers3 = require('../helpers/shaders.helpers.texture3d');

var _shadersHelpers4 = _interopRequireDefault(_shadersHelpers3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InterpolationIdentity = function (_ShadersBase) {
  _inherits(InterpolationIdentity, _ShadersBase);

  function InterpolationIdentity() {
    _classCallCheck(this, InterpolationIdentity);

    var _this = _possibleConstructorReturn(this, (InterpolationIdentity.__proto__ || Object.getPrototypeOf(InterpolationIdentity)).call(this));

    _this.name = 'interpolationIdentity';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    return _this;
  }

  _createClass(InterpolationIdentity, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue){\n  // lower bound\n  vec3 rcurrentVoxel = vec3(floor(currentVoxel.x + 0.5 ), floor(currentVoxel.y + 0.5 ), floor(currentVoxel.z + 0.5 ));\n  ivec3 voxel = ivec3(int(rcurrentVoxel.x), int(rcurrentVoxel.y), int(rcurrentVoxel.z));\n\n  vec4 tmp = vec4(0., 0., 0., 0.);\n  int offset = 0;\n\n  ' + _shadersHelpers4.default.api(this._base, 'voxel', 'tmp', 'offset') + '\n  ' + _shadersHelpers2.default.api(this._base, 'tmp', 'offset', 'dataValue') + '\n}\n    ';
    }
  }]);

  return InterpolationIdentity;
}(_shaders2.default);

exports.default = new InterpolationIdentity();

},{"../helpers/shaders.helpers.texture3d":143,"../helpers/shaders.helpers.unpack":144,"../shaders.base":148}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

var _shadersInterpolation3 = require('./shaders.interpolation.trilinear');

var _shadersInterpolation4 = _interopRequireDefault(_shadersInterpolation3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shadersInterpolation(baseFragment, currentVoxel, dataValue, gradient) {
  switch (baseFragment._uniforms.uInterpolation.value) {

    case 0:
      // no interpolation
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

    case 1:
      // trilinear interpolation
      return _shadersInterpolation4.default.api(baseFragment, currentVoxel, dataValue, gradient);

    default:
      return _shadersInterpolation2.default.api(baseFragment, currentVoxel, dataValue);

  }
}

exports.default = shadersInterpolation;

},{"./shaders.interpolation.identity":145,"./shaders.interpolation.trilinear":147}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('../shaders.base');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersInterpolation = require('./shaders.interpolation.identity');

var _shadersInterpolation2 = _interopRequireDefault(_shadersInterpolation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InterpolationTrilinear = function (_ShadersBase) {
  _inherits(InterpolationTrilinear, _ShadersBase);

  function InterpolationTrilinear() {
    _classCallCheck(this, InterpolationTrilinear);

    var _this = _possibleConstructorReturn(this, (InterpolationTrilinear.__proto__ || Object.getPrototypeOf(InterpolationTrilinear)).call(this));

    _this.name = 'interpolationTrilinear';

    // default properties names
    _this._currentVoxel = 'currentVoxel';
    _this._dataValue = 'dataValue';
    _this._gradient = 'gradient';
    return _this;
  }

  _createClass(InterpolationTrilinear, [{
    key: 'api',
    value: function api() {
      var baseFragment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._base;
      var currentVoxel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._currentVoxel;
      var dataValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dataValue;
      var gradient = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._gradient;

      this._base = baseFragment;
      return this.compute(currentVoxel, dataValue, gradient);
    }
  }, {
    key: 'compute',
    value: function compute(currentVoxel, dataValue, gradient) {
      this.computeDefinition();
      this._base._functions[this._name] = this._definition;
      return this._name + '(' + currentVoxel + ', ' + dataValue + ', ' + gradient + ');';
    }
  }, {
    key: 'computeDefinition',
    value: function computeDefinition() {
      this._definition = '\nvoid ' + this._name + '(in vec3 currentVoxel, out vec4 dataValue, out vec3 gradient){\n\n  // https://en.wikipedia.org/wiki/Trilinear_interpolation\n  vec3 lower_bound = vec3(floor(currentVoxel.x), floor(currentVoxel.y), floor(currentVoxel.z));\n  if(lower_bound.x < 0.){\n    lower_bound.x = 0.;\n  }\n  if(lower_bound.y < 0.){\n    lower_bound.y = 0.;\n  }\n  if(lower_bound.z < 0.){\n    lower_bound.z = 0.;\n  }\n  \n  vec3 higher_bound = lower_bound + vec3(1);\n\n  float xd = ( currentVoxel.x - lower_bound.x ) / ( higher_bound.x - lower_bound.x );\n  float yd = ( currentVoxel.y - lower_bound.y ) / ( higher_bound.y - lower_bound.y );\n  float zd = ( currentVoxel.z - lower_bound.z ) / ( higher_bound.z - lower_bound.z );\n\n  //\n  // c00\n  //\n\n  //\n\n  vec4 v000 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c000 = vec3(lower_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c000', 'v000') + '\n  vec3 g000 = v000.r * vec3(-1., -1., -1.);\n\n  //\n\n  vec4 v100 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c100 = vec3(higher_bound.x, lower_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c100', 'v100') + '\n  vec3 g100 = v100.r * vec3(1., -1., -1.);\n\n  vec4 c00 = v000 * ( 1.0 - xd ) + v100 * xd;\n\n  //\n  // c01\n  //\n  vec4 v001 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c001 = vec3(lower_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c001', 'v001') + '\n  vec3 g001 = v001.r * vec3(-1., -1., 1.);\n\n  vec4 v101 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c101 = vec3(higher_bound.x, lower_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c101', 'v101') + '\n  vec3 g101 = v101.r * vec3(1., -1., 1.);\n\n  vec4 c01 = v001 * ( 1.0 - xd ) + v101 * xd;\n\n  //\n  // c10\n  //\n  vec4 v010 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c010 = vec3(lower_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c010', 'v010') + '\n  vec3 g010 = v010.r * vec3(-1., 1., -1.);\n\n  vec4 v110 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c110 = vec3(higher_bound.x, higher_bound.y, lower_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c110', 'v110') + '\n  vec3 g110 = v110.r * vec3(1., 1., -1.);\n\n  vec4 c10 = v010 * ( 1.0 - xd ) + v110 * xd;\n\n  //\n  // c11\n  //\n  vec4 v011 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c011 = vec3(lower_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c011', 'v011') + '\n  vec3 g011 = v011.r * vec3(-1., 1., 1.);\n\n  vec4 v111 = vec4(0.0, 0.0, 0.0, 0.0);\n  vec3 c111 = vec3(higher_bound.x, higher_bound.y, higher_bound.z);\n  ' + _shadersInterpolation2.default.api(this._base, 'c111', 'v111') + '\n  vec3 g111 = v111.r * vec3(1., 1., 1.);\n\n  vec4 c11 = v011 * ( 1.0 - xd ) + v111 * xd;\n\n  // c0 and c1\n  vec4 c0 = c00 * ( 1.0 - yd) + c10 * yd;\n  vec4 c1 = c01 * ( 1.0 - yd) + c11 * yd;\n\n  // c\n  vec4 c = c0 * ( 1.0 - zd) + c1 * zd;\n  dataValue = c;\n\n  // compute gradient\n  gradient = g000 + g100 + g010 + g110 + g011 + g111 + g110 + g011;\n  // gradientMagnitude = length(gradient);\n  // // https://en.wikipedia.org/wiki/Normal_(geometry)#Transforming_normals\n  // vec3 localNormal = (-1. / gradientMagnitude) * gradient;\n  // normal = normalize(normalPixelToPatient' + this.id + ' * localNormal);\n  //normal = gradient;\n\n}\n    ';
    }
  }]);

  return InterpolationTrilinear;
}(_shaders2.default);

exports.default = new InterpolationTrilinear();

},{"../shaders.base":148,"./shaders.interpolation.identity":145}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersBase = function () {
  function ShadersBase() {
    _classCallCheck(this, ShadersBase);

    this._name = 'shadersBase';
    this._base = {
      _functions: {},
      _uniforms: {}
    };
    this._definition = '';
  }

  _createClass(ShadersBase, [{
    key: 'name',
    get: function get() {
      return this._name;
    },
    set: function set(name) {
      this._name = name;
    }
  }]);

  return ShadersBase;
}();

exports.default = ShadersBase;

},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\n\n    float luma (vec3 rgb) {\n\treturn (rgb.r + rgb.g + rgb.b)/3.0;\n}\n\nconst float T = 0.04;\nconst float M = 1.0;\nconst float L = 0.002;\n\nvoid main(void) {\n\n  vec2 texCoord = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  float borderWidth = uWidth; // in px\n  float step_u = borderWidth * 1.0 / uCanvasWidth;\n  float step_v = borderWidth * 1.0 / uCanvasHeight;\n  vec4 centerPixel = texture2D(uTextureFilled, texCoord);\n\n  vec4 rightPixel  = texture2D(uTextureFilled, texCoord + vec2(step_u, 0.0));\n  vec4 bottomPixel = texture2D(uTextureFilled, texCoord + vec2(0.0, step_v));\n\n  // now manually compute the derivatives\n  float _dFdX = length(rightPixel - centerPixel) / step_u;\n  float _dFdY = length(bottomPixel - centerPixel) / step_v;\n\n  // gl_FragColor.r = _dFdX;\n  // gl_FragColor.g = _dFdY;\n  gl_FragColor.r = max(max(centerPixel.r, rightPixel.r), bottomPixel.r);\n  gl_FragColor.g = max(max(centerPixel.g, rightPixel.g), bottomPixel.g);\n  gl_FragColor.b = max(max(centerPixel.b, rightPixel.b), bottomPixel.b);\n  gl_FragColor.a = max(_dFdX, _dFdY);\n\n  return;\n  float h = 1./uCanvasHeight;\n  float w = 1./uCanvasWidth;\n  vec4 n[9];\n  n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  gl_FragColor = vec4( sobel, max(max(sobel.r, sobel.g), sobel.b) );\n\n\n  return;\n\n  gl_FragColor.r = (texCoord + vec2(0.0, step_v)).r;\n  gl_FragColor.g = (texCoord + vec2(step_u, 0.0)).g;\n  gl_FragColor = centerPixel;\n  gl_FragColor.r = texCoord.x;\n  // gl_FragColor.g = (texCoord + vec2(0.0, step_v)).x;\n  gl_FragColor.b = (texCoord + vec2(step_u, 0.0)).x;\n  gl_FragColor.rg = (texCoord + vec2(0.0, step_v));\n  gl_FragColor.b = 0.;\n  return;\n  vec2 texCoordSlope = fwidth(texCoord);\n  vec4 color2 = texture2D(uTextureFilled, vProjectedTextCoords);\n  // dfdx that vProjectedTextCoords\n  float l = luma (color2.rgb) ;\n    float luminance = dot(color2.rgb,vec3(0.2126, 0.7152, 0.0722));\n\n  \tfloat q0 = fwidth (luminance);\n    if(q0 > 0.01){\n      q0 = 1.0;\n    }\n\tfloat q1 = abs (dFdx (l)); \n\tfloat q2 = abs (dFdy (l));\n\n  \tvec4 ct = vec4 (1.0, 1.0, 1.0, 0.0);\n\tvec4 c0 = mix (ct, vec4 (1.0, 0.0, 0.0, 1.0), \n\t\tsmoothstep (T * (1.0 - M), T * (1.0 + M), q0));\n\ngl_FragColor.r = fwidth(color2.r);//abs(dFdx(color2.b));//texCoord;//color2.rgb;\ngl_FragColor.g = fwidth(color2.g);\ngl_FragColor.b = fwidth(color2.b);\ngl_FragColor.a = 1.;\n// gl_FragColor.a = q0;\n// gl_FragColor = color2;\n//return;\n\n\n  //The back position is the world space position stored in the texture.\n  vec4 color = texture2D(uTextureFilled, texCoord);\n  float lColor = length(color.rgb);\n  float maxColor = length(color.rgb);//max(max(color.r, color.g), color.b);\n  // if(maxColor > 0.1){\n  //   maxColor = 1.0;\n  // }\n\n\n\n  // gl_FragColor = color;//vec4(color.r, color.g, color.b, 1);\n  // return;\n  // float tmpxx  = abs(dFdx(lColor));\n  // float tmpxy  = abs(dFdy(lColor));\n  // float tmpx = max(tmpxx,tmpxy);\n\n  // float tmpyx  = abs(dFdx(color.y));\n  // float tmpyy  = abs(dFdy(color.y));\n  // float tmpy = max(tmpyx,tmpyy);\n\n  // float tmpzx  = abs(dFdx(color.z));\n  // float tmpzy  = abs(dFdy(color.z));\n  // float tmpz = max(tmpzx,tmpzy);\n\n  // float tmpmax = max(max(tmpx, tmpy), tmpz);\n  // if(tmpmax > 0.01){\n  //   tmpmax = 1.0;\n  // }\n  // gl_FragColor.r = tmpx;//smoothstep(tmpx-5., tmpx+5., lColor);\n  // gl_FragColor.g = tmpx;\n  // gl_FragColor.b = tmpx;\n\n  // vec4 color2 = texture2D(uTextureFilled, vec2(texcX, texcY));\n\n  // gl_FragColor.r = color.r - texcX;\n  // gl_FragColor.g = color.g - texcY;\n  // gl_FragColor.b = color.b - color2.b;\n  // gl_FragColor.a = 1.;\n\n  // float threshold = 0.7;\n  // float afwidth = length(vec2(dFdx(maxColor), dFdy(maxColor)));\n  // gl_FragColor.a = afwidth;\n  // float opacity =\n  //   smoothstep(afwidth - threshold, afwidth + threshold, maxColor);\n\n  // gl_FragColor.a = maxColor;\n\n// float aaf = fwidth(maxColor);\n// float alpha = smoothstep(.01, .8, aaf);\n// gl_FragColor = vec4(color.rgb, alpha);\n\n  // float h = 1./uCanvasHeight;\n  // float w = 1./uCanvasWidth;\n  // vec4 n[9];\n  // n[0] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, -h));\n  // n[1] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(0.0, -h));\n  // n[2] = texture2D(uTextureFilled, vProjectedTextCoords + vec2(  w, -h));\n  // n[3] = texture2D(uTextureFilled, vProjectedTextCoords + vec2( -w, 0.0));\n  // n[4] = texture2D(uTextureFilled, vProjectedTextCoords);\n  // n[5] = texture2D(uTextureFilled, texCoord + vec2(  w, 0.0));\n  // n[6] = texture2D(uTextureFilled, texCoord + vec2( -w, h));\n  // n[7] = texture2D(uTextureFilled, texCoord + vec2(0.0, h));\n  // n[8] = texture2D(uTextureFilled, texCoord + vec2(  w, h));\n  // vec4 sobel_horizEdge = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  // vec4 sobel_vertEdge  = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  // vec3 sobel = sqrt((sobel_horizEdge.rgb * sobel_horizEdge.rgb) + (sobel_vertEdge.rgb * sobel_vertEdge.rgb));\n  // gl_FragColor = vec4( n[1].rgb, 1.0 );\n  // gl_FragColor.r = 1.0;\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\nvarying vec2      vProjectedTextCoords;\nvarying mat4      vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uWidth': {
          type: 'f',
          value: 1.,
          typeGLSL: 'float'
        },
        'uTextureFilled': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\nvarying mat4 vProjectionViewMatrix;\nvarying vec2 vProjectedTextCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vProjectedTextCoords = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  // draw border if slice is cropped\n  // float uBorderDashLength = 10.;\n\n  if( uCanvasWidth > 0. &&\n      ((gl_FragCoord.x > uBorderMargin && (gl_FragCoord.x - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.x < (uCanvasWidth - uBorderMargin) && (gl_FragCoord.x + uBorderMargin) > (uCanvasWidth - uBorderWidth) ))){\n    float valueY = mod(gl_FragCoord.y, 2. * uBorderDashLength);\n    if( valueY < uBorderDashLength && gl_FragCoord.y > uBorderMargin && gl_FragCoord.y < (uCanvasHeight - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  if( uCanvasHeight > 0. &&\n      ((gl_FragCoord.y > uBorderMargin && (gl_FragCoord.y - uBorderMargin) < uBorderWidth) ||\n       (gl_FragCoord.y < (uCanvasHeight - uBorderMargin) && (gl_FragCoord.y + uBorderMargin) > (uCanvasHeight - uBorderWidth) ))){\n    float valueX = mod(gl_FragCoord.x, 2. * uBorderDashLength);\n    if( valueX < uBorderDashLength && gl_FragCoord.x > uBorderMargin && gl_FragCoord.x < (uCanvasWidth - uBorderMargin) ){\n      gl_FragColor = vec4(uBorderColor, 1.);\n      return;\n    }\n  }\n\n  // get texture coordinates of current pixel\n  vec4 dataCoordinates = uWorldToData * vPos;\n  vec3 currentVoxel = vec3(dataCoordinates.x, dataCoordinates.y, dataCoordinates.z);\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  vec3 gradient = vec3(0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'currentVoxel', 'dataValue', 'gradient') + '\n\n  // how do we deal wil more than 1 channel?\n  if(uNumberOfChannels == 1){\n    float intensity = dataValue.r;\n\n    // rescale/slope\n    intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n\n    float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n    float windowMax = uWindowCenterWidth[0] + uWindowCenterWidth[1] * 0.5;\n    intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n\n    dataValue.r = dataValue.g = dataValue.b = intensity;\n    dataValue.a = 1.0;\n  }\n\n  // Apply LUT table...\n  //\n  if(uLut == 1){\n    // should opacity be grabbed there?\n    dataValue = texture2D( uTextureLUT, vec2( dataValue.r , 1.0) );\n  }\n\n  if(uInvert == 1){\n    dataValue = vec4(1.) - dataValue;\n    // how do we deal with that and opacity?\n    dataValue.a = 1.;\n  }\n\n  gl_FragColor = dataValue;\n\n    // if on edge, draw line\n  // float xPos = gl_FragCoord.x/512.;\n  // float yPos = gl_FragCoord.y/512.;\n  // if( xPos < 0.05 || xPos > .95 || yPos < 0.05 || yPos > .95){\n  //   gl_FragColor = vec4(xPos, yPos, 0., 1.);//dataValue;\n  //   //return;\n  // }\n\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./interpolation/shaders.interpolation":146}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uBorderColor': {
          type: 'v3',
          value: [1.0, 0.0, 0.5],
          typeGLSL: 'vec3'
        },
        'uBorderWidth': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderMargin': {
          type: 'f',
          value: 2.,
          typeGLSL: 'float'
        },
        'uBorderDashLength': {
          type: 'f',
          value: 10.,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shadersContour = require('./shaders.contour.uniform');

var _shadersContour2 = _interopRequireDefault(_shadersContour);

var _shadersContour3 = require('./shaders.contour.fragment');

var _shadersContour4 = _interopRequireDefault(_shadersContour3);

var _shadersContour5 = require('./shaders.contour.vertex');

var _shadersContour6 = _interopRequireDefault(_shadersContour5);

var _shadersData = require('./shaders.data.uniform');

var _shadersData2 = _interopRequireDefault(_shadersData);

var _shadersData3 = require('./shaders.data.fragment');

var _shadersData4 = _interopRequireDefault(_shadersData3);

var _shadersData5 = require('./shaders.data.vertex');

var _shadersData6 = _interopRequireDefault(_shadersData5);

var _shadersVr = require('./shaders.vr.uniform');

var _shadersVr2 = _interopRequireDefault(_shadersVr);

var _shadersVr3 = require('./shaders.vr.fragment');

var _shadersVr4 = _interopRequireDefault(_shadersVr3);

var _shadersVr5 = require('./shaders.vr.vertex');

var _shadersVr6 = _interopRequireDefault(_shadersVr5);

var _shadersLayer = require('./shaders.layer.uniform');

var _shadersLayer2 = _interopRequireDefault(_shadersLayer);

var _shadersLayer3 = require('./shaders.layer.fragment');

var _shadersLayer4 = _interopRequireDefault(_shadersLayer3);

var _shadersLayer5 = require('./shaders.layer.vertex');

var _shadersLayer6 = _interopRequireDefault(_shadersLayer5);

var _shadersLocalizer = require('./shaders.localizer.uniform');

var _shadersLocalizer2 = _interopRequireDefault(_shadersLocalizer);

var _shadersLocalizer3 = require('./shaders.localizer.fragment');

var _shadersLocalizer4 = _interopRequireDefault(_shadersLocalizer3);

var _shadersLocalizer5 = require('./shaders.localizer.vertex');

var _shadersLocalizer6 = _interopRequireDefault(_shadersLocalizer5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module shaders
 */

exports.default = {
  ContourUniform: _shadersContour2.default,
  ContourFragment: _shadersContour4.default,
  ContourVertex: _shadersContour6.default,

  DataUniform: _shadersData2.default,
  DataFragment: _shadersData4.default,
  DataVertex: _shadersData6.default,

  VRUniform: _shadersVr2.default,
  VRFragment: _shadersVr4.default,
  VRVertex: _shadersVr6.default,

  LayerUniform: _shadersLayer2.default,
  LayerFragment: _shadersLayer4.default,
  LayerVertex: _shadersLayer6.default,

  LocalizerUniform: _shadersLocalizer2.default,
  LocalizerFragment: _shadersLocalizer4.default,
  LocalizerVertex: _shadersLocalizer6.default
};

},{"./shaders.contour.fragment":149,"./shaders.contour.uniform":150,"./shaders.contour.vertex":151,"./shaders.data.fragment":152,"./shaders.data.uniform":153,"./shaders.data.vertex":154,"./shaders.layer.fragment":156,"./shaders.layer.uniform":157,"./shaders.layer.vertex":158,"./shaders.localizer.fragment":159,"./shaders.localizer.uniform":160,"./shaders.localizer.vertex":161,"./shaders.vr.fragment":162,"./shaders.vr.uniform":163,"./shaders.vr.vertex":164}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid main(void) {\n\n  vec2 texc = vec2(((vProjectedCoords.x / vProjectedCoords.w) + 1.0 ) / 2.0,\n                ((vProjectedCoords.y / vProjectedCoords.w) + 1.0 ) / 2.0 );\n\n  // just silence warning for\n  vec4 dummy = vPos;\n\n  //The back position is the world space position stored in the texture.\n  vec4 baseColor0 = texture2D(uTextureBackTest0, texc);\n  vec4 baseColor1 = texture2D(uTextureBackTest1, texc);\n\n  if( uTrackMouse == 1 ){\n\n      if( vProjectedCoords.x < uMouse.x ){\n\n        gl_FragColor = baseColor0;\n\n      }\n      else{\n\n        gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n      }\n\n  }\n  else{\n\n    if( uType1 == 0 ){\n\n      //merge an image into\n      gl_FragColor = mix( baseColor0, baseColor1, uOpacity1 );\n\n    }\n    else{\n\n      float opacity = baseColor1.a;\n      gl_FragColor = mix( baseColor0, baseColor1, opacity * uOpacity1 );\n\n    }\n\n  }\n\n  return;\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\nvarying vec4      vProjectedCoords;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureBackTest0': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uTextureBackTest1': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uOpacity0': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uOpacity1': {
          type: 'f',
          value: 1.0,
          typeGLSL: 'float'
        },
        'uType0': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uType1': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uTrackMouse': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uMouse': {
          type: 'v2',
          value: new THREE.Vector2(),
          typeGLSL: 'vec2'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying vec4 vProjectedCoords;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Localizer fragment shader
 */
var _class = function () {

  /**
   * 
   */
  function _class(uniforms) {
    _classCallCheck(this, _class);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  /**
   * 
   */


  _createClass(_class, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }

    /**
     * 
     */

  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid intersectionProjection(\n  in vec4 plane,\n  in vec4 slice,\n  out vec3 intersectionProjection){\n\n      vec3 intersectionDirection = normalize(cross(plane.xyz, slice.xyz));\n      vec3 intersectionPoint = \n        cross(intersectionDirection,slice.xyz) * plane.w +\n        cross(plane.xyz, intersectionDirection) * slice.w;\n\n      intersectionProjection =\n        intersectionPoint.xyz +\n        (dot(vPos.xyz - intersectionPoint, intersectionDirection)\n          * intersectionDirection);\n\n}\n\nvoid main(void) {\n      vec4 c1 = vec4(0., 0., 0., 0.);\n      vec4 c2 = vec4(0., 0., 0., 0.);\n      vec4 c3 = vec4(0., 0., 0., 0.);\n\n      // localizer #1\n      // must be normalized!\n      if(length(uPlane1.xyz) > 0.5) {\n        vec3 projection1 = vec3(1.);\n        intersectionProjection(\n          uPlane1,\n          uSlice,\n          projection1\n        );\n\n        vec4 projInter1 = (vProjectionViewMatrix * vec4(projection1, 1.));\n        vec3 ndc1 = projInter1.xyz / projInter1.w;\n        vec2 screenSpace1 = (ndc1.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d1 = distance(gl_FragCoord.xy, screenSpace1.xy);\n        c1 = vec4(uPlaneColor1, 1. - smoothstep(.5, .7, d1));\n      }\n\n      // localizer #2\n      if(length(uPlane2.xyz) > 0.5) {\n        vec3 projection2 = vec3(1.);\n        intersectionProjection(\n          uPlane2,\n          uSlice,\n          projection2\n        );\n\n        vec4 projInter2 = (vProjectionViewMatrix * vec4(projection2, 1.));\n        vec3 ndc2 = projInter2.xyz / projInter2.w;\n        vec2 screenSpace2 = (ndc2.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d2 = distance(gl_FragCoord.xy, screenSpace2.xy);\n        c2 = vec4(uPlaneColor2, 1. - smoothstep(.5, .7, d2));\n      }\n\n      // localizer #3\n      if(length(uPlane3.xyz) > 0.5) {\n        vec3 projection3 = vec3(1.);\n        intersectionProjection(\n          uPlane3,\n          uSlice,\n          projection3\n        );\n\n        vec4 projInter3 = (vProjectionViewMatrix * vec4(projection3, 1.));\n        vec3 ndc3 = projInter3.xyz / projInter3.w;\n        vec2 screenSpace3 = (ndc3.xy * .5 + .5) * vec2(uCanvasWidth, uCanvasHeight);\n\n        float d3 = distance(gl_FragCoord.xy, screenSpace3.xy);\n        c3 = vec4(uPlaneColor3, 1. - smoothstep(.5, .7, d3));\n      }\n\n      vec3 colorMix = c1.xyz*c1.w + c2.xyz*c2.w + c3.xyz*c3.w;\n      gl_FragColor = vec4(colorMix, max(max(c1.w, c2.w),c3.w));\n}\n   ';
    }

    /**
     * 
     */

  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return _class;
}();

exports.default = _class;

},{"./interpolation/shaders.interpolation":146}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/localizer/uniforms
 */

var _class = function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  _createClass(_class, null, [{
    key: 'uniforms',

    /**
     * Shaders data uniforms
     */
    value: function uniforms() {
      return {
        'uCanvasWidth': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uCanvasHeight': {
          type: 'f',
          value: 0.,
          typeGLSL: 'float'
        },
        'uSlice': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlane1': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor1': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane2': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor2': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        },
        'uPlane3': {
          type: 'v4',
          value: [0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'vec4'
        },
        'uPlaneColor3': {
          type: 'v3',
          value: [1.0, 1.0, 0.0],
          typeGLSL: 'vec3'
        }

      };
    }
  }]);

  return _class;
}();

exports.default = _class;

},{}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 
 */
var _class = function () {
    /**
     * 
     */
    function _class() {
        _classCallCheck(this, _class);
    }

    /**
     * 
     */


    _createClass(_class, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\nvarying mat4 vProjectionViewMatrix;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  vProjectionViewMatrix = projectionMatrix * viewMatrix;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return _class;
}();

exports.default = _class;

},{}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _shaders = require('./interpolation/shaders.interpolation');

var _shaders2 = _interopRequireDefault(_shaders);

var _shadersHelpers = require('./helpers/shaders.helpers.intersectBox');

var _shadersHelpers2 = _interopRequireDefault(_shadersHelpers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersFragment = function () {

  // pass uniforms object
  function ShadersFragment(uniforms) {
    _classCallCheck(this, ShadersFragment);

    this._uniforms = uniforms;
    this._functions = {};
    this._main = '';
  }

  _createClass(ShadersFragment, [{
    key: 'functions',
    value: function functions() {
      if (this._main === '') {
        // if main is empty, functions can not have been computed
        this.main();
      }

      var content = '';
      for (var property in this._functions) {
        content += this._functions[property] + '\n';
      }

      return content;
    }
  }, {
    key: 'uniforms',
    value: function uniforms() {
      var content = '';
      for (var property in this._uniforms) {
        var uniform = this._uniforms[property];
        content += 'uniform ' + uniform.typeGLSL + ' ' + property;

        if (uniform && uniform.length) {
          content += '[' + uniform.length + ']';
        }

        content += ';\n';
      }

      return content;
    }
  }, {
    key: 'main',
    value: function main() {
      // need to pre-call main to fill up the functions list
      this._main = '\nvoid getIntensity(in vec3 dataCoordinates, out float intensity, out vec3 gradient){\n\n  vec4 dataValue = vec4(0., 0., 0., 0.);\n  ' + (0, _shaders2.default)(this, 'dataCoordinates', 'dataValue', 'gradient') + '\n\n  intensity = dataValue.r;\n\n  // rescale/slope\n  intensity = intensity*uRescaleSlopeIntercept[0] + uRescaleSlopeIntercept[1];\n  // window level\n  float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\n  intensity = ( intensity - windowMin ) / uWindowCenterWidth[1];\n}\n\nvoid main(void) {\n  const int maxSteps = 1024;\n\n  // the ray\n  vec3 rayOrigin = cameraPosition;\n  vec3 rayDirection = normalize(vPos.xyz - rayOrigin);\n\n  // the Axe-Aligned B-Box\n  vec3 AABBMin = vec3(uWorldBBox[0], uWorldBBox[2], uWorldBBox[4]);\n  vec3 AABBMax = vec3(uWorldBBox[1], uWorldBBox[3], uWorldBBox[5]);\n\n  // Intersection ray/bbox\n  float tNear, tFar;\n  bool intersect = false;\n  ' + _shadersHelpers2.default.api(this, 'rayOrigin', 'rayDirection', 'AABBMin', 'AABBMax', 'tNear', 'tFar', 'intersect') + '\n  if (tNear < 0.0) tNear = 0.0;\n\n  // init the ray marching\n  float tCurrent = tNear;\n  float tStep = (tFar - tNear) / float(uSteps);\n  vec4 accumulatedColor = vec4(0.0);\n  float accumulatedAlpha = 0.0;\n\n  for(int rayStep = 0; rayStep < maxSteps; rayStep++){\n    vec3 currentPosition = rayOrigin + rayDirection * tCurrent;\n    // some non-linear FUN\n    // some occlusion issue to be fixed\n    vec3 transformedPosition = currentPosition; //transformPoint(currentPosition, uAmplitude, uFrequence);\n    // world to data coordinates\n    // rounding trick\n    // first center of first voxel in data space is CENTERED on (0,0,0)\n    vec4 dataCoordinatesRaw = uWorldToData * vec4(transformedPosition, 1.0);\n    vec3 currentVoxel = vec3(dataCoordinatesRaw.x, dataCoordinatesRaw.y, dataCoordinatesRaw.z);\n    float intensity = 0.0;\n    vec3 gradient = vec3(0., 0., 0.);\n    getIntensity(currentVoxel, intensity, gradient);\n\n    vec4 colorSample;\n    float alphaSample;\n    if(uLut == 1){\n      vec4 colorFromLUT = texture2D( uTextureLUT, vec2( intensity, 1.0) );\n      // 256 colors\n      colorSample = colorFromLUT;\n      alphaSample = colorFromLUT.a;\n    }\n    else{\n      alphaSample = intensity;\n      colorSample.r = colorSample.g = colorSample.b = intensity * alphaSample;\n    }\n\n    alphaSample = alphaSample * uAlphaCorrection;\n    alphaSample *= (1.0 - accumulatedAlpha);\n\n    accumulatedColor += alphaSample * colorSample;\n    accumulatedAlpha += alphaSample;\n\n    tCurrent += tStep;\n\n    if(tCurrent > tFar || accumulatedAlpha >= 1.0 ) break;\n  }\n\n  gl_FragColor = vec4(accumulatedColor.xyz, accumulatedAlpha);\n}\n   ';
    }
  }, {
    key: 'compute',
    value: function compute() {
      var shaderInterpolation = '';
      // shaderInterpolation.inline(args) //true/false
      // shaderInterpolation.functions(args)

      return '\n// uniforms\n' + this.uniforms() + '\n\n// varying (should fetch it from vertex directly)\nvarying vec4      vPos;\n\n// tailored functions\n' + this.functions() + '\n\n// main loop\n' + this._main + '\n      ';
    }
  }]);

  return ShadersFragment;
}();

exports.default = ShadersFragment;

},{"./helpers/shaders.helpers.intersectBox":142,"./interpolation/shaders.interpolation":146}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module shaders/data
 */
var ShadersUniform = function () {
  function ShadersUniform() {
    _classCallCheck(this, ShadersUniform);
  }

  _createClass(ShadersUniform, null, [{
    key: 'uniforms',
    value: function uniforms() {
      return {
        'uTextureSize': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureContainer': {
          type: 'tv',
          value: [],
          typeGLSL: 'sampler2D',
          length: 7
        },
        'uDataDimensions': {
          type: 'iv',
          value: [0, 0, 0],
          typeGLSL: 'ivec3'
        },
        'uWorldToData': {
          type: 'm4',
          value: new THREE.Matrix4(),
          typeGLSL: 'mat4'
        },
        'uWindowCenterWidth': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uRescaleSlopeIntercept': {
          type: 'fv1',
          value: [0.0, 0.0],
          typeGLSL: 'float',
          length: 2
        },
        'uNumberOfChannels': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uBitsAllocated': {
          type: 'i',
          value: 8,
          typeGLSL: 'int'
        },
        'uInvert': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uLut': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uTextureLUT': {
          type: 't',
          value: [],
          typeGLSL: 'sampler2D'
        },
        'uPixelType': {
          type: 'i',
          value: 0,
          typeGLSL: 'int'
        },
        'uPackedPerPixel': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uInterpolation': {
          type: 'i',
          value: 1,
          typeGLSL: 'int'
        },
        'uWorldBBox': {
          type: 'fv1',
          value: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          typeGLSL: 'float',
          length: 6
        },
        'uSteps': {
          type: 'i',
          value: 256,
          typeGLSL: 'int'
        },
        'uAlphaCorrection': {
          type: 'f',
          value: 0.5,
          typeGLSL: 'float'
        },
        'uFrequence': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        },
        'uAmplitude': {
          type: 'f',
          value: 0.0,
          typeGLSL: 'float'
        }
      };
    }
  }]);

  return ShadersUniform;
}();

exports.default = ShadersUniform;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ShadersVertex = function () {
    function ShadersVertex() {
        _classCallCheck(this, ShadersVertex);
    }

    _createClass(ShadersVertex, [{
        key: "compute",
        value: function compute() {
            return "\nvarying vec4 vPos;\n\n//\n// main\n//\nvoid main() {\n\n  vPos = modelMatrix * vec4(position, 1.0 );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );\n\n}\n        ";
        }
    }]);

    return ShadersVertex;
}();

exports.default = ShadersVertex;

},{}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsAnnotation = function (_WidgetsBase) {
    _inherits(WidgetsAnnotation, _WidgetsBase);

    function WidgetsAnnotation(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsAnnotation);

        var _this = _possibleConstructorReturn(this, (WidgetsAnnotation.__proto__ || Object.getPrototypeOf(WidgetsAnnotation)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._line = null;
        _this._label = null;
        _this._cone = null;
        _this._labeltext = null;

        //booleans
        _this._alreadycreated = null; //bool that turns true when the user enter the name of the label
        _this._movinglabel = null; //bool that turns true when the label is moving with the mouse
        _this._labelmoved = false; //bool that turns true once the label is moved by the user (at least once)

        _this._labelhovered = false;
        _this._domHovered = false;
        _this._hovered = true;

        //var
        _this._labelpositionx = null; //position of label (top left corner)
        _this._labelpositiony = null; //position of label (top left corner)
        _this._differencemousecenterlabelx = 0; //difference between mouse position in the label and position of label (top left corner)
        _this._differencemousecenterlabely = 0; //difference between mouse position in the label and position of label (top left corner)

        // add handles
        _this._handles = [];

        self = _this;

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        secondHandle.worldPosition = _this._worldPosition;
        secondHandle.hovered = true;
        // active and tracking might be redundant
        secondHandle.active = true;
        secondHandle.tracking = true;
        _this.add(secondHandle);

        _this._handles.push(secondHandle);

        // Create annotation

        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.onHoverlabel = _this.onHoverlabel.bind(_this);
        _this.notonHoverlabel = _this.notonHoverlabel.bind(_this);
        _this.changelabeltext = _this.changelabeltext.bind(_this);
        _this.movelabel = _this.movelabel.bind(_this);
        _this.notmovelabel = _this.notmovelabel.bind(_this);

        _this.addEventListeners();

        return _this;
    }

    _createClass(WidgetsAnnotation, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._label.addEventListener('mouseenter', this.onHoverlabel);
            this._label.addEventListener('mouseleave', this.notonHoverlabel);
            this._label.addEventListener('dblclick', this.changelabeltext);
            this._label.addEventListener('mousedown', this.movelabel);
            this._container.addEventListener('mouseup', this.notmovelabel);

            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'movelabel',
        value: function movelabel() {
            //function called when mousedown
            if (this._labelhovered = true) {
                //if label hobered we will move the label
                this._movinglabel = true;
                this._labelmoved = true;
                var mousey = -(-event.clientY + this._container.offsetHeight);
                var mousex = event.clientX;
                //calculate differencemousecenterlabel (difference between ref position of the label (top-left corner) and mouse position in the label)
                this._differencemousecenterlabelx = Math.abs(Math.abs(mousex) - Math.abs(this._labelpositionx));
                this._differencemousecenterlabely = Math.abs(Math.abs(mousey) - Math.abs(this._labelpositiony));
            }
        }
    }, {
        key: 'notmovelabel',
        value: function notmovelabel() {
            //this function is called when mouseup
            this._movinglabel = false;
            this._handles[0]._controls.enabled = true; //move the camera when mousedown and mousedown again
            this._handles[1]._controls.enabled = true;
            this._differencemousecenterlabelx = 0; //restart the value of differencemousecenterlabel. Necessary?
            this._differencemousecenterlabely = 0;
        }
    }, {
        key: 'onHoverlabel',
        value: function onHoverlabel() {
            //this function is called when mouse enters the label with "mouseenter" event
            this._labelhovered = true;
        }
    }, {
        key: 'notonHoverlabel',
        value: function notonHoverlabel() {
            //this function is called when mouse leaves the label with "mouseleave" event
            this._labelhovered = false;
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {

            if (this._movinglabel == true) {
                this._handles[0]._controls.enabled = false;
                this._handles[1]._controls.enabled = false;
            }

            this._dragged = true;

            this._handles[0].onMove(evt);
            this._handles[1].onMove(evt);

            this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._labelhovered;

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {

            this._dragged = false;

            this._handles[0].onStart(evt);
            this._handles[1].onStart(evt);

            this._active = this._handles[0].active || this._handles[1].active;

            this.update();
        }
    }, {
        key: 'setlabeltext',
        value: function setlabeltext() {
            this._labeltext = prompt("Please enter the name of the label", ""); //this function is called when the user creates a new arrow
            if (typeof this._labeltext == 'string') {
                //avoid error
                if (this._labeltext.length > 0) {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
                    this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label once we know the content
                } else {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = 'none'; //hide the label
                    this._dashline.style.display = 'none'; //hide the label
                }
            }
        }
    }, {
        key: 'changelabeltext',
        value: function changelabeltext() {
            //this function is called when the user does double click in the label
            this._labeltext = prompt("Please enter new name of the label", this._label.innerHTML);
            if (typeof this._labeltext == 'string') {
                //avoid error
                if (this._labeltext.length > 0) {
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = ''; //in css an empty string is used to revert display=none. Show the label
                    this._dashline.style.display = ''; //in css an empty string is used to revert display=none. Show the label
                } else {
                    // if the length is 0 the user pressed Cancel
                    this._label.innerHTML = this._labeltext;
                    this._label.style.display = 'none'; //hide the label
                    this._dashline.style.display = 'none'; //hide the label
                }
            }
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            this._handles[0].onEnd(evt);

            // Second Handle
            if (this._dragged || !this._handles[1].tracking) {
                this._handles[1].tracking = false;
                this._handles[1].onEnd(evt);
            } else {
                this._handles[1].tracking = false;
            }

            if (self._alreadycreated != true) {
                this.setlabeltext();
                self._alreadycreated = true;
            }

            // State of annotation widget
            this._active = this._handles[0].active || this._handles[1].active;
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createMesh();
            this.createDOM();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'createMesh',
        value: function createMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            this._geometry.vertices.push(this._handles[0].worldPosition);
            this._geometry.vertices.push(this._handles[1].worldPosition);

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._meshline = new THREE.Line(this._geometry, this._material);
            this._meshline.visible = true;

            // add it!
            this.add(this._meshline);

            //create cone and add it
            this._conegeometry = new THREE.CylinderGeometry(0, 2, 10);
            this._conegeometry.translate(0, -5, 0);
            this._conegeometry.rotateX(-Math.PI / 2);
            this._cone = new THREE.Mesh(this._conegeometry, this._material);
            this._cone.visible = true;
            this.add(this._cone);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px'; //2
            this._line.style.width = '3px'; //3
            this._container.appendChild(this._line);

            // add dash line
            this._dashline = document.createElement('div');
            this._dashline.setAttribute('class', 'widgets handle dashline');
            this._dashline.style.position = 'absolute';
            this._dashline.style.border = 'none';
            this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
            this._dashline.style.transformOrigin = '0 100%';
            this._dashline.style.height = '1px';
            this._dashline.style.width = '50%';
            this._dashline.style.display = 'none';
            this._container.appendChild(this._dashline);

            // add label!
            this._label = document.createElement('div');
            this._label.setAttribute('id', this.uuid);
            this._label.setAttribute('class', 'widgets handle label');
            this._label.style.border = '2px solid #F9F9F9';
            this._label.style.backgroundColor = '#F9F9F9';
            // this._label.style.opacity = '0.5';
            this._label.style.color = '#353535';
            this._label.style.padding = '4px';
            this._label.style.position = 'absolute';
            this._label.style.transformOrigin = '0 100%';
            this._label.innerHTML = 'Hello, world!';
            this._label.style.display = 'none';
            this._container.appendChild(this._label);

            this.updateDOMColor();
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {

            console.log('function updateDOMPosition');
            // update annotation lines and text!
            var x1 = this._handles[0].screenPosition.x;
            var y1 = this._handles[0].screenPosition.y;
            var x2 = this._handles[1].screenPosition.x;
            var y2 = this._handles[1].screenPosition.y;

            var x0 = x1 + (x2 - x1) / 2;
            var y0 = y1 + (y2 - y1) / 2;

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            this._line.style.transform = transform;
            this._line.style.width = length + 'px';

            // update label position
            var mousex = 0;
            var mousey = 0;

            var posY0 = void 0;

            posY0 = y0 - this._container.offsetHeight - this._label.offsetHeight / 2;
            x0 -= this._label.offsetWidth / 2;

            var x;
            var y;

            if (this._labelmoved == false) {
                //if the user hasnt moved the label, the position is defined by the position of the arrow
                var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
                this._label.style.transform = transform2;
                this._labelpositionx = Math.round(x0);
                this._labelpositiony = Math.round(posY0);
            }

            if (this._movinglabel) {
                //if the user has moved the label, the position is defined by the mouse
                mousex = event.clientX;
                mousey = -(-event.clientY + this._container.offsetHeight);
                this._label.style.transform = 'translate3D(' + (mousex - this._differencemousecenterlabelx) + 'px,' + (mousey - this._differencemousecenterlabely) + 'px, 0)';
                //we use differencemousecenterlabel to check the difference between the position of the mouse in the label and the reference position of the label (top-left corner)
                this._labelpositionx = mousex - this._differencemousecenterlabelx;
                this._labelpositiony = mousey - this._differencemousecenterlabely;
            }

            //update cone
            var w0 = this._handles[0].worldPosition;
            var w1 = this._handles[1].worldPosition;

            //position and rotation of cone
            this._cone.position.set(w1.x, w1.y, w1.z);
            this._cone.lookAt(w0);

            // update dash line

            //calculate the place in the label: center of the label
            x1 = this._handles[0].screenPosition.x;
            y1 = this._handles[0].screenPosition.y;
            x2 = this._labelpositionx;
            y2 = this._labelpositiony + this._container.offsetHeight; //revert the operation in 'mousey' to get the previous eventY

            //get the size of the label so we can place the dashed line in the center of it
            var labelheight = this._label.offsetHeight;
            var labelwidth = this._label.offsetWidth;

            var centerlabelx = 0;
            var centerlabely = 0;

            if (isFinite(labelwidth) && isFinite(labelheight)) {
                //if the extraction has been succesfull, we calculate the center of the label with total size
                centerlabelx = labelwidth / 2;
                centerlabely = labelheight / 2;
            }

            x2 += centerlabelx;
            y2 += centerlabely;

            //calculate the place in the arrow: closest part of the line to place the dashed line
            var x1_tail = this._handles[0].screenPosition.x; //first position: tail of arrow
            var y1_tail = this._handles[0].screenPosition.y;
            var x1_body = (this._handles[0].screenPosition.x + this._handles[1].screenPosition.x) / 2; //second position: center of arrow
            var y1_body = (this._handles[0].screenPosition.y + this._handles[1].screenPosition.y) / 2;
            var x1_nose = this._handles[1].screenPosition.x; //third position: peak of arrow
            var y1_nose = this._handles[1].screenPosition.y;

            //calculate all the lengths to the label, so we can choose the min
            var lengthtaillabel = Math.sqrt((x1_tail - x2) * (x1_tail - x2) + (y1_tail - y2) * (y1_tail - y2));
            var lengthbodylabel = Math.sqrt((x1_body - x2) * (x1_body - x2) + (y1_body - y2) * (y1_body - y2));
            var lengthnoselabel = Math.sqrt((x1_nose - x2) * (x1_nose - x2) + (y1_nose - y2) * (y1_nose - y2));

            var lengths = [lengthtaillabel, lengthbodylabel, lengthnoselabel];
            var minlength = Math.min(lengthtaillabel, lengthbodylabel, lengthnoselabel);
            var minlengthindex = lengths.indexOf(minlength);

            if (minlengthindex == 0) {
                x1 = x1_tail;
                y1 = y1_tail;
            }
            if (minlengthindex == 1) {
                x1 = x1_body;
                y1 = y1_body;
            }
            if (minlengthindex == 2) {
                x1 = x1_nose;
                y1 = y1_nose;
            }

            // Once we found the closest point to the label, we create the dashed line from that point
            var lengthdashline = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angledashline = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; //result in deg

            var posYdashline = y1 - this._container.offsetHeight;

            // update dashed line
            var transformdashline = 'translate3D(' + x1 + 'px,' + posYdashline + 'px, 0)';
            transformdashline += ' rotate(' + angledashline + 'deg)';

            this._dashline.style.transform = transformdashline;
            this._dashline.style.width = lengthdashline + 'px';
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            this._line.style.backgroundColor = '' + this._color;
            this._dashline.style.borderTop = '2.5px dashed ' + ('' + this._color);
            this._label.style.borderColor = '' + this._color;
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            this._line.style.display = 'none';
            this._dashline.style.display = 'none';
            this._label.style.display = 'none';
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            this._line.style.display = '';
            this._dashline.style.display = '';
            this._label.style.display = '';
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;
            this._handles[0].worldPosition = this._worldPosition;
            this._handles[1].worldPosition = this._worldPosition;

            this.update();
        }
    }]);

    return WidgetsAnnotation;
}(_widgets2.default);

exports.default = WidgetsAnnotation;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 */
var WidgetsBase = function (_THREE$Object3D) {
  _inherits(WidgetsBase, _THREE$Object3D);

  function WidgetsBase(container) {
    _classCallCheck(this, WidgetsBase);

    // is widget enabled?
    var _this = _possibleConstructorReturn(this, (WidgetsBase.__proto__ || Object.getPrototypeOf(WidgetsBase)).call(this));
    // init THREE Object 3D


    _this._enabled = true;

    // STATE, ENUM might be better
    _this._selected = false;
    _this._hovered = false;
    _this._active = false;
    // thos._state = 'SELECTED';

    _this._colors = {
      default: '#00B0FF',
      active: '#FFEB3B',
      hover: '#F50057',
      select: '#76FF03'
    };
    _this._color = _this._colors.default;

    _this._dragged = false;
    // can not call it visible because it conflicts with THREE.Object3D
    _this._displayed = true;

    _this._container = container;
    return _this;
  }

  _createClass(WidgetsBase, [{
    key: 'initOffsets',
    value: function initOffsets() {
      var box = this._container.getBoundingClientRect();

      var body = document.body;
      var docEl = document.documentElement;

      var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;

      var clientTop = docEl.clientTop || body.clientTop || 0;
      var clientLeft = docEl.clientLeft || body.clientLeft || 0;

      var top = box.top + scrollTop - clientTop;
      var left = box.left + scrollLeft - clientLeft;

      this._offsets = {
        top: Math.round(top),
        left: Math.round(left)
      };
    }
  }, {
    key: 'offsetChanged',
    value: function offsetChanged() {
      this.initOffsets();
      this.update();
    }
  }, {
    key: 'getMouseOffsets',
    value: function getMouseOffsets(event, container) {
      return {
        x: (event.clientX - this._offsets.left) / container.offsetWidth * 2 - 1,
        y: -((event.clientY - this._offsets.top) / container.offsetHeight) * 2 + 1,
        screenX: event.clientX - this._offsets.left,
        screenY: event.clientY - this._offsets.top
      };
    }
  }, {
    key: 'update',
    value: function update() {
      // to be overloaded
      window.console.log('update() should be overloaded!');
    }
  }, {
    key: 'free',
    value: function free() {
      this._container = null;
    }
  }, {
    key: 'updateColor',
    value: function updateColor() {
      if (this._active) {
        this._color = this._colors.active;
      } else if (this._hovered) {
        this._color = this._colors.hover;
      } else if (this._selected) {
        this._color = this._colors.select;
      } else {
        this._color = this._colors.default;
      }
    }
  }, {
    key: 'enabled',
    get: function get() {
      return this._enabled;
    },
    set: function set(enabled) {
      this._enabled = enabled;
      this.update();
    }
  }, {
    key: 'selected',
    get: function get() {
      return this._selected;
    },
    set: function set(selected) {
      this._selected = selected;
      this.update();
    }
  }, {
    key: 'hovered',
    get: function get() {
      return this._hovered;
    },
    set: function set(hovered) {
      this._hovered = hovered;
      this.update();
    }
  }, {
    key: 'dragged',
    get: function get() {
      return this._dragged;
    },
    set: function set(dragged) {
      this._dragged = dragged;
      this.update();
    }
  }, {
    key: 'displayed',
    get: function get() {
      return this._displayed;
    },
    set: function set(displayed) {
      this._displayed = displayed;
      this.update();
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      this.update();
    }
  }, {
    key: 'color',
    get: function get() {
      return this._color;
    },
    set: function set(color) {
      this._color = color;
      this.update();
    }
  }]);

  return WidgetsBase;
}(THREE.Object3D);

exports.default = WidgetsBase;

},{}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
        value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsBiRuler = function (_WidgetsBase) {
        _inherits(WidgetsBiRuler, _WidgetsBase);

        function WidgetsBiRuler(targetMesh, controls, camera, container) {
                _classCallCheck(this, WidgetsBiRuler);

                var _this = _possibleConstructorReturn(this, (WidgetsBiRuler.__proto__ || Object.getPrototypeOf(WidgetsBiRuler)).call(this));

                _this._targetMesh = targetMesh;
                _this._controls = controls;
                _this._camera = camera;
                _this._container = container;

                _this._active = true;
                _this._initOrtho = false;

                _this._worldPosition = new THREE.Vector3();
                if (_this._targetMesh !== null) {
                        _this._worldPosition = _this._targetMesh.position;
                }

                // mesh stuff
                _this._material = null;
                _this._geometry = null;
                _this._mesh = null;

                // dom stuff
                _this._line = null;
                _this._distance = null;

                // add handles
                _this._handles = [];

                // first handle
                var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                firstHandle.worldPosition = _this._worldPosition;
                firstHandle.hovered = true;
                _this.add(firstHandle);

                _this._handles.push(firstHandle);

                var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                secondHandle.worldPosition = _this._worldPosition;
                secondHandle.hovered = true;
                // active and tracking might be redundant
                secondHandle.active = true;
                secondHandle.tracking = true;
                _this.add(secondHandle);

                _this._handles.push(secondHandle);

                // third handle
                var thirdHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                thirdHandle.worldPosition = _this._worldPosition;
                thirdHandle.hovered = true;
                _this.add(thirdHandle);

                _this._handles.push(thirdHandle);

                // fourth handle
                var fourthHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
                fourthHandle.worldPosition = _this._worldPosition;
                fourthHandle.hovered = true;
                _this.add(fourthHandle);

                _this._handles.push(fourthHandle);

                // Create ruler
                _this.create();

                _this.onMove = _this.onMove.bind(_this);
                _this.addEventListeners();

                _this._orientation = null;
                _this._slice = null;
                return _this;
        }

        _createClass(WidgetsBiRuler, [{
                key: 'addEventListeners',
                value: function addEventListeners() {
                        this._container.addEventListener('mousewheel', this.onMove);
                        this._container.addEventListener('DOMMouseScroll', this.onMove);
                }
        }, {
                key: 'onMove',
                value: function onMove(evt) {
                        this._dragged = true;

                        this._handles[0].onMove(evt);
                        this._handles[1].onMove(evt);
                        this._handles[2].onMove(evt);
                        this._handles[3].onMove(evt);

                        this._hovered = this._handles[0].hovered || this._handles[1].hovered || this._handles[2].hovered || this._handles[3].hovered;

                        this.update();
                }
        }, {
                key: 'onStart',
                value: function onStart(evt) {
                        this._dragged = false;

                        this._handles[0].onStart(evt);
                        this._handles[1].onStart(evt);
                        this._handles[2].onStart(evt);
                        this._handles[3].onStart(evt);

                        this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
                        this.update();
                }
        }, {
                key: 'onEnd',
                value: function onEnd(evt) {
                        // First Handle
                        this._handles[0].onEnd(evt);
                        this._handles[2].onEnd(evt);
                        this._handles[3].onEnd(evt);

                        window.console.log(this);

                        // Second Handle
                        if (this._dragged || !this._handles[1].tracking) {
                                this._handles[1].tracking = false;
                                this._handles[1].onEnd(evt);
                        } else {
                                this._handles[1].tracking = false;
                        }

                        // State of ruler widget
                        this._active = this._handles[0].active || this._handles[1].active || this._handles[2].active || this._handles[3].active;
                        this.update();
                }
        }, {
                key: 'create',
                value: function create() {
                        this.createMesh();
                        this.createDOM();
                }
        }, {
                key: 'hideDOM',
                value: function hideDOM() {
                        this._line.style.display = 'none';
                        this._distance.style.display = 'none';
                        this._line2.style.display = 'none';
                        this._distance2.style.display = 'none';

                        for (var index in this._handles) {
                                this._handles[index].hideDOM();
                        }

                        this._dashline.style.display = 'none';
                }
        }, {
                key: 'showDOM',
                value: function showDOM() {
                        this._line.style.display = '';
                        this._distance.style.display = '';
                        this._line2.style.display = '';
                        this._distance2.style.display = '';

                        for (var index in this._handles) {
                                this._handles[index].showDOM();
                        }

                        this._dashline.style.display = '';
                }
        }, {
                key: 'hideMesh',
                value: function hideMesh() {
                        this._mesh.visible = false;
                        this._mesh2.visible = false;
                        this._handles[0].visible = false;
                        this._handles[1].visible = false;
                        this._handles[2].visible = false;
                        this._handles[3].visible = false;
                }
        }, {
                key: 'showMesh',
                value: function showMesh() {
                        this._mesh.visible = true;
                        this._mesh2.visible = true;
                        this._handles[0].visible = true;
                        this._handles[1].visible = true;
                        this._handles[2].visible = true;
                        this._handles[3].visible = true;
                }
        }, {
                key: 'show',
                value: function show() {
                        this.showDOM();
                        this.showMesh();
                }
        }, {
                key: 'hide',
                value: function hide() {
                        this.hideDOM();
                        this.hideMesh();
                }
        }, {
                key: 'update',
                value: function update() {
                        this.updateColor();

                        // mesh stuff
                        this.updateMeshColor();
                        this.updateMeshPosition();

                        // DOM stuff
                        this.updateDOMPosition();
                        this.updateDOMColor();
                }
        }, {
                key: 'createMesh',
                value: function createMesh() {
                        // geometry
                        this._geometry = new THREE.Geometry();
                        this._geometry.vertices.push(this._handles[0].worldPosition);
                        this._geometry.vertices.push(this._handles[1].worldPosition);

                        // geometry
                        this._geometry2 = new THREE.Geometry();
                        this._geometry2.vertices.push(this._handles[2].worldPosition);
                        this._geometry2.vertices.push(this._handles[3].worldPosition);

                        // material
                        this._material = new THREE.LineBasicMaterial();
                        this._material2 = new THREE.LineBasicMaterial();
                        this.updateMeshColor();

                        // mesh
                        this._mesh = new THREE.Line(this._geometry, this._material);
                        this._mesh.visible = true;
                        this._mesh2 = new THREE.Line(this._geometry2, this._material2);
                        this._mesh2.visible = true;

                        // add it!
                        this.add(this._mesh);
                        this.add(this._mesh2);
                }
        }, {
                key: 'updateMeshColor',
                value: function updateMeshColor() {
                        if (this._material) {
                                this._material.color.set(this._color);
                        }
                        if (this._material2) {
                                this._material2.color.set(this._color);
                        }
                }
        }, {
                key: 'updateMeshPosition',
                value: function updateMeshPosition() {
                        if (this._geometry) {
                                this._geometry.verticesNeedUpdate = true;
                        }
                        if (this._geometry2) {
                                this._geometry2.verticesNeedUpdate = true;
                        }
                }
        }, {
                key: 'createDOM',
                value: function createDOM() {
                        // add line!
                        this._line = document.createElement('div');
                        this._line.setAttribute('class', 'widgets handle line');
                        this._line.style.position = 'absolute';
                        this._line.style.transformOrigin = '0 100%';
                        this._line.style.marginTop = '-1px';
                        this._line.style.height = '2px';
                        this._line.style.width = '3px';
                        this._container.appendChild(this._line);

                        // add distance!
                        this._distance = document.createElement('div');
                        this._distance.setAttribute('class', 'widgets handle distance');
                        this._distance.style.border = '2px solid';
                        this._distance.style.backgroundColor = '#F9F9F9';
                        // this._distance.style.opacity = '0.5';
                        this._distance.style.color = '#353535';
                        this._distance.style.padding = '4px';
                        this._distance.style.position = 'absolute';
                        this._distance.style.transformOrigin = '0 100%';
                        this._distance.innerHTML = 'Hello, world!';
                        this._container.appendChild(this._distance);

                        // add line!
                        this._line2 = document.createElement('div');
                        this._line2.setAttribute('class', 'widgets handle line');
                        this._line2.style.position = 'absolute';
                        this._line2.style.transformOrigin = '0 100%';
                        this._line2.style.marginTop = '-1px';
                        this._line2.style.height = '2px';
                        this._line2.style.width = '3px';
                        this._container.appendChild(this._line2);

                        // add distance!
                        this._distance2 = document.createElement('div');
                        this._distance2.setAttribute('class', 'widgets handle distance');
                        this._distance.style.border = '2px solid';
                        this._distance.style.backgroundColor = '#F9F9F9';
                        // this._distance2.style.opacity = '0.5';
                        this._distance2.style.color = '#353535';
                        this._distance2.style.padding = '4px';
                        this._distance2.style.position = 'absolute';
                        this._distance2.style.transformOrigin = '0 100%';
                        this._distance2.innerHTML = 'Hello, world!';
                        this._container.appendChild(this._distance2);

                        // add dash line
                        this._dashline = document.createElement('div');
                        this._dashline.setAttribute('class', 'widgets handle dashline');
                        this._dashline.style.position = 'absolute';
                        this._dashline.style.border = 'none';
                        this._dashline.style.borderTop = '2.5px dashed #F9F9F9';
                        this._dashline.style.transformOrigin = '0 100%';
                        this._dashline.style.height = '1px';
                        this._dashline.style.width = '50%';
                        this._container.appendChild(this._dashline);

                        this.updateDOMColor();
                }
        }, {
                key: 'updateDOMPosition',
                value: function updateDOMPosition() {
                        // update rulers lines and text!
                        var x1 = this._handles[0].screenPosition.x;
                        var y1 = this._handles[0].screenPosition.y;
                        var x2 = this._handles[1].screenPosition.x;
                        var y2 = this._handles[1].screenPosition.y;

                        //let x0 = x1 + (x2 - x1)/2;
                        //let y0 = y1 + (y2 - y1)/2;
                        var x0 = x2;
                        var y0 = y2;

                        if (y1 >= y2) {
                                y0 = y2 - 30;
                        } else {
                                y0 = y2 + 30;
                        }

                        var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                        var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                        var posY = y1 - this._container.offsetHeight;

                        // update line
                        var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._line.style.transform = transform;
                        this._line.style.width = length;

                        // update distance
                        var w0 = this._handles[0].worldPosition;
                        var w1 = this._handles[1].worldPosition;

                        this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
                        this._distanceValue = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2);
                        var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
                        x0 -= this._distance.offsetWidth / 2;

                        var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
                        this._distance.style.transform = transform2;

                        // update rulers lines 2 and text!
                        var x3 = this._handles[2].screenPosition.x;
                        var y3 = this._handles[2].screenPosition.y;
                        var x4 = this._handles[3].screenPosition.x;
                        var y4 = this._handles[3].screenPosition.y;

                        //let x0 = x1 + (x2 - x1)/2;
                        //let y0 = y1 + (y2 - y1)/2;
                        var x02 = x4;
                        var y02 = y4;

                        if (y3 >= y4) {
                                y02 = y4 - 30;
                        } else {
                                y02 = y4 + 30;
                        }

                        length = Math.sqrt((x3 - x4) * (x3 - x4) + (y3 - y4) * (y3 - y4));
                        angle = Math.atan2(y4 - y3, x4 - x3) * 180 / Math.PI;

                        posY = y3 - this._container.offsetHeight;

                        // update line
                        transform = 'translate3D(' + x3 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._line2.style.transform = transform;
                        this._line2.style.width = length;

                        // update distance
                        var w02 = this._handles[2].worldPosition;
                        var w12 = this._handles[3].worldPosition;

                        this._distance2.innerHTML = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2) + ' mm';
                        this._distance2Value = Math.sqrt((w02.x - w12.x) * (w02.x - w12.x) + (w02.y - w12.y) * (w02.y - w12.y) + (w02.z - w12.z) * (w02.z - w12.z)).toFixed(2);
                        var posY02 = y02 - this._container.offsetHeight - this._distance2.offsetHeight / 2;
                        x02 -= this._distance2.offsetWidth / 2;

                        transform2 = 'translate3D(' + Math.round(x02) + 'px,' + Math.round(posY02) + 'px, 0)';
                        this._distance2.style.transform = transform2;

                        // update dash line

                        var l1center = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
                        var l2center = this.getPointInBetweenByPerc(this._handles[2].worldPosition, this._handles[3].worldPosition, 0.5);

                        var screen1 = this._handles[0].worldToScreen(l1center, this._camera, this._container);
                        var screen2 = this._handles[0].worldToScreen(l2center, this._camera, this._container);

                        x1 = screen1.x;
                        y1 = screen1.y;
                        x2 = screen2.x;
                        y2 = screen2.y;

                        length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
                        angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

                        posY = y1 - this._container.offsetHeight;

                        // update line
                        transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
                        transform += ' rotate(' + angle + 'deg)';

                        this._dashline.style.transform = transform;
                        this._dashline.style.width = length;
                }
        }, {
                key: 'updateDOMColor',
                value: function updateDOMColor() {
                        this._line.style.backgroundColor = '' + this._color;
                        this._distance.style.borderColor = '' + this._color;

                        this._line2.style.backgroundColor = '' + this._color;
                        this._distance2.style.borderColor = '' + this._color;
                }
        }, {
                key: 'getPointInBetweenByPerc',
                value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

                        var dir = pointB.clone().sub(pointA);
                        var len = dir.length();
                        dir = dir.normalize().multiplyScalar(len * percentage);
                        return pointA.clone().add(dir);
                }
        }, {
                key: 'initOrtho',
                value: function initOrtho() {
                        this._initOrtho = true;

                        var pcenter = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.5);
                        this._handles[2].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.25);
                        this._handles[3].worldPosition = this.getPointInBetweenByPerc(this._handles[0].worldPosition, this._handles[1].worldPosition, 0.75);

                        this._handles[2].worldPosition.x = pcenter.x - Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
                        this._handles[2].worldPosition.y = pcenter.y + Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));

                        this._handles[3].worldPosition.x = pcenter.x + Math.sqrt((pcenter.y - this._handles[2].worldPosition.y) * (pcenter.y - this._handles[2].worldPosition.y));
                        this._handles[3].worldPosition.y = pcenter.y - Math.sqrt((pcenter.x - this._handles[2].worldPosition.x) * (pcenter.x - this._handles[2].worldPosition.x));
                }
        }, {
                key: 'worldPosition',
                get: function get() {
                        return this._worldPosition;
                },
                set: function set(worldPosition) {
                        this._worldPosition = worldPosition;
                        this._handles[0].worldPosition = this._worldPosition;
                        this._handles[1].worldPosition = this._worldPosition;
                        this._handles[2].worldPosition = this._worldPosition;
                        this._handles[3].worldPosition = this._worldPosition;

                        this.update();
                }
        }, {
                key: 'shotestDistance',
                get: function get() {
                        return this._distanceValue < this._distance2Value ? this._distanceValue : this._distance2Value;
                }
        }, {
                key: 'longestDistance',
                get: function get() {
                        return this._distanceValue > this._distance2Value ? this._distanceValue : this._distance2Value;
                }
        }]);

        return WidgetsBiRuler;
}(_widgets2.default);

exports.default = WidgetsBiRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsHandle = function (_WidgetsBase) {
  _inherits(WidgetsHandle, _WidgetsBase);

  function WidgetsHandle(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsHandle);

    var _this = _possibleConstructorReturn(this, (WidgetsHandle.__proto__ || Object.getPrototypeOf(WidgetsHandle)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };
    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of this handle
    _this._worldPosition = new THREE.Vector3();

    // screen position of this handle
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsHandle, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      console.log(evt);
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);
      console.log(this._mouse);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }

    /**
     *
     *
     */

  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();

      // update screen position of handle
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }

    //

  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._mesh) {
        this._mesh.position.x = this._worldPosition.x;
        this._mesh.position.y = this._worldPosition.y;
        this._mesh.position.z = this._worldPosition.z;
      }
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.SphereGeometry(1, 16, 16);

      // material
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 2
      });

      // mesh
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.position.x = this._worldPosition.x;
      this._mesh.position.y = this._worldPosition.y;
      this._mesh.position.z = this._worldPosition.z;
      this._mesh.visible = true;

      this.updateMeshColor();

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget Handle');
      this._dom.style.border = '2px solid';
      this._dom.style.backgroundColor = '#F9F9F9';
      this._dom.style.color = '#F9F9F9';
      this._dom.style.position = 'absolute';
      this._dom.style.width = '12px';
      this._dom.style.height = '12px';
      this._dom.style.margin = '-6px';
      this._dom.style.borderRadius = '50%';
      this._dom.style.transformOrigin = '0 100%';

      var posY = this._screenPosition.y - this._container.offsetHeight;
      this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';

      this.updateDOMColor();

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      // threejs stuff

      // dom
      this._container.removeChild(this._dom);
      // event
      this.removeEventListeners();

      _get(WidgetsHandle.prototype.__proto__ || Object.getPrototypeOf(WidgetsHandle.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);

      this.update();
    },
    get: function get() {
      return this._worldPosition;
    }
  }, {
    key: 'screenPosition',
    set: function set(screenPosition) {
      this._screenPosition = screenPosition;
    },
    get: function get() {
      return this._screenPosition;
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    },
    set: function set(active) {
      this._active = active;
      // this._tracking = this._active;
      this._controls.enabled = !this._active;

      this.update();
    }
  }, {
    key: 'tracking',
    get: function get() {
      return this._tracking;
    },
    set: function set(tracking) {
      this._tracking = tracking;
      this.update();
    }
  }]);

  return WidgetsHandle;
}(_widgets2.default);

exports.default = WidgetsHandle;

},{"../core/core.intersections":102,"../widgets/widgets.base":166}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _widgets = require('./widgets.annotation');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('./widgets.biruler');

var _widgets4 = _interopRequireDefault(_widgets3);

var _widgets5 = require('./widgets.handle');

var _widgets6 = _interopRequireDefault(_widgets5);

var _widgets7 = require('./widgets.roi');

var _widgets8 = _interopRequireDefault(_widgets7);

var _widgets9 = require('./widgets.ruler');

var _widgets10 = _interopRequireDefault(_widgets9);

var _widgets11 = require('./widgets.voxelProbe');

var _widgets12 = _interopRequireDefault(_widgets11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module widgets
 */

exports.default = {
  Annotation: _widgets2.default,
  BiRuler: _widgets4.default,
  Handle: _widgets6.default,
  Roi: _widgets8.default,
  Ruler: _widgets10.default,
  VoxelProbe: _widgets12.default
};

},{"./widgets.annotation":165,"./widgets.biruler":167,"./widgets.handle":168,"./widgets.roi":170,"./widgets.ruler":171,"./widgets.voxelProbe":172}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsRoi = function (_WidgetsBase) {
    _inherits(WidgetsRoi, _WidgetsBase);

    function WidgetsRoi(targetMesh, controls, camera, container) {
        _classCallCheck(this, WidgetsRoi);

        var _this = _possibleConstructorReturn(this, (WidgetsRoi.__proto__ || Object.getPrototypeOf(WidgetsRoi)).call(this));

        _this._targetMesh = targetMesh;
        _this._controls = controls;
        _this._camera = camera;
        _this._container = container;

        _this._active = true;
        _this._init = false;

        _this._worldPosition = new THREE.Vector3();
        if (_this._targetMesh !== null) {
            _this._worldPosition = _this._targetMesh.position;
        }

        // mesh stuff
        _this._material = null;
        _this._geometry = null;
        _this._mesh = null;

        // dom stuff
        _this._lines = [];
        _this._area = null;

        // add handles
        _this._handles = [];

        // first handle
        var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
        firstHandle.worldPosition = _this._worldPosition;
        firstHandle.hovered = true;
        _this.add(firstHandle);

        _this._handles.push(firstHandle);

        // Create ruler
        _this.create();

        _this.onMove = _this.onMove.bind(_this);
        _this.addEventListeners();

        _this._orientation = null;
        _this._slice = null;
        return _this;
    }

    _createClass(WidgetsRoi, [{
        key: 'addEventListeners',
        value: function addEventListeners() {
            this._container.addEventListener('mousewheel', this.onMove);
            this._container.addEventListener('DOMMouseScroll', this.onMove);
        }
    }, {
        key: 'onMove',
        value: function onMove(evt) {
            this._dragged = true;
            var numHandles = this._handles.length;

            if (this.active && !this._init) {
                var lastHandle = this._handles[numHandles - 1];
                lastHandle.hovered = false;
                lastHandle.active = false;
                lastHandle.tracking = false;

                var nextHandle = new _widgets4.default(this._targetMesh, this._controls, this._camera, this._container);
                nextHandle.worldPosition = this._worldPosition;
                nextHandle.hovered = true;
                nextHandle.active = true;
                nextHandle.tracking = true;
                this.add(nextHandle);

                this._handles.push(nextHandle);

                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            var hovered = false;

            for (var index in this._handles) {
                this._handles[index].onMove(evt);
                hovered = hovered || this._handles[index].hovered;
            }

            this._hovered = hovered;

            if (this.active && numHandles > 2) {
                this.pushPopHandle();
            }

            this.update();
        }
    }, {
        key: 'onStart',
        value: function onStart(evt) {
            this._dragged = false;

            var active = false;

            for (var index in this._handles) {
                this._handles[index].onStart(evt);
                active = active || this._handles[index].active;
            }

            this._active = active;
            this.update();
        }
    }, {
        key: 'onEnd',
        value: function onEnd(evt) {
            // First Handle
            var active = false;
            for (var index in this._handles.slice(0, this._handles.length - 2)) {
                this._handles[index].onEnd(evt);
                active = active || this._handles[index].active;
            }

            // Second Handle
            if (this._dragged || !this._handles[this._handles.length - 1].tracking) {
                this._handles[this._handles.length - 1].tracking = false;
                this._handles[this._handles.length - 1].onEnd(evt);
            } else {
                this._handles[this._handles.length - 1].tracking = false;
            }

            active = active || this._handles[this._handles.length - 1].active;
            // State of ruler widget
            this._active = active;

            if (this._lines.length < this._handles.length) {
                var newLine = document.createElement('div');
                newLine.setAttribute('class', 'widgets handle line');
                newLine.style.position = 'absolute';
                newLine.style.transformOrigin = '0 100%';
                newLine.style.marginTop = '-1px';
                newLine.style.height = '2px';
                newLine.style.width = '3px';
                newLine.style.backgroundColor = '#F9F9F9';

                this._lines.push(newLine);
                this._container.appendChild(newLine);
            }

            this._init = true;
            this.updateMesh();
            this.update();
        }
    }, {
        key: 'create',
        value: function create() {
            this.createDOM();
        }
    }, {
        key: 'hideDOM',
        value: function hideDOM() {
            for (var index in this._handles) {
                this._handles[index].hideDOM();
            }

            for (var _index in this._lines) {
                this._lines[_index].style.display = 'none';
            }
        }
    }, {
        key: 'showDOM',
        value: function showDOM() {
            for (var index in this._handles) {
                this._handles[index].showDOM();
            }

            for (var _index2 in this._lines) {
                this._lines[_index2].style.display = '';
            }
        }
    }, {
        key: 'hideMesh',
        value: function hideMesh() {
            this.visible = false;
        }
    }, {
        key: 'showMesh',
        value: function showMesh() {
            this.visible = true;
        }
    }, {
        key: 'show',
        value: function show() {
            this.showDOM();
            this.showMesh();
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.hideDOM();
            this.hideMesh();
        }
    }, {
        key: 'update',
        value: function update() {
            this.updateColor();

            for (var index in this._handles) {
                this._handles[index].update();
            }

            // mesh stuff
            this.updateMeshColor();
            this.updateMeshPosition();

            // DOM stuff
            this.updateDOMPosition();
            this.updateDOMColor();
        }
    }, {
        key: 'updateMesh',
        value: function updateMesh() {
            // geometry
            this._geometry = new THREE.Geometry();
            for (var index in this._handles) {
                this._geometry.vertices.push(this._handles[index].worldPosition);
            }

            // material
            this._material = new THREE.LineBasicMaterial();
            this.updateMeshColor();

            // mesh
            this._mesh = new THREE.Line(this._geometry, this._material);
            this._mesh.visible = true;

            // add it!
            this.add(this._mesh);
        }
    }, {
        key: 'updateMeshColor',
        value: function updateMeshColor() {
            if (this._material) {
                this._material.color.set(this._color);
            }
        }
    }, {
        key: 'updateMeshPosition',
        value: function updateMeshPosition() {
            if (this._geometry) {
                this._geometry.verticesNeedUpdate = true;
            }
        }
    }, {
        key: 'createDOM',
        value: function createDOM() {
            // add line!
            this._line = document.createElement('div');
            this._line.setAttribute('class', 'widgets handle line');
            this._line.style.position = 'absolute';
            this._line.style.transformOrigin = '0 100%';
            this._line.style.marginTop = '-1px';
            this._line.style.height = '2px';
            this._line.style.width = '3px';
            this._container.appendChild(this._line);

            this.updateDOMColor();
        }
    }, {
        key: 'isPointOnLine',
        value: function isPointOnLine(pointA, pointB, pointToCheck) {
            var c = new THREE.Vector3();
            c.crossVectors(pointA.clone().sub(pointToCheck), pointB.clone().sub(pointToCheck));
            return !c.length();
        }
    }, {
        key: 'pushPopHandle',
        value: function pushPopHandle() {
            var handle0 = this._handles[this._handles.length - 3];
            var handle1 = this._handles[this._handles.length - 2];
            var newhandle = this._handles[this._handles.length - 1];

            var isOnLine = this.isPointOnLine(handle0.worldPosition, handle1.worldPosition, newhandle.worldPosition);

            if (isOnLine) {
                handle1._dom.style.display = 'none';
                this.remove(handle1);

                this._handles[this._handles.length - 2] = newhandle;
                this._handles.pop();

                var tempLine = this._lines.pop();
                tempLine.style.display = 'none';
                this._container.removeChild(tempLine);
            }

            return isOnLine;
        }
    }, {
        key: 'updateLineDOM',
        value: function updateLineDOM(lineIndex, handle0Index, handle1Index) {
            // update rulers lines and text!
            var x1 = this._handles[handle0Index].screenPosition.x;
            var y1 = this._handles[handle0Index].screenPosition.y;
            var x2 = this._handles[handle1Index].screenPosition.x;
            var y2 = this._handles[handle1Index].screenPosition.y;

            var x0 = x2;
            var y0 = y2;

            if (y1 >= y2) {
                y0 = y2 - 30;
            } else {
                y0 = y2 + 30;
            }

            var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            var posY = y1 - this._container.offsetHeight;

            // update line
            var transform = 'translate3D(' + x1 + 'px, ' + posY + 'px, 0)';
            transform += ' rotate(' + angle + 'deg)';

            //this._lines[lineIndex].style.display = '';
            this._lines[lineIndex].style.transform = transform;
            this._lines[lineIndex].style.width = length + 'px';
        }
    }, {
        key: 'updateDOMPosition',
        value: function updateDOMPosition() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this.updateLineDOM(index, index, parseInt(index) + 1 == this._handles.length ? 0 : parseInt(index) + 1);
                }
            }
        }
    }, {
        key: 'updateDOMColor',
        value: function updateDOMColor() {
            if (this._handles.length >= 2) {
                for (var index in this._lines) {
                    this._lines[index].style.backgroundColor = '' + this._color;
                }
            }
        }
    }, {
        key: 'getPointInBetweenByPerc',
        value: function getPointInBetweenByPerc(pointA, pointB, percentage) {

            var dir = pointB.clone().sub(pointA);
            var len = dir.length();
            dir = dir.normalize().multiplyScalar(len * percentage);
            return pointA.clone().add(dir);
        }
    }, {
        key: 'worldPosition',
        get: function get() {
            return this._worldPosition;
        },
        set: function set(worldPosition) {
            this._worldPosition = worldPosition;

            for (var index in this._handles) {
                this._handles[index]._worldPosition = this._worldPosition;
            }

            this.update();
        }
    }]);

    return WidgetsRoi;
}(_widgets2.default);

exports.default = WidgetsRoi;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _widgets3 = require('../widgets/widgets.handle');

var _widgets4 = _interopRequireDefault(_widgets3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/handle
 *
 */

var WidgetsRuler = function (_WidgetsBase) {
  _inherits(WidgetsRuler, _WidgetsBase);

  function WidgetsRuler(targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsRuler);

    var _this = _possibleConstructorReturn(this, (WidgetsRuler.__proto__ || Object.getPrototypeOf(WidgetsRuler)).call(this, container));

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    _this._active = true;
    _this._lastEvent = null;

    _this._worldPosition = new THREE.Vector3();
    if (_this._targetMesh !== null) {
      _this._worldPosition = _this._targetMesh.position;
    }

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;

    // dom stuff
    _this._line = null;
    _this._distance = null;

    // add handles
    _this._handles = [];

    // first handle
    var firstHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    firstHandle.worldPosition = _this._worldPosition;
    firstHandle.hovered = true;
    _this.add(firstHandle);

    _this._handles.push(firstHandle);

    var secondHandle = new _widgets4.default(_this._targetMesh, _this._controls, _this._camera, _this._container);
    secondHandle.worldPosition = _this._worldPosition;
    secondHandle.hovered = true;
    // active and tracking might be redundant
    secondHandle.active = true;
    secondHandle.tracking = true;
    _this.add(secondHandle);

    _this._handles.push(secondHandle);

    // Create ruler
    _this.create();
    _this.initOffsets();

    _this.onMove = _this.onMove.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsRuler, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      this._dragged = true;

      this._handles[0].onMove(evt);
      this._handles[1].onMove(evt);

      this._hovered = this._handles[0].hovered || this._handles[1].hovered;
      this.update();
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      this._dragged = false;

      this._handles[0].onStart(evt);
      this._handles[1].onStart(evt);

      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      // First Handle
      this._handles[0].onEnd(evt);

      // window.console.log(this);

      // Second Handle
      if (this._dragged || !this._handles[1].tracking) {
        this._handles[1].tracking = false;
        this._handles[1].onEnd(evt);
      } else {
        this._handles[1].tracking = false;
      }

      // State of ruler widget
      this._active = this._handles[0].active || this._handles[1].active;
      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'create',
    value: function create() {
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._line.style.display = 'none';
      this._distance.style.display = 'none';
      for (var index in this._handles) {
        this._handles[index].hideDOM();
      }
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._line.style.display = '';
      this._distance.style.display = '';
      for (var index in this._handles) {
        this._handles[index].showDOM();
      }
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'update',
    value: function update() {
      this.updateColor();

      // update handles
      this._handles[0].update();
      this._handles[1].update();

      // mesh stuff
      this.updateMeshColor();
      this.updateMeshPosition();

      // DOM stuff
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      // geometry
      this._geometry = new THREE.Geometry();
      this._geometry.vertices.push(this._handles[0].worldPosition);
      this._geometry.vertices.push(this._handles[1].worldPosition);

      // material
      this._material = new THREE.LineBasicMaterial();
      this.updateMeshColor();

      // mesh
      this._mesh = new THREE.Line(this._geometry, this._material);
      this._mesh.visible = true;

      // add it!
      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'updateMeshPosition',
    value: function updateMeshPosition() {
      if (this._geometry) {
        this._geometry.verticesNeedUpdate = true;
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // add line!
      this._line = document.createElement('div');
      this._line.setAttribute('id', this.uuid);
      this._line.setAttribute('class', 'AMI Widget Ruler');
      this._line.style.position = 'absolute';
      this._line.style.transformOrigin = '0 100%';
      this._line.style.marginTop = '-1px';
      this._line.style.height = '2px';
      this._line.style.width = '3px';
      this._container.appendChild(this._line);

      // add distance!
      this._distance = document.createElement('div');
      this._distance.setAttribute('class', 'widgets handle distance');
      this._distance.style.border = '2px solid';
      this._distance.style.backgroundColor = '#F9F9F9';
      // this._distance.style.opacity = '0.5';
      this._distance.style.color = '#353535';
      this._distance.style.padding = '4px';
      this._distance.style.position = 'absolute';
      this._distance.style.transformOrigin = '0 100%';
      this._distance.innerHTML = 'Hello, world!';
      this._container.appendChild(this._distance);

      this.updateDOMColor();
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      // update rulers lines and text!
      var x1 = this._handles[0].screenPosition.x;
      var y1 = this._handles[0].screenPosition.y;
      var x2 = this._handles[1].screenPosition.x;
      var y2 = this._handles[1].screenPosition.y;

      //let x0 = x1 + (x2 - x1)/2;
      //let y0 = y1 + (y2 - y1)/2;
      var x0 = x2;
      var y0 = y2;

      if (y1 >= y2) {
        y0 = y2 - 30;
      } else {
        y0 = y2 + 30;
      }

      var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

      var posY = y1 - this._container.offsetHeight;

      // update line
      var transform = 'translate3D(' + x1 + 'px,' + posY + 'px, 0)';
      transform += ' rotate(' + angle + 'deg)';

      this._line.style.transform = transform;
      this._line.style.width = length + 'px';

      // update distance
      var w0 = this._handles[0].worldPosition;
      var w1 = this._handles[1].worldPosition;

      this._distance.innerHTML = Math.sqrt((w0.x - w1.x) * (w0.x - w1.x) + (w0.y - w1.y) * (w0.y - w1.y) + (w0.z - w1.z) * (w0.z - w1.z)).toFixed(2) + ' mm';
      var posY0 = y0 - this._container.offsetHeight - this._distance.offsetHeight / 2;
      x0 -= this._distance.offsetWidth / 2;

      var transform2 = 'translate3D(' + Math.round(x0) + 'px,' + Math.round(posY0) + 'px, 0)';
      this._distance.style.transform = transform2;
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._line.style.backgroundColor = '' + this._color;
      this._distance.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._handles.forEach(function (h) {
        h.free();
      });

      this._handles = [];

      this._container.removeChild(this._line);
      this._container.removeChild(this._distance);

      this.remove(this._mesh);

      _get(WidgetsRuler.prototype.__proto__ || Object.getPrototypeOf(WidgetsRuler.prototype), 'free', this).call(this);
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this._worldPosition;
    },
    set: function set(worldPosition) {
      this._worldPosition = worldPosition;
      this._handles[0].worldPosition = this._worldPosition;
      this._handles[1].worldPosition = this._worldPosition;

      this.update();
    }
  }]);

  return WidgetsRuler;
}(_widgets2.default);

exports.default = WidgetsRuler;

},{"../widgets/widgets.base":166,"../widgets/widgets.handle":168}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _widgets = require('../widgets/widgets.base');

var _widgets2 = _interopRequireDefault(_widgets);

var _geometries = require('../geometries/geometries.voxel');

var _geometries2 = _interopRequireDefault(_geometries);

var _models = require('../models/models.stack');

var _models2 = _interopRequireDefault(_models);

var _models3 = require('../models/models.voxel');

var _models4 = _interopRequireDefault(_models3);

var _core = require('../core/core.intersections');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module widgets/voxelProbe
 */

var WidgetsVoxelProbe = function (_WidgetsBase) {
  _inherits(WidgetsVoxelProbe, _WidgetsBase);

  function WidgetsVoxelProbe(stack, targetMesh, controls, camera, container) {
    _classCallCheck(this, WidgetsVoxelProbe);

    var _this = _possibleConstructorReturn(this, (WidgetsVoxelProbe.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe)).call(this, container));

    _this._stack = stack;

    _this._targetMesh = targetMesh;
    _this._controls = controls;
    _this._camera = camera;

    // if no target mesh, use plane for FREE dragging.
    _this._plane = {
      position: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };

    _this._offset = new THREE.Vector3();
    _this._raycaster = new THREE.Raycaster();

    _this._tracking = false;

    _this._mouse = new THREE.Vector2();
    _this._lastEvent = null;

    // world (LPS) position of the center
    _this._worldPosition = new THREE.Vector3();

    // screen position of the center
    _this._screenPosition = new THREE.Vector2();

    // mesh stuff
    _this._material = null;
    _this._geometry = null;
    _this._mesh = null;
    _this._meshDisplayed = true;
    _this._meshHovered = false;
    _this._meshStyle = 'sphere'; // cube, etc.

    // dom stuff
    _this._dom = null;
    _this._domDisplayed = true;
    _this._domHovered = false;
    _this._domStyle = 'circle'; // square, triangle

    if (_this._targetMesh !== null) {
      _this._worldPosition.copy(_this._targetMesh.position);
    }

    _this._screenPosition = _this.worldToScreen(_this._worldPosition, _this._camera, _this._container);

    // create handle
    _this.create();
    _this.initOffsets();

    // event listeners
    _this.onMove = _this.onMove.bind(_this);
    _this.onHover = _this.onHover.bind(_this);
    _this.onEndControl = _this.onEndControl.bind(_this);
    _this.addEventListeners();
    return _this;
  }

  _createClass(WidgetsVoxelProbe, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      this._dom.addEventListener('mouseenter', this.onHover);
      this._dom.addEventListener('mouseleave', this.onHover);

      this._container.addEventListener('mousewheel', this.onMove);
      this._container.addEventListener('DOMMouseScroll', this.onMove);

      this._controls.addEventListener('end', this.onEndControl);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      this._dom.removeEventListener('mouseenter', this.onHover);
      this._dom.removeEventListener('mouseleave', this.onHover);

      this._container.removeEventListener('mousewheel', this.onMove);
      this._container.removeEventListener('DOMMouseScroll', this.onMove);

      this._controls.removeEventListener('end', this.onEndControl);
    }
  }, {
    key: 'onStart',
    value: function onStart(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._hovered) {
        this._active = true;
        this._controls.enabled = false;

        if (this._targetMesh) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._offset.copy(intersectsTarget[0].point).sub(this._worldPosition);
          }
        } else {
          this._plane.position.copy(this._worldPosition);
          this._plane.direction.copy(this._camera.getWorldDirection());
          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._offset.copy(intersection).sub(this._plane.position);
          }
        }

        this.update();
      }
    }
  }, {
    key: 'onEnd',
    value: function onEnd(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      // stay active and keep controls disabled
      if (this._tracking === true) {
        return;
      }

      // unselect if go up without moving
      if (!this._dragged && this._active) {
        // change state if was not dragging
        this._selected = !this._selected;
      }

      this._active = false;
      this._dragged = false;
      this._controls.enabled = true;

      this.update();
    }
  }, {
    key: 'onEndControl',
    value: function onEndControl() {
      var _this2 = this;

      if (!this._lastEvent) {
        return;
      }

      window.requestAnimationFrame(function () {
        _this2.onMove(_this2._lastEvent);
      });
    }
  }, {
    key: 'onMove',
    value: function onMove(evt) {
      this._lastEvent = evt;
      evt.preventDefault();

      var offsets = this.getMouseOffsets(evt, this._container);
      this._mouse.set(offsets.x, offsets.y);

      // update raycaster
      // set ray.position to satisfy CoreIntersections::rayPlane API
      this._raycaster.setFromCamera(this._mouse, this._camera);
      this._raycaster.ray.position = this._raycaster.ray.origin;

      if (this._active) {
        this._dragged = true;

        if (this._targetMesh !== null) {
          var intersectsTarget = this._raycaster.intersectObject(this._targetMesh);
          if (intersectsTarget.length > 0) {
            this._worldPosition.copy(intersectsTarget[0].point.sub(this._offset));
          }
        } else {
          if (this._plane.direction.length() === 0) {
            // free mode!this._targetMesh
            this._plane.position.copy(this._worldPosition);
            this._plane.direction.copy(this._camera.getWorldDirection());
          }

          var intersection = _core2.default.rayPlane(this._raycaster.ray, this._plane);
          if (intersection !== null) {
            this._worldPosition.copy(intersection.sub(this._offset));
          }
        }
      } else {
        this.onHover(null);
      }

      this.update();
    }
  }, {
    key: 'onHover',
    value: function onHover(evt) {
      if (evt) {
        this._lastEvent = evt;
        evt.preventDefault();
        this.hoverDom(evt);
      }

      this.hoverMesh();

      this._hovered = this._meshHovered || this._domHovered;
      this._container.style.cursor = this._hovered ? 'pointer' : 'default';
    }
  }, {
    key: 'hoverMesh',
    value: function hoverMesh() {
      // check raycast intersection, do we want to hover on mesh or just css?
      var intersectsHandle = this._raycaster.intersectObject(this._mesh);
      this._meshHovered = intersectsHandle.length > 0;
    }
  }, {
    key: 'hoverDom',
    value: function hoverDom(evt) {
      this._domHovered = evt.type === 'mouseenter';
    }
  }, {
    key: 'worldToScreen',
    value: function worldToScreen(worldCoordinate, camera, canvas) {
      var screenCoordinates = worldCoordinate.clone();
      screenCoordinates.project(camera);

      screenCoordinates.x = Math.round((screenCoordinates.x + 1) * canvas.offsetWidth / 2);
      screenCoordinates.y = Math.round((-screenCoordinates.y + 1) * canvas.offsetHeight / 2);
      screenCoordinates.z = 0;

      return screenCoordinates;
    }
  }, {
    key: 'create',
    value: function create() {
      this.createVoxel();
      this.createMesh();
      this.createDOM();
    }
  }, {
    key: 'createVoxel',
    value: function createVoxel() {
      this._voxel = new _models4.default();
      this._voxel.id = this.id;
      this._voxel.worldCoordinates = this._worldCoordinates;
    }
  }, {
    key: 'createMesh',
    value: function createMesh() {
      var dataCoordinates = _models2.default.worldToData(this._stack, this._worldPosition);

      this._geometry = new _geometries2.default(dataCoordinates);
      this._material = new THREE.MeshBasicMaterial({
        wireframe: true,
        wireframeLinewidth: 1
      });
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._mesh.applyMatrix(this._stack.ijk2LPS);
      this._mesh.visible = true;

      this.updateMeshColor();

      this.add(this._mesh);
    }
  }, {
    key: 'updateMeshColor',
    value: function updateMeshColor() {
      if (this._material) {
        this._material.color.set(this._color);
      }
    }
  }, {
    key: 'createDOM',
    value: function createDOM() {
      // dom
      this._dom = document.createElement('div');
      this._dom.setAttribute('id', this.uuid);
      this._dom.setAttribute('class', 'AMI Widget VoxelProbe');
      this._dom.style.border = '2px solid #000';
      this._dom.style.backgroundColor = 'rgb(249, 249, 249)';
      this._dom.style.color = '#212121';
      this._dom.style.position = 'absolute';
      this._dom.style.transformOrigin = '0px 100% 0px';

      // measurenents
      var measurementsContainer = document.createElement('div');
      // LPS
      var lpsContainer = document.createElement('div');
      lpsContainer.setAttribute('id', 'lpsPosition');
      measurementsContainer.appendChild(lpsContainer);
      // IJK
      var ijkContainer = document.createElement('div');
      ijkContainer.setAttribute('id', 'ijkPosition');
      measurementsContainer.appendChild(ijkContainer);
      // Value
      var valueContainer = document.createElement('div');
      valueContainer.setAttribute('id', 'value');
      measurementsContainer.appendChild(valueContainer);

      this.updateDOMColor();
      this._dom.appendChild(measurementsContainer);

      // add it!
      this._container.appendChild(this._dom);
    }
  }, {
    key: 'updateDOMContent',
    value: function updateDOMContent() {
      var rasContainer = this._dom.querySelector('#lpsPosition');
      rasContainer.innerHTML = 'LPS: \n      ' + this._voxel.worldCoordinates.x.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.y.toFixed(2) + ' :\n      ' + this._voxel.worldCoordinates.z.toFixed(2);

      var ijkContainer = this._dom.querySelector('#ijkPosition');
      ijkContainer.innerHTML = 'IJK: \n      ' + this._voxel.dataCoordinates.x + ' :\n      ' + this._voxel.dataCoordinates.y + ' :\n      ' + this._voxel.dataCoordinates.z;

      var valueContainer = this._dom.querySelector('#value');
      valueContainer.innerHTML = 'Value: ' + this._voxel.value;
    }
  }, {
    key: 'update',
    value: function update() {
      // general update
      this.updateColor();
      this._screenPosition = this.worldToScreen(this._worldPosition, this._camera, this._container);

      // set data coordinates && value
      this.updateVoxel(this._worldPosition);

      // update mesh position
      this.updateMeshColor();
      if (this._mesh && this._mesh.geometry) {
        this._mesh.geometry.location = this._voxel.dataCoordinates;
        this._mesh.updateMatrix();
      }

      // update dom
      this.updateDOMContent();
      this.updateDOMColor();
      this.updateDOMPosition();
    }
  }, {
    key: 'updateVoxel',
    value: function updateVoxel(worldCoordinates) {
      // update world coordinates
      this._voxel.worldCoordinates = worldCoordinates;

      // update data coordinates
      this._voxel.dataCoordinates = _models2.default.worldToData(this._stack, this._voxel.worldCoordinates);

      // update value
      var value = _models2.default.value(this._stack, this._voxel.dataCoordinates);

      this._voxel.value = _models2.default.valueRescaleSlopeIntercept(value, this._stack.rescaleSlope, this._stack.rescaleIntercept);
    }
  }, {
    key: 'updateDOMPosition',
    value: function updateDOMPosition() {
      if (this._dom) {
        var posY = this._screenPosition.y - this._container.offsetHeight;
        this._dom.style.transform = 'translate3D(' + this._screenPosition.x + 'px, ' + posY + 'px, 0)';
      }
    }
  }, {
    key: 'updateDOMColor',
    value: function updateDOMColor() {
      this._dom.style.borderColor = '' + this._color;
    }
  }, {
    key: 'free',
    value: function free() {
      this._container.removeEventListener('mouseup', this.onMouseUpHandler, false);
      this._container.removeEventListener('mousemove', this.onMouseMoveHandler, false);

      this._container.removeEventListener('mousewheel', this.onMouseMoveHandler, false);
      this._container.removeEventListener('DOMMouseScroll', this.onMouseMoveHandler, false);

      this._voxel.removeTest();
      this.remove(this._voxel);
      this._voxel = null;

      _get(WidgetsVoxelProbe.prototype.__proto__ || Object.getPrototypeOf(WidgetsVoxelProbe.prototype), 'free', this).call(this);
    }
  }, {
    key: 'hoverVoxel',
    value: function hoverVoxel(mouseScreenCoordinates, currentDataCoordinates) {
      // update distance mouse/this._voxel
      var dx = mouseScreenCoordinates.screenX - this._voxel.voxel.screenCoordinates.x;
      var dy = mouseScreenCoordinates.screenY - this._voxel.voxel.screenCoordinates.y;
      var distance = Math.sqrt(dx * dx + dy * dy);
      this._voxel.distance = distance;
      if (distance >= 0 && distance < 10) {
        this._hover = true;
      } else {
        this._hover = false;
      }
    }
  }, {
    key: 'hideDOM',
    value: function hideDOM() {
      this._dom.style.display = 'none';
    }
  }, {
    key: 'showDOM',
    value: function showDOM() {
      this._dom.style.display = '';
    }
  }, {
    key: 'hideMesh',
    value: function hideMesh() {
      this.visible = false;
    }
  }, {
    key: 'showMesh',
    value: function showMesh() {
      this.visible = true;
    }
  }, {
    key: 'show',
    value: function show() {
      this.showDOM();
      this.showMesh();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.hideDOM();
      this.hideMesh();
    }
  }, {
    key: 'worldPosition',
    set: function set(worldPosition) {
      this._worldPosition.copy(worldPosition);
      this.update();
    }
  }, {
    key: 'defaultColor',
    set: function set(defaultColor) {
      this._defaultColor = defaultColor;
      this.update();
    },
    get: function get() {
      return this._defaultColor;
    }
  }, {
    key: 'activeColor',
    set: function set(activeColor) {
      this._activeColor = activeColor;
      this.update();
    },
    get: function get() {
      return this._activeColor;
    }
  }, {
    key: 'hoverColor',
    set: function set(hoverColor) {
      this._hoverColor = hoverColor;
      this.update();
    },
    get: function get() {
      return this._hoverColor;
    }
  }, {
    key: 'selectedColor',
    set: function set(selectedColor) {
      this._selectedColor = selectedColor;
      this.update();
    },
    get: function get() {
      return this._selectedColor;
    }
  }, {
    key: 'showVoxel',
    set: function set(showVoxel) {
      this._showVoxel = showVoxel;
      this.update();
    },
    get: function get() {
      return this._showVoxel;
    }
  }, {
    key: 'showDomSVG',
    set: function set(showDomSVG) {
      this._showDomSVG = showDomSVG;
      this.update();
    },
    get: function get() {
      return this._showDomSVG;
    }
  }, {
    key: 'showDomMeasurements',
    set: function set(showDomMeasurements) {
      this._showDomMeasurements = showDomMeasurements;
      this.update();
    },
    get: function get() {
      return this._showDomMeasurements;
    }
  }]);

  return WidgetsVoxelProbe;
}(_widgets2.default);

exports.default = WidgetsVoxelProbe;

},{"../core/core.intersections":102,"../geometries/geometries.voxel":109,"../models/models.stack":134,"../models/models.voxel":135,"../widgets/widgets.base":166}]},{},[95])(95)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pwZWcuanMiLCJleHRlcm5hbC9zY3JpcHRzL2pweC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXpsaWIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL3NyYy9iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29uc3QtbmluZi1mbG9hdDMyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zdC1waW5mLWZsb2F0MzIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kaWNvbS1wYXJzZXIvZGlzdC9kaWNvbVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9jb21wb25lbnQtc3BlYy5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2RhdGEtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2ZyYW1lLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL2h1ZmZtYW4tdGFibGUuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvcXVhbnRpemF0aW9uLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pwZWctbG9zc2xlc3MtZGVjb2Rlci1qcy9zcmMvc2Nhbi1jb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3NyYy9zY2FuLWhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtYWJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWNlaWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9kaXYyLmpzIiwibm9kZV9tb2R1bGVzL21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWZsb2F0MzItdG8tYmluYXJ5LXN0cmluZy9saWIvbXVsdDIuanMiLCJub2RlX21vZHVsZXMvbWF0aC1mbG9vci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmlmdGktcmVhZGVyLWpzL3NyYy9uaWZ0aS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMS5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL25pZnRpMi5qcyIsIm5vZGVfbW9kdWxlcy9uaWZ0aS1yZWFkZXItanMvc3JjL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9ucnJkLWpzL25ycmQuanMiLCJub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlscy1sZWZ0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJlcGVhdC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWxzLXJpZ2h0LXBhZC1zdHJpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmlvLW51bWJlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZS9saWIvaW5kZXguanMiLCJwYWNrYWdlLmpzb24iLCJzcmNcXGFtaS5qcyIsInNyY1xcY2FtZXJhc1xcY2FtZXJhcy5qcyIsInNyY1xcY2FtZXJhc1xcY2FtZXJhcy5vcnRob2dyYXBoaWMuanMiLCJzcmNcXGNvbnRyb2xzXFxjb250cm9scy5qcyIsInNyY1xcY29udHJvbHNcXGNvbnRyb2xzLnRyYWNrYmFsbC5qcyIsInNyY1xcY29udHJvbHNcXGNvbnRyb2xzLnRyYWNrYmFsbG9ydGhvLmpzIiwic3JjXFxjb3JlXFxjb3JlLmNvbG9ycy5qcyIsInNyY1xcY29yZVxcY29yZS5pbnRlcnNlY3Rpb25zLmpzIiwic3JjXFxjb3JlXFxjb3JlLmpzIiwic3JjXFxjb3JlXFxjb3JlLnBhY2suanMiLCJzcmNcXGNvcmVcXGNvcmUudXRpbHMuanMiLCJzcmNcXGNvcmVcXGNvcmUudmFsaWRhdG9ycy5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy5zbGljZS5qcyIsInNyY1xcZ2VvbWV0cmllc1xcZ2VvbWV0cmllcy52b3hlbC5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5ib3JkZXIuanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMuYm91bmRpbmdib3guanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMuanMiLCJzcmNcXGhlbHBlcnNcXGhlbHBlcnMubG9jYWxpemVyLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLmx1dC5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5tYXRlcmlhbC5taXhpbi5qcyIsInNyY1xcaGVscGVyc1xcaGVscGVycy5wcm9ncmVzc2Jhci5ldmVudGJhc2VkLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnByb2dyZXNzYmFyLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnNsaWNlLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnN0YWNrLmpzIiwic3JjXFxoZWxwZXJzXFxoZWxwZXJzLnZvbHVtZXJlbmRlcmluZy5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54LmludGVyYWN0b3IuanMiLCJzcmNcXGhlbHBlcnNcXHhcXGhlbHBlcnMueC5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54Lm1lc2guanMiLCJzcmNcXGhlbHBlcnNcXHhcXGhlbHBlcnMueC5yZW5kZXJlcjJkLmpzIiwic3JjXFxoZWxwZXJzXFx4XFxoZWxwZXJzLngucmVuZGVyZXIzZC5qcyIsInNyY1xcaGVscGVyc1xceFxcaGVscGVycy54LnZvbHVtZS5qcyIsInNyY1xcbG9hZGVyc1xcbG9hZGVycy5iYXNlLmpzIiwic3JjXFxsb2FkZXJzXFxsb2FkZXJzLmpzIiwic3JjXFxsb2FkZXJzXFxsb2FkZXJzLnZvbHVtZS5qcyIsInNyY1xcbW9kZWxzXFxtb2RlbHMuYmFzZS5qcyIsInNyY1xcbW9kZWxzXFxtb2RlbHMuZnJhbWUuanMiLCJzcmNcXG1vZGVsc1xcbW9kZWxzLmpzIiwic3JjXFxtb2RlbHNcXG1vZGVscy5zZXJpZXMuanMiLCJzcmNcXG1vZGVsc1xcbW9kZWxzLnN0YWNrLmpzIiwic3JjXFxtb2RlbHNcXG1vZGVscy52b3hlbC5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5kaWNvbS5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy5taGQuanMiLCJzcmNcXHBhcnNlcnNcXHBhcnNlcnMubmlmdGkuanMiLCJzcmNcXHBhcnNlcnNcXHBhcnNlcnMubnJyZC5qcyIsInNyY1xccGFyc2Vyc1xccGFyc2Vycy52b2x1bWUuanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy5pbnRlcnNlY3RCb3guanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy50ZXh0dXJlM2QuanMiLCJzcmNcXHNoYWRlcnNcXGhlbHBlcnNcXHNoYWRlcnMuaGVscGVycy51bnBhY2suanMiLCJzcmNcXHNoYWRlcnNcXGludGVycG9sYXRpb25cXHNoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eS5qcyIsInNyY1xcc2hhZGVyc1xcaW50ZXJwb2xhdGlvblxcc2hhZGVycy5pbnRlcnBvbGF0aW9uLmpzIiwic3JjXFxzaGFkZXJzXFxpbnRlcnBvbGF0aW9uXFxzaGFkZXJzLmludGVycG9sYXRpb24udHJpbGluZWFyLmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmJhc2UuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuY29udG91ci5mcmFnbWVudC5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5jb250b3VyLnVuaWZvcm0uanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuY29udG91ci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuZGF0YS5mcmFnbWVudC5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5kYXRhLnVuaWZvcm0uanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuZGF0YS52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubGF5ZXIuZnJhZ21lbnQuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubGF5ZXIudW5pZm9ybS5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy5sYXllci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50LmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmxvY2FsaXplci51bmlmb3JtLmpzIiwic3JjXFxzaGFkZXJzXFxzaGFkZXJzLmxvY2FsaXplci52ZXJ0ZXguanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMudnIuZnJhZ21lbnQuanMiLCJzcmNcXHNoYWRlcnNcXHNoYWRlcnMudnIudW5pZm9ybS5qcyIsInNyY1xcc2hhZGVyc1xcc2hhZGVycy52ci52ZXJ0ZXguanMiLCJzcmNcXHdpZGdldHNcXHdpZGdldHMuYW5ub3RhdGlvbi5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy5iYXNlLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLmJpcnVsZXIuanMiLCJzcmNcXHdpZGdldHNcXHdpZGdldHMuaGFuZGxlLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLmpzIiwic3JjXFx3aWRnZXRzXFx3aWRnZXRzLnJvaS5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy5ydWxlci5qcyIsInNyY1xcd2lkZ2V0c1xcd2lkZ2V0cy52b3hlbFByb2JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy96REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzU2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtB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QW9CLFdBQXBCO0FBQ0EsV0FBSyxNQUFMO0FBQ0QsSzt3QkFFaUI7QUFDaEIsYUFBTyxLQUFLLFlBQVo7QUFDRDs7O3NCQUVjLFUsRUFBWTtBQUN6QixXQUFLLFdBQUwsR0FBbUIsVUFBbkI7QUFDQSxXQUFLLE1BQUw7QUFDRCxLO3dCQUVnQjtBQUNmLGFBQU8sS0FBSyxXQUFaO0FBQ0Q7OztzQkFFaUIsYSxFQUFlO0FBQy9CLFdBQUssY0FBTCxHQUFzQixhQUF0QjtBQUNBLFdBQUssTUFBTDtBQUNELEs7d0JBRW1CO0FBQ2xCLGFBQU8sS0FBSyxjQUFaO0FBQ0Q7OztzQkFFYSxTLEVBQVc7QUFDdkIsV0FBSyxVQUFMLEdBQWtCLFNBQWxCO0FBQ0EsV0FBSyxNQUFMO0FBQ0QsSzt3QkFFZTtBQUNkLGFBQU8sS0FBSyxVQUFaO0FBQ0Q7OztzQkFFYyxVLEVBQVk7QUFDekIsV0FBSyxXQUFMLEdBQW1CLFVBQW5CO0FBQ0EsV0FBSyxNQUFMO0FBQ0QsSzt3QkFFZ0I7QUFDZixhQUFPLEtBQUssV0FBWjtBQUNEOzs7c0JBRXVCLG1CLEVBQXFCO0FBQzNDLFdBQUssb0JBQUwsR0FBNEIsbUJBQTVCO0FBQ0EsV0FBSyxNQUFMO0FBQ0QsSzt3QkFFeUI7QUFDeEIsYUFBTyxLQUFLLG9CQUFaO0FBQ0Q7Ozs7OztrQkFuZGtCLGlCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIGpzaGludCBpZ25vcmU6IHN0YXJ0XHJcblxyXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAvXHJcbiAvKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXHJcbi8qXHJcbiBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXRcclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MVxyXG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvaXR1LXQ4MS5wZGYpXHJcbi8vIC0gVGhlIEpGSUYgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIEpQRUcgRmlsZSBJbnRlcmNoYW5nZSBGb3JtYXRcclxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZilcclxuLy8gLSBUaGUgQWRvYmUgQXBwbGljYXRpb24tU3BlY2lmaWMgSlBFRyBtYXJrZXJzIGluIHRoZSBTdXBwb3J0aW5nIHRoZSBEQ1QgRmlsdGVyc1xyXG4vLyAgIGluIFBvc3RTY3JpcHQgTGV2ZWwgMiwgVGVjaG5pY2FsIE5vdGUgIzUxMTZcclxuLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpXHJcblxyXG52YXIgQ29sb3JTcGFjZSA9IHtVbmtvd246IDAsIEdyYXlzY2FsZTogMSwgQWRvYmVSR0I6IDIsIFJHQjogMywgQ1lNSzogNH07XHJcbnZhciBKcGVnSW1hZ2UgPSAoZnVuY3Rpb24ganBlZ0ltYWdlKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG4gIHZhciBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbXHJcbiAgICAwLFxyXG4gICAgMSwgOCxcclxuICAgIDE2LCA5LCAyLFxyXG4gICAgMywgMTAsIDE3LCAyNCxcclxuICAgIDMyLCAyNSwgMTgsIDExLCA0LFxyXG4gICAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLFxyXG4gICAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgNixcclxuICAgIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LFxyXG4gICAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsXHJcbiAgICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LFxyXG4gICAgNTksIDUyLCA0NSwgMzgsIDMxLFxyXG4gICAgMzksIDQ2LCA1MywgNjAsXHJcbiAgICA2MSwgNTQsIDQ3LFxyXG4gICAgNTUsIDYyLFxyXG4gICAgNjNcclxuICBdKTtcclxuXHJcbiAgdmFyIGRjdENvczEgPSA0MDE3OyAgIC8vIGNvcyhwaS8xNilcclxuICB2YXIgZGN0U2luMSA9IDc5OTsgICAvLyBzaW4ocGkvMTYpXHJcbiAgdmFyIGRjdENvczMgPSAzNDA2OyAgIC8vIGNvcygzKnBpLzE2KVxyXG4gIHZhciBkY3RTaW4zID0gMjI3NjsgICAvLyBzaW4oMypwaS8xNilcclxuICB2YXIgZGN0Q29zNiA9IDE1Njc7ICAgLy8gY29zKDYqcGkvMTYpXHJcbiAgdmFyIGRjdFNpbjYgPSAzNzg0OyAgIC8vIHNpbig2KnBpLzE2KVxyXG4gIHZhciBkY3RTcXJ0MiA9IDU3OTM7ICAgLy8gc3FydCgyKVxyXG4gIHZhciBkY3RTcXJ0MWQyID0gMjg5NjsgIC8vIHNxcnQoMikgLyAyXHJcblxyXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCkge1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMsIHZhbHVlcykge1xyXG4gICAgdmFyIGsgPSAwLCBjb2RlID0gW10sIGksIGosIGxlbmd0aCA9IDE2O1xyXG4gICAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgIWNvZGVMZW5ndGhzW2xlbmd0aCAtIDFdKVxyXG4gICAgICBsZW5ndGgtLTtcclxuICAgIGNvZGUucHVzaCh7Y2hpbGRyZW46IFtdLCBpbmRleDogMH0pO1xyXG4gICAgdmFyIHAgPSBjb2RlWzBdLCBxO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XHJcbiAgICAgICAgcCA9IGNvZGUucG9wKCk7XHJcbiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHZhbHVlc1trXTtcclxuICAgICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcclxuICAgICAgICAgIHAgPSBjb2RlLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwLmluZGV4Kys7XHJcbiAgICAgICAgY29kZS5wdXNoKHApO1xyXG4gICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8PSBpKSB7XHJcbiAgICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XHJcbiAgICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcclxuICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrKys7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcclxuICAgICAgICBjb2RlLnB1c2gocSA9IHtjaGlsZHJlbjogW10sIGluZGV4OiAwfSk7XHJcbiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XHJcbiAgICAgICAgcCA9IHE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCByb3csIGNvbCkge1xyXG4gICAgcmV0dXJuIDY0ICogKChjb21wb25lbnQuYmxvY2tzUGVyTGluZSArIDEpICogcm93ICsgY29sKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7XHJcbiAgICB2YXIgcHJlY2lzaW9uID0gZnJhbWUucHJlY2lzaW9uO1xyXG4gICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XHJcbiAgICB2YXIgc2NhbkxpbmVzID0gZnJhbWUuc2NhbkxpbmVzO1xyXG4gICAgdmFyIG1jdXNQZXJMaW5lID0gZnJhbWUubWN1c1BlckxpbmU7XHJcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBmcmFtZS5wcm9ncmVzc2l2ZTtcclxuICAgIHZhciBtYXhIID0gZnJhbWUubWF4SCwgbWF4ViA9IGZyYW1lLm1heFY7XHJcblxyXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0LCBiaXRzRGF0YSA9IDAsIGJpdHNDb3VudCA9IDA7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEJpdCgpIHtcclxuICAgICAgaWYgKGJpdHNDb3VudCA+IDApIHtcclxuICAgICAgICBiaXRzQ291bnQtLTtcclxuICAgICAgICByZXR1cm4gKGJpdHNEYXRhID4+IGJpdHNDb3VudCkgJiAxO1xyXG4gICAgICB9XHJcbiAgICAgIGJpdHNEYXRhID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgIGlmIChiaXRzRGF0YSA9PSAweEZGKSB7XHJcbiAgICAgICAgdmFyIG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgaWYgKG5leHRCeXRlKSB7XHJcbiAgICAgICAgICB0aHJvdyBcInVuZXhwZWN0ZWQgbWFya2VyOiBcIiArICgoYml0c0RhdGEgPDwgOCkgfCBuZXh0Qnl0ZSkudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bnN0dWZmIDBcclxuICAgICAgfVxyXG4gICAgICBiaXRzQ291bnQgPSA3O1xyXG4gICAgICByZXR1cm4gYml0c0RhdGEgPj4+IDc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjb2RlSHVmZm1hbih0cmVlKSB7XHJcbiAgICAgIHZhciBub2RlID0gdHJlZTtcclxuICAgICAgdmFyIGJpdDtcclxuICAgICAgd2hpbGUgKChiaXQgPSByZWFkQml0KCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGVbYml0XTtcclxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlXCI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVjZWl2ZShsZW5ndGgpIHtcclxuICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBiaXQgPSByZWFkQml0KCk7XHJcbiAgICAgICAgaWYgKGJpdCA9PT0gbnVsbClcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBuID0gKG4gPDwgMSkgfCBiaXQ7XHJcbiAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHtcclxuICAgICAgdmFyIG4gPSByZWNlaXZlKGxlbmd0aCk7XHJcbiAgICAgIGlmIChuID49IDEgPDwgKGxlbmd0aCAtIDEpKVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWNvZGVCYXNlbGluZShjb21wb25lbnQsIG9mZnNldCkge1xyXG4gICAgICB2YXIgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcclxuICAgICAgdmFyIGRpZmYgPSB0ID09PSAwID8gMCA6IHJlY2VpdmVBbmRFeHRlbmQodCk7XHJcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSA9IChjb21wb25lbnQucHJlZCArPSBkaWZmKTtcclxuICAgICAgdmFyIGsgPSAxO1xyXG4gICAgICB3aGlsZSAoayA8IDY0KSB7XHJcbiAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xyXG4gICAgICAgIHZhciBzID0gcnMgJiAxNSwgciA9IHJzID4+IDQ7XHJcbiAgICAgICAgaWYgKHMgPT09IDApIHtcclxuICAgICAgICAgIGlmIChyIDwgMTUpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgayArPSAxNjtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrICs9IHI7XHJcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XHJcbiAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XHJcbiAgICAgICAgaysrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIG9mZnNldCkge1xyXG4gICAgICB2YXIgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcclxuICAgICAgdmFyIGRpZmYgPSB0ID09PSAwID8gMCA6IChyZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmUpO1xyXG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gPSAoY29tcG9uZW50LnByZWQgKz0gZGlmZik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGNvbXBvbmVudCwgb2Zmc2V0KSB7XHJcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSB8PSByZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW9icnVuID0gMDtcclxuICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcclxuICAgICAgaWYgKGVvYnJ1biA+IDApIHtcclxuICAgICAgICBlb2JydW4tLTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQ7XHJcbiAgICAgIHdoaWxlIChrIDw9IGUpIHtcclxuICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XHJcbiAgICAgICAgdmFyIHMgPSBycyAmIDE1LCByID0gcnMgPj4gNDtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKHIgPCAxNSkge1xyXG4gICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcikgLSAxO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGsgKz0gMTY7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgayArPSByO1xyXG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xyXG4gICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpICogKDEgPDwgc3VjY2Vzc2l2ZSk7XHJcbiAgICAgICAgaysrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMCwgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlO1xyXG4gICAgZnVuY3Rpb24gZGVjb2RlQUNTdWNjZXNzaXZlKGNvbXBvbmVudCwgb2Zmc2V0KSB7XHJcbiAgICAgIHZhciBrID0gc3BlY3RyYWxTdGFydCwgZSA9IHNwZWN0cmFsRW5kLCByID0gMDtcclxuICAgICAgd2hpbGUgKGsgPD0gZSkge1xyXG4gICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2tdO1xyXG4gICAgICAgIHN3aXRjaCAoc3VjY2Vzc2l2ZUFDU3RhdGUpIHtcclxuICAgICAgICAgIGNhc2UgMDogLy8gaW5pdGlhbCBzdGF0ZVxyXG4gICAgICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XHJcbiAgICAgICAgICAgIHZhciBzID0gcnMgJiAxNTtcclxuICAgICAgICAgICAgciA9IHJzID4+IDQ7XHJcbiAgICAgICAgICAgIGlmIChzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHIgPCAxNSkge1xyXG4gICAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSA0O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByID0gMTY7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChzICE9PSAxKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIEFDbiBlbmNvZGluZ1wiO1xyXG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XHJcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICBjYXNlIDE6IC8vIHNraXBwaW5nIHIgemVybyBpdGVtc1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByLS07XHJcbiAgICAgICAgICAgICAgaWYgKHIgPT09IDApXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHN1Y2Nlc3NpdmVBQ1N0YXRlID09IDIgPyAzIDogMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlIDw8IHN1Y2Nlc3NpdmU7XHJcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA0OiAvLyBlb2JcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0pIHtcclxuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGsrKztcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHtcclxuICAgICAgICBlb2JydW4tLTtcclxuICAgICAgICBpZiAoZW9icnVuID09PSAwKVxyXG4gICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlLCBtY3UsIHJvdywgY29sKSB7XHJcbiAgICAgIHZhciBtY3VSb3cgPSAobWN1IC8gbWN1c1BlckxpbmUpIHwgMDtcclxuICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xyXG4gICAgICB2YXIgYmxvY2tSb3cgPSBtY3VSb3cgKiBjb21wb25lbnQudiArIHJvdztcclxuICAgICAgdmFyIGJsb2NrQ29sID0gbWN1Q29sICogY29tcG9uZW50LmggKyBjb2w7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XHJcbiAgICAgIGRlY29kZShjb21wb25lbnQsIG9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGUsIG1jdSkge1xyXG4gICAgICB2YXIgYmxvY2tSb3cgPSAobWN1IC8gY29tcG9uZW50LmJsb2Nrc1BlckxpbmUpIHwgMDtcclxuICAgICAgdmFyIGJsb2NrQ29sID0gbWN1ICUgY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XHJcbiAgICAgIGRlY29kZShjb21wb25lbnQsIG9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDtcclxuICAgIHZhciBjb21wb25lbnQsIGksIGosIGssIG47XHJcbiAgICB2YXIgZGVjb2RlRm47XHJcbiAgICBpZiAocHJvZ3Jlc3NpdmUpIHtcclxuICAgICAgaWYgKHNwZWN0cmFsU3RhcnQgPT09IDApXHJcbiAgICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZURDRmlyc3QgOiBkZWNvZGVEQ1N1Y2Nlc3NpdmU7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlQUNGaXJzdCA6IGRlY29kZUFDU3VjY2Vzc2l2ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1jdSA9IDAsIG1hcmtlcjtcclxuICAgIHZhciBtY3VFeHBlY3RlZDtcclxuICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09IDEpIHtcclxuICAgICAgbWN1RXhwZWN0ZWQgPSBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgKiBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZXNldEludGVydmFsKSB7XHJcbiAgICAgIHJlc2V0SW50ZXJ2YWwgPSBtY3VFeHBlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaCwgdjtcclxuICAgIHdoaWxlIChtY3UgPCBtY3VFeHBlY3RlZCkge1xyXG4gICAgICAvLyByZXNldCBpbnRlcnZhbCBzdHVmZlxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29tcG9uZW50c1tpXS5wcmVkID0gMDtcclxuICAgICAgfVxyXG4gICAgICBlb2JydW4gPSAwO1xyXG5cclxuICAgICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT0gMSkge1xyXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IHJlc2V0SW50ZXJ2YWw7IG4rKykge1xyXG4gICAgICAgICAgZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1KTtcclxuICAgICAgICAgIG1jdSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgICAgIGggPSBjb21wb25lbnQuaDtcclxuICAgICAgICAgICAgdiA9IGNvbXBvbmVudC52O1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSwgaiwgayk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtY3UrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbmQgbWFya2VyXHJcbiAgICAgIGJpdHNDb3VudCA9IDA7XHJcbiAgICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xyXG4gICAgICBpZiAobWFya2VyIDw9IDB4RkYwMCkge1xyXG4gICAgICAgIHRocm93IFwibWFya2VyIHdhcyBub3QgZm91bmRcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1hcmtlciA+PSAweEZGRDAgJiYgbWFya2VyIDw9IDB4RkZENykgeyAvLyBSU1R4XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBBIHBvcnQgb2YgcG9wcGxlcidzIElEQ1QgbWV0aG9kIHdoaWNoIGluIHR1cm4gaXMgdGFrZW4gZnJvbTpcclxuICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosXHJcbiAgLy8gICBcIlByYWN0aWNhbCBGYXN0IDEtRCBEQ1QgQWxnb3JpdGhtcyB3aXRoIDExIE11bHRpcGxpY2F0aW9uc1wiLFxyXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxyXG4gIC8vICAgOTg4LTk5MS5cclxuICBmdW5jdGlvbiBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LCBibG9ja0J1ZmZlck9mZnNldCwgcCkge1xyXG4gICAgdmFyIHF0ID0gY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlO1xyXG4gICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdDtcclxuICAgIHZhciBpO1xyXG5cclxuICAgIC8vIGRlcXVhbnRcclxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XHJcbiAgICAgIHBbaV0gPSBjb21wb25lbnQuYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgaV0gKiBxdFtpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XHJcbiAgICAgIHZhciByb3cgPSA4ICogaTtcclxuXHJcbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcclxuICAgICAgaWYgKHBbMSArIHJvd10gPT09IDAgJiYgcFsyICsgcm93XSA9PT0gMCAmJiBwWzMgKyByb3ddID09PSAwICYmXHJcbiAgICAgICAgcFs0ICsgcm93XSA9PT0gMCAmJiBwWzUgKyByb3ddID09PSAwICYmIHBbNiArIHJvd10gPT09IDAgJiZcclxuICAgICAgICBwWzcgKyByb3ddID09PSAwKSB7XHJcbiAgICAgICAgdCA9IChkY3RTcXJ0MiAqIHBbMCArIHJvd10gKyA1MTIpID4+IDEwO1xyXG4gICAgICAgIHBbMCArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbMSArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbMiArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbMyArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbNCArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbNSArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbNiArIHJvd10gPSB0O1xyXG4gICAgICAgIHBbNyArIHJvd10gPSB0O1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzdGFnZSA0XHJcbiAgICAgIHYwID0gKGRjdFNxcnQyICogcFswICsgcm93XSArIDEyOCkgPj4gODtcclxuICAgICAgdjEgPSAoZGN0U3FydDIgKiBwWzQgKyByb3ddICsgMTI4KSA+PiA4O1xyXG4gICAgICB2MiA9IHBbMiArIHJvd107XHJcbiAgICAgIHYzID0gcFs2ICsgcm93XTtcclxuICAgICAgdjQgPSAoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddIC0gcFs3ICsgcm93XSkgKyAxMjgpID4+IDg7XHJcbiAgICAgIHY3ID0gKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSArIHBbNyArIHJvd10pICsgMTI4KSA+PiA4O1xyXG4gICAgICB2NSA9IHBbMyArIHJvd10gPDwgNDtcclxuICAgICAgdjYgPSBwWzUgKyByb3ddIDw8IDQ7XHJcblxyXG4gICAgICAvLyBzdGFnZSAzXHJcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XHJcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xyXG4gICAgICB2MSA9IHQ7XHJcbiAgICAgIHQgPSAodjIgKiBkY3RTaW42ICsgdjMgKiBkY3RDb3M2ICsgMTI4KSA+PiA4O1xyXG4gICAgICB2MiA9ICh2MiAqIGRjdENvczYgLSB2MyAqIGRjdFNpbjYgKyAxMjgpID4+IDg7XHJcbiAgICAgIHYzID0gdDtcclxuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcclxuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XHJcbiAgICAgIHY2ID0gdDtcclxuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcclxuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XHJcbiAgICAgIHY3ID0gdDtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDJcclxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcclxuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XHJcbiAgICAgIHYzID0gdDtcclxuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcclxuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XHJcbiAgICAgIHYyID0gdDtcclxuICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHY3ID0gdDtcclxuICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHY2ID0gdDtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDFcclxuICAgICAgcFswICsgcm93XSA9IHYwICsgdjc7XHJcbiAgICAgIHBbNyArIHJvd10gPSB2MCAtIHY3O1xyXG4gICAgICBwWzEgKyByb3ddID0gdjEgKyB2NjtcclxuICAgICAgcFs2ICsgcm93XSA9IHYxIC0gdjY7XHJcbiAgICAgIHBbMiArIHJvd10gPSB2MiArIHY1O1xyXG4gICAgICBwWzUgKyByb3ddID0gdjIgLSB2NTtcclxuICAgICAgcFszICsgcm93XSA9IHYzICsgdjQ7XHJcbiAgICAgIHBbNCArIHJvd10gPSB2MyAtIHY0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGludmVyc2UgRENUIG9uIGNvbHVtbnNcclxuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcclxuICAgICAgdmFyIGNvbCA9IGk7XHJcblxyXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXHJcbiAgICAgIGlmIChwWzEgKiA4ICsgY29sXSA9PT0gMCAmJiBwWzIgKiA4ICsgY29sXSA9PT0gMCAmJiBwWzMgKiA4ICsgY29sXSA9PT0gMCAmJlxyXG4gICAgICAgIHBbNCAqIDggKyBjb2xdID09PSAwICYmIHBbNSAqIDggKyBjb2xdID09PSAwICYmIHBbNiAqIDggKyBjb2xdID09PSAwICYmXHJcbiAgICAgICAgcFs3ICogOCArIGNvbF0gPT09IDApIHtcclxuICAgICAgICB0ID0gKGRjdFNxcnQyICogcFtpICsgMF0gKyA4MTkyKSA+PiAxNDtcclxuICAgICAgICBwWzAgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgcFsxICogOCArIGNvbF0gPSB0O1xyXG4gICAgICAgIHBbMiAqIDggKyBjb2xdID0gdDtcclxuICAgICAgICBwWzMgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgcFs0ICogOCArIGNvbF0gPSB0O1xyXG4gICAgICAgIHBbNSAqIDggKyBjb2xdID0gdDtcclxuICAgICAgICBwWzYgKiA4ICsgY29sXSA9IHQ7XHJcbiAgICAgICAgcFs3ICogOCArIGNvbF0gPSB0O1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzdGFnZSA0XHJcbiAgICAgIHYwID0gKGRjdFNxcnQyICogcFswICogOCArIGNvbF0gKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjEgPSAoZGN0U3FydDIgKiBwWzQgKiA4ICsgY29sXSArIDIwNDgpID4+IDEyO1xyXG4gICAgICB2MiA9IHBbMiAqIDggKyBjb2xdO1xyXG4gICAgICB2MyA9IHBbNiAqIDggKyBjb2xdO1xyXG4gICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSAqIDggKyBjb2xdIC0gcFs3ICogOCArIGNvbF0pICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHY3ID0gKGRjdFNxcnQxZDIgKiAocFsxICogOCArIGNvbF0gKyBwWzcgKiA4ICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjUgPSBwWzMgKiA4ICsgY29sXTtcclxuICAgICAgdjYgPSBwWzUgKiA4ICsgY29sXTtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDNcclxuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcclxuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XHJcbiAgICAgIHYxID0gdDtcclxuICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHYzID0gdDtcclxuICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcclxuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XHJcbiAgICAgIHY2ID0gdDtcclxuICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcclxuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XHJcbiAgICAgIHY3ID0gdDtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDJcclxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcclxuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XHJcbiAgICAgIHYzID0gdDtcclxuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcclxuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XHJcbiAgICAgIHYyID0gdDtcclxuICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHY3ID0gdDtcclxuICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcclxuICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XHJcbiAgICAgIHY2ID0gdDtcclxuXHJcbiAgICAgIC8vIHN0YWdlIDFcclxuICAgICAgcFswICogOCArIGNvbF0gPSB2MCArIHY3O1xyXG4gICAgICBwWzcgKiA4ICsgY29sXSA9IHYwIC0gdjc7XHJcbiAgICAgIHBbMSAqIDggKyBjb2xdID0gdjEgKyB2NjtcclxuICAgICAgcFs2ICogOCArIGNvbF0gPSB2MSAtIHY2O1xyXG4gICAgICBwWzIgKiA4ICsgY29sXSA9IHYyICsgdjU7XHJcbiAgICAgIHBbNSAqIDggKyBjb2xdID0gdjIgLSB2NTtcclxuICAgICAgcFszICogOCArIGNvbF0gPSB2MyArIHY0O1xyXG4gICAgICBwWzQgKiA4ICsgY29sXSA9IHYzIC0gdjQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29udmVydCB0byA4LWJpdCBpbnRlZ2Vyc1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcclxuICAgICAgdmFyIGluZGV4ID0gYmxvY2tCdWZmZXJPZmZzZXQgKyBpO1xyXG4gICAgICB2YXIgcSA9IHBbaV07XHJcbiAgICAgIHEgPSAocSA8PSAtMjA1NiAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uKSA/IDAgOlxyXG4gICAgICAgIChxID49IDIwMjQgLyBjb21wb25lbnQuYml0Q29udmVyc2lvbikgPyAyNTUgLyBjb21wb25lbnQuYml0Q29udmVyc2lvbiA6XHJcbiAgICAgICAgKHEgKyAyMDU2IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb24pID4+IDQ7XHJcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbaW5kZXhdID0gcTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XHJcbiAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbjtcclxuICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcclxuICAgIHZhciBjb21wdXRhdGlvbkJ1ZmZlciA9IG5ldyBJbnQzMkFycmF5KDY0KTtcclxuXHJcbiAgICB2YXIgaSwgaiwgbGwgPSAwO1xyXG4gICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xyXG4gICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XHJcbiAgICAgICAgcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudCwgb2Zmc2V0LCBjb21wdXRhdGlvbkJ1ZmZlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb21wb25lbnQuYmxvY2tEYXRhO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xhbXBUb1VpbnQ4KGEpIHtcclxuICAgIHJldHVybiBhIDw9IDAgPyAwIDogYSA+PSAyNTUgPyAyNTUgOiBhIHwgMDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHtcclxuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQocGF0aCkge1xyXG4gICAgICB2YXIgaGFuZGxlRGF0YSA9IChmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMub25sb2FkKVxyXG4gICAgICAgICAgdGhpcy5vbmxvYWQoKTtcclxuICAgICAgfSkuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgIGlmIChwYXRoLmluZGV4T2YoXCJkYXRhOlwiKSA+IC0xKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhdGguaW5kZXhPZihcImJhc2U2NCxcIikgKyA3O1xyXG4gICAgICAgIHZhciBkYXRhID0gYXRvYihwYXRoLnN1YnN0cmluZyhvZmZzZXQpKTtcclxuICAgICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZURhdGEoZGF0YSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xyXG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBUT0RPIGNhdGNoIHBhcnNlIGVycm9yXHJcbiAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XHJcbiAgICAgICAgICBoYW5kbGVEYXRhKGRhdGEpO1xyXG4gICAgICAgIH0pLmJpbmQodGhpcyk7XHJcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xyXG5cclxuICAgICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcclxuICAgICAgICBvZmZzZXQgKz0gMjtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICB2YXIgYXJyYXkgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoIC0gMik7XHJcbiAgICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XHJcbiAgICAgICAgdmFyIG1jdXNQZXJMaW5lID0gTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCAvIGZyYW1lLm1heEgpO1xyXG4gICAgICAgIHZhciBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBmcmFtZS5tYXhWKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZSA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4KSAqIGNvbXBvbmVudC5oIC8gZnJhbWUubWF4SCk7XHJcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zY2FuTGluZXMgLyA4KSAqIGNvbXBvbmVudC52IC8gZnJhbWUubWF4Vik7XHJcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XHJcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uRm9yTWN1ID0gbWN1c1BlckNvbHVtbiAqIGNvbXBvbmVudC52O1xyXG5cclxuICAgICAgICAgIHZhciBibG9ja3NCdWZmZXJTaXplID0gNjQgKiBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgKiAoYmxvY2tzUGVyTGluZUZvck1jdSArIDEpO1xyXG4gICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YSA9IG5ldyBJbnQxNkFycmF5KGJsb2Nrc0J1ZmZlclNpemUpO1xyXG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xyXG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTtcclxuICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICB2YXIgamZpZiA9IG51bGw7XHJcbiAgICAgIHZhciBhZG9iZSA9IG51bGw7XHJcbiAgICAgIHZhciBwaXhlbHMgPSBudWxsO1xyXG4gICAgICB2YXIgZnJhbWUsIHJlc2V0SW50ZXJ2YWw7XHJcbiAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXMgPSBbXTtcclxuICAgICAgdmFyIGh1ZmZtYW5UYWJsZXNBQyA9IFtdLCBodWZmbWFuVGFibGVzREMgPSBbXTtcclxuICAgICAgdmFyIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XHJcbiAgICAgIGlmIChmaWxlTWFya2VyICE9IDB4RkZEOCkgeyAvLyBTT0kgKFN0YXJ0IG9mIEltYWdlKVxyXG4gICAgICAgIHRocm93IFwiU09JIG5vdCBmb3VuZFwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICB3aGlsZSAoZmlsZU1hcmtlciAhPSAweEZGRDkpIHsgLy8gRU9JIChFbmQgb2YgaW1hZ2UpXHJcbiAgICAgICAgdmFyIGksIGosIGw7XHJcbiAgICAgICAgc3dpdGNoIChmaWxlTWFya2VyKSB7XHJcbiAgICAgICAgICBjYXNlIDB4RkZFMDogLy8gQVBQMCAoQXBwbGljYXRpb24gU3BlY2lmaWMpXHJcbiAgICAgICAgICBjYXNlIDB4RkZFMTogLy8gQVBQMVxyXG4gICAgICAgICAgY2FzZSAweEZGRTI6IC8vIEFQUDJcclxuICAgICAgICAgIGNhc2UgMHhGRkUzOiAvLyBBUFAzXHJcbiAgICAgICAgICBjYXNlIDB4RkZFNDogLy8gQVBQNFxyXG4gICAgICAgICAgY2FzZSAweEZGRTU6IC8vIEFQUDVcclxuICAgICAgICAgIGNhc2UgMHhGRkU2OiAvLyBBUFA2XHJcbiAgICAgICAgICBjYXNlIDB4RkZFNzogLy8gQVBQN1xyXG4gICAgICAgICAgY2FzZSAweEZGRTg6IC8vIEFQUDhcclxuICAgICAgICAgIGNhc2UgMHhGRkU5OiAvLyBBUFA5XHJcbiAgICAgICAgICBjYXNlIDB4RkZFQTogLy8gQVBQMTBcclxuICAgICAgICAgIGNhc2UgMHhGRkVCOiAvLyBBUFAxMVxyXG4gICAgICAgICAgY2FzZSAweEZGRUM6IC8vIEFQUDEyXHJcbiAgICAgICAgICBjYXNlIDB4RkZFRDogLy8gQVBQMTNcclxuICAgICAgICAgIGNhc2UgMHhGRkVFOiAvLyBBUFAxNFxyXG4gICAgICAgICAgY2FzZSAweEZGRUY6IC8vIEFQUDE1XHJcbiAgICAgICAgICBjYXNlIDB4RkZGRTogLy8gQ09NIChDb21tZW50KVxyXG4gICAgICAgICAgICB2YXIgYXBwRGF0YSA9IHJlYWREYXRhQmxvY2soKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHtcclxuICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDkgJiZcclxuICAgICAgICAgICAgICAgIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlxceDAwJ1xyXG4gICAgICAgICAgICAgICAgamZpZiA9IHtcclxuICAgICAgICAgICAgICAgICAgdmVyc2lvbjoge21ham9yOiBhcHBEYXRhWzVdLCBtaW5vcjogYXBwRGF0YVs2XX0sXHJcbiAgICAgICAgICAgICAgICAgIGRlbnNpdHlVbml0czogYXBwRGF0YVs3XSxcclxuICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcclxuICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLFxyXG4gICAgICAgICAgICAgICAgICB0aHVtYldpZHRoOiBhcHBEYXRhWzEyXSxcclxuICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxyXG4gICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPIEFQUDEgLSBFeGlmXHJcbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcclxuICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYgJiZcclxuICAgICAgICAgICAgICAgIGFwcERhdGFbM10gPT09IDB4NjIgJiYgYXBwRGF0YVs0XSA9PT0gMHg2NSAmJiBhcHBEYXRhWzVdID09PSAwKSB7IC8vICdBZG9iZVxceDAwJ1xyXG4gICAgICAgICAgICAgICAgYWRvYmUgPSB7XHJcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IGFwcERhdGFbNl0sXHJcbiAgICAgICAgICAgICAgICAgIGZsYWdzMDogKGFwcERhdGFbN10gPDwgOCkgfCBhcHBEYXRhWzhdLFxyXG4gICAgICAgICAgICAgICAgICBmbGFnczE6IChhcHBEYXRhWzldIDw8IDgpIHwgYXBwRGF0YVsxMF0sXHJcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUNvZGU6IGFwcERhdGFbMTFdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDB4RkZEQjogLy8gRFFUIChEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlcylcclxuICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlc0VuZCA9IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCArIG9mZnNldCAtIDI7XHJcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcclxuICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgICAgICAgdmFyIHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTtcclxuICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2pdO1xyXG4gICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8xNiBiaXRcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB6eiA9IGRjdFppZ1phZ1tqXTtcclxuICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3p6XSA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWNcIjtcclxuICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZXNbcXVhbnRpemF0aW9uVGFibGVTcGVjICYgMTVdID0gdGFibGVEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMHhGRkMwOiAvLyBTT0YwIChTdGFydCBvZiBGcmFtZSwgQmFzZWxpbmUgRENUKVxyXG4gICAgICAgICAgY2FzZSAweEZGQzE6IC8vIFNPRjEgKFN0YXJ0IG9mIEZyYW1lLCBFeHRlbmRlZCBEQ1QpXHJcbiAgICAgICAgICBjYXNlIDB4RkZDMjogLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVClcclxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgXCJPbmx5IHNpbmdsZSBmcmFtZSBKUEVHcyBzdXBwb3J0ZWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGhcclxuICAgICAgICAgICAgZnJhbWUgPSB7fTtcclxuICAgICAgICAgICAgZnJhbWUuZXh0ZW5kZWQgPSAoZmlsZU1hcmtlciA9PT0gMHhGRkMxKTtcclxuICAgICAgICAgICAgZnJhbWUucHJvZ3Jlc3NpdmUgPSAoZmlsZU1hcmtlciA9PT0gMHhGRkMyKTtcclxuICAgICAgICAgICAgZnJhbWUucHJlY2lzaW9uID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgICAgIGZyYW1lLnNjYW5MaW5lcyA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICAgICAgZnJhbWUuc2FtcGxlc1BlckxpbmUgPSByZWFkVWludDE2KCk7XHJcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50SWRzID0ge307XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXSwgY29tcG9uZW50SWQ7XHJcbiAgICAgICAgICAgIHZhciBtYXhIID0gMCwgbWF4ViA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkID0gZGF0YVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgIHZhciBoID0gZGF0YVtvZmZzZXQgKyAxXSA+PiA0O1xyXG4gICAgICAgICAgICAgIHZhciB2ID0gZGF0YVtvZmZzZXQgKyAxXSAmIDE1O1xyXG4gICAgICAgICAgICAgIGlmIChtYXhIIDwgaClcclxuICAgICAgICAgICAgICAgIG1heEggPSBoO1xyXG4gICAgICAgICAgICAgIGlmIChtYXhWIDwgdilcclxuICAgICAgICAgICAgICAgIG1heFYgPSB2O1xyXG4gICAgICAgICAgICAgIHZhciBxSWQgPSBkYXRhW29mZnNldCArIDJdO1xyXG4gICAgICAgICAgICAgIGwgPSBmcmFtZS5jb21wb25lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaDogaCxcclxuICAgICAgICAgICAgICAgIHY6IHYsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZTogcXVhbnRpemF0aW9uVGFibGVzW3FJZF0sXHJcbiAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZUlkOiBxSWQsXHJcbiAgICAgICAgICAgICAgICBiaXRDb252ZXJzaW9uOiAyNTUgLyAoKDEgPDwgZnJhbWUucHJlY2lzaW9uKSAtIDEpXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50SWRzW2NvbXBvbmVudElkXSA9IGwgLSAxO1xyXG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lLm1heEggPSBtYXhIO1xyXG4gICAgICAgICAgICBmcmFtZS5tYXhWID0gbWF4VjtcclxuICAgICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDB4RkZDNDogLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXHJcbiAgICAgICAgICAgIHZhciBodWZmbWFuTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgaHVmZm1hbkxlbmd0aDsgKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgICB2YXIgY29kZUxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgxNik7XHJcbiAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhTdW0gPSAwO1xyXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKylcclxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gKGNvZGVMZW5ndGhzW2pdID0gZGF0YVtvZmZzZXRdKTtcclxuICAgICAgICAgICAgICB2YXIgaHVmZm1hblZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvZGVMZW5ndGhTdW0pO1xyXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKVxyXG4gICAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTtcclxuXHJcbiAgICAgICAgICAgICAgKChodWZmbWFuVGFibGVTcGVjID4+IDQpID09PSAwID9cclxuICAgICAgICAgICAgICAgIGh1ZmZtYW5UYWJsZXNEQyA6IGh1ZmZtYW5UYWJsZXNBQylbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9XHJcbiAgICAgICAgICAgICAgICBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAweEZGREQ6IC8vIERSSSAoRGVmaW5lIFJlc3RhcnQgSW50ZXJ2YWwpXHJcbiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxyXG4gICAgICAgICAgICByZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDB4RkZEQTogLy8gU09TIChTdGFydCBvZiBTY2FuKVxyXG4gICAgICAgICAgICB2YXIgc2Nhbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yc0NvdW50ID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gW10sIGNvbXBvbmVudDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SW5kZXggPSBmcmFtZS5jb21wb25lbnRJZHNbZGF0YVtvZmZzZXQrK11dO1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgIHZhciB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSBodWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xyXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyA9IGh1ZmZtYW5UYWJsZXNBQ1t0YWJsZVNwZWMgJiAxNV07XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTtcclxuICAgICAgICAgICAgdmFyIHNwZWN0cmFsRW5kID0gZGF0YVtvZmZzZXQrK107XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA9IGRhdGFbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXHJcbiAgICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXHJcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPj4gNCwgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gJiAxNSk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBwcm9jZXNzZWQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gM10gPT0gMHhGRiAmJlxyXG4gICAgICAgICAgICAgIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHtcclxuICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gbGFzdCAweEZGIGJ5dGUgb2YgdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgLy8gYmxvY2sgd2FzIGVhdGVuIGJ5IHRoZSBlbmNvZGVyXHJcbiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgXCJ1bmtub3duIEpQRUcgbWFya2VyIFwiICsgZmlsZU1hcmtlci50b1N0cmluZygxNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMud2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcclxuICAgICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XHJcbiAgICAgIHRoaXMuamZpZiA9IGpmaWY7XHJcbiAgICAgIHRoaXMuYWRvYmUgPSBhZG9iZTtcclxuICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XHJcbiAgICAgIHN3aXRjaCAoZnJhbWUuY29tcG9uZW50cy5sZW5ndGgpXHJcbiAgICAgIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLkdyYXlzY2FsZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGlmICh0aGlzLmFkb2JlKVxyXG4gICAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLkFkb2JlUkdCO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLlJHQjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuQ1lNSztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLlVua25vd247XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbaV07XHJcbiAgICAgICAgaWYgKCFjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgJiYgY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlSWQgIT09IG51bGwpXHJcbiAgICAgICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgPSBxdWFudGl6YXRpb25UYWJsZXNbY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlSWRdO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHtcclxuICAgICAgICAgIG91dHB1dDogYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpLFxyXG4gICAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXHJcbiAgICAgICAgICBzY2FsZVk6IGNvbXBvbmVudC52IC8gZnJhbWUubWF4VixcclxuICAgICAgICAgIGJsb2Nrc1BlckxpbmU6IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lLFxyXG4gICAgICAgICAgYmxvY2tzUGVyQ29sdW1uOiBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uLFxyXG4gICAgICAgICAgYml0Q29udmVyc2lvbjogY29tcG9uZW50LmJpdENvbnZlcnNpb25cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldERhdGExNjogZnVuY3Rpb24gZ2V0RGF0YTE2KHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggIT09IDEpXHJcbiAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xyXG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy53aWR0aCAvIHdpZHRoLCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGhlaWdodDtcclxuXHJcbiAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudFNjYWxlWCwgY29tcG9uZW50U2NhbGVZO1xyXG4gICAgICB2YXIgeCwgeSwgaTtcclxuICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcclxuICAgICAgdmFyIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIG51bUNvbXBvbmVudHM7XHJcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGRhdGFMZW5ndGgpO1xyXG4gICAgICB2YXIgY29tcG9uZW50TGluZTtcclxuXHJcbiAgICAgIC8vIGxpbmVEYXRhIGlzIHJldXNlZCBmb3IgYWxsIGNvbXBvbmVudHMuIEFzc3VtZSBmaXJzdCBjb21wb25lbnQgaXNcclxuICAgICAgLy8gdGhlIGJpZ2dlc3RcclxuICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IFVpbnQxNkFycmF5KCh0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSA8PCAzKSAqXHJcbiAgICAgIHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW4gKiA4KTtcclxuXHJcbiAgICAgIC8vIEZpcnN0IGNvbnN0cnVjdCBpbWFnZSBkYXRhIC4uLlxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2ldO1xyXG4gICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XHJcbiAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XHJcbiAgICAgICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xyXG5cclxuICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xyXG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XHJcbiAgICAgICAgICB2YXIgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xyXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA4OyBqKyspIHtcclxuICAgICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IChzY2FuTGluZSArIGopICogc2FtcGxlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgbGluZURhdGFbbGluZU9mZnNldCArIHNhbXBsZSArIGtdID1cclxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm91dHB1dFtidWZmZXJPZmZzZXQgKyBvZmZzZXQrK107XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb25lbnRTY2FsZVggPSBjb21wb25lbnQuc2NhbGVYICogc2NhbGVYO1xyXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWSA9IGNvbXBvbmVudC5zY2FsZVkgKiBzY2FsZVk7XHJcbiAgICAgICAgb2Zmc2V0ID0gaTtcclxuXHJcbiAgICAgICAgdmFyIGN4LCBjeTtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XHJcbiAgICAgICAgICAgIGN4ID0gMCB8ICh4ICogY29tcG9uZW50U2NhbGVYKTtcclxuICAgICAgICAgICAgaW5kZXggPSBjeSAqIHNhbXBsZXNQZXJMaW5lICsgY3g7XHJcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IG51bUNvbXBvbmVudHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGdldERhdGE6IGZ1bmN0aW9uIGdldERhdGEod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy53aWR0aCAvIHdpZHRoLCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGhlaWdodDtcclxuXHJcbiAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudFNjYWxlWCwgY29tcG9uZW50U2NhbGVZO1xyXG4gICAgICB2YXIgeCwgeSwgaTtcclxuICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgIHZhciBZLCBDYiwgQ3IsIEssIEMsIE0sIFllLCBSLCBHLCBCO1xyXG4gICAgICB2YXIgY29sb3JUcmFuc2Zvcm07XHJcbiAgICAgIHZhciBudW1Db21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcclxuICAgICAgdmFyIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIG51bUNvbXBvbmVudHM7XHJcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XHJcbiAgICAgIHZhciBjb21wb25lbnRMaW5lO1xyXG5cclxuICAgICAgLy8gbGluZURhdGEgaXMgcmV1c2VkIGZvciBhbGwgY29tcG9uZW50cy4gQXNzdW1lIGZpcnN0IGNvbXBvbmVudCBpc1xyXG4gICAgICAvLyB0aGUgYmlnZ2VzdFxyXG4gICAgICB2YXIgbGluZURhdGEgPSBuZXcgVWludDhBcnJheSgodGhpcy5jb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgPDwgMykgKlxyXG4gICAgICB0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uICogOCk7XHJcblxyXG4gICAgICAvLyBGaXJzdCBjb25zdHJ1Y3QgaW1hZ2UgZGF0YSAuLi5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bUNvbXBvbmVudHM7IGkrKykge1xyXG4gICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpXTtcclxuICAgICAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xyXG4gICAgICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xyXG4gICAgICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcclxuXHJcbiAgICAgICAgdmFyIGosIGssIGxsID0gMDtcclxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xyXG4gICAgICAgICAgdmFyIHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMztcclxuICAgICAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXJPZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwLCBzYW1wbGUgPSBibG9ja0NvbCA8PCAzO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgODsgaisrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAoc2NhbkxpbmUgKyBqKSAqIHNhbXBsZXNQZXJMaW5lO1xyXG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCA4OyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGxpbmVEYXRhW2xpbmVPZmZzZXQgKyBzYW1wbGUgKyBrXSA9XHJcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vdXRwdXRbYnVmZmVyT2Zmc2V0ICsgb2Zmc2V0KytdICogY29tcG9uZW50LmJpdENvbnZlcnNpb247XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb25lbnRTY2FsZVggPSBjb21wb25lbnQuc2NhbGVYICogc2NhbGVYO1xyXG4gICAgICAgIGNvbXBvbmVudFNjYWxlWSA9IGNvbXBvbmVudC5zY2FsZVkgKiBzY2FsZVk7XHJcbiAgICAgICAgb2Zmc2V0ID0gaTtcclxuXHJcbiAgICAgICAgdmFyIGN4LCBjeTtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XHJcbiAgICAgICAgICAgIGN4ID0gMCB8ICh4ICogY29tcG9uZW50U2NhbGVYKTtcclxuICAgICAgICAgICAgaW5kZXggPSBjeSAqIHNhbXBsZXNQZXJMaW5lICsgY3g7XHJcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IG51bUNvbXBvbmVudHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAuLi4gdGhlbiB0cmFuc2Zvcm0gY29sb3JzLCBpZiBuZWNlc3NhcnlcclxuICAgICAgc3dpdGNoIChudW1Db21wb25lbnRzKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIG5vIGNvbG9yIGNvbnZlcnNpb24gZm9yIG9uZSBvciB0d28gY29tcG9lbmVudHNcclxuXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdHJhbnNmb3JtIGZvciB0aHJlZSBjb21wb25lbnRzIGlzIHRydWVcclxuICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcclxuICAgICAgICAgIC8vIFRoZSBhZG9iZSB0cmFuc2Zvcm0gbWFya2VyIG92ZXJyaWRlcyBhbnkgcHJldmlvdXMgc2V0dGluZ1xyXG4gICAgICAgICAgaWYgKHRoaXMuYWRvYmUgJiYgdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlKVxyXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XHJcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xyXG5cclxuICAgICAgICAgIGlmIChjb2xvclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgWSA9IGRhdGFbaSAgICBdO1xyXG4gICAgICAgICAgICAgIENiID0gZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgQ3IgPSBkYXRhW2kgKyAyXTtcclxuXHJcbiAgICAgICAgICAgICAgUiA9IGNsYW1wVG9VaW50OChZIC0gMTc5LjQ1NiArIDEuNDAyICogQ3IpO1xyXG4gICAgICAgICAgICAgIEcgPSBjbGFtcFRvVWludDgoWSArIDEzNS40NTkgLSAwLjM0NCAqIENiIC0gMC43MTQgKiBDcik7XHJcbiAgICAgICAgICAgICAgQiA9IGNsYW1wVG9VaW50OChZIC0gMjI2LjgxNiArIDEuNzcyICogQ2IpO1xyXG5cclxuICAgICAgICAgICAgICBkYXRhW2kgICAgXSA9IFI7XHJcbiAgICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBHO1xyXG4gICAgICAgICAgICAgIGRhdGFbaSArIDJdID0gQjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgaWYgKCF0aGlzLmFkb2JlKVxyXG4gICAgICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgY29sb3IgbW9kZSAoNCBjb21wb25lbnRzKSc7XHJcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB0cmFuc2Zvcm0gZm9yIGZvdXIgY29tcG9uZW50cyBpcyBmYWxzZVxyXG4gICAgICAgICAgY29sb3JUcmFuc2Zvcm0gPSBmYWxzZTtcclxuICAgICAgICAgIC8vIFRoZSBhZG9iZSB0cmFuc2Zvcm0gbWFya2VyIG92ZXJyaWRlcyBhbnkgcHJldmlvdXMgc2V0dGluZ1xyXG4gICAgICAgICAgaWYgKHRoaXMuYWRvYmUgJiYgdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlKVxyXG4gICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XHJcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xyXG5cclxuICAgICAgICAgIGlmIChjb2xvclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgWSA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgICAgQ2IgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgICBDciA9IGRhdGFbaSArIDJdO1xyXG5cclxuICAgICAgICAgICAgICBDID0gY2xhbXBUb1VpbnQ4KDQzNC40NTYgLSBZIC0gMS40MDIgKiBDcik7XHJcbiAgICAgICAgICAgICAgTSA9IGNsYW1wVG9VaW50OCgxMTkuNTQxIC0gWSArIDAuMzQ0ICogQ2IgKyAwLjcxNCAqIENyKTtcclxuICAgICAgICAgICAgICBZID0gY2xhbXBUb1VpbnQ4KDQ4MS44MTYgLSBZIC0gMS43NzIgKiBDYik7XHJcblxyXG4gICAgICAgICAgICAgIGRhdGFbaSAgICBdID0gQztcclxuICAgICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE07XHJcbiAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBZO1xyXG4gICAgICAgICAgICAgIC8vIEsgaXMgdW5jaGFuZ2VkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgY29sb3IgbW9kZSc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnN0cnVjdG9yO1xyXG59KSgpO1xyXG5cclxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xyXG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKcGVnSW1hZ2U7XHJcbn0iLCIvKiEgaW1hZ2UtSlBFRzIwMDAgLSB2MC4zLjEgLSAyMDE1LTA4LTI2IHwgaHR0cHM6Ly9naXRodWIuY29tL09ISUYvaW1hZ2UtSlBFRzIwMDAgKi9cclxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cclxuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xyXG4vKiBDb3B5cmlnaHQgMjAxMiBNb3ppbGxhIEZvdW5kYXRpb25cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiBnbG9iYWxzIEFyaXRobWV0aWNEZWNvZGVyLCBnbG9iYWxTY29wZSwgbG9nMiwgcmVhZFVpbnQxNiwgcmVhZFVpbnQzMixcclxuICAgICAgICAgICBpbmZvLCB3YXJuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSnB4SW1hZ2UgPSAoZnVuY3Rpb24gSnB4SW1hZ2VDbG9zdXJlKCkge1xyXG4gIC8vIFRhYmxlIEUuMVxyXG4gIHZhciBTdWJiYW5kc0dhaW5Mb2cyID0ge1xyXG4gICAgJ0xMJzogMCxcclxuICAgICdMSCc6IDEsXHJcbiAgICAnSEwnOiAxLFxyXG4gICAgJ0hIJzogMlxyXG4gIH07XHJcbiAgZnVuY3Rpb24gSnB4SW1hZ2UoKSB7XHJcbiAgICB0aGlzLmZhaWxPbkNvcnJ1cHRlZEltYWdlID0gZmFsc2U7XHJcbiAgfVxyXG4gIEpweEltYWdlLnByb3RvdHlwZSA9IHtcclxuICAgIHBhcnNlOiBmdW5jdGlvbiBKcHhJbWFnZV9wYXJzZShkYXRhKSB7XHJcblxyXG4gICAgICB2YXIgaGVhZCA9IHJlYWRVaW50MTYoZGF0YSwgMCk7XHJcbiAgICAgIC8vIE5vIGJveCBoZWFkZXIsIGltbWVkaWF0ZSBzdGFydCBvZiBjb2Rlc3RyZWFtIChTT0MpXHJcbiAgICAgIGlmIChoZWFkID09PSAweEZGNEYpIHtcclxuICAgICAgICB0aGlzLnBhcnNlQ29kZXN0cmVhbShkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGhlYWRlclNpemUgPSA4O1xyXG4gICAgICAgIHZhciBsYm94ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHRib3ggPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgcG9zaXRpb24gKz0gaGVhZGVyU2l6ZTtcclxuICAgICAgICBpZiAobGJveCA9PT0gMSkge1xyXG4gICAgICAgICAgLy8gWExCb3g6IHJlYWQgVUludDY0IGFjY29yZGluZyB0byBzcGVjLlxyXG4gICAgICAgICAgLy8gSmF2YVNjcmlwdCdzIGludCBwcmVjaXNpb24gb2YgNTMgYml0IHNob3VsZCBiZSBzdWZmaWNpZW50IGhlcmUuXHJcbiAgICAgICAgICBsYm94ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbikgKiA0Mjk0OTY3Mjk2ICtcclxuICAgICAgICAgICAgICAgICByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgICBwb3NpdGlvbiArPSA4O1xyXG4gICAgICAgICAgaGVhZGVyU2l6ZSArPSA4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGJveCA9PT0gMCkge1xyXG4gICAgICAgICAgbGJveCA9IGxlbmd0aCAtIHBvc2l0aW9uICsgaGVhZGVyU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxib3ggPCBoZWFkZXJTaXplKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBib3ggZmllbGQgc2l6ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IGxib3ggLSBoZWFkZXJTaXplO1xyXG4gICAgICAgIHZhciBqdW1wRGF0YUxlbmd0aCA9IHRydWU7XHJcbiAgICAgICAgc3dpdGNoICh0Ym94KSB7XHJcbiAgICAgICAgICBjYXNlIDB4NkE3MDMyNjg6IC8vICdqcDJoJ1xyXG4gICAgICAgICAgICBqdW1wRGF0YUxlbmd0aCA9IGZhbHNlOyAvLyBwYXJzaW5nIGNoaWxkIGJveGVzXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAweDYzNkY2QzcyOiAvLyAnY29scidcclxuICAgICAgICAgICAgLy8gQ29sb3JzcGFjZXMgYXJlIG5vdCB1c2VkLCB0aGUgQ1MgZnJvbSB0aGUgUERGIGlzIHVzZWQuXHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBkYXRhW3Bvc2l0aW9uXTtcclxuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSBkYXRhW3Bvc2l0aW9uICsgMV07XHJcbiAgICAgICAgICAgIHZhciBhcHByb3hpbWF0aW9uID0gZGF0YVtwb3NpdGlvbiArIDJdO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgLy8gZW51bWVyYXRlZCBjb2xvcnNwYWNlXHJcbiAgICAgICAgICAgICAgdmFyIGNvbG9yc3BhY2UgPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMyk7XHJcbiAgICAgICAgICAgICAgc3dpdGNoIChjb2xvcnNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiAvLyB0aGlzIGluZGljYXRlcyBhIHNSR0IgY29sb3JzcGFjZVxyXG4gICAgICAgICAgICAgICAgY2FzZSAxNzogLy8gdGhpcyBpbmRpY2F0ZXMgYSBncmF5c2NhbGUgY29sb3JzcGFjZVxyXG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gdGhpcyBpbmRpY2F0ZXMgYSBZVVYgY29sb3JzcGFjZVxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgIHdhcm4oJ1Vua25vd24gY29sb3JzcGFjZSAnICsgY29sb3JzcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IDIpIHtcclxuICAgICAgICAgICAgICBpbmZvKCdJQ0MgcHJvZmlsZSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDB4NkE3MDMyNjM6IC8vICdqcDJjJ1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29kZXN0cmVhbShkYXRhLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBkYXRhTGVuZ3RoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDB4NkE1MDIwMjA6IC8vICdqUFxcMDI0XFwwMjQnXHJcbiAgICAgICAgICAgIGlmICgweDBkMGE4NzBhICE9PSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSlAyIHNpZ25hdHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBoZWFkZXIgdHlwZXMgYXJlIHZhbGlkIGJ1dCBjdXJyZW50bHkgbm90IHVzZWQ6XHJcbiAgICAgICAgICBjYXNlIDB4NkE1MDFBMUE6IC8vICdqUFxcMDMyXFwwMzInXHJcbiAgICAgICAgICBjYXNlIDB4NjY3NDc5NzA6IC8vICdmdHlwJ1xyXG4gICAgICAgICAgY2FzZSAweDcyNzI2NTcxOiAvLyAncnJlcSdcclxuICAgICAgICAgIGNhc2UgMHg3MjY1NzMyMDogLy8gJ3JlcyAnXHJcbiAgICAgICAgICBjYXNlIDB4Njk2ODY0NzI6IC8vICdpaGRyJ1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXJUeXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgodGJveCA+PiAyNCkgJiAweEZGLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRib3ggPj4gMTYpICYgMHhGRixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0Ym94ID4+IDgpICYgMHhGRixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRib3ggJiAweEZGKTtcclxuICAgICAgICAgICAgd2FybignVW5zdXBwb3J0ZWQgaGVhZGVyIHR5cGUgJyArIHRib3ggKyAnICgnICsgaGVhZGVyVHlwZSArICcpJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVtcERhdGFMZW5ndGgpIHtcclxuICAgICAgICAgIHBvc2l0aW9uICs9IGRhdGFMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcGFyc2VJbWFnZVByb3BlcnRpZXM6IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlSW1hZ2VQcm9wZXJ0aWVzKHN0cmVhbSkge1xyXG4gICAgICB2YXIgbmV3Qnl0ZSA9IHN0cmVhbS5nZXRCeXRlKCk7XHJcbiAgICAgIHdoaWxlIChuZXdCeXRlID49IDApIHtcclxuICAgICAgICB2YXIgb2xkQnl0ZSA9IG5ld0J5dGU7XHJcbiAgICAgICAgbmV3Qnl0ZSA9IHN0cmVhbS5nZXRCeXRlKCk7XHJcbiAgICAgICAgdmFyIGNvZGUgPSAob2xkQnl0ZSA8PCA4KSB8IG5ld0J5dGU7XHJcbiAgICAgICAgLy8gSW1hZ2UgYW5kIHRpbGUgc2l6ZSAoU0laKVxyXG4gICAgICAgIGlmIChjb2RlID09PSAweEZGNTEpIHtcclxuICAgICAgICAgIHN0cmVhbS5za2lwKDQpO1xyXG4gICAgICAgICAgdmFyIFhzaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSA0XHJcbiAgICAgICAgICB2YXIgWXNpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDhcclxuICAgICAgICAgIHZhciBYT3NpeiA9IHN0cmVhbS5nZXRJbnQzMigpID4+PiAwOyAvLyBCeXRlIDEyXHJcbiAgICAgICAgICB2YXIgWU9zaXogPSBzdHJlYW0uZ2V0SW50MzIoKSA+Pj4gMDsgLy8gQnl0ZSAxNlxyXG4gICAgICAgICAgc3RyZWFtLnNraXAoMTYpO1xyXG4gICAgICAgICAgdmFyIENzaXogPSBzdHJlYW0uZ2V0VWludDE2KCk7IC8vIEJ5dGUgMzZcclxuICAgICAgICAgIHRoaXMud2lkdGggPSBYc2l6IC0gWE9zaXo7XHJcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IFlzaXogLSBZT3NpejtcclxuICAgICAgICAgIHRoaXMuY29tcG9uZW50c0NvdW50ID0gQ3NpejtcclxuICAgICAgICAgIC8vIFJlc3VsdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBVaW50OEFycmF5c1xyXG4gICAgICAgICAgdGhpcy5iaXRzUGVyQ29tcG9uZW50ID0gODtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IE5vIHNpemUgbWFya2VyIGZvdW5kIGluIEpQWCBzdHJlYW0nKTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUNvZGVzdHJlYW06IGZ1bmN0aW9uIEpweEltYWdlX3BhcnNlQ29kZXN0cmVhbShkYXRhLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgIHZhciBjb250ZXh0ID0ge307XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGRvTm90UmVjb3ZlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHN0YXJ0O1xyXG4gICAgICAgIHdoaWxlIChwb3NpdGlvbiArIDEgPCBlbmQpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICBwb3NpdGlvbiArPSAyO1xyXG5cclxuICAgICAgICAgIHZhciBsZW5ndGggPSAwLCBqLCBzcWNkLCBzcHFjZHMsIHNwcWNkU2l6ZSwgc2NhbGFyRXhwb3VuZGVkLCB0aWxlO1xyXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjRGOiAvLyBTdGFydCBvZiBjb2Rlc3RyZWFtIChTT0MpXHJcbiAgICAgICAgICAgICAgY29udGV4dC5tYWluSGVhZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGRDk6IC8vIEVuZCBvZiBjb2Rlc3RyZWFtIChFT0MpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjUxOiAvLyBJbWFnZSBhbmQgdGlsZSBzaXplIChTSVopXHJcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgdmFyIHNpeiA9IHt9O1xyXG4gICAgICAgICAgICAgIHNpei5Yc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDQpO1xyXG4gICAgICAgICAgICAgIHNpei5Zc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDgpO1xyXG4gICAgICAgICAgICAgIHNpei5YT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAxMik7XHJcbiAgICAgICAgICAgICAgc2l6LllPc2l6ID0gcmVhZFVpbnQzMihkYXRhLCBwb3NpdGlvbiArIDE2KTtcclxuICAgICAgICAgICAgICBzaXouWFRzaXogPSByZWFkVWludDMyKGRhdGEsIHBvc2l0aW9uICsgMjApO1xyXG4gICAgICAgICAgICAgIHNpei5ZVHNpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAyNCk7XHJcbiAgICAgICAgICAgICAgc2l6LlhUT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAyOCk7XHJcbiAgICAgICAgICAgICAgc2l6LllUT3NpeiA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyAzMik7XHJcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24gKyAzNik7XHJcbiAgICAgICAgICAgICAgc2l6LkNzaXogPSBjb21wb25lbnRzQ291bnQ7XHJcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICBqID0gcG9zaXRpb24gKyAzODtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICBwcmVjaXNpb246IChkYXRhW2pdICYgMHg3RikgKyAxLFxyXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZDogISEoZGF0YVtqXSAmIDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICBYUnNpejogZGF0YVtqICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgIFlSc2l6OiBkYXRhW2ogKyAxXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUNvbXBvbmVudERpbWVuc2lvbnMoY29tcG9uZW50LCBzaXopO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnRleHQuU0laID0gc2l6O1xyXG4gICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgICAgY2FsY3VsYXRlVGlsZUdyaWRzKGNvbnRleHQsIGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICAgIGNvbnRleHQuUUNDID0gW107XHJcbiAgICAgICAgICAgICAgY29udGV4dC5DT0MgPSBbXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGNUM6IC8vIFF1YW50aXphdGlvbiBkZWZhdWx0IChRQ0QpXHJcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgdmFyIHFjZCA9IHt9O1xyXG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XHJcbiAgICAgICAgICAgICAgc3FjZCA9IGRhdGFbaisrXTtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKHNxY2QgJiAweDFGKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDg7XHJcbiAgICAgICAgICAgICAgICAgIHNjYWxhckV4cG91bmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSAxNjtcclxuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICBzcHFjZFNpemUgPSAxNjtcclxuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogSW52YWxpZCBTUWNkIHZhbHVlICcgKyBzcWNkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcWNkLm5vUXVhbnRpemF0aW9uID0gKHNwcWNkU2l6ZSA9PT0gOCk7XHJcbiAgICAgICAgICAgICAgcWNkLnNjYWxhckV4cG91bmRlZCA9IHNjYWxhckV4cG91bmRlZDtcclxuICAgICAgICAgICAgICBxY2QuZ3VhcmRCaXRzID0gc3FjZCA+PiA1O1xyXG4gICAgICAgICAgICAgIHNwcWNkcyA9IFtdO1xyXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuZ3RoICsgcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzcHFjZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcWNkU2l6ZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICBzcHFjZC5lcHNpbG9uID0gZGF0YVtqKytdID4+IDM7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2pdID4+IDM7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gKChkYXRhW2pdICYgMHg3KSA8PCA4KSB8IGRhdGFbaiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcHFjZHMucHVzaChzcHFjZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHFjZC5TUHFjZHMgPSBzcHFjZHM7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWFpbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5RQ0QgPSBxY2Q7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuUUNEID0gcWNkO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5RQ0MgPSBbXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjVEOiAvLyBRdWFudGl6YXRpb24gY29tcG9uZW50IChRQ0MpXHJcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgdmFyIHFjYyA9IHt9O1xyXG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XHJcbiAgICAgICAgICAgICAgdmFyIGNxY2M7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQuU0laLkNzaXogPCAyNTcpIHtcclxuICAgICAgICAgICAgICAgIGNxY2MgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNxY2MgPSByZWFkVWludDE2KGRhdGEsIGopO1xyXG4gICAgICAgICAgICAgICAgaiArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzcWNkID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAoc3FjZCAmIDB4MUYpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgc3BxY2RTaXplID0gODtcclxuICAgICAgICAgICAgICAgICAgc2NhbGFyRXhwb3VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkU2l6ZSA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICBzY2FsYXJFeHBvdW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBJbnZhbGlkIFNRY2QgdmFsdWUgJyArIHNxY2QpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBxY2Mubm9RdWFudGl6YXRpb24gPSAoc3BxY2RTaXplID09PSA4KTtcclxuICAgICAgICAgICAgICBxY2Muc2NhbGFyRXhwb3VuZGVkID0gc2NhbGFyRXhwb3VuZGVkO1xyXG4gICAgICAgICAgICAgIHFjYy5ndWFyZEJpdHMgPSBzcWNkID4+IDU7XHJcbiAgICAgICAgICAgICAgc3BxY2RzID0gW107XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGogPCAobGVuZ3RoICsgcG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBzcHFjZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcWNkU2l6ZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICBzcHFjZC5lcHNpbG9uID0gZGF0YVtqKytdID4+IDM7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLmVwc2lsb24gPSBkYXRhW2pdID4+IDM7XHJcbiAgICAgICAgICAgICAgICAgIHNwcWNkLm11ID0gKChkYXRhW2pdICYgMHg3KSA8PCA4KSB8IGRhdGFbaiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcHFjZHMucHVzaChzcHFjZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHFjYy5TUHFjZHMgPSBzcHFjZHM7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWFpbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5RQ0NbY3FjY10gPSBxY2M7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuUUNDW2NxY2NdID0gcWNjO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGNTI6IC8vIENvZGluZyBzdHlsZSBkZWZhdWx0IChDT0QpXHJcbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgdmFyIGNvZCA9IHt9O1xyXG4gICAgICAgICAgICAgIGogPSBwb3NpdGlvbiArIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHNjb2QgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgY29kLmVudHJvcHlDb2RlcldpdGhDdXN0b21QcmVjaW5jdHMgPSAhIShzY29kICYgMSk7XHJcbiAgICAgICAgICAgICAgY29kLnNvcE1hcmtlclVzZWQgPSAhIShzY29kICYgMik7XHJcbiAgICAgICAgICAgICAgY29kLmVwaE1hcmtlclVzZWQgPSAhIShzY29kICYgNCk7XHJcbiAgICAgICAgICAgICAgY29kLnByb2dyZXNzaW9uT3JkZXIgPSBkYXRhW2orK107XHJcbiAgICAgICAgICAgICAgY29kLmxheWVyc0NvdW50ID0gcmVhZFVpbnQxNihkYXRhLCBqKTtcclxuICAgICAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICAgICAgY29kLm11bHRpcGxlQ29tcG9uZW50VHJhbnNmb3JtID0gZGF0YVtqKytdO1xyXG5cclxuICAgICAgICAgICAgICBjb2QuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgIGNvZC54Y2IgPSAoZGF0YVtqKytdICYgMHhGKSArIDI7XHJcbiAgICAgICAgICAgICAgY29kLnljYiA9IChkYXRhW2orK10gJiAweEYpICsgMjtcclxuICAgICAgICAgICAgICB2YXIgYmxvY2tTdHlsZSA9IGRhdGFbaisrXTtcclxuICAgICAgICAgICAgICBjb2Quc2VsZWN0aXZlQXJpdGhtZXRpY0NvZGluZ0J5cGFzcyA9ICEhKGJsb2NrU3R5bGUgJiAxKTtcclxuICAgICAgICAgICAgICBjb2QucmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcyA9ICEhKGJsb2NrU3R5bGUgJiAyKTtcclxuICAgICAgICAgICAgICBjb2QudGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzID0gISEoYmxvY2tTdHlsZSAmIDQpO1xyXG4gICAgICAgICAgICAgIGNvZC52ZXJ0aWNhbHlTdHJpcGUgPSAhIShibG9ja1N0eWxlICYgOCk7XHJcbiAgICAgICAgICAgICAgY29kLnByZWRpY3RhYmxlVGVybWluYXRpb24gPSAhIShibG9ja1N0eWxlICYgMTYpO1xyXG4gICAgICAgICAgICAgIGNvZC5zZWdtZW50YXRpb25TeW1ib2xVc2VkID0gISEoYmxvY2tTdHlsZSAmIDMyKTtcclxuICAgICAgICAgICAgICBjb2QucmV2ZXJzaWJsZVRyYW5zZm9ybWF0aW9uID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgIGlmIChjb2QuZW50cm9weUNvZGVyV2l0aEN1c3RvbVByZWNpbmN0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1NpemVzID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbmd0aCArIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdHNTaXplID0gZGF0YVtqKytdO1xyXG4gICAgICAgICAgICAgICAgICBwcmVjaW5jdHNTaXplcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBQUHg6IHByZWNpbmN0c1NpemUgJiAweEYsXHJcbiAgICAgICAgICAgICAgICAgICAgUFB5OiBwcmVjaW5jdHNTaXplID4+IDRcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2QucHJlY2luY3RzU2l6ZXMgPSBwcmVjaW5jdHNTaXplcztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIHVuc3VwcG9ydGVkID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKGNvZC5zZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCdzZWxlY3RpdmVBcml0aG1ldGljQ29kaW5nQnlwYXNzJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChjb2QucmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgncmVzZXRDb250ZXh0UHJvYmFiaWxpdGllcycpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoY29kLnRlcm1pbmF0aW9uT25FYWNoQ29kaW5nUGFzcykge1xyXG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQucHVzaCgndGVybWluYXRpb25PbkVhY2hDb2RpbmdQYXNzJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChjb2QudmVydGljYWx5U3RyaXBlKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCd2ZXJ0aWNhbHlTdHJpcGUnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGNvZC5wcmVkaWN0YWJsZVRlcm1pbmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5wdXNoKCdwcmVkaWN0YWJsZVRlcm1pbmF0aW9uJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICh1bnN1cHBvcnRlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBkb05vdFJlY292ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IFVuc3VwcG9ydGVkIENPRCBvcHRpb25zICgnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZC5qb2luKCcsICcpICsgJyknKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQubWFpbkhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5DT0QgPSBjb2Q7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbGUuQ09EID0gY29kO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGlsZS5DT0MgPSBbXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjkwOiAvLyBTdGFydCBvZiB0aWxlLXBhcnQgKFNPVClcclxuICAgICAgICAgICAgICBsZW5ndGggPSByZWFkVWludDE2KGRhdGEsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICB0aWxlID0ge307XHJcbiAgICAgICAgICAgICAgdGlsZS5pbmRleCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24gKyAyKTtcclxuICAgICAgICAgICAgICB0aWxlLmxlbmd0aCA9IHJlYWRVaW50MzIoZGF0YSwgcG9zaXRpb24gKyA0KTtcclxuICAgICAgICAgICAgICB0aWxlLmRhdGFFbmQgPSB0aWxlLmxlbmd0aCArIHBvc2l0aW9uIC0gMjtcclxuICAgICAgICAgICAgICB0aWxlLnBhcnRJbmRleCA9IGRhdGFbcG9zaXRpb24gKyA4XTtcclxuICAgICAgICAgICAgICB0aWxlLnBhcnRzQ291bnQgPSBkYXRhW3Bvc2l0aW9uICsgOV07XHJcblxyXG4gICAgICAgICAgICAgIGNvbnRleHQubWFpbkhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGlmICh0aWxlLnBhcnRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgY29tcG9uZW50IHNwZWNpZmljIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICB0aWxlLkNPRCA9IGNvbnRleHQuQ09EO1xyXG4gICAgICAgICAgICAgICAgdGlsZS5DT0MgPSBjb250ZXh0LkNPQy5zbGljZSgwKTsgLy8gY2xvbmUgb2YgdGhlIGdsb2JhbCBDT0NcclxuICAgICAgICAgICAgICAgIHRpbGUuUUNEID0gY29udGV4dC5RQ0Q7XHJcbiAgICAgICAgICAgICAgICB0aWxlLlFDQyA9IGNvbnRleHQuUUNDLnNsaWNlKDApOyAvLyBjbG9uZSBvZiB0aGUgZ2xvYmFsIENPQ1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlID0gdGlsZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGOTM6IC8vIFN0YXJ0IG9mIGRhdGEgKFNPRClcclxuICAgICAgICAgICAgICB0aWxlID0gY29udGV4dC5jdXJyZW50VGlsZTtcclxuICAgICAgICAgICAgICBpZiAodGlsZS5wYXJ0SW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVUaWxlKGNvbnRleHQsIHRpbGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQYWNrZXRzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbW92aW5nIHRvIHRoZSBlbmQgb2YgdGhlIGRhdGFcclxuICAgICAgICAgICAgICBsZW5ndGggPSB0aWxlLmRhdGFFbmQgLSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICBwYXJzZVRpbGVQYWNrZXRzKGNvbnRleHQsIGRhdGEsIHBvc2l0aW9uLCBsZW5ndGgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4RkY1NTogLy8gVGlsZS1wYXJ0IGxlbmd0aHMsIG1haW4gaGVhZGVyIChUTE0pXHJcbiAgICAgICAgICAgIGNhc2UgMHhGRjU3OiAvLyBQYWNrZXQgbGVuZ3RoLCBtYWluIGhlYWRlciAoUExNKVxyXG4gICAgICAgICAgICBjYXNlIDB4RkY1ODogLy8gUGFja2V0IGxlbmd0aCwgdGlsZS1wYXJ0IGhlYWRlciAoUExUKVxyXG4gICAgICAgICAgICBjYXNlIDB4RkY2NDogLy8gQ29tbWVudCAoQ09NKVxyXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHJlYWRVaW50MTYoZGF0YSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgIC8vIHNraXBwaW5nIGNvbnRlbnRcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEZGNTM6IC8vIENvZGluZyBzdHlsZSBjb21wb25lbnQgKENPQylcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogQ29kZXN0cmVhbSBjb2RlIDB4RkY1MyAoQ09DKSBpcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlBYIEVycm9yOiBVbmtub3duIGNvZGVzdHJlYW0gY29kZTogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvc2l0aW9uICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZG9Ob3RSZWNvdmVyIHx8IHRoaXMuZmFpbE9uQ29ycnVwdGVkSW1hZ2UpIHtcclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdhcm4oJ1RyeWluZyB0byByZWNvdmVyIGZyb20gJyArIGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudGlsZXMgPSB0cmFuc2Zvcm1Db21wb25lbnRzKGNvbnRleHQpO1xyXG4gICAgICB0aGlzLndpZHRoID0gY29udGV4dC5TSVouWHNpeiAtIGNvbnRleHQuU0laLlhPc2l6O1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGNvbnRleHQuU0laLllzaXogLSBjb250ZXh0LlNJWi5ZT3NpejtcclxuICAgICAgdGhpcy5jb21wb25lbnRzQ291bnQgPSBjb250ZXh0LlNJWi5Dc2l6O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQ29tcG9uZW50RGltZW5zaW9ucyhjb21wb25lbnQsIHNpeikge1xyXG4gICAgLy8gU2VjdGlvbiBCLjIgQ29tcG9uZW50IG1hcHBpbmdcclxuICAgIGNvbXBvbmVudC54MCA9IE1hdGguY2VpbChzaXouWE9zaXogLyBjb21wb25lbnQuWFJzaXopO1xyXG4gICAgY29tcG9uZW50LngxID0gTWF0aC5jZWlsKHNpei5Yc2l6IC8gY29tcG9uZW50LlhSc2l6KTtcclxuICAgIGNvbXBvbmVudC55MCA9IE1hdGguY2VpbChzaXouWU9zaXogLyBjb21wb25lbnQuWVJzaXopO1xyXG4gICAgY29tcG9uZW50LnkxID0gTWF0aC5jZWlsKHNpei5Zc2l6IC8gY29tcG9uZW50LllSc2l6KTtcclxuICAgIGNvbXBvbmVudC53aWR0aCA9IGNvbXBvbmVudC54MSAtIGNvbXBvbmVudC54MDtcclxuICAgIGNvbXBvbmVudC5oZWlnaHQgPSBjb21wb25lbnQueTEgLSBjb21wb25lbnQueTA7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbGVHcmlkcyhjb250ZXh0LCBjb21wb25lbnRzKSB7XHJcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XHJcbiAgICAvLyBTZWN0aW9uIEIuMyBEaXZpc2lvbiBpbnRvIHRpbGUgYW5kIHRpbGUtY29tcG9uZW50c1xyXG4gICAgdmFyIHRpbGUsIHRpbGVzID0gW107XHJcbiAgICB2YXIgbnVtWHRpbGVzID0gTWF0aC5jZWlsKChzaXouWHNpeiAtIHNpei5YVE9zaXopIC8gc2l6LlhUc2l6KTtcclxuICAgIHZhciBudW1ZdGlsZXMgPSBNYXRoLmNlaWwoKHNpei5Zc2l6IC0gc2l6LllUT3NpeikgLyBzaXouWVRzaXopO1xyXG4gICAgZm9yICh2YXIgcSA9IDA7IHEgPCBudW1ZdGlsZXM7IHErKykge1xyXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IG51bVh0aWxlczsgcCsrKSB7XHJcbiAgICAgICAgdGlsZSA9IHt9O1xyXG4gICAgICAgIHRpbGUudHgwID0gTWF0aC5tYXgoc2l6LlhUT3NpeiArIHAgKiBzaXouWFRzaXosIHNpei5YT3Npeik7XHJcbiAgICAgICAgdGlsZS50eTAgPSBNYXRoLm1heChzaXouWVRPc2l6ICsgcSAqIHNpei5ZVHNpeiwgc2l6LllPc2l6KTtcclxuICAgICAgICB0aWxlLnR4MSA9IE1hdGgubWluKHNpei5YVE9zaXogKyAocCArIDEpICogc2l6LlhUc2l6LCBzaXouWHNpeik7XHJcbiAgICAgICAgdGlsZS50eTEgPSBNYXRoLm1pbihzaXouWVRPc2l6ICsgKHEgKyAxKSAqIHNpei5ZVHNpeiwgc2l6LllzaXopO1xyXG4gICAgICAgIHRpbGUud2lkdGggPSB0aWxlLnR4MSAtIHRpbGUudHgwO1xyXG4gICAgICAgIHRpbGUuaGVpZ2h0ID0gdGlsZS50eTEgLSB0aWxlLnR5MDtcclxuICAgICAgICB0aWxlLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICB0aWxlcy5wdXNoKHRpbGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnRpbGVzID0gdGlsZXM7XHJcblxyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29tcG9uZW50c0NvdW50OyBpIDwgaWk7IGkrKykge1xyXG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcclxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gdGlsZXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgIHZhciB0aWxlQ29tcG9uZW50ID0ge307XHJcbiAgICAgICAgdGlsZSA9IHRpbGVzW2pdO1xyXG4gICAgICAgIHRpbGVDb21wb25lbnQudGN4MCA9IE1hdGguY2VpbCh0aWxlLnR4MCAvIGNvbXBvbmVudC5YUnNpeik7XHJcbiAgICAgICAgdGlsZUNvbXBvbmVudC50Y3kwID0gTWF0aC5jZWlsKHRpbGUudHkwIC8gY29tcG9uZW50LllSc2l6KTtcclxuICAgICAgICB0aWxlQ29tcG9uZW50LnRjeDEgPSBNYXRoLmNlaWwodGlsZS50eDEgLyBjb21wb25lbnQuWFJzaXopO1xyXG4gICAgICAgIHRpbGVDb21wb25lbnQudGN5MSA9IE1hdGguY2VpbCh0aWxlLnR5MSAvIGNvbXBvbmVudC5ZUnNpeik7XHJcbiAgICAgICAgdGlsZUNvbXBvbmVudC53aWR0aCA9IHRpbGVDb21wb25lbnQudGN4MSAtIHRpbGVDb21wb25lbnQudGN4MDtcclxuICAgICAgICB0aWxlQ29tcG9uZW50LmhlaWdodCA9IHRpbGVDb21wb25lbnQudGN5MSAtIHRpbGVDb21wb25lbnQudGN5MDtcclxuICAgICAgICB0aWxlLmNvbXBvbmVudHNbaV0gPSB0aWxlQ29tcG9uZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEJsb2Nrc0RpbWVuc2lvbnMoY29udGV4dCwgY29tcG9uZW50LCByKSB7XHJcbiAgICB2YXIgY29kT3JDb2MgPSBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKCFjb2RPckNvYy5lbnRyb3B5Q29kZXJXaXRoQ3VzdG9tUHJlY2luY3RzKSB7XHJcbiAgICAgIHJlc3VsdC5QUHggPSAxNTtcclxuICAgICAgcmVzdWx0LlBQeSA9IDE1O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0LlBQeCA9IGNvZE9yQ29jLnByZWNpbmN0c1NpemVzW3JdLlBQeDtcclxuICAgICAgcmVzdWx0LlBQeSA9IGNvZE9yQ29jLnByZWNpbmN0c1NpemVzW3JdLlBQeTtcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSBjb2RlYmxvY2sgc2l6ZSBhcyBkZXNjcmliZWQgaW4gc2VjdGlvbiBCLjdcclxuICAgIHJlc3VsdC54Y2JfID0gKHIgPiAwID8gTWF0aC5taW4oY29kT3JDb2MueGNiLCByZXN1bHQuUFB4IC0gMSkgOlxyXG4gICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29kT3JDb2MueGNiLCByZXN1bHQuUFB4KSk7XHJcbiAgICByZXN1bHQueWNiXyA9IChyID4gMCA/IE1hdGgubWluKGNvZE9yQ29jLnljYiwgcmVzdWx0LlBQeSAtIDEpIDpcclxuICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGNvZE9yQ29jLnljYiwgcmVzdWx0LlBQeSkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gYnVpbGRQcmVjaW5jdHMoY29udGV4dCwgcmVzb2x1dGlvbiwgZGltZW5zaW9ucykge1xyXG4gICAgLy8gU2VjdGlvbiBCLjYgRGl2aXNpb24gcmVzb2x1dGlvbiB0byBwcmVjaW5jdHNcclxuICAgIHZhciBwcmVjaW5jdFdpZHRoID0gMSA8PCBkaW1lbnNpb25zLlBQeDtcclxuICAgIHZhciBwcmVjaW5jdEhlaWdodCA9IDEgPDwgZGltZW5zaW9ucy5QUHk7XHJcbiAgICAvLyBKYXNwZXIgaW50cm9kdWNlcyBjb2RlYmxvY2sgZ3JvdXBzIGZvciBtYXBwaW5nIGVhY2ggc3ViYmFuZCBjb2RlYmxvY2tzXHJcbiAgICAvLyB0byBwcmVjaW5jdHMuIFByZWNpbmN0IHBhcnRpdGlvbiBkaXZpZGVzIGEgcmVzb2x1dGlvbiBhY2NvcmRpbmcgdG8gd2lkdGhcclxuICAgIC8vIGFuZCBoZWlnaHQgcGFyYW1ldGVycy4gVGhlIHN1YmJhbmQgdGhhdCBiZWxvbmdzIHRvIHRoZSByZXNvbHV0aW9uIGxldmVsXHJcbiAgICAvLyBoYXMgYSBkaWZmZXJlbnQgc2l6ZSB0aGFuIHRoZSBsZXZlbCwgdW5sZXNzIGl0IGlzIHRoZSB6ZXJvIHJlc29sdXRpb24uXHJcblxyXG4gICAgLy8gRnJvbSBKYXNwZXIgZG9jdW1lbnRhdGlvbjoganBlZzIwMDAucGRmLCBzZWN0aW9uIEs6IFRpZXItMiBjb2Rpbmc6XHJcbiAgICAvLyBUaGUgcHJlY2luY3QgcGFydGl0aW9uaW5nIGZvciBhIHBhcnRpY3VsYXIgc3ViYmFuZCBpcyBkZXJpdmVkIGZyb20gYVxyXG4gICAgLy8gcGFydGl0aW9uaW5nIG9mIGl0cyBwYXJlbnQgTEwgYmFuZCAoaS5lLiwgdGhlIExMIGJhbmQgYXQgdGhlIG5leHQgaGlnaGVyXHJcbiAgICAvLyByZXNvbHV0aW9uIGxldmVsKS4uLiBUaGUgTEwgYmFuZCBhc3NvY2lhdGVkIHdpdGggZWFjaCByZXNvbHV0aW9uIGxldmVsIGlzXHJcbiAgICAvLyBkaXZpZGVkIGludG8gcHJlY2luY3RzLi4uIEVhY2ggb2YgdGhlIHJlc3VsdGluZyBwcmVjaW5jdCByZWdpb25zIGlzIHRoZW5cclxuICAgIC8vIG1hcHBlZCBpbnRvIGl0cyBjaGlsZCBzdWJiYW5kcyAoaWYgYW55KSBhdCB0aGUgbmV4dCBsb3dlciByZXNvbHV0aW9uXHJcbiAgICAvLyBsZXZlbC4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgdXNpbmcgdGhlIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cclxuICAgIC8vICh1LCB2KSA9IChjZWlsKHgvMiksIGNlaWwoeS8yKSkgd2hlcmUgKHgsIHkpIGFuZCAodSwgdikgYXJlIHRoZVxyXG4gICAgLy8gY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBpbiB0aGUgTEwgYmFuZCBhbmQgY2hpbGQgc3ViYmFuZCwgcmVzcGVjdGl2ZWx5LlxyXG4gICAgdmFyIGlzWmVyb1JlcyA9IHJlc29sdXRpb24ucmVzTGV2ZWwgPT09IDA7XHJcbiAgICB2YXIgcHJlY2luY3RXaWR0aEluU3ViYmFuZCA9IDEgPDwgKGRpbWVuc2lvbnMuUFB4ICsgKGlzWmVyb1JlcyA/IDAgOiAtMSkpO1xyXG4gICAgdmFyIHByZWNpbmN0SGVpZ2h0SW5TdWJiYW5kID0gMSA8PCAoZGltZW5zaW9ucy5QUHkgKyAoaXNaZXJvUmVzID8gMCA6IC0xKSk7XHJcbiAgICB2YXIgbnVtcHJlY2luY3Rzd2lkZSA9IChyZXNvbHV0aW9uLnRyeDEgPiByZXNvbHV0aW9uLnRyeDAgP1xyXG4gICAgICBNYXRoLmNlaWwocmVzb2x1dGlvbi50cngxIC8gcHJlY2luY3RXaWR0aCkgLVxyXG4gICAgICBNYXRoLmZsb29yKHJlc29sdXRpb24udHJ4MCAvIHByZWNpbmN0V2lkdGgpIDogMCk7XHJcbiAgICB2YXIgbnVtcHJlY2luY3RzaGlnaCA9IChyZXNvbHV0aW9uLnRyeTEgPiByZXNvbHV0aW9uLnRyeTAgP1xyXG4gICAgICBNYXRoLmNlaWwocmVzb2x1dGlvbi50cnkxIC8gcHJlY2luY3RIZWlnaHQpIC1cclxuICAgICAgTWF0aC5mbG9vcihyZXNvbHV0aW9uLnRyeTAgLyBwcmVjaW5jdEhlaWdodCkgOiAwKTtcclxuICAgIHZhciBudW1wcmVjaW5jdHMgPSBudW1wcmVjaW5jdHN3aWRlICogbnVtcHJlY2luY3RzaGlnaDtcclxuXHJcbiAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycyA9IHtcclxuICAgICAgcHJlY2luY3RXaWR0aDogcHJlY2luY3RXaWR0aCxcclxuICAgICAgcHJlY2luY3RIZWlnaHQ6IHByZWNpbmN0SGVpZ2h0LFxyXG4gICAgICBudW1wcmVjaW5jdHN3aWRlOiBudW1wcmVjaW5jdHN3aWRlLFxyXG4gICAgICBudW1wcmVjaW5jdHNoaWdoOiBudW1wcmVjaW5jdHNoaWdoLFxyXG4gICAgICBudW1wcmVjaW5jdHM6IG51bXByZWNpbmN0cyxcclxuICAgICAgcHJlY2luY3RXaWR0aEluU3ViYmFuZDogcHJlY2luY3RXaWR0aEluU3ViYmFuZCxcclxuICAgICAgcHJlY2luY3RIZWlnaHRJblN1YmJhbmQ6IHByZWNpbmN0SGVpZ2h0SW5TdWJiYW5kXHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBidWlsZENvZGVibG9ja3MoY29udGV4dCwgc3ViYmFuZCwgZGltZW5zaW9ucykge1xyXG4gICAgLy8gU2VjdGlvbiBCLjcgRGl2aXNpb24gc3ViLWJhbmQgaW50byBjb2RlLWJsb2Nrc1xyXG4gICAgdmFyIHhjYl8gPSBkaW1lbnNpb25zLnhjYl87XHJcbiAgICB2YXIgeWNiXyA9IGRpbWVuc2lvbnMueWNiXztcclxuICAgIHZhciBjb2RlYmxvY2tXaWR0aCA9IDEgPDwgeGNiXztcclxuICAgIHZhciBjb2RlYmxvY2tIZWlnaHQgPSAxIDw8IHljYl87XHJcbiAgICB2YXIgY2J4MCA9IHN1YmJhbmQudGJ4MCA+PiB4Y2JfO1xyXG4gICAgdmFyIGNieTAgPSBzdWJiYW5kLnRieTAgPj4geWNiXztcclxuICAgIHZhciBjYngxID0gKHN1YmJhbmQudGJ4MSArIGNvZGVibG9ja1dpZHRoIC0gMSkgPj4geGNiXztcclxuICAgIHZhciBjYnkxID0gKHN1YmJhbmQudGJ5MSArIGNvZGVibG9ja0hlaWdodCAtIDEpID4+IHljYl87XHJcbiAgICB2YXIgcHJlY2luY3RQYXJhbWV0ZXJzID0gc3ViYmFuZC5yZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycztcclxuICAgIHZhciBjb2RlYmxvY2tzID0gW107XHJcbiAgICB2YXIgcHJlY2luY3RzID0gW107XHJcbiAgICB2YXIgaSwgaiwgY29kZWJsb2NrLCBwcmVjaW5jdE51bWJlcjtcclxuICAgIGZvciAoaiA9IGNieTA7IGogPCBjYnkxOyBqKyspIHtcclxuICAgICAgZm9yIChpID0gY2J4MDsgaSA8IGNieDE7IGkrKykge1xyXG4gICAgICAgIGNvZGVibG9jayA9IHtcclxuICAgICAgICAgIGNieDogaSxcclxuICAgICAgICAgIGNieTogaixcclxuICAgICAgICAgIHRieDA6IGNvZGVibG9ja1dpZHRoICogaSxcclxuICAgICAgICAgIHRieTA6IGNvZGVibG9ja0hlaWdodCAqIGosXHJcbiAgICAgICAgICB0YngxOiBjb2RlYmxvY2tXaWR0aCAqIChpICsgMSksXHJcbiAgICAgICAgICB0YnkxOiBjb2RlYmxvY2tIZWlnaHQgKiAoaiArIDEpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29kZWJsb2NrLnRieDBfID0gTWF0aC5tYXgoc3ViYmFuZC50YngwLCBjb2RlYmxvY2sudGJ4MCk7XHJcbiAgICAgICAgY29kZWJsb2NrLnRieTBfID0gTWF0aC5tYXgoc3ViYmFuZC50YnkwLCBjb2RlYmxvY2sudGJ5MCk7XHJcbiAgICAgICAgY29kZWJsb2NrLnRieDFfID0gTWF0aC5taW4oc3ViYmFuZC50YngxLCBjb2RlYmxvY2sudGJ4MSk7XHJcbiAgICAgICAgY29kZWJsb2NrLnRieTFfID0gTWF0aC5taW4oc3ViYmFuZC50YnkxLCBjb2RlYmxvY2sudGJ5MSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjaW5jdCBudW1iZXIgZm9yIHRoaXMgY29kZWJsb2NrLCBjb2RlYmxvY2sgcG9zaXRpb25cclxuICAgICAgICAvLyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gaXRzIHN1YmJhbmQsIHVzZSBhY3R1YWwgZGltZW5zaW9uIGFuZCBwb3NpdGlvblxyXG4gICAgICAgIC8vIFNlZSBjb21tZW50IGFib3V0IGNvZGVibG9jayBncm91cCB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICAgICAgdmFyIHBpID0gTWF0aC5mbG9vcigoY29kZWJsb2NrLnRieDBfIC0gc3ViYmFuZC50YngwKSAvXHJcbiAgICAgICAgICBwcmVjaW5jdFBhcmFtZXRlcnMucHJlY2luY3RXaWR0aEluU3ViYmFuZCk7XHJcbiAgICAgICAgdmFyIHBqID0gTWF0aC5mbG9vcigoY29kZWJsb2NrLnRieTBfIC0gc3ViYmFuZC50YnkwKSAvXHJcbiAgICAgICAgICBwcmVjaW5jdFBhcmFtZXRlcnMucHJlY2luY3RIZWlnaHRJblN1YmJhbmQpO1xyXG4gICAgICAgIHByZWNpbmN0TnVtYmVyID0gcGkgKyAocGogKiBwcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3Rzd2lkZSk7XHJcblxyXG4gICAgICAgIGNvZGVibG9jay5wcmVjaW5jdE51bWJlciA9IHByZWNpbmN0TnVtYmVyO1xyXG4gICAgICAgIGNvZGVibG9jay5zdWJiYW5kVHlwZSA9IHN1YmJhbmQudHlwZTtcclxuICAgICAgICBjb2RlYmxvY2suTGJsb2NrID0gMztcclxuXHJcbiAgICAgICAgaWYgKGNvZGVibG9jay50YngxXyA8PSBjb2RlYmxvY2sudGJ4MF8gfHxcclxuICAgICAgICAgICAgY29kZWJsb2NrLnRieTFfIDw9IGNvZGVibG9jay50YnkwXykge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvZGVibG9ja3MucHVzaChjb2RlYmxvY2spO1xyXG4gICAgICAgIC8vIGJ1aWxkaW5nIHByZWNpbmN0IGZvciB0aGUgc3ViLWJhbmRcclxuICAgICAgICB2YXIgcHJlY2luY3QgPSBwcmVjaW5jdHNbcHJlY2luY3ROdW1iZXJdO1xyXG4gICAgICAgIGlmIChwcmVjaW5jdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAoaSA8IHByZWNpbmN0LmNieE1pbikge1xyXG4gICAgICAgICAgICBwcmVjaW5jdC5jYnhNaW4gPSBpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gcHJlY2luY3QuY2J4TWF4KSB7XHJcbiAgICAgICAgICAgIHByZWNpbmN0LmNieE1heCA9IGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaiA8IHByZWNpbmN0LmNieU1pbikge1xyXG4gICAgICAgICAgICBwcmVjaW5jdC5jYnhNaW4gPSBqO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gcHJlY2luY3QuY2J5TWF4KSB7XHJcbiAgICAgICAgICAgIHByZWNpbmN0LmNieU1heCA9IGo7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByZWNpbmN0c1twcmVjaW5jdE51bWJlcl0gPSBwcmVjaW5jdCA9IHtcclxuICAgICAgICAgICAgY2J4TWluOiBpLFxyXG4gICAgICAgICAgICBjYnlNaW46IGosXHJcbiAgICAgICAgICAgIGNieE1heDogaSxcclxuICAgICAgICAgICAgY2J5TWF4OiBqXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2RlYmxvY2sucHJlY2luY3QgPSBwcmVjaW5jdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3ViYmFuZC5jb2RlYmxvY2tQYXJhbWV0ZXJzID0ge1xyXG4gICAgICBjb2RlYmxvY2tXaWR0aDogeGNiXyxcclxuICAgICAgY29kZWJsb2NrSGVpZ2h0OiB5Y2JfLFxyXG4gICAgICBudW1jb2RlYmxvY2t3aWRlOiBjYngxIC0gY2J4MCArIDEsXHJcbiAgICAgIG51bWNvZGVibG9ja2hpZ2g6IGNieTEgLSBjYnkwICsgMVxyXG4gICAgfTtcclxuICAgIHN1YmJhbmQuY29kZWJsb2NrcyA9IGNvZGVibG9ja3M7XHJcbiAgICBzdWJiYW5kLnByZWNpbmN0cyA9IHByZWNpbmN0cztcclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIHByZWNpbmN0TnVtYmVyLCBsYXllck51bWJlcikge1xyXG4gICAgdmFyIHByZWNpbmN0Q29kZWJsb2NrcyA9IFtdO1xyXG4gICAgLy8gU2VjdGlvbiBCLjEwLjggT3JkZXIgb2YgaW5mbyBpbiBwYWNrZXRcclxuICAgIHZhciBzdWJiYW5kcyA9IHJlc29sdXRpb24uc3ViYmFuZHM7XHJcbiAgICAvLyBzdWItYmFuZHMgYWxyZWFkeSBvcmRlcmVkIGluICdMTCcsICdITCcsICdMSCcsIGFuZCAnSEgnIHNlcXVlbmNlXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzdWJiYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgIHZhciBzdWJiYW5kID0gc3ViYmFuZHNbaV07XHJcbiAgICAgIHZhciBjb2RlYmxvY2tzID0gc3ViYmFuZC5jb2RlYmxvY2tzO1xyXG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBjb2RlYmxvY2tzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICB2YXIgY29kZWJsb2NrID0gY29kZWJsb2Nrc1tqXTtcclxuICAgICAgICBpZiAoY29kZWJsb2NrLnByZWNpbmN0TnVtYmVyICE9PSBwcmVjaW5jdE51bWJlcikge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZWNpbmN0Q29kZWJsb2Nrcy5wdXNoKGNvZGVibG9jayk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxheWVyTnVtYmVyOiBsYXllck51bWJlcixcclxuICAgICAgY29kZWJsb2NrczogcHJlY2luY3RDb2RlYmxvY2tzXHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBMYXllclJlc29sdXRpb25Db21wb25lbnRQb3NpdGlvbkl0ZXJhdG9yKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gMDtcclxuICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY29tcG9uZW50c0NvdW50OyBxKyspIHtcclxuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxyXG4gICAgICAgIHRpbGUuY29tcG9uZW50c1txXS5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbCA9IDAsIHIgPSAwLCBpID0gMCwgayA9IDA7XHJcblxyXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcclxuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuMSBMYXllci1yZXNvbHV0aW9uLWNvbXBvbmVudC1wb3NpdGlvblxyXG4gICAgICBmb3IgKDsgbCA8IGxheWVyc0NvdW50OyBsKyspIHtcclxuICAgICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW3JdO1xyXG4gICAgICAgICAgICB2YXIgbnVtcHJlY2luY3RzID0gcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO1xyXG4gICAgICAgICAgICBmb3IgKDsgayA8IG51bXByZWNpbmN0czspIHtcclxuICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIGssIGwpO1xyXG4gICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGsgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBSZXNvbHV0aW9uTGF5ZXJDb21wb25lbnRQb3NpdGlvbkl0ZXJhdG9yKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gMDtcclxuICAgIGZvciAodmFyIHEgPSAwOyBxIDwgY29tcG9uZW50c0NvdW50OyBxKyspIHtcclxuICAgICAgbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID0gTWF0aC5tYXgobWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50LFxyXG4gICAgICAgIHRpbGUuY29tcG9uZW50c1txXS5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgciA9IDAsIGwgPSAwLCBpID0gMCwgayA9IDA7XHJcblxyXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcclxuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuMiBSZXNvbHV0aW9uLWxheWVyLWNvbXBvbmVudC1wb3NpdGlvblxyXG4gICAgICBmb3IgKDsgciA8PSBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xyXG4gICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7IGwrKykge1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW3JdO1xyXG4gICAgICAgICAgICB2YXIgbnVtcHJlY2luY3RzID0gcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzO1xyXG4gICAgICAgICAgICBmb3IgKDsgayA8IG51bXByZWNpbmN0czspIHtcclxuICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIGssIGwpO1xyXG4gICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGsgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBSZXNvbHV0aW9uUG9zaXRpb25Db21wb25lbnRMYXllckl0ZXJhdG9yKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgbGF5ZXJzQ291bnQgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubGF5ZXJzQ291bnQ7XHJcbiAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gc2l6LkNzaXo7XHJcbiAgICB2YXIgbCwgciwgYywgcDtcclxuICAgIHZhciBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPSAwO1xyXG4gICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XHJcbiAgICAgIG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9IE1hdGgubWF4KG1heERlY29tcG9zaXRpb25MZXZlbHNDb3VudCxcclxuICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudCk7XHJcbiAgICB9XHJcbiAgICB2YXIgbWF4TnVtUHJlY2luY3RzSW5MZXZlbCA9IG5ldyBJbnQzMkFycmF5KFxyXG4gICAgICBtYXhEZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgKyAxKTtcclxuICAgIGZvciAociA9IDA7IHIgPD0gbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyArK3IpIHtcclxuICAgICAgdmFyIG1heE51bVByZWNpbmN0cyA9IDA7XHJcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7ICsrYykge1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9ucyA9IHRpbGUuY29tcG9uZW50c1tjXS5yZXNvbHV0aW9ucztcclxuICAgICAgICBpZiAociA8IHJlc29sdXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgbWF4TnVtUHJlY2luY3RzID0gTWF0aC5tYXgobWF4TnVtUHJlY2luY3RzLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uc1tyXS5wcmVjaW5jdFBhcmFtZXRlcnMubnVtcHJlY2luY3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbWF4TnVtUHJlY2luY3RzSW5MZXZlbFtyXSA9IG1heE51bVByZWNpbmN0cztcclxuICAgIH1cclxuICAgIGwgPSAwO1xyXG4gICAgciA9IDA7XHJcbiAgICBjID0gMDtcclxuICAgIHAgPSAwO1xyXG5cclxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XHJcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjMgUmVzb2x1dGlvbi1wb3NpdGlvbi1jb21wb25lbnQtbGF5ZXJcclxuICAgICAgZm9yICg7IHIgPD0gbWF4RGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByKyspIHtcclxuICAgICAgICBmb3IgKDsgcCA8IG1heE51bVByZWNpbmN0c0luTGV2ZWxbcl07IHArKykge1xyXG4gICAgICAgICAgZm9yICg7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xyXG4gICAgICAgICAgICBpZiAociA+IGNvbXBvbmVudC5jb2RpbmdTdHlsZVBhcmFtZXRlcnMuZGVjb21wb3NpdGlvbkxldmVsc0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgIHZhciBudW1wcmVjaW5jdHMgPSByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHM7XHJcbiAgICAgICAgICAgIGlmIChwID49IG51bXByZWNpbmN0cykge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7KSB7XHJcbiAgICAgICAgICAgICAgdmFyIHBhY2tldCA9IGNyZWF0ZVBhY2tldChyZXNvbHV0aW9uLCBwLCBsKTtcclxuICAgICAgICAgICAgICBsKys7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gMDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gUG9zaXRpb25Db21wb25lbnRSZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KSB7XHJcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XHJcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcclxuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xyXG4gICAgdmFyIGxheWVyc0NvdW50ID0gdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzLmxheWVyc0NvdW50O1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgdmFyIHByZWNpbmN0c1NpemVzID0gZ2V0UHJlY2luY3RTaXplc0luSW1hZ2VTY2FsZSh0aWxlKTtcclxuICAgIHZhciBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyA9IHByZWNpbmN0c1NpemVzO1xyXG4gICAgdmFyIGwgPSAwLCByID0gMCwgYyA9IDAsIHB4ID0gMCwgcHkgPSAwO1xyXG5cclxuICAgIHRoaXMubmV4dFBhY2tldCA9IGZ1bmN0aW9uIEpweEltYWdlX25leHRQYWNrZXQoKSB7XHJcbiAgICAgIC8vIFNlY3Rpb24gQi4xMi4xLjQgUG9zaXRpb24tY29tcG9uZW50LXJlc29sdXRpb24tbGF5ZXJcclxuICAgICAgZm9yICg7IHB5IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtSGlnaDsgcHkrKykge1xyXG4gICAgICAgIGZvciAoOyBweCA8IHByZWNpbmN0c0l0ZXJhdGlvblNpemVzLm1heE51bVdpZGU7IHB4KyspIHtcclxuICAgICAgICAgIGZvciAoOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgICAgICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XHJcbiAgICAgICAgICAgIGZvciAoOyByIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgcisrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBjb21wb25lbnQucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgICAgdmFyIHNpemVJbkltYWdlU2NhbGUgPVxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RzU2l6ZXMuY29tcG9uZW50c1tjXS5yZXNvbHV0aW9uc1tyXTtcclxuICAgICAgICAgICAgICB2YXIgayA9IGdldFByZWNpbmN0SW5kZXhJZkV4aXN0KFxyXG4gICAgICAgICAgICAgICAgcHgsXHJcbiAgICAgICAgICAgICAgICBweSxcclxuICAgICAgICAgICAgICAgIHNpemVJbkltYWdlU2NhbGUsXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNJdGVyYXRpb25TaXplcyxcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgIGlmIChrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZm9yICg7IGwgPCBsYXllcnNDb3VudDspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWNrZXQgPSBjcmVhdGVQYWNrZXQocmVzb2x1dGlvbiwgaywgbCk7XHJcbiAgICAgICAgICAgICAgICBsKys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBweCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIENvbXBvbmVudFBvc2l0aW9uUmVzb2x1dGlvbkxheWVySXRlcmF0b3IoY29udGV4dCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIHRpbGVJbmRleCA9IGNvbnRleHQuY3VycmVudFRpbGUuaW5kZXg7XHJcbiAgICB2YXIgdGlsZSA9IGNvbnRleHQudGlsZXNbdGlsZUluZGV4XTtcclxuICAgIHZhciBsYXllcnNDb3VudCA9IHRpbGUuY29kaW5nU3R5bGVEZWZhdWx0UGFyYW1ldGVycy5sYXllcnNDb3VudDtcclxuICAgIHZhciBjb21wb25lbnRzQ291bnQgPSBzaXouQ3NpejtcclxuICAgIHZhciBwcmVjaW5jdHNTaXplcyA9IGdldFByZWNpbmN0U2l6ZXNJbkltYWdlU2NhbGUodGlsZSk7XHJcbiAgICB2YXIgbCA9IDAsIHIgPSAwLCBjID0gMCwgcHggPSAwLCBweSA9IDA7XHJcblxyXG4gICAgdGhpcy5uZXh0UGFja2V0ID0gZnVuY3Rpb24gSnB4SW1hZ2VfbmV4dFBhY2tldCgpIHtcclxuICAgICAgLy8gU2VjdGlvbiBCLjEyLjEuNSBDb21wb25lbnQtcG9zaXRpb24tcmVzb2x1dGlvbi1sYXllclxyXG4gICAgICBmb3IgKDsgYyA8IGNvbXBvbmVudHNDb3VudDsgKytjKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgICAgICB2YXIgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMgPSBwcmVjaW5jdHNTaXplcy5jb21wb25lbnRzW2NdO1xyXG4gICAgICAgIHZhciBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQgPVxyXG4gICAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XHJcbiAgICAgICAgZm9yICg7IHB5IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtSGlnaDsgcHkrKykge1xyXG4gICAgICAgICAgZm9yICg7IHB4IDwgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMubWF4TnVtV2lkZTsgcHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKDsgciA8PSBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xyXG4gICAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW3JdO1xyXG4gICAgICAgICAgICAgIHZhciBzaXplSW5JbWFnZVNjYWxlID0gcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMucmVzb2x1dGlvbnNbcl07XHJcbiAgICAgICAgICAgICAgdmFyIGsgPSBnZXRQcmVjaW5jdEluZGV4SWZFeGlzdChcclxuICAgICAgICAgICAgICAgIHB4LFxyXG4gICAgICAgICAgICAgICAgcHksXHJcbiAgICAgICAgICAgICAgICBzaXplSW5JbWFnZVNjYWxlLFxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RzSXRlcmF0aW9uU2l6ZXMsXHJcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgICBpZiAoayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgbGF5ZXJzQ291bnQ7KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFja2V0ID0gY3JlYXRlUGFja2V0KHJlc29sdXRpb24sIGssIGwpO1xyXG4gICAgICAgICAgICAgICAgbCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgciA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBweCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB5ID0gMDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0UHJlY2luY3RJbmRleElmRXhpc3QoXHJcbiAgICBweEluZGV4LCBweUluZGV4LCBzaXplSW5JbWFnZVNjYWxlLCBwcmVjaW5jdEl0ZXJhdGlvblNpemVzLCByZXNvbHV0aW9uKSB7XHJcbiAgICB2YXIgcG9zWCA9IHB4SW5kZXggKiBwcmVjaW5jdEl0ZXJhdGlvblNpemVzLm1pbldpZHRoO1xyXG4gICAgdmFyIHBvc1kgPSBweUluZGV4ICogcHJlY2luY3RJdGVyYXRpb25TaXplcy5taW5IZWlnaHQ7XHJcbiAgICBpZiAocG9zWCAlIHNpemVJbkltYWdlU2NhbGUud2lkdGggIT09IDAgfHxcclxuICAgICAgICBwb3NZICUgc2l6ZUluSW1hZ2VTY2FsZS5oZWlnaHQgIT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhcnRQcmVjaW5jdFJvd0luZGV4ID1cclxuICAgICAgKHBvc1kgLyBzaXplSW5JbWFnZVNjYWxlLndpZHRoKSAqXHJcbiAgICAgIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0c3dpZGU7XHJcbiAgICByZXR1cm4gKHBvc1ggLyBzaXplSW5JbWFnZVNjYWxlLmhlaWdodCkgKyBzdGFydFByZWNpbmN0Um93SW5kZXg7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldFByZWNpbmN0U2l6ZXNJbkltYWdlU2NhbGUodGlsZSkge1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHRpbGUuY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICB2YXIgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdmFyIG1pbkhlaWdodCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB2YXIgbWF4TnVtV2lkZSA9IDA7XHJcbiAgICB2YXIgbWF4TnVtSGlnaCA9IDA7XHJcbiAgICB2YXIgc2l6ZVBlckNvbXBvbmVudCA9IG5ldyBBcnJheShjb21wb25lbnRzQ291bnQpO1xyXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xyXG4gICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5jb21wb25lbnRzW2NdO1xyXG4gICAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cclxuICAgICAgICBjb21wb25lbnQuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcclxuICAgICAgdmFyIHNpemVQZXJSZXNvbHV0aW9uID0gbmV3IEFycmF5KGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCArIDEpO1xyXG4gICAgICB2YXIgbWluV2lkdGhDdXJyZW50Q29tcG9uZW50ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgdmFyIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICB2YXIgbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQgPSAwO1xyXG4gICAgICB2YXIgbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQgPSAwO1xyXG4gICAgICB2YXIgc2NhbGUgPSAxO1xyXG4gICAgICBmb3IgKHZhciByID0gZGVjb21wb3NpdGlvbkxldmVsc0NvdW50OyByID49IDA7IC0tcikge1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW3JdO1xyXG4gICAgICAgIHZhciB3aWR0aEN1cnJlbnRSZXNvbHV0aW9uID1cclxuICAgICAgICAgIHNjYWxlICogcmVzb2x1dGlvbi5wcmVjaW5jdFBhcmFtZXRlcnMucHJlY2luY3RXaWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0Q3VycmVudFJlc29sdXRpb24gPVxyXG4gICAgICAgICAgc2NhbGUgKiByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5wcmVjaW5jdEhlaWdodDtcclxuICAgICAgICBtaW5XaWR0aEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1pbihcclxuICAgICAgICAgIG1pbldpZHRoQ3VycmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHdpZHRoQ3VycmVudFJlc29sdXRpb24pO1xyXG4gICAgICAgIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1pbihcclxuICAgICAgICAgIG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICBoZWlnaHRDdXJyZW50UmVzb2x1dGlvbik7XHJcbiAgICAgICAgbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQgPSBNYXRoLm1heChtYXhOdW1XaWRlQ3VycmVudENvbXBvbmVudCxcclxuICAgICAgICAgIHJlc29sdXRpb24ucHJlY2luY3RQYXJhbWV0ZXJzLm51bXByZWNpbmN0c3dpZGUpO1xyXG4gICAgICAgIG1heE51bUhpZ2hDdXJyZW50Q29tcG9uZW50ID0gTWF0aC5tYXgobWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICByZXNvbHV0aW9uLnByZWNpbmN0UGFyYW1ldGVycy5udW1wcmVjaW5jdHNoaWdoKTtcclxuICAgICAgICBzaXplUGVyUmVzb2x1dGlvbltyXSA9IHtcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aEN1cnJlbnRSZXNvbHV0aW9uLFxyXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRDdXJyZW50UmVzb2x1dGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2NhbGUgPDw9IDE7XHJcbiAgICAgIH1cclxuICAgICAgbWluV2lkdGggPSBNYXRoLm1pbihtaW5XaWR0aCwgbWluV2lkdGhDdXJyZW50Q29tcG9uZW50KTtcclxuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5taW4obWluSGVpZ2h0LCBtaW5IZWlnaHRDdXJyZW50Q29tcG9uZW50KTtcclxuICAgICAgbWF4TnVtV2lkZSA9IE1hdGgubWF4KG1heE51bVdpZGUsIG1heE51bVdpZGVDdXJyZW50Q29tcG9uZW50KTtcclxuICAgICAgbWF4TnVtSGlnaCA9IE1hdGgubWF4KG1heE51bUhpZ2gsIG1heE51bUhpZ2hDdXJyZW50Q29tcG9uZW50KTtcclxuICAgICAgc2l6ZVBlckNvbXBvbmVudFtjXSA9IHtcclxuICAgICAgICByZXNvbHV0aW9uczogc2l6ZVBlclJlc29sdXRpb24sXHJcbiAgICAgICAgbWluV2lkdGg6IG1pbldpZHRoQ3VycmVudENvbXBvbmVudCxcclxuICAgICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodEN1cnJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgbWF4TnVtV2lkZTogbWF4TnVtV2lkZUN1cnJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgbWF4TnVtSGlnaDogbWF4TnVtSGlnaEN1cnJlbnRDb21wb25lbnRcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbXBvbmVudHM6IHNpemVQZXJDb21wb25lbnQsXHJcbiAgICAgIG1pbldpZHRoOiBtaW5XaWR0aCxcclxuICAgICAgbWluSGVpZ2h0OiBtaW5IZWlnaHQsXHJcbiAgICAgIG1heE51bVdpZGU6IG1heE51bVdpZGUsXHJcbiAgICAgIG1heE51bUhpZ2g6IG1heE51bUhpZ2hcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJ1aWxkUGFja2V0cyhjb250ZXh0KSB7XHJcbiAgICB2YXIgc2l6ID0gY29udGV4dC5TSVo7XHJcbiAgICB2YXIgdGlsZUluZGV4ID0gY29udGV4dC5jdXJyZW50VGlsZS5pbmRleDtcclxuICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1t0aWxlSW5kZXhdO1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgLy8gQ3JlYXRpbmcgcmVzb2x1dGlvbnMgYW5kIHN1Yi1iYW5kcyBmb3IgZWFjaCBjb21wb25lbnRcclxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29tcG9uZW50c0NvdW50OyBjKyspIHtcclxuICAgICAgdmFyIGNvbXBvbmVudCA9IHRpbGUuY29tcG9uZW50c1tjXTtcclxuICAgICAgdmFyIGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCA9XHJcbiAgICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycy5kZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7XHJcbiAgICAgIC8vIFNlY3Rpb24gQi41IFJlc29sdXRpb24gbGV2ZWxzIGFuZCBzdWItYmFuZHNcclxuICAgICAgdmFyIHJlc29sdXRpb25zID0gW107XHJcbiAgICAgIHZhciBzdWJiYW5kcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8PSBkZWNvbXBvc2l0aW9uTGV2ZWxzQ291bnQ7IHIrKykge1xyXG4gICAgICAgIHZhciBibG9ja3NEaW1lbnNpb25zID0gZ2V0QmxvY2tzRGltZW5zaW9ucyhjb250ZXh0LCBjb21wb25lbnQsIHIpO1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0ge307XHJcbiAgICAgICAgdmFyIHNjYWxlID0gMSA8PCAoZGVjb21wb3NpdGlvbkxldmVsc0NvdW50IC0gcik7XHJcbiAgICAgICAgcmVzb2x1dGlvbi50cngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gc2NhbGUpO1xyXG4gICAgICAgIHJlc29sdXRpb24udHJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIHNjYWxlKTtcclxuICAgICAgICByZXNvbHV0aW9uLnRyeDEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDEgLyBzY2FsZSk7XHJcbiAgICAgICAgcmVzb2x1dGlvbi50cnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gc2NhbGUpO1xyXG4gICAgICAgIHJlc29sdXRpb24ucmVzTGV2ZWwgPSByO1xyXG4gICAgICAgIGJ1aWxkUHJlY2luY3RzKGNvbnRleHQsIHJlc29sdXRpb24sIGJsb2Nrc0RpbWVuc2lvbnMpO1xyXG4gICAgICAgIHJlc29sdXRpb25zLnB1c2gocmVzb2x1dGlvbik7XHJcblxyXG4gICAgICAgIHZhciBzdWJiYW5kO1xyXG4gICAgICAgIGlmIChyID09PSAwKSB7XHJcbiAgICAgICAgICAvLyBvbmUgc3ViLWJhbmQgKExMKSB3aXRoIGxhc3QgZGVjb21wb3NpdGlvblxyXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xyXG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0xMJztcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MCAvIHNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIHNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIHNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MSAvIHNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XHJcbiAgICAgICAgICBidWlsZENvZGVibG9ja3MoY29udGV4dCwgc3ViYmFuZCwgYmxvY2tzRGltZW5zaW9ucyk7XHJcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xyXG4gICAgICAgICAgcmVzb2x1dGlvbi5zdWJiYW5kcyA9IFtzdWJiYW5kXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGJzY2FsZSA9IDEgPDwgKGRlY29tcG9zaXRpb25MZXZlbHNDb3VudCAtIHIgKyAxKTtcclxuICAgICAgICAgIHZhciByZXNvbHV0aW9uU3ViYmFuZHMgPSBbXTtcclxuICAgICAgICAgIC8vIHRocmVlIHN1Yi1iYW5kcyAoSEwsIExIIGFuZCBISCkgd2l0aCByZXN0IG9mIGRlY29tcG9zaXRpb25zXHJcbiAgICAgICAgICBzdWJiYW5kID0ge307XHJcbiAgICAgICAgICBzdWJiYW5kLnR5cGUgPSAnSEwnO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gwIC8gYnNjYWxlIC0gMC41KTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MCAvIGJzY2FsZSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieDEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDEgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kxIC8gYnNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XHJcbiAgICAgICAgICBidWlsZENvZGVibG9ja3MoY29udGV4dCwgc3ViYmFuZCwgYmxvY2tzRGltZW5zaW9ucyk7XHJcbiAgICAgICAgICBzdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xyXG4gICAgICAgICAgcmVzb2x1dGlvblN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XHJcblxyXG4gICAgICAgICAgc3ViYmFuZCA9IHt9O1xyXG4gICAgICAgICAgc3ViYmFuZC50eXBlID0gJ0xIJztcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MCA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MCAvIGJzY2FsZSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieTAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTAgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YngxID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3gxIC8gYnNjYWxlKTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ5MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN5MSAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgYnVpbGRDb2RlYmxvY2tzKGNvbnRleHQsIHN1YmJhbmQsIGJsb2Nrc0RpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgc3ViYmFuZHMucHVzaChzdWJiYW5kKTtcclxuICAgICAgICAgIHJlc29sdXRpb25TdWJiYW5kcy5wdXNoKHN1YmJhbmQpO1xyXG5cclxuICAgICAgICAgIHN1YmJhbmQgPSB7fTtcclxuICAgICAgICAgIHN1YmJhbmQudHlwZSA9ICdISCc7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieDAgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeDAgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC50YnkwID0gTWF0aC5jZWlsKGNvbXBvbmVudC50Y3kwIC8gYnNjYWxlIC0gMC41KTtcclxuICAgICAgICAgIHN1YmJhbmQudGJ4MSA9IE1hdGguY2VpbChjb21wb25lbnQudGN4MSAvIGJzY2FsZSAtIDAuNSk7XHJcbiAgICAgICAgICBzdWJiYW5kLnRieTEgPSBNYXRoLmNlaWwoY29tcG9uZW50LnRjeTEgLyBic2NhbGUgLSAwLjUpO1xyXG4gICAgICAgICAgc3ViYmFuZC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICAgIGJ1aWxkQ29kZWJsb2Nrcyhjb250ZXh0LCBzdWJiYW5kLCBibG9ja3NEaW1lbnNpb25zKTtcclxuICAgICAgICAgIHN1YmJhbmRzLnB1c2goc3ViYmFuZCk7XHJcbiAgICAgICAgICByZXNvbHV0aW9uU3ViYmFuZHMucHVzaChzdWJiYW5kKTtcclxuXHJcbiAgICAgICAgICByZXNvbHV0aW9uLnN1YmJhbmRzID0gcmVzb2x1dGlvblN1YmJhbmRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb21wb25lbnQucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9ucztcclxuICAgICAgY29tcG9uZW50LnN1YmJhbmRzID0gc3ViYmFuZHM7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcGFja2V0cyBzZXF1ZW5jZVxyXG4gICAgdmFyIHByb2dyZXNzaW9uT3JkZXIgPSB0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMucHJvZ3Jlc3Npb25PcmRlcjtcclxuICAgIHN3aXRjaCAocHJvZ3Jlc3Npb25PcmRlcikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgdGlsZS5wYWNrZXRzSXRlcmF0b3IgPVxyXG4gICAgICAgICAgbmV3IExheWVyUmVzb2x1dGlvbkNvbXBvbmVudFBvc2l0aW9uSXRlcmF0b3IoY29udGV4dCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XHJcbiAgICAgICAgICBuZXcgUmVzb2x1dGlvbkxheWVyQ29tcG9uZW50UG9zaXRpb25JdGVyYXRvcihjb250ZXh0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHRpbGUucGFja2V0c0l0ZXJhdG9yID1cclxuICAgICAgICAgIG5ldyBSZXNvbHV0aW9uUG9zaXRpb25Db21wb25lbnRMYXllckl0ZXJhdG9yKGNvbnRleHQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgdGlsZS5wYWNrZXRzSXRlcmF0b3IgPVxyXG4gICAgICAgICAgbmV3IFBvc2l0aW9uQ29tcG9uZW50UmVzb2x1dGlvbkxheWVySXRlcmF0b3IoY29udGV4dCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICB0aWxlLnBhY2tldHNJdGVyYXRvciA9XHJcbiAgICAgICAgICBuZXcgQ29tcG9uZW50UG9zaXRpb25SZXNvbHV0aW9uTGF5ZXJJdGVyYXRvcihjb250ZXh0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pQWCBFcnJvcjogVW5zdXBwb3J0ZWQgcHJvZ3Jlc3Npb24gb3JkZXIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVRpbGVQYWNrZXRzKGNvbnRleHQsIGRhdGEsIG9mZnNldCwgZGF0YUxlbmd0aCkge1xyXG4gICAgdmFyIHBvc2l0aW9uID0gMDtcclxuICAgIHZhciBidWZmZXIsIGJ1ZmZlclNpemUgPSAwLCBza2lwTmV4dEJpdCA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gcmVhZEJpdHMoY291bnQpIHtcclxuICAgICAgd2hpbGUgKGJ1ZmZlclNpemUgPCBjb3VudCkge1xyXG4gICAgICAgIGlmKG9mZnNldCArIHBvc2l0aW9uICA+PSBkYXRhLmxlbmd0aCl7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIEVPRlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIHBvc2l0aW9uXTtcclxuICAgICAgICBwb3NpdGlvbisrO1xyXG4gICAgICAgIGlmIChza2lwTmV4dEJpdCkge1xyXG4gICAgICAgICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA3KSB8IGI7XHJcbiAgICAgICAgICBidWZmZXJTaXplICs9IDc7XHJcbiAgICAgICAgICBza2lwTmV4dEJpdCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgYjtcclxuICAgICAgICAgIGJ1ZmZlclNpemUgKz0gODtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT09IDB4RkYpIHtcclxuICAgICAgICAgIHNraXBOZXh0Qml0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnVmZmVyU2l6ZSAtPSBjb3VudDtcclxuICAgICAgcmV0dXJuIChidWZmZXIgPj4+IGJ1ZmZlclNpemUpICYgKCgxIDw8IGNvdW50KSAtIDEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2tpcE1hcmtlcklmRXF1YWwodmFsdWUpIHtcclxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgcG9zaXRpb24gLSAxXSA9PT0gMHhGRiAmJlxyXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyBwb3NpdGlvbl0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgc2tpcEJ5dGVzKDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGFbb2Zmc2V0ICsgcG9zaXRpb25dID09PSAweEZGICYmXHJcbiAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyBwb3NpdGlvbiArIDFdID09PSB2YWx1ZSkge1xyXG4gICAgICAgIHNraXBCeXRlcygyKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBza2lwQnl0ZXMoY291bnQpIHtcclxuICAgICAgcG9zaXRpb24gKz0gY291bnQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhbGlnblRvQnl0ZSgpIHtcclxuICAgICAgYnVmZmVyU2l6ZSA9IDA7XHJcbiAgICAgIGlmIChza2lwTmV4dEJpdCkge1xyXG4gICAgICAgIHBvc2l0aW9uKys7XHJcbiAgICAgICAgc2tpcE5leHRCaXQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVhZENvZGluZ3Bhc3NlcygpIHtcclxuICAgICAgaWYgKHJlYWRCaXRzKDEpID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlYWRCaXRzKDEpID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHZhbHVlID0gcmVhZEJpdHMoMik7XHJcbiAgICAgIGlmICh2YWx1ZSA8IDMpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgKyAzO1xyXG4gICAgICB9XHJcbiAgICAgIHZhbHVlID0gcmVhZEJpdHMoNSk7XHJcbiAgICAgIGlmICh2YWx1ZSA8IDMxKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICsgNjtcclxuICAgICAgfVxyXG4gICAgICB2YWx1ZSA9IHJlYWRCaXRzKDcpO1xyXG4gICAgICByZXR1cm4gdmFsdWUgKyAzNztcclxuICAgIH1cclxuICAgIHZhciB0aWxlSW5kZXggPSBjb250ZXh0LmN1cnJlbnRUaWxlLmluZGV4O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICB2YXIgc29wTWFya2VyVXNlZCA9IGNvbnRleHQuQ09ELnNvcE1hcmtlclVzZWQ7XHJcbiAgICB2YXIgZXBoTWFya2VyVXNlZCA9IGNvbnRleHQuQ09ELmVwaE1hcmtlclVzZWQ7XHJcbiAgICB2YXIgcGFja2V0c0l0ZXJhdG9yID0gdGlsZS5wYWNrZXRzSXRlcmF0b3I7XHJcbiAgICB3aGlsZSAocG9zaXRpb24gPCBkYXRhTGVuZ3RoKSB7XHJcbiAgICAgIHRyeXtcclxuICAgICAgICBhbGlnblRvQnl0ZSgpO1xyXG4gICAgICAgIGlmIChzb3BNYXJrZXJVc2VkICYmIHNraXBNYXJrZXJJZkVxdWFsKDB4OTEpKSB7XHJcbiAgICAgICAgICAvLyBTa2lwIGFsc28gbWFya2VyIHNlZ21lbnQgbGVuZ3RoIGFuZCBwYWNrZXQgc2VxdWVuY2UgSURcclxuICAgICAgICAgIHNraXBCeXRlcyg0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhY2tldCA9IHBhY2tldHNJdGVyYXRvci5uZXh0UGFja2V0KCk7XHJcbiAgICAgICAgaWYgKHBhY2tldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAvL05vIG1vcmUgcGFja2V0cy4gU3RyZWFtIGlzIHByb2JhYmx5IHRydW5jYXRlZC5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWFkQml0cygxKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsYXllck51bWJlciA9IHBhY2tldC5sYXllck51bWJlcjtcclxuICAgICAgICB2YXIgcXVldWUgPSBbXSwgY29kZWJsb2NrO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhY2tldC5jb2RlYmxvY2tzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIGNvZGVibG9jayA9IHBhY2tldC5jb2RlYmxvY2tzW2ldO1xyXG4gICAgICAgICAgdmFyIHByZWNpbmN0ID0gY29kZWJsb2NrLnByZWNpbmN0O1xyXG4gICAgICAgICAgdmFyIGNvZGVibG9ja0NvbHVtbiA9IGNvZGVibG9jay5jYnggLSBwcmVjaW5jdC5jYnhNaW47XHJcbiAgICAgICAgICB2YXIgY29kZWJsb2NrUm93ID0gY29kZWJsb2NrLmNieSAtIHByZWNpbmN0LmNieU1pbjtcclxuICAgICAgICAgIHZhciBjb2RlYmxvY2tJbmNsdWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIGZpcnN0VGltZUluY2x1c2lvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIHZhbHVlUmVhZHk7XHJcbiAgICAgICAgICBpZiAoY29kZWJsb2NrWydpbmNsdWRlZCddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29kZWJsb2NrSW5jbHVkZWQgPSAhIXJlYWRCaXRzKDEpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVhZGluZyBpbmNsdXNpb24gdHJlZVxyXG4gICAgICAgICAgICBwcmVjaW5jdCA9IGNvZGVibG9jay5wcmVjaW5jdDtcclxuICAgICAgICAgICAgdmFyIGluY2x1c2lvblRyZWUsIHplcm9CaXRQbGFuZXNUcmVlO1xyXG4gICAgICAgICAgICBpZiAocHJlY2luY3RbJ2luY2x1c2lvblRyZWUnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZSA9IHByZWNpbmN0LmluY2x1c2lvblRyZWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gYnVpbGRpbmcgaW5jbHVzaW9uIGFuZCB6ZXJvIGJpdC1wbGFuZXMgdHJlZXNcclxuICAgICAgICAgICAgICB2YXIgd2lkdGggPSBwcmVjaW5jdC5jYnhNYXggLSBwcmVjaW5jdC5jYnhNaW4gKyAxO1xyXG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwcmVjaW5jdC5jYnlNYXggLSBwcmVjaW5jdC5jYnlNaW4gKyAxO1xyXG4gICAgICAgICAgICAgIGluY2x1c2lvblRyZWUgPSBuZXcgSW5jbHVzaW9uVHJlZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICB6ZXJvQml0UGxhbmVzVHJlZSA9IG5ldyBUYWdUcmVlKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgIHByZWNpbmN0LmluY2x1c2lvblRyZWUgPSBpbmNsdXNpb25UcmVlO1xyXG4gICAgICAgICAgICAgIHByZWNpbmN0Lnplcm9CaXRQbGFuZXNUcmVlID0gemVyb0JpdFBsYW5lc1RyZWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGluY2x1c2lvblRyZWUucmVzZXQoY29kZWJsb2NrQ29sdW1uLCBjb2RlYmxvY2tSb3csIGxheWVyTnVtYmVyKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGluY2x1c2lvblRyZWUuaXNBYm92ZVRocmVzaG9sZCgpKXtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0tub3duKCkpIHtcclxuICAgICAgICAgICAgICAgIGluY2x1c2lvblRyZWUubmV4dExldmVsKCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHJlYWRCaXRzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmNsdXNpb25UcmVlLnNldEtub3duKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uVHJlZS5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICBjb2RlYmxvY2suaW5jbHVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBjb2RlYmxvY2tJbmNsdWRlZCA9IGZpcnN0VGltZUluY2x1c2lvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZS5uZXh0TGV2ZWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5jbHVzaW9uVHJlZS5pbmNyZW1lbnRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb2RlYmxvY2tJbmNsdWRlZCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChmaXJzdFRpbWVJbmNsdXNpb24pIHtcclxuICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUgPSBwcmVjaW5jdC56ZXJvQml0UGxhbmVzVHJlZTtcclxuICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUucmVzZXQoY29kZWJsb2NrQ29sdW1uLCBjb2RlYmxvY2tSb3cpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAocmVhZEJpdHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlUmVhZHkgPSAhemVyb0JpdFBsYW5lc1RyZWUubmV4dExldmVsKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgemVyb0JpdFBsYW5lc1RyZWUuaW5jcmVtZW50VmFsdWUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29kZWJsb2NrLnplcm9CaXRQbGFuZXMgPSB6ZXJvQml0UGxhbmVzVHJlZS52YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBjb2RpbmdwYXNzZXMgPSByZWFkQ29kaW5ncGFzc2VzKCk7XHJcbiAgICAgICAgICB3aGlsZSAocmVhZEJpdHMoMSkpIHtcclxuICAgICAgICAgICAgY29kZWJsb2NrLkxibG9jaysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGNvZGluZ3Bhc3Nlc0xvZzIgPSBsb2cyKGNvZGluZ3Bhc3Nlcyk7XHJcbiAgICAgICAgICAvLyByb3VuZGluZyBkb3duIGxvZzJcclxuICAgICAgICAgIHZhciBiaXRzID0gKChjb2RpbmdwYXNzZXMgPCAoMSA8PCBjb2RpbmdwYXNzZXNMb2cyKSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29kaW5ncGFzc2VzTG9nMiAtIDEgOiBjb2RpbmdwYXNzZXNMb2cyKSArIGNvZGVibG9jay5MYmxvY2s7XHJcbiAgICAgICAgICB2YXIgY29kZWREYXRhTGVuZ3RoID0gcmVhZEJpdHMoYml0cyk7XHJcbiAgICAgICAgICBxdWV1ZS5wdXNoKHtcclxuICAgICAgICAgICAgY29kZWJsb2NrOiBjb2RlYmxvY2ssXHJcbiAgICAgICAgICAgIGNvZGluZ3Bhc3NlczogY29kaW5ncGFzc2VzLFxyXG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiBjb2RlZERhdGFMZW5ndGhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbGlnblRvQnl0ZSgpO1xyXG4gICAgICAgIGlmIChlcGhNYXJrZXJVc2VkKSB7XHJcbiAgICAgICAgICBza2lwTWFya2VySWZFcXVhbCgweDkyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhciBwYWNrZXRJdGVtID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgIGNvZGVibG9jayA9IHBhY2tldEl0ZW0uY29kZWJsb2NrO1xyXG4gICAgICAgICAgaWYgKGNvZGVibG9ja1snZGF0YSddID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29kZWJsb2NrLmRhdGEgPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvZGVibG9jay5kYXRhLnB1c2goe1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBzdGFydDogb2Zmc2V0ICsgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgcG9zaXRpb24gKyBwYWNrZXRJdGVtLmRhdGFMZW5ndGgsXHJcbiAgICAgICAgICAgIGNvZGluZ3Bhc3NlczogcGFja2V0SXRlbS5jb2RpbmdwYXNzZXNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcG9zaXRpb24gKz0gcGFja2V0SXRlbS5kYXRhTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb3B5Q29lZmZpY2llbnRzKGNvZWZmaWNpZW50cywgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIHN1YmJhbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSwgbWIsIHJldmVyc2libGUsIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQpIHtcclxuICAgIHZhciB4MCA9IHN1YmJhbmQudGJ4MDtcclxuICAgIHZhciB5MCA9IHN1YmJhbmQudGJ5MDtcclxuICAgIHZhciB3aWR0aCA9IHN1YmJhbmQudGJ4MSAtIHN1YmJhbmQudGJ4MDtcclxuICAgIHZhciBjb2RlYmxvY2tzID0gc3ViYmFuZC5jb2RlYmxvY2tzO1xyXG4gICAgdmFyIHJpZ2h0ID0gc3ViYmFuZC50eXBlLmNoYXJBdCgwKSA9PT0gJ0gnID8gMSA6IDA7XHJcbiAgICB2YXIgYm90dG9tID0gc3ViYmFuZC50eXBlLmNoYXJBdCgxKSA9PT0gJ0gnID8gbGV2ZWxXaWR0aCA6IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29kZWJsb2Nrcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XHJcbiAgICAgIHZhciBjb2RlYmxvY2sgPSBjb2RlYmxvY2tzW2ldO1xyXG4gICAgICB2YXIgYmxvY2tXaWR0aCA9IGNvZGVibG9jay50YngxXyAtIGNvZGVibG9jay50YngwXztcclxuICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gY29kZWJsb2NrLnRieTFfIC0gY29kZWJsb2NrLnRieTBfO1xyXG4gICAgICBpZiAoYmxvY2tXaWR0aCA9PT0gMCB8fCBibG9ja0hlaWdodCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb2RlYmxvY2tbJ2RhdGEnXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBiaXRNb2RlbCwgY3VycmVudENvZGluZ3Bhc3NUeXBlO1xyXG4gICAgICBiaXRNb2RlbCA9IG5ldyBCaXRNb2RlbChibG9ja1dpZHRoLCBibG9ja0hlaWdodCwgY29kZWJsb2NrLnN1YmJhbmRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlYmxvY2suemVyb0JpdFBsYW5lcywgbWIpO1xyXG4gICAgICBjdXJyZW50Q29kaW5ncGFzc1R5cGUgPSAyOyAvLyBmaXJzdCBiaXQgcGxhbmUgc3RhcnRzIGZyb20gY2xlYW51cFxyXG5cclxuICAgICAgLy8gY29sbGVjdCBkYXRhXHJcbiAgICAgIHZhciBkYXRhID0gY29kZWJsb2NrLmRhdGEsIHRvdGFsTGVuZ3RoID0gMCwgY29kaW5ncGFzc2VzID0gMDtcclxuICAgICAgdmFyIGosIGpqLCBkYXRhSXRlbTtcclxuICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICBkYXRhSXRlbSA9IGRhdGFbal07XHJcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUl0ZW0uZW5kIC0gZGF0YUl0ZW0uc3RhcnQ7XHJcbiAgICAgICAgY29kaW5ncGFzc2VzICs9IGRhdGFJdGVtLmNvZGluZ3Bhc3NlcztcclxuICAgICAgfVxyXG4gICAgICB2YXIgZW5jb2RlZERhdGEgPSBuZXcgSW50MTZBcnJheSh0b3RhbExlbmd0aCk7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XHJcbiAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YS5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgZGF0YUl0ZW0gPSBkYXRhW2pdO1xyXG4gICAgICAgIHZhciBjaHVuayA9IGRhdGFJdGVtLmRhdGEuc3ViYXJyYXkoZGF0YUl0ZW0uc3RhcnQsIGRhdGFJdGVtLmVuZCk7XHJcbiAgICAgICAgZW5jb2RlZERhdGEuc2V0KGNodW5rLCBwb3NpdGlvbik7XHJcbiAgICAgICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGRlY29kaW5nIHRoZSBpdGVtXHJcbiAgICAgIHZhciBkZWNvZGVyID0gbmV3IEFyaXRobWV0aWNEZWNvZGVyKGVuY29kZWREYXRhLCAwLCB0b3RhbExlbmd0aCk7XHJcbiAgICAgIGJpdE1vZGVsLnNldERlY29kZXIoZGVjb2Rlcik7XHJcblxyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgY29kaW5ncGFzc2VzOyBqKyspIHtcclxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDb2RpbmdwYXNzVHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICBiaXRNb2RlbC5ydW5TaWduaWZpY2FuY2VQcm9wb2dhdGlvblBhc3MoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIGJpdE1vZGVsLnJ1bk1hZ25pdHVkZVJlZmluZW1lbnRQYXNzKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBiaXRNb2RlbC5ydW5DbGVhbnVwUGFzcygpO1xyXG4gICAgICAgICAgICBpZiAoc2VnbWVudGF0aW9uU3ltYm9sVXNlZCkge1xyXG4gICAgICAgICAgICAgIGJpdE1vZGVsLmNoZWNrU2VnbWVudGF0aW9uU3ltYm9sKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRDb2RpbmdwYXNzVHlwZSA9IChjdXJyZW50Q29kaW5ncGFzc1R5cGUgKyAxKSAlIDM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvZmZzZXQgPSAoY29kZWJsb2NrLnRieDBfIC0geDApICsgKGNvZGVibG9jay50YnkwXyAtIHkwKSAqIHdpZHRoO1xyXG4gICAgICB2YXIgc2lnbiA9IGJpdE1vZGVsLmNvZWZmaWNlbnRzU2lnbjtcclxuICAgICAgdmFyIG1hZ25pdHVkZSA9IGJpdE1vZGVsLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xyXG4gICAgICB2YXIgYml0c0RlY29kZWQgPSBiaXRNb2RlbC5iaXRzRGVjb2RlZDtcclxuICAgICAgdmFyIG1hZ25pdHVkZUNvcnJlY3Rpb24gPSByZXZlcnNpYmxlID8gMCA6IDAuNTtcclxuICAgICAgdmFyIGssIG4sIG5iO1xyXG4gICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgIC8vIERvIHRoZSBpbnRlcmxlYXZpbmcgb2YgU2VjdGlvbiBGLjMuMyBoZXJlLCBzbyB3ZSBkbyBub3QgbmVlZFxyXG4gICAgICAvLyB0byBjb3B5IGxhdGVyLiBMTCBsZXZlbCBpcyBub3QgaW50ZXJsZWF2ZWQsIGp1c3QgY29waWVkLlxyXG4gICAgICB2YXIgaW50ZXJsZWF2ZSA9IChzdWJiYW5kLnR5cGUgIT09ICdMTCcpO1xyXG4gICAgICBmb3IgKGogPSAwOyBqIDwgYmxvY2tIZWlnaHQ7IGorKykge1xyXG4gICAgICAgIHZhciByb3cgPSAob2Zmc2V0IC8gd2lkdGgpIHwgMDsgLy8gcm93IGluIHRoZSBub24taW50ZXJsZWF2ZWQgc3ViYmFuZFxyXG4gICAgICAgIHZhciBsZXZlbE9mZnNldCA9IDIgKiByb3cgKiAobGV2ZWxXaWR0aCAtIHdpZHRoKSArIHJpZ2h0ICsgYm90dG9tO1xyXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBibG9ja1dpZHRoOyBrKyspIHtcclxuICAgICAgICAgIG4gPSBtYWduaXR1ZGVbcG9zaXRpb25dO1xyXG4gICAgICAgICAgaWYgKG4gIT09IDApIHtcclxuICAgICAgICAgICAgbiA9IChuICsgbWFnbml0dWRlQ29ycmVjdGlvbikgKiBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHNpZ25bcG9zaXRpb25dICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgbiA9IC1uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5iID0gYml0c0RlY29kZWRbcG9zaXRpb25dO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gaW50ZXJsZWF2ZSA/IChsZXZlbE9mZnNldCArIChvZmZzZXQgPDwgMSkpIDogb2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAocmV2ZXJzaWJsZSAmJiAobmIgPj0gbWIpKSB7XHJcbiAgICAgICAgICAgICAgY29lZmZpY2llbnRzW3Bvc10gPSBuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvZWZmaWNpZW50c1twb3NdID0gbiAqICgxIDw8IChtYiAtIG5iKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgcG9zaXRpb24rKztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IHdpZHRoIC0gYmxvY2tXaWR0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB0cmFuc2Zvcm1UaWxlKGNvbnRleHQsIHRpbGUsIGMpIHtcclxuICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XHJcbiAgICB2YXIgY29kaW5nU3R5bGVQYXJhbWV0ZXJzID0gY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycztcclxuICAgIHZhciBxdWFudGl6YXRpb25QYXJhbWV0ZXJzID0gY29tcG9uZW50LnF1YW50aXphdGlvblBhcmFtZXRlcnM7XHJcbiAgICB2YXIgZGVjb21wb3NpdGlvbkxldmVsc0NvdW50ID1cclxuICAgICAgY29kaW5nU3R5bGVQYXJhbWV0ZXJzLmRlY29tcG9zaXRpb25MZXZlbHNDb3VudDtcclxuICAgIHZhciBzcHFjZHMgPSBxdWFudGl6YXRpb25QYXJhbWV0ZXJzLlNQcWNkcztcclxuICAgIHZhciBzY2FsYXJFeHBvdW5kZWQgPSBxdWFudGl6YXRpb25QYXJhbWV0ZXJzLnNjYWxhckV4cG91bmRlZDtcclxuICAgIHZhciBndWFyZEJpdHMgPSBxdWFudGl6YXRpb25QYXJhbWV0ZXJzLmd1YXJkQml0cztcclxuICAgIHZhciBzZWdtZW50YXRpb25TeW1ib2xVc2VkID0gY29kaW5nU3R5bGVQYXJhbWV0ZXJzLnNlZ21lbnRhdGlvblN5bWJvbFVzZWQ7XHJcbiAgICB2YXIgcHJlY2lzaW9uID0gY29udGV4dC5jb21wb25lbnRzW2NdLnByZWNpc2lvbjtcclxuXHJcbiAgICB2YXIgcmV2ZXJzaWJsZSA9IGNvZGluZ1N0eWxlUGFyYW1ldGVycy5yZXZlcnNpYmxlVHJhbnNmb3JtYXRpb247XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gKHJldmVyc2libGUgPyBuZXcgUmV2ZXJzaWJsZVRyYW5zZm9ybSgpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJcnJldmVyc2libGVUcmFuc2Zvcm0oKSk7XHJcblxyXG4gICAgdmFyIHN1YmJhbmRDb2VmZmljaWVudHMgPSBbXTtcclxuICAgIHZhciBiID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRlY29tcG9zaXRpb25MZXZlbHNDb3VudDsgaSsrKSB7XHJcbiAgICAgIHZhciByZXNvbHV0aW9uID0gY29tcG9uZW50LnJlc29sdXRpb25zW2ldO1xyXG5cclxuICAgICAgdmFyIHdpZHRoID0gcmVzb2x1dGlvbi50cngxIC0gcmVzb2x1dGlvbi50cngwO1xyXG4gICAgICB2YXIgaGVpZ2h0ID0gcmVzb2x1dGlvbi50cnkxIC0gcmVzb2x1dGlvbi50cnkwO1xyXG4gICAgICAvLyBBbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdob2xlIHN1YmxldmVsLlxyXG4gICAgICB2YXIgY29lZmZpY2llbnRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSByZXNvbHV0aW9uLnN1YmJhbmRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICB2YXIgbXUsIGVwc2lsb247XHJcbiAgICAgICAgaWYgKCFzY2FsYXJFeHBvdW5kZWQpIHtcclxuICAgICAgICAgIC8vIGZvcm11bGEgRS01XHJcbiAgICAgICAgICBtdSA9IHNwcWNkc1swXS5tdTtcclxuICAgICAgICAgIGVwc2lsb24gPSBzcHFjZHNbMF0uZXBzaWxvbiArIChpID4gMCA/IDEgLSBpIDogMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG11ID0gc3BxY2RzW2JdLm11O1xyXG4gICAgICAgICAgZXBzaWxvbiA9IHNwcWNkc1tiXS5lcHNpbG9uO1xyXG4gICAgICAgICAgYisrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN1YmJhbmQgPSByZXNvbHV0aW9uLnN1YmJhbmRzW2pdO1xyXG4gICAgICAgIHZhciBnYWluTG9nMiA9IFN1YmJhbmRzR2FpbkxvZzJbc3ViYmFuZC50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gY2FsdWxhdGUgcXVhbnRpemF0aW9uIGNvZWZmaWNpZW50IChTZWN0aW9uIEUuMS4xLjEpXHJcbiAgICAgICAgdmFyIGRlbHRhID0gKHJldmVyc2libGUgPyAxIDpcclxuICAgICAgICAgIE1hdGgucG93KDIsIHByZWNpc2lvbiArIGdhaW5Mb2cyIC0gZXBzaWxvbikgKiAoMSArIG11IC8gMjA0OCkpO1xyXG4gICAgICAgIHZhciBtYiA9IChndWFyZEJpdHMgKyBlcHNpbG9uIC0gMSk7XHJcblxyXG4gICAgICAgIC8vIEluIHRoZSBmaXJzdCByZXNvbHV0aW9uIGxldmVsLCBjb3B5Q29lZmZpY2llbnRzIHdpbGwgZmlsbCB0aGVcclxuICAgICAgICAvLyB3aG9sZSBhcnJheSB3aXRoIGNvZWZmaWNpZW50cy4gSW4gdGhlIHN1Y2NlZGluZyBwYXNzZXMsXHJcbiAgICAgICAgLy8gY29weUNvZWZmaWNpZW50cyB3aWxsIGNvbnNlY3V0aXZlbHkgZmlsbCBpbiB0aGUgdmFsdWVzIHRoYXQgYmVsb25nXHJcbiAgICAgICAgLy8gdG8gdGhlIGludGVybGVhdmVkIHBvc2l0aW9ucyBvZiB0aGUgSEwsIExILCBhbmQgSEggY29lZmZpY2llbnRzLlxyXG4gICAgICAgIC8vIFRoZSBMTCBjb2VmZmljaWVudHMgd2lsbCB0aGVuIGJlIGludGVybGVhdmVkIGluIFRyYW5zZm9ybS5pdGVyYXRlKCkuXHJcbiAgICAgICAgY29weUNvZWZmaWNpZW50cyhjb2VmZmljaWVudHMsIHdpZHRoLCBoZWlnaHQsIHN1YmJhbmQsIGRlbHRhLCBtYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2libGUsIHNlZ21lbnRhdGlvblN5bWJvbFVzZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHN1YmJhbmRDb2VmZmljaWVudHMucHVzaCh7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGl0ZW1zOiBjb2VmZmljaWVudHNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybS5jYWxjdWxhdGUoc3ViYmFuZENvZWZmaWNpZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC50Y3gwLCBjb21wb25lbnQudGN5MCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZWZ0OiBjb21wb25lbnQudGN4MCxcclxuICAgICAgdG9wOiBjb21wb25lbnQudGN5MCxcclxuICAgICAgd2lkdGg6IHJlc3VsdC53aWR0aCxcclxuICAgICAgaGVpZ2h0OiByZXN1bHQuaGVpZ2h0LFxyXG4gICAgICBpdGVtczogcmVzdWx0Lml0ZW1zXHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Db21wb25lbnRzKGNvbnRleHQpIHtcclxuICAgIHZhciBzaXogPSBjb250ZXh0LlNJWjtcclxuICAgIHZhciBjb21wb25lbnRzID0gY29udGV4dC5jb21wb25lbnRzO1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgdmFyIHJlc3VsdEltYWdlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29udGV4dC50aWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgIHZhciB0aWxlID0gY29udGV4dC50aWxlc1tpXTtcclxuICAgICAgdmFyIHRyYW5zZm9ybWVkVGlsZXMgPSBbXTtcclxuICAgICAgdmFyIGM7XHJcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBjb21wb25lbnRzQ291bnQ7IGMrKykge1xyXG4gICAgICAgIHRyYW5zZm9ybWVkVGlsZXNbY10gPSB0cmFuc2Zvcm1UaWxlKGNvbnRleHQsIHRpbGUsIGMpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0aWxlMCA9IHRyYW5zZm9ybWVkVGlsZXNbMF07XHJcbiAgICAgIHZhciBpc1NpZ25lZCA9IGNvbXBvbmVudHNbMF0uaXNTaWduZWQ7XHJcbiAgICAgIGlmIChpc1NpZ25lZCkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgSW50MTZBcnJheSh0aWxlMC5pdGVtcy5sZW5ndGggKiBjb21wb25lbnRzQ291bnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDE2QXJyYXkodGlsZTAuaXRlbXMubGVuZ3RoICogY29tcG9uZW50c0NvdW50KTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgIGxlZnQ6IHRpbGUwLmxlZnQsXHJcbiAgICAgICAgdG9wOiB0aWxlMC50b3AsXHJcbiAgICAgICAgd2lkdGg6IHRpbGUwLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogdGlsZTAuaGVpZ2h0LFxyXG4gICAgICAgIGl0ZW1zOiBvdXRcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFNlY3Rpb24gRy4yLjIgSW52ZXJzZSBtdWx0aSBjb21wb25lbnQgdHJhbnNmb3JtXHJcbiAgICAgIHZhciBzaGlmdCwgb2Zmc2V0LCBtYXgsIG1pbiwgbWF4SztcclxuICAgICAgdmFyIHBvcyA9IDAsIGosIGpqLCB5MCwgeTEsIHkyLCByLCBnLCBiLCBrLCB2YWw7XHJcbiAgICAgIGlmICh0aWxlLmNvZGluZ1N0eWxlRGVmYXVsdFBhcmFtZXRlcnMubXVsdGlwbGVDb21wb25lbnRUcmFuc2Zvcm0pIHtcclxuICAgICAgICB2YXIgZm91ckNvbXBvbmVudHMgPSBjb21wb25lbnRzQ291bnQgPT09IDQ7XHJcbiAgICAgICAgdmFyIHkwaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzWzBdLml0ZW1zO1xyXG4gICAgICAgIHZhciB5MWl0ZW1zID0gdHJhbnNmb3JtZWRUaWxlc1sxXS5pdGVtcztcclxuICAgICAgICB2YXIgeTJpdGVtcyA9IHRyYW5zZm9ybWVkVGlsZXNbMl0uaXRlbXM7XHJcbiAgICAgICAgdmFyIHkzaXRlbXMgPSBmb3VyQ29tcG9uZW50cyA/IHRyYW5zZm9ybWVkVGlsZXNbM10uaXRlbXMgOiBudWxsO1xyXG5cclxuICAgICAgICAvLyBIQUNLOiBUaGUgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybSBmb3JtdWxhcyBiZWxvdyBhc3N1bWUgdGhhdFxyXG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhhdmUgdGhlIHNhbWUgcHJlY2lzaW9uLiBXaXRoIHRoaXMgaW4gbWluZCwgd2VcclxuICAgICAgICAvLyBjb21wdXRlIHNoaWZ0IGFuZCBvZmZzZXQgb25seSBvbmNlLlxyXG4gICAgICAgIHNoaWZ0ID0gY29tcG9uZW50c1swXS5wcmVjaXNpb24gLSA4O1xyXG4gICAgICAgIG9mZnNldCA9ICgxMjggPDwgc2hpZnQpICsgMC41O1xyXG4gICAgICAgIG1heCA9IDI1NSAqICgxIDw8IHNoaWZ0KTtcclxuICAgICAgICBtYXhLID0gbWF4ICogMC41O1xyXG4gICAgICAgIG1pbiA9IC1tYXhLO1xyXG5cclxuICAgICAgICB2YXIgY29tcG9uZW50MCA9IHRpbGUuY29tcG9uZW50c1swXTtcclxuICAgICAgICB2YXIgYWxwaGEwMSA9IGNvbXBvbmVudHNDb3VudCAtIDM7XHJcbiAgICAgICAgamogPSB5MGl0ZW1zLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudDAuY29kaW5nU3R5bGVQYXJhbWV0ZXJzLnJldmVyc2libGVUcmFuc2Zvcm1hdGlvbikge1xyXG4gICAgICAgICAgLy8gaW52ZXJzZSBpcnJldmVyc2libGUgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybVxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpqOyBqKyssIHBvcyArPSBhbHBoYTAxKSB7XHJcbiAgICAgICAgICAgIHkwID0geTBpdGVtc1tqXSArIG9mZnNldDtcclxuICAgICAgICAgICAgeTEgPSB5MWl0ZW1zW2pdO1xyXG4gICAgICAgICAgICB5MiA9IHkyaXRlbXNbal07XHJcbiAgICAgICAgICAgIHIgPSB5MCArIDEuNDAyICogeTI7XHJcbiAgICAgICAgICAgIGcgPSB5MCAtIDAuMzQ0MTMgKiB5MSAtIDAuNzE0MTQgKiB5MjtcclxuICAgICAgICAgICAgYiA9IHkwICsgMS43NzIgKiB5MTtcclxuICAgICAgICAgICAgb3V0W3BvcysrXSA9IHIgPD0gMCA/IDAgOiByID49IG1heCA/IDI1NSA6IHIgPj4gc2hpZnQ7XHJcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSBnIDw9IDAgPyAwIDogZyA+PSBtYXggPyAyNTUgOiBnID4+IHNoaWZ0O1xyXG4gICAgICAgICAgICBvdXRbcG9zKytdID0gYiA8PSAwID8gMCA6IGIgPj0gbWF4ID8gMjU1IDogYiA+PiBzaGlmdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gaW52ZXJzZSByZXZlcnNpYmxlIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqajsgaisrLCBwb3MgKz0gYWxwaGEwMSkge1xyXG4gICAgICAgICAgICB5MCA9IHkwaXRlbXNbal0gKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHkxID0geTFpdGVtc1tqXTtcclxuICAgICAgICAgICAgeTIgPSB5Mml0ZW1zW2pdO1xyXG4gICAgICAgICAgICBnID0geTAgLSAoKHkyICsgeTEpID4+IDIpO1xyXG4gICAgICAgICAgICByID0gZyArIHkyO1xyXG4gICAgICAgICAgICBiID0gZyArIHkxO1xyXG4gICAgICAgICAgICBvdXRbcG9zKytdID0gciA8PSAwID8gMCA6IHIgPj0gbWF4ID8gMjU1IDogciA+PiBzaGlmdDtcclxuICAgICAgICAgICAgb3V0W3BvcysrXSA9IGcgPD0gMCA/IDAgOiBnID49IG1heCA/IDI1NSA6IGcgPj4gc2hpZnQ7XHJcbiAgICAgICAgICAgIG91dFtwb3MrK10gPSBiIDw9IDAgPyAwIDogYiA+PSBtYXggPyAyNTUgOiBiID4+IHNoaWZ0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm91ckNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIGZvciAoaiA9IDAsIHBvcyA9IDM7IGogPCBqajsgaisrLCBwb3MgKz0gNCkge1xyXG4gICAgICAgICAgICBrID0geTNpdGVtc1tqXTtcclxuICAgICAgICAgICAgb3V0W3Bvc10gPSBrIDw9IG1pbiA/IDAgOiBrID49IG1heEsgPyAyNTUgOiAoayArIG9mZnNldCkgPj4gc2hpZnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgeyAvLyBubyBtdWx0aS1jb21wb25lbnQgdHJhbnNmb3JtXHJcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgICAgICBpZiAoY29tcG9uZW50c1tjXS5wcmVjaXNpb24gPT09IDgpe1xyXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzW2NdLml0ZW1zO1xyXG4gICAgICAgICAgICBzaGlmdCA9IGNvbXBvbmVudHNbY10ucHJlY2lzaW9uIC0gODtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKDEyOCA8PCBzaGlmdCkgKyAwLjU7XHJcbiAgICAgICAgICAgIG1heCA9ICgxMjcuNSAqICgxIDw8IHNoaWZ0KSk7XHJcbiAgICAgICAgICAgIG1pbiA9IC1tYXg7XHJcbiAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgICAgIHZhbCA9IGl0ZW1zW2pdO1xyXG4gICAgICAgICAgICAgIG91dFtwb3NdID0gdmFsIDw9IG1pbiA/IDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFsID49IG1heCA/IDI1NSA6ICh2YWwgKyBvZmZzZXQpID4+IHNoaWZ0O1xyXG4gICAgICAgICAgICAgIHBvcyArPSBjb21wb25lbnRzQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB2YXIgaXNTaWduZWQgPSBjb21wb25lbnRzW2NdLmlzU2lnbmVkO1xyXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmFuc2Zvcm1lZFRpbGVzW2NdLml0ZW1zO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNTaWduZWQpe1xyXG4gICAgICAgICAgICAgIGZvciAocG9zID0gYywgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgICAgICAgb3V0W3Bvc10gPSBpdGVtc1tqXTtcclxuICAgICAgICAgICAgICAgIHBvcyArPSBjb21wb25lbnRzQ291bnQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICBzaGlmdCA9IGNvbXBvbmVudHNbY10ucHJlY2lzaW9uIC0gODtcclxuICAgICAgICAgICAgICBvZmZzZXQgPSAoMTI4IDw8IHNoaWZ0KSArIDAuNTtcclxuICAgICAgICAgICAgICB2YXIgcHJlY2lzaW9uTWF4ID0gTWF0aC5wb3coMixjb21wb25lbnRzW2NdLnByZWNpc2lvbiktMTtcclxuICAgICAgICAgICAgICBmb3IgKHBvcyA9IGMsIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGl0ZW1zW2pdO1xyXG4gICAgICAgICAgICAgICAgb3V0W3Bvc10gPSBNYXRoLm1heChNYXRoLm1pbigodmFsICsgb2Zmc2V0KSxwcmVjaXNpb25NYXgpLDApO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbXBvbmVudHNDb3VudDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0SW1hZ2VzLnB1c2gocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRJbWFnZXM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUaWxlKGNvbnRleHQsIHRpbGVJbmRleCkge1xyXG4gICAgdmFyIHNpeiA9IGNvbnRleHQuU0laO1xyXG4gICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IHNpei5Dc2l6O1xyXG4gICAgdmFyIHRpbGUgPSBjb250ZXh0LnRpbGVzW3RpbGVJbmRleF07XHJcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHNDb3VudDsgYysrKSB7XHJcbiAgICAgIHZhciBjb21wb25lbnQgPSB0aWxlLmNvbXBvbmVudHNbY107XHJcbiAgICAgIHZhciBxY2RPclFjYyA9IChjb250ZXh0LmN1cnJlbnRUaWxlLlFDQ1tjXSAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLlFDQ1tjXSA6IGNvbnRleHQuY3VycmVudFRpbGUuUUNEKTtcclxuICAgICAgY29tcG9uZW50LnF1YW50aXphdGlvblBhcmFtZXRlcnMgPSBxY2RPclFjYztcclxuICAgICAgdmFyIGNvZE9yQ29jID0gKGNvbnRleHQuY3VycmVudFRpbGUuQ09DW2NdICE9PSB1bmRlZmluZWQgID9cclxuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaWxlLkNPQ1tjXSA6IGNvbnRleHQuY3VycmVudFRpbGUuQ09EKTtcclxuICAgICAgY29tcG9uZW50LmNvZGluZ1N0eWxlUGFyYW1ldGVycyA9IGNvZE9yQ29jO1xyXG4gICAgfVxyXG4gICAgdGlsZS5jb2RpbmdTdHlsZURlZmF1bHRQYXJhbWV0ZXJzID0gY29udGV4dC5jdXJyZW50VGlsZS5DT0Q7XHJcbiAgfVxyXG5cclxuICAvLyBTZWN0aW9uIEIuMTAuMiBUYWcgdHJlZXNcclxuICB2YXIgVGFnVHJlZSA9IChmdW5jdGlvbiBUYWdUcmVlQ2xvc3VyZSgpIHtcclxuICAgIGZ1bmN0aW9uIFRhZ1RyZWUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgbGV2ZWxzTGVuZ3RoID0gbG9nMihNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSkgKyAxO1xyXG4gICAgICB0aGlzLmxldmVscyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0ge1xyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICBpdGVtczogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGV2ZWxzLnB1c2gobGV2ZWwpO1xyXG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gMik7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBUYWdUcmVlLnByb3RvdHlwZSA9IHtcclxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIFRhZ1RyZWVfcmVzZXQoaSwgaikge1xyXG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSAwLCB2YWx1ZSA9IDAsIGxldmVsO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50TGV2ZWwgPCB0aGlzLmxldmVscy5sZW5ndGgpIHtcclxuICAgICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcclxuICAgICAgICAgIHZhciBpbmRleCA9IGkgKyBqICogbGV2ZWwud2lkdGg7XHJcbiAgICAgICAgICBpZiAobGV2ZWwuaXRlbXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBsZXZlbC5pdGVtc1tpbmRleF07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV2ZWwuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgIGkgPj49IDE7XHJcbiAgICAgICAgICBqID4+PSAxO1xyXG4gICAgICAgICAgY3VycmVudExldmVsKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRMZXZlbC0tO1xyXG4gICAgICAgIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcclxuICAgICAgICBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcclxuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZTtcclxuICAgICAgfSxcclxuICAgICAgaW5jcmVtZW50VmFsdWU6IGZ1bmN0aW9uIFRhZ1RyZWVfaW5jcmVtZW50VmFsdWUoKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSsrO1xyXG4gICAgICB9LFxyXG4gICAgICBuZXh0TGV2ZWw6IGZ1bmN0aW9uIFRhZ1RyZWVfbmV4dExldmVsKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XTtcclxuICAgICAgICBjdXJyZW50TGV2ZWwtLTtcclxuICAgICAgICBpZiAoY3VycmVudExldmVsIDwgMCkge1xyXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWw7XHJcbiAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsc1tjdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhZ1RyZWU7XHJcbiAgfSkoKTtcclxuXHJcbiAgdmFyIEluY2x1c2lvblRyZWUgPSAoZnVuY3Rpb24gSW5jbHVzaW9uVHJlZUNsb3N1cmUoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmNsdXNpb25UcmVlKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgdmFyIGxldmVsc0xlbmd0aCA9IGxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpICsgMTtcclxuICAgICAgdGhpcy5sZXZlbHMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KTtcclxuICAgICAgICB2YXIgc3RhdHVzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcclxuICAgICAgICAgIGl0ZW1zW2pdID0gMDtcclxuICAgICAgICAgIHN0YXR1c1tqXSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGV2ZWwgPSB7XHJcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgIGl0ZW1zOiBpdGVtcyxcclxuICAgICAgICAgIHN0YXR1czogc3RhdHVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxldmVscy5wdXNoKGxldmVsKTtcclxuXHJcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyAyKTtcclxuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIEluY2x1c2lvblRyZWUucHJvdG90eXBlID0ge1xyXG4gICAgICByZXNldDogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9yZXNldChpLCBqLCBzdG9wVmFsdWUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdG9wVmFsdWUgPSBzdG9wVmFsdWU7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRMZXZlbCA8IHRoaXMubGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcclxuICAgICAgICAgIHZhciBpbmRleCA9IGkgKyBqICogbGV2ZWwud2lkdGg7XHJcbiAgICAgICAgICBsZXZlbC5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgIGkgPj49IDE7XHJcbiAgICAgICAgICBqID4+PSAxO1xyXG4gICAgICAgICAgY3VycmVudExldmVsKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IHRoaXMubGV2ZWxzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdGhpcy5taW5WYWx1ZSA9dGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdLml0ZW1zWzBdO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSxcclxuICAgICAgaW5jcmVtZW50VmFsdWU6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaW5jcmVtZW50VmFsdWUoKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxdO1xyXG4gICAgICAgIGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSArIDE7XHJcbiAgICAgICAgaWYobGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID4gdGhpcy5taW5WYWx1ZSkge1xyXG4gICAgICAgICAgdGhpcy5taW5WYWx1ZSA9IGxldmVsLml0ZW1zW2xldmVsLmluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIG5leHRMZXZlbDogZnVuY3Rpb24gSW5jbHVzaW9uVHJlZV9uZXh0TGV2ZWwoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xyXG4gICAgICAgIGN1cnJlbnRMZXZlbC0tO1xyXG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuY3VycmVudExldmVsID0gY3VycmVudExldmVsO1xyXG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbY3VycmVudExldmVsXTtcclxuICAgICAgICAgIGlmKGxldmVsLml0ZW1zW2xldmVsLmluZGV4XSA8IHRoaXMubWluVmFsdWUpIHtcclxuICAgICAgICAgICAgbGV2ZWwuaXRlbXNbbGV2ZWwuaW5kZXhdID0gdGhpcy5taW5WYWx1ZTtcclxuICAgICAgICAgIH1lbHNlIGlmIChsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPiB0aGlzLm1pblZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluVmFsdWUgPSBsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICBpc0xlYWY6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaXNMZWFmKCl7XHJcbiAgICAgIHJldHVybiAodGhpcy5jdXJyZW50TGV2ZWwgPT09IDApO1xyXG4gICAgfSxcclxuICAgIGlzQWJvdmVUaHJlc2hvbGQ6IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaXNBYm92ZVRocmVzaG9sZCgpe1xyXG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xyXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tsZXZlbGluZGV4XTtcclxuICAgICAgcmV0dXJuIChsZXZlbC5pdGVtc1tsZXZlbC5pbmRleF0gPiB0aGlzLmN1cnJlbnRTdG9wVmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGlzS25vd246IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfaXNLbm93bigpe1xyXG4gICAgICB2YXIgbGV2ZWxpbmRleCA9IHRoaXMuY3VycmVudExldmVsO1xyXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1tsZXZlbGluZGV4XTtcclxuICAgICAgcmV0dXJuIChsZXZlbC5zdGF0dXNbbGV2ZWwuaW5kZXhdID4gMCk7XHJcbiAgICB9LFxyXG4gICAgc2V0S25vd246IGZ1bmN0aW9uIEluY2x1c2lvblRyZWVfc2V0S25vd24oKXtcclxuICAgICAgdmFyIGxldmVsaW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbDtcclxuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbbGV2ZWxpbmRleF07XHJcbiAgICAgIGxldmVsLnN0YXR1c1tsZXZlbC5pbmRleF0gPSAxO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIHJldHVybiBJbmNsdXNpb25UcmVlO1xyXG4gIH0pKCk7XHJcblxyXG4gIC8vIFNlY3Rpb24gRC4gQ29lZmZpY2llbnQgYml0IG1vZGVsaW5nXHJcbiAgdmFyIEJpdE1vZGVsID0gKGZ1bmN0aW9uIEJpdE1vZGVsQ2xvc3VyZSgpIHtcclxuICAgIHZhciBVTklGT1JNX0NPTlRFWFQgPSAxNztcclxuICAgIHZhciBSVU5MRU5HVEhfQ09OVEVYVCA9IDE4O1xyXG4gICAgLy8gVGFibGUgRC0xXHJcbiAgICAvLyBUaGUgaW5kZXggaXMgYmluYXJ5IHByZXNlbnRhdGlvbjogMGRkZHZ2aGgsIGRkZCAtIHN1bSBvZiBEaSAoMC4uNCksXHJcbiAgICAvLyB2diAtIHN1bSBvZiBWaSAoMC4uMiksIGFuZCBoaCAtIHN1bSBvZiBIaSAoMC4uMilcclxuICAgIHZhciBMTEFuZExIQ29udGV4dHNMYWJlbCA9IG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgMCwgNSwgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOCwgMCwgMCwgMCwgMCwgMCwgMSwgNiwgOCwgMCwgMywgNywgOCwgMCwgNCxcclxuICAgICAgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNiwgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNixcclxuICAgICAgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOCwgMCwgMCwgMCwgMCwgMCwgMiwgNiwgOCwgMCwgMywgNywgOCwgMCwgNCwgNywgOFxyXG4gICAgXSk7XHJcbiAgICB2YXIgSExDb250ZXh0TGFiZWwgPSBuZXcgVWludDhBcnJheShbXHJcbiAgICAgIDAsIDMsIDQsIDAsIDUsIDcsIDcsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDEsIDMsIDQsIDAsIDYsIDcsIDcsIDAsIDgsXHJcbiAgICAgIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDQsIDAsIDYsIDcsIDcsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDIsIDMsXHJcbiAgICAgIDQsIDAsIDYsIDcsIDcsIDAsIDgsIDgsIDgsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDQsIDAsIDYsIDcsIDcsIDAsIDgsIDgsIDhcclxuICAgIF0pO1xyXG4gICAgdmFyIEhIQ29udGV4dExhYmVsID0gbmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgICAwLCAxLCAyLCAwLCAxLCAyLCAyLCAwLCAyLCAyLCAyLCAwLCAwLCAwLCAwLCAwLCAzLCA0LCA1LCAwLCA0LCA1LCA1LCAwLCA1LFxyXG4gICAgICA1LCA1LCAwLCAwLCAwLCAwLCAwLCA2LCA3LCA3LCAwLCA3LCA3LCA3LCAwLCA3LCA3LCA3LCAwLCAwLCAwLCAwLCAwLCA4LCA4LFxyXG4gICAgICA4LCAwLCA4LCA4LCA4LCAwLCA4LCA4LCA4LCAwLCAwLCAwLCAwLCAwLCA4LCA4LCA4LCAwLCA4LCA4LCA4LCAwLCA4LCA4LCA4XHJcbiAgICBdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBCaXRNb2RlbCh3aWR0aCwgaGVpZ2h0LCBzdWJiYW5kLCB6ZXJvQml0UGxhbmVzLCBtYikge1xyXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgdGhpcy5jb250ZXh0TGFiZWxUYWJsZSA9IChzdWJiYW5kID09PSAnSEgnID8gSEhDb250ZXh0TGFiZWwgOlxyXG4gICAgICAgIChzdWJiYW5kID09PSAnSEwnID8gSExDb250ZXh0TGFiZWwgOiBMTEFuZExIQ29udGV4dHNMYWJlbCkpO1xyXG5cclxuICAgICAgdmFyIGNvZWZmaWNpZW50Q291bnQgPSB3aWR0aCAqIGhlaWdodDtcclxuXHJcbiAgICAgIC8vIGNvZWZmaWNpZW50cyBvdXRzaWRlIHRoZSBlbmNvZGluZyByZWdpb24gdHJlYXRlZCBhcyBpbnNpZ25pZmljYW50XHJcbiAgICAgIC8vIGFkZCBib3JkZXIgc3RhdGUgY2VsbHMgZm9yIHNpZ25pZmljYW5jZVN0YXRlXHJcbiAgICAgIHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XHJcbiAgICAgIHRoaXMuY29lZmZpY2VudHNTaWduID0gbmV3IFVpbnQ4QXJyYXkoY29lZmZpY2llbnRDb3VudCk7XHJcbiAgICAgIHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGUgPSBtYiA+IDE0ID8gbmV3IFVpbnQzMkFycmF5KGNvZWZmaWNpZW50Q291bnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iID4gNiA/IG5ldyBVaW50MTZBcnJheShjb2VmZmljaWVudENvdW50KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcclxuICAgICAgdGhpcy5wcm9jZXNzaW5nRmxhZ3MgPSBuZXcgVWludDhBcnJheShjb2VmZmljaWVudENvdW50KTtcclxuXHJcbiAgICAgIHZhciBiaXRzRGVjb2RlZCA9IG5ldyBVaW50OEFycmF5KGNvZWZmaWNpZW50Q291bnQpO1xyXG4gICAgICBpZiAoemVyb0JpdFBsYW5lcyAhPT0gMCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29lZmZpY2llbnRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBiaXRzRGVjb2RlZFtpXSA9IHplcm9CaXRQbGFuZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYml0c0RlY29kZWQgPSBiaXRzRGVjb2RlZDtcclxuXHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBCaXRNb2RlbC5wcm90b3R5cGUgPSB7XHJcbiAgICAgIHNldERlY29kZXI6IGZ1bmN0aW9uIEJpdE1vZGVsX3NldERlY29kZXIoZGVjb2Rlcikge1xyXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGRlY29kZXI7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiBCaXRNb2RlbF9yZXNldCgpIHtcclxuICAgICAgICAvLyBXZSBoYXZlIDE3IGNvbnRleHRzIHRoYXQgYXJlIGFjY2Vzc2VkIHZpYSBjb250ZXh0IGxhYmVscyxcclxuICAgICAgICAvLyBwbHVzIHRoZSB1bmlmb3JtIGFuZCBydW5sZW5ndGggY29udGV4dC5cclxuICAgICAgICB0aGlzLmNvbnRleHRzID0gbmV3IEludDhBcnJheSgxOSk7XHJcblxyXG4gICAgICAgIC8vIENvbnRleHRzIGFyZSBwYWNrZWQgaW50byAxIGJ5dGU6XHJcbiAgICAgICAgLy8gaGlnaGVzdCA3IGJpdHMgY2FycnkgdGhlIGluZGV4LCBsb3dlc3QgYml0IGNhcnJpZXMgbXBzXHJcbiAgICAgICAgdGhpcy5jb250ZXh0c1swXSA9ICg0IDw8IDEpIHwgMDtcclxuICAgICAgICB0aGlzLmNvbnRleHRzW1VOSUZPUk1fQ09OVEVYVF0gPSAoNDYgPDwgMSkgfCAwO1xyXG4gICAgICAgIHRoaXMuY29udGV4dHNbUlVOTEVOR1RIX0NPTlRFWFRdID0gKDMgPDwgMSkgfCAwO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXROZWlnaGJvcnNTaWduaWZpY2FuY2U6XHJcbiAgICAgICAgZnVuY3Rpb24gQml0TW9kZWxfc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKHJvdywgY29sdW1uLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBuZWlnaGJvcnNTaWduaWZpY2FuY2UgPSB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgbGVmdCA9IChjb2x1bW4gPiAwKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSAoY29sdW1uICsgMSA8IHdpZHRoKTtcclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgaWYgKHJvdyA+IDApIHtcclxuICAgICAgICAgIGkgPSBpbmRleCAtIHdpZHRoO1xyXG4gICAgICAgICAgaWYgKGxlZnQpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgLSAxXSArPSAweDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpICsgMV0gKz0gMHgxMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpXSArPSAweDA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJvdyArIDEgPCBoZWlnaHQpIHtcclxuICAgICAgICAgIGkgPSBpbmRleCArIHdpZHRoO1xyXG4gICAgICAgICAgaWYgKGxlZnQpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2kgLSAxXSArPSAweDEwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpICsgMV0gKz0gMHgxMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpXSArPSAweDA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxlZnQpIHtcclxuICAgICAgICAgIG5laWdoYm9yc1NpZ25pZmljYW5jZVtpbmRleCAtIDFdICs9IDB4MDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyaWdodCkge1xyXG4gICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4ICsgMV0gKz0gMHgwMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XSB8PSAweDgwO1xyXG4gICAgICB9LFxyXG4gICAgICBydW5TaWduaWZpY2FuY2VQcm9wb2dhdGlvblBhc3M6XHJcbiAgICAgICAgZnVuY3Rpb24gQml0TW9kZWxfcnVuU2lnbmlmaWNhbmNlUHJvcG9nYXRpb25QYXNzKCkge1xyXG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzU2lnbiA9IHRoaXMuY29lZmZpY2VudHNTaWduO1xyXG4gICAgICAgIHZhciBuZWlnaGJvcnNTaWduaWZpY2FuY2UgPSB0aGlzLm5laWdoYm9yc1NpZ25pZmljYW5jZTtcclxuICAgICAgICB2YXIgcHJvY2Vzc2luZ0ZsYWdzID0gdGhpcy5wcm9jZXNzaW5nRmxhZ3M7XHJcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcclxuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5jb250ZXh0TGFiZWxUYWJsZTtcclxuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWRJbnZlcnNlTWFzayA9IH4xO1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWRNYXNrID0gMTtcclxuICAgICAgICB2YXIgZmlyc3RNYWduaXR1ZGVCaXRNYXNrID0gMjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IGhlaWdodDsgaTAgKz0gNCkge1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkwICogd2lkdGggKyBqO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgNDsgaTErKywgaW5kZXggKz0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICB2YXIgaSA9IGkwICsgaTE7XHJcbiAgICAgICAgICAgICAgaWYgKGkgPj0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gY2xlYXIgcHJvY2Vzc2VkIGZsYWcgZmlyc3RcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICY9IHByb2Nlc3NlZEludmVyc2VNYXNrO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIHx8XHJcbiAgICAgICAgICAgICAgICAgICFuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsYWJlbHNbbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XV07XHJcbiAgICAgICAgICAgICAgdmFyIGRlY2lzaW9uID0gZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xyXG4gICAgICAgICAgICAgIGlmIChkZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB0aGlzLmRlY29kZVNpZ25CaXQoaSwgaiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY29lZmZpY2VudHNTaWduW2luZGV4XSA9IHNpZ247XHJcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROZWlnaGJvcnNTaWduaWZpY2FuY2UoaSwgaiwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSB8PSBmaXJzdE1hZ25pdHVkZUJpdE1hc2s7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4XSsrO1xyXG4gICAgICAgICAgICAgIHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gfD0gcHJvY2Vzc2VkTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgZGVjb2RlU2lnbkJpdDogZnVuY3Rpb24gQml0TW9kZWxfZGVjb2RlU2lnbkJpdChyb3csIGNvbHVtbiwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgY29lZmZpY2VudHNNYWduaXR1ZGUgPSB0aGlzLmNvZWZmaWNlbnRzTWFnbml0dWRlO1xyXG4gICAgICAgIHZhciBjb2VmZmljZW50c1NpZ24gPSB0aGlzLmNvZWZmaWNlbnRzU2lnbjtcclxuICAgICAgICB2YXIgY29udHJpYnV0aW9uLCBzaWduMCwgc2lnbjEsIHNpZ25pZmljYW5jZTE7XHJcbiAgICAgICAgdmFyIGNvbnRleHRMYWJlbCwgZGVjb2RlZDtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIGhvcml6b250YWwgY29udHJpYnV0aW9uXHJcbiAgICAgICAgc2lnbmlmaWNhbmNlMSA9IChjb2x1bW4gPiAwICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4IC0gMV0gIT09IDApO1xyXG4gICAgICAgIGlmIChjb2x1bW4gKyAxIDwgd2lkdGggJiYgY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXggKyAxXSAhPT0gMCkge1xyXG4gICAgICAgICAgc2lnbjEgPSBjb2VmZmljZW50c1NpZ25baW5kZXggKyAxXTtcclxuICAgICAgICAgIGlmIChzaWduaWZpY2FuY2UxKSB7XHJcbiAgICAgICAgICAgIHNpZ24wID0gY29lZmZpY2VudHNTaWduW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDEgLSBzaWduMSAtIHNpZ24wO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaWduaWZpY2FuY2UxKSB7XHJcbiAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIDFdO1xyXG4gICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24wIC0gc2lnbjA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBob3Jpem9udGFsQ29udHJpYnV0aW9uID0gMyAqIGNvbnRyaWJ1dGlvbjtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHZlcnRpY2FsIGNvbnRyaWJ1dGlvbiBhbmQgY29tYmluZSB3aXRoIHRoZSBob3Jpem9udGFsXHJcbiAgICAgICAgc2lnbmlmaWNhbmNlMSA9IChyb3cgPiAwICYmIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4IC0gd2lkdGhdICE9PSAwKTtcclxuICAgICAgICBpZiAocm93ICsgMSA8IGhlaWdodCAmJiBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleCArIHdpZHRoXSAhPT0gMCkge1xyXG4gICAgICAgICAgc2lnbjEgPSBjb2VmZmljZW50c1NpZ25baW5kZXggKyB3aWR0aF07XHJcbiAgICAgICAgICBpZiAoc2lnbmlmaWNhbmNlMSkge1xyXG4gICAgICAgICAgICBzaWduMCA9IGNvZWZmaWNlbnRzU2lnbltpbmRleCAtIHdpZHRoXTtcclxuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjAgKyBob3Jpem9udGFsQ29udHJpYnV0aW9uO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udHJpYnV0aW9uID0gMSAtIHNpZ24xIC0gc2lnbjEgKyBob3Jpem9udGFsQ29udHJpYnV0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmlmaWNhbmNlMSkge1xyXG4gICAgICAgICAgc2lnbjAgPSBjb2VmZmljZW50c1NpZ25baW5kZXggLSB3aWR0aF07XHJcbiAgICAgICAgICBjb250cmlidXRpb24gPSAxIC0gc2lnbjAgLSBzaWduMCArIGhvcml6b250YWxDb250cmlidXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRyaWJ1dGlvbiA9IGhvcml6b250YWxDb250cmlidXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29udHJpYnV0aW9uID49IDApIHtcclxuICAgICAgICAgIGNvbnRleHRMYWJlbCA9IDkgKyBjb250cmlidXRpb247XHJcbiAgICAgICAgICBkZWNvZGVkID0gdGhpcy5kZWNvZGVyLnJlYWRCaXQodGhpcy5jb250ZXh0cywgY29udGV4dExhYmVsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGV4dExhYmVsID0gOSAtIGNvbnRyaWJ1dGlvbjtcclxuICAgICAgICAgIGRlY29kZWQgPSB0aGlzLmRlY29kZXIucmVhZEJpdCh0aGlzLmNvbnRleHRzLCBjb250ZXh0TGFiZWwpIF4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1bk1hZ25pdHVkZVJlZmluZW1lbnRQYXNzOlxyXG4gICAgICAgIGZ1bmN0aW9uIEJpdE1vZGVsX3J1bk1hZ25pdHVkZVJlZmluZW1lbnRQYXNzKCkge1xyXG4gICAgICAgIHZhciBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjb2VmZmljZW50c01hZ25pdHVkZSA9IHRoaXMuY29lZmZpY2VudHNNYWduaXR1ZGU7XHJcbiAgICAgICAgdmFyIG5laWdoYm9yc1NpZ25pZmljYW5jZSA9IHRoaXMubmVpZ2hib3JzU2lnbmlmaWNhbmNlO1xyXG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XHJcbiAgICAgICAgdmFyIGJpdHNEZWNvZGVkID0gdGhpcy5iaXRzRGVjb2RlZDtcclxuICAgICAgICB2YXIgcHJvY2Vzc2luZ0ZsYWdzID0gdGhpcy5wcm9jZXNzaW5nRmxhZ3M7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZE1hc2sgPSAxO1xyXG4gICAgICAgIHZhciBmaXJzdE1hZ25pdHVkZUJpdE1hc2sgPSAyO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICB2YXIgd2lkdGg0ID0gd2lkdGggKiA0O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpbmRleDAgPSAwLCBpbmRleE5leHQ7IGluZGV4MCA8IGxlbmd0aDsgaW5kZXgwID0gaW5kZXhOZXh0KSB7XHJcbiAgICAgICAgICBpbmRleE5leHQgPSBNYXRoLm1pbihsZW5ndGgsIGluZGV4MCArIHdpZHRoNCk7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBpbmRleDAgKyBqOyBpbmRleCA8IGluZGV4TmV4dDsgaW5kZXggKz0gd2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gc2lnbmlmaWNhbnQgYnV0IG5vdCB0aG9zZSB0aGF0IGhhdmUganVzdCBiZWNvbWVcclxuICAgICAgICAgICAgICBpZiAoIWNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSB8fFxyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3NpbmdGbGFnc1tpbmRleF0gJiBwcm9jZXNzZWRNYXNrKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgY29udGV4dExhYmVsID0gMTY7XHJcbiAgICAgICAgICAgICAgaWYgKChwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdICYgZmlyc3RNYWduaXR1ZGVCaXRNYXNrKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSBePSBmaXJzdE1hZ25pdHVkZUJpdE1hc2s7XHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCByZWZpbmVtZW50XHJcbiAgICAgICAgICAgICAgIHZhciBzaWduaWZpY2FuY2UgPSBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdICYgMTI3O1xyXG4gICAgICAgICAgICAgICBjb250ZXh0TGFiZWwgPSBzaWduaWZpY2FuY2UgPT09IDAgPyAxNSA6IDE0O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIGJpdCA9IGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgY29udGV4dExhYmVsKTtcclxuICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPVxyXG4gICAgICAgICAgICAgICAgKGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA8PCAxKSB8IGJpdDtcclxuICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleF0rKztcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IHByb2Nlc3NlZE1hc2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHJ1bkNsZWFudXBQYXNzOiBmdW5jdGlvbiBCaXRNb2RlbF9ydW5DbGVhbnVwUGFzcygpIHtcclxuICAgICAgICB2YXIgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgbmVpZ2hib3JzU2lnbmlmaWNhbmNlID0gdGhpcy5uZWlnaGJvcnNTaWduaWZpY2FuY2U7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNlbnRzTWFnbml0dWRlID0gdGhpcy5jb2VmZmljZW50c01hZ25pdHVkZTtcclxuICAgICAgICB2YXIgY29lZmZpY2VudHNTaWduID0gdGhpcy5jb2VmZmljZW50c1NpZ247XHJcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcclxuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5jb250ZXh0TGFiZWxUYWJsZTtcclxuICAgICAgICB2YXIgYml0c0RlY29kZWQgPSB0aGlzLmJpdHNEZWNvZGVkO1xyXG4gICAgICAgIHZhciBwcm9jZXNzaW5nRmxhZ3MgPSB0aGlzLnByb2Nlc3NpbmdGbGFncztcclxuICAgICAgICB2YXIgcHJvY2Vzc2VkTWFzayA9IDE7XHJcbiAgICAgICAgdmFyIGZpcnN0TWFnbml0dWRlQml0TWFzayA9IDI7XHJcbiAgICAgICAgdmFyIG9uZVJvd0Rvd24gPSB3aWR0aDtcclxuICAgICAgICB2YXIgdHdvUm93c0Rvd24gPSB3aWR0aCAqIDI7XHJcbiAgICAgICAgdmFyIHRocmVlUm93c0Rvd24gPSB3aWR0aCAqIDM7XHJcbiAgICAgICAgdmFyIGlOZXh0O1xyXG4gICAgICAgIGZvciAodmFyIGkwID0gMDsgaTAgPCBoZWlnaHQ7IGkwID0gaU5leHQpIHtcclxuICAgICAgICAgIGlOZXh0ID0gTWF0aC5taW4oaTAgKyA0LCBoZWlnaHQpO1xyXG4gICAgICAgICAgdmFyIGluZGV4QmFzZSA9IGkwICogd2lkdGg7XHJcbiAgICAgICAgICB2YXIgY2hlY2tBbGxFbXB0eSA9IGkwICsgMyA8IGhlaWdodDtcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXgwID0gaW5kZXhCYXNlICsgajtcclxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIHByb3BlcnR5OiBsYWJlbHNbbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XV0gPT09IDBcclxuICAgICAgICAgICAgLy8gd2hlbiBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXhdID09PSAwXHJcbiAgICAgICAgICAgIHZhciBhbGxFbXB0eSA9IChjaGVja0FsbEVtcHR5ICYmXHJcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4MF0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgb25lUm93RG93bl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXgwICsgdHdvUm93c0Rvd25dID09PSAwICYmXHJcbiAgICAgICAgICAgICAgcHJvY2Vzc2luZ0ZsYWdzW2luZGV4MCArIHRocmVlUm93c0Rvd25dID09PSAwICYmXHJcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MF0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwICsgb25lUm93RG93bl0gPT09IDAgJiZcclxuICAgICAgICAgICAgICBuZWlnaGJvcnNTaWduaWZpY2FuY2VbaW5kZXgwICsgdHdvUm93c0Rvd25dID09PSAwICYmXHJcbiAgICAgICAgICAgICAgbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4MCArIHRocmVlUm93c0Rvd25dID09PSAwKTtcclxuICAgICAgICAgICAgdmFyIGkxID0gMCwgaW5kZXggPSBpbmRleDA7XHJcbiAgICAgICAgICAgIHZhciBpID0gaTAsIHNpZ247XHJcbiAgICAgICAgICAgIGlmIChhbGxFbXB0eSkge1xyXG4gICAgICAgICAgICAgIHZhciBoYXNTaWduaWZpY2FudENvZWZmaWNlbnQgPVxyXG4gICAgICAgICAgICAgICAgZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBSVU5MRU5HVEhfQ09OVEVYVCk7XHJcbiAgICAgICAgICAgICAgaWYgKCFoYXNTaWduaWZpY2FudENvZWZmaWNlbnQpIHtcclxuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MF0rKztcclxuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MCArIG9uZVJvd0Rvd25dKys7XHJcbiAgICAgICAgICAgICAgICBiaXRzRGVjb2RlZFtpbmRleDAgKyB0d29Sb3dzRG93bl0rKztcclxuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4MCArIHRocmVlUm93c0Rvd25dKys7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gbmV4dCBjb2x1bW5cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaTEgPSAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDEpIHxcclxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCk7XHJcbiAgICAgICAgICAgICAgaWYgKGkxICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpID0gaTAgKyBpMTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IGkxICogd2lkdGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBzaWduID0gdGhpcy5kZWNvZGVTaWduQml0KGksIGosIGluZGV4KTtcclxuICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcclxuICAgICAgICAgICAgICBjb2VmZmljZW50c01hZ25pdHVkZVtpbmRleF0gPSAxO1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0TmVpZ2hib3JzU2lnbmlmaWNhbmNlKGksIGosIGluZGV4KTtcclxuICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcclxuXHJcbiAgICAgICAgICAgICAgaW5kZXggPSBpbmRleDA7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTIgPSBpMDsgaTIgPD0gaTsgaTIrKywgaW5kZXggKz0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGJpdHNEZWNvZGVkW2luZGV4XSsrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaTErKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSBpMCArIGkxOyBpIDwgaU5leHQ7IGkrKywgaW5kZXggKz0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICBpZiAoY29lZmZpY2VudHNNYWduaXR1ZGVbaW5kZXhdIHx8XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzc2luZ0ZsYWdzW2luZGV4XSAmIHByb2Nlc3NlZE1hc2spICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBjb250ZXh0TGFiZWwgPSBsYWJlbHNbbmVpZ2hib3JzU2lnbmlmaWNhbmNlW2luZGV4XV07XHJcbiAgICAgICAgICAgICAgdmFyIGRlY2lzaW9uID0gZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBjb250ZXh0TGFiZWwpO1xyXG4gICAgICAgICAgICAgIGlmIChkZWNpc2lvbiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgc2lnbiA9IHRoaXMuZGVjb2RlU2lnbkJpdChpLCBqLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb2VmZmljZW50c1NpZ25baW5kZXhdID0gc2lnbjtcclxuICAgICAgICAgICAgICAgIGNvZWZmaWNlbnRzTWFnbml0dWRlW2luZGV4XSA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5laWdoYm9yc1NpZ25pZmljYW5jZShpLCBqLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nRmxhZ3NbaW5kZXhdIHw9IGZpcnN0TWFnbml0dWRlQml0TWFzaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYml0c0RlY29kZWRbaW5kZXhdKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGNoZWNrU2VnbWVudGF0aW9uU3ltYm9sOiBmdW5jdGlvbiBCaXRNb2RlbF9jaGVja1NlZ21lbnRhdGlvblN5bWJvbCgpIHtcclxuICAgICAgICB2YXIgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcclxuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xyXG4gICAgICAgIHZhciBzeW1ib2wgPSAoZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpIDw8IDMpIHxcclxuICAgICAgICAgICAgICAgICAgICAgKGRlY29kZXIucmVhZEJpdChjb250ZXh0cywgVU5JRk9STV9DT05URVhUKSA8PCAyKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgIChkZWNvZGVyLnJlYWRCaXQoY29udGV4dHMsIFVOSUZPUk1fQ09OVEVYVCkgPDwgMSkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5yZWFkQml0KGNvbnRleHRzLCBVTklGT1JNX0NPTlRFWFQpO1xyXG4gICAgICAgIGlmIChzeW1ib2wgIT09IDB4QSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKUFggRXJyb3I6IEludmFsaWQgc2VnbWVudGF0aW9uIHN5bWJvbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQml0TW9kZWw7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gU2VjdGlvbiBGLCBEaXNjcmV0ZSB3YXZlbGV0IHRyYW5zZm9ybWF0aW9uXHJcbiAgdmFyIFRyYW5zZm9ybSA9IChmdW5jdGlvbiBUcmFuc2Zvcm1DbG9zdXJlKCkge1xyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtKCkge31cclxuXHJcbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZSA9XHJcbiAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUNhbGN1bGF0ZShzdWJiYW5kcywgdTAsIHYwKSB7XHJcbiAgICAgIHZhciBsbCA9IHN1YmJhbmRzWzBdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMSwgaWkgPSBzdWJiYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgbGwgPSB0aGlzLml0ZXJhdGUobGwsIHN1YmJhbmRzW2ldLCB1MCwgdjApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsbDtcclxuICAgIH07XHJcbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChidWZmZXIsIG9mZnNldCwgc2l6ZSkge1xyXG4gICAgICAvLyBTZWN0aW9uIEYuMy43IGV4dGVuZGluZy4uLiB1c2luZyBtYXggZXh0ZW5zaW9uIG9mIDRcclxuICAgICAgdmFyIGkxID0gb2Zmc2V0IC0gMSwgajEgPSBvZmZzZXQgKyAxO1xyXG4gICAgICB2YXIgaTIgPSBvZmZzZXQgKyBzaXplIC0gMiwgajIgPSBvZmZzZXQgKyBzaXplO1xyXG4gICAgICBidWZmZXJbaTEtLV0gPSBidWZmZXJbajErK107XHJcbiAgICAgIGJ1ZmZlcltqMisrXSA9IGJ1ZmZlcltpMi0tXTtcclxuICAgICAgYnVmZmVyW2kxLS1dID0gYnVmZmVyW2oxKytdO1xyXG4gICAgICBidWZmZXJbajIrK10gPSBidWZmZXJbaTItLV07XHJcbiAgICAgIGJ1ZmZlcltpMS0tXSA9IGJ1ZmZlcltqMSsrXTtcclxuICAgICAgYnVmZmVyW2oyKytdID0gYnVmZmVyW2kyLS1dO1xyXG4gICAgICBidWZmZXJbaTFdID0gYnVmZmVyW2oxXTtcclxuICAgICAgYnVmZmVyW2oyXSA9IGJ1ZmZlcltpMl07XHJcbiAgICB9O1xyXG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gVHJhbnNmb3JtX2l0ZXJhdGUobGwsIGhsX2xoX2hoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdTAsIHYwKSB7XHJcbiAgICAgIHZhciBsbFdpZHRoID0gbGwud2lkdGgsIGxsSGVpZ2h0ID0gbGwuaGVpZ2h0LCBsbEl0ZW1zID0gbGwuaXRlbXM7XHJcbiAgICAgIHZhciB3aWR0aCA9IGhsX2xoX2hoLndpZHRoO1xyXG4gICAgICB2YXIgaGVpZ2h0ID0gaGxfbGhfaGguaGVpZ2h0O1xyXG4gICAgICB2YXIgaXRlbXMgPSBobF9saF9oaC5pdGVtcztcclxuICAgICAgdmFyIGksIGosIGssIGwsIHUsIHY7XHJcblxyXG4gICAgICAvLyBJbnRlcmxlYXZlIExMIGFjY29yZGluZyB0byBTZWN0aW9uIEYuMy4zXHJcbiAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgbGxIZWlnaHQ7IGkrKykge1xyXG4gICAgICAgIGwgPSBpICogMiAqIHdpZHRoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsbFdpZHRoOyBqKyssIGsrKywgbCArPSAyKSB7XHJcbiAgICAgICAgICBpdGVtc1tsXSA9IGxsSXRlbXNba107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFRoZSBMTCBiYW5kIGlzIG5vdCBuZWVkZWQgYW55bW9yZS5cclxuICAgICAgbGxJdGVtcyA9IGxsLml0ZW1zID0gbnVsbDtcclxuXHJcbiAgICAgIHZhciBidWZmZXJQYWRkaW5nID0gNDtcclxuICAgICAgdmFyIHJvd0J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKyAyICogYnVmZmVyUGFkZGluZyk7XHJcblxyXG4gICAgICAvLyBTZWN0aW9uIEYuMy40IEhPUl9TUlxyXG4gICAgICBpZiAod2lkdGggPT09IDEpIHtcclxuICAgICAgICAvLyBpZiB3aWR0aCA9IDEsIHdoZW4gdTAgZXZlbiBrZWVwIGl0ZW1zIGFzIGlzLCB3aGVuIG9kZCBkaXZpZGUgYnkgMlxyXG4gICAgICAgIGlmICgodTAgJiAxKSAhPT0gMCkge1xyXG4gICAgICAgICAgZm9yICh2ID0gMCwgayA9IDA7IHYgPCBoZWlnaHQ7IHYrKywgayArPSB3aWR0aCkge1xyXG4gICAgICAgICAgICBpdGVtc1trXSAqPSAwLjU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodiA9IDAsIGsgPSAwOyB2IDwgaGVpZ2h0OyB2KyssIGsgKz0gd2lkdGgpIHtcclxuICAgICAgICAgIHJvd0J1ZmZlci5zZXQoaXRlbXMuc3ViYXJyYXkoaywgayArIHdpZHRoKSwgYnVmZmVyUGFkZGluZyk7XHJcblxyXG4gICAgICAgICAgdGhpcy5leHRlbmQocm93QnVmZmVyLCBidWZmZXJQYWRkaW5nLCB3aWR0aCk7XHJcbiAgICAgICAgICB0aGlzLmZpbHRlcihyb3dCdWZmZXIsIGJ1ZmZlclBhZGRpbmcsIHdpZHRoKTtcclxuXHJcbiAgICAgICAgICBpdGVtcy5zZXQoXHJcbiAgICAgICAgICAgIHJvd0J1ZmZlci5zdWJhcnJheShidWZmZXJQYWRkaW5nLCBidWZmZXJQYWRkaW5nICsgd2lkdGgpLFxyXG4gICAgICAgICAgICBrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFjY2Vzc2VzIHRvIHRoZSBpdGVtcyBhcnJheSBjYW4gdGFrZSBsb25nLCBiZWNhdXNlIGl0IG1heSBub3QgZml0IGludG9cclxuICAgICAgLy8gQ1BVIGNhY2hlIGFuZCBoYXMgdG8gYmUgZmV0Y2hlZCBmcm9tIG1haW4gbWVtb3J5LiBTaW5jZSBzdWJzZXF1ZW50XHJcbiAgICAgIC8vIGFjY2Vzc2VzIHRvIHRoZSBpdGVtcyBhcnJheSBhcmUgbm90IGxvY2FsIHdoZW4gcmVhZGluZyBjb2x1bW5zLCB3ZVxyXG4gICAgICAvLyBoYXZlIGEgY2FjaGUgbWlzcyBldmVyeSB0aW1lLiBUbyByZWR1Y2UgY2FjaGUgbWlzc2VzLCBnZXQgdXAgdG9cclxuICAgICAgLy8gJ251bUJ1ZmZlcnMnIGl0ZW1zIGF0IGEgdGltZSBhbmQgc3RvcmUgdGhlbSBpbnRvIHRoZSBpbmRpdmlkdWFsXHJcbiAgICAgIC8vIGJ1ZmZlcnMuIFRoZSBjb2xCdWZmZXJzIHNob3VsZCBiZSBzbWFsbCBlbm91Z2ggdG8gZml0IGludG8gQ1BVIGNhY2hlLlxyXG4gICAgICB2YXIgbnVtQnVmZmVycyA9IDE2O1xyXG4gICAgICB2YXIgY29sQnVmZmVycyA9IFtdO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQnVmZmVyczsgaSsrKSB7XHJcbiAgICAgICAgY29sQnVmZmVycy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoaGVpZ2h0ICsgMiAqIGJ1ZmZlclBhZGRpbmcpKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYiwgY3VycmVudEJ1ZmZlciA9IDA7XHJcbiAgICAgIGxsID0gYnVmZmVyUGFkZGluZyArIGhlaWdodDtcclxuXHJcbiAgICAgIC8vIFNlY3Rpb24gRi4zLjUgVkVSX1NSXHJcbiAgICAgIGlmIChoZWlnaHQgPT09IDEpIHtcclxuICAgICAgICAgIC8vIGlmIGhlaWdodCA9IDEsIHdoZW4gdjAgZXZlbiBrZWVwIGl0ZW1zIGFzIGlzLCB3aGVuIG9kZCBkaXZpZGUgYnkgMlxyXG4gICAgICAgIGlmICgodjAgJiAxKSAhPT0gMCkge1xyXG4gICAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcclxuICAgICAgICAgICAgaXRlbXNbdV0gKj0gMC41O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xyXG4gICAgICAgICAgLy8gaWYgd2UgcmFuIG91dCBvZiBidWZmZXJzLCBjb3B5IHNldmVyYWwgaW1hZ2UgY29sdW1ucyBhdCBvbmNlXHJcbiAgICAgICAgICBpZiAoY3VycmVudEJ1ZmZlciA9PT0gMCkge1xyXG4gICAgICAgICAgICBudW1CdWZmZXJzID0gTWF0aC5taW4od2lkdGggLSB1LCBudW1CdWZmZXJzKTtcclxuICAgICAgICAgICAgZm9yIChrID0gdSwgbCA9IGJ1ZmZlclBhZGRpbmc7IGwgPCBsbDsgayArPSB3aWR0aCwgbCsrKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChiID0gMDsgYiA8IG51bUJ1ZmZlcnM7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgY29sQnVmZmVyc1tiXVtsXSA9IGl0ZW1zW2sgKyBiXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEJ1ZmZlciA9IG51bUJ1ZmZlcnM7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY3VycmVudEJ1ZmZlci0tO1xyXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGNvbEJ1ZmZlcnNbY3VycmVudEJ1ZmZlcl07XHJcbiAgICAgICAgICB0aGlzLmV4dGVuZChidWZmZXIsIGJ1ZmZlclBhZGRpbmcsIGhlaWdodCk7XHJcbiAgICAgICAgICB0aGlzLmZpbHRlcihidWZmZXIsIGJ1ZmZlclBhZGRpbmcsIGhlaWdodCk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBsYXN0IGJ1ZmZlciBpbiB0aGlzIGdyb3VwIG9mIGJ1ZmZlcnMsIGZsdXNoIGFsbCBidWZmZXJzLlxyXG4gICAgICAgICAgaWYgKGN1cnJlbnRCdWZmZXIgPT09IDApIHtcclxuICAgICAgICAgICAgayA9IHUgLSBudW1CdWZmZXJzICsgMTtcclxuICAgICAgICAgICAgZm9yIChsID0gYnVmZmVyUGFkZGluZzsgbCA8IGxsOyBrICs9IHdpZHRoLCBsKyspIHtcclxuICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbnVtQnVmZmVyczsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtc1trICsgYl0gPSBjb2xCdWZmZXJzW2JdW2xdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgaXRlbXM6IGl0ZW1zXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyYW5zZm9ybTtcclxuICB9KSgpO1xyXG5cclxuICAvLyBTZWN0aW9uIDMuOC4yIElycmV2ZXJzaWJsZSA5LTcgZmlsdGVyXHJcbiAgdmFyIElycmV2ZXJzaWJsZVRyYW5zZm9ybSA9IChmdW5jdGlvbiBJcnJldmVyc2libGVUcmFuc2Zvcm1DbG9zdXJlKCkge1xyXG4gICAgZnVuY3Rpb24gSXJyZXZlcnNpYmxlVHJhbnNmb3JtKCkge1xyXG4gICAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBJcnJldmVyc2libGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcclxuICAgIElycmV2ZXJzaWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZmlsdGVyID1cclxuICAgICAgZnVuY3Rpb24gaXJyZXZlcnNpYmxlVHJhbnNmb3JtRmlsdGVyKHgsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBsZW4gPSBsZW5ndGggPj4gMTtcclxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcclxuICAgICAgdmFyIGosIG4sIGN1cnJlbnQsIG5leHQ7XHJcblxyXG4gICAgICB2YXIgYWxwaGEgPSAtMS41ODYxMzQzNDIwNTk5MjQ7XHJcbiAgICAgIHZhciBiZXRhID0gLTAuMDUyOTgwMTE4NTcyOTYxO1xyXG4gICAgICB2YXIgZ2FtbWEgPSAwLjg4MjkxMTA3NTUzMDkzNDtcclxuICAgICAgdmFyIGRlbHRhID0gMC40NDM1MDY4NTIwNDM5NzE7XHJcbiAgICAgIHZhciBLID0gMS4yMzAxNzQxMDQ5MTQwMDE7XHJcbiAgICAgIHZhciBLXyA9IDEgLyBLO1xyXG5cclxuICAgICAgLy8gc3RlcCAxIGlzIGNvbWJpbmVkIHdpdGggc3RlcCAzXHJcblxyXG4gICAgICAvLyBzdGVwIDJcclxuICAgICAgaiA9IG9mZnNldCAtIDM7XHJcbiAgICAgIGZvciAobiA9IGxlbiArIDQ7IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgeFtqXSAqPSBLXztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RlcCAxICYgM1xyXG4gICAgICBqID0gb2Zmc2V0IC0gMjtcclxuICAgICAgY3VycmVudCA9IGRlbHRhICogeFtqIC0xXTtcclxuICAgICAgZm9yIChuID0gbGVuICsgMzsgbi0tOyBqICs9IDIpIHtcclxuICAgICAgICBuZXh0ID0gZGVsdGEgKiB4W2ogKyAxXTtcclxuICAgICAgICB4W2pdID0gSyAqIHhbal0gLSBjdXJyZW50IC0gbmV4dDtcclxuICAgICAgICBpZiAobi0tKSB7XHJcbiAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICBjdXJyZW50ID0gZGVsdGEgKiB4W2ogKyAxXTtcclxuICAgICAgICAgIHhbal0gPSBLICogeFtqXSAtIGN1cnJlbnQgLSBuZXh0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHN0ZXAgNFxyXG4gICAgICBqID0gb2Zmc2V0IC0gMTtcclxuICAgICAgY3VycmVudCA9IGdhbW1hICogeFtqIC0gMV07XHJcbiAgICAgIGZvciAobiA9IGxlbiArIDI7IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgbmV4dCA9IGdhbW1hICogeFtqICsgMV07XHJcbiAgICAgICAgeFtqXSAtPSBjdXJyZW50ICsgbmV4dDtcclxuICAgICAgICBpZiAobi0tKSB7XHJcbiAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICBjdXJyZW50ID0gZ2FtbWEgKiB4W2ogKyAxXTtcclxuICAgICAgICAgIHhbal0gLT0gY3VycmVudCArIG5leHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RlcCA1XHJcbiAgICAgIGogPSBvZmZzZXQ7XHJcbiAgICAgIGN1cnJlbnQgPSBiZXRhICogeFtqIC0gMV07XHJcbiAgICAgIGZvciAobiA9IGxlbiArIDE7IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgbmV4dCA9IGJldGEgKiB4W2ogKyAxXTtcclxuICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xyXG4gICAgICAgIGlmIChuLS0pIHtcclxuICAgICAgICAgIGogKz0gMjtcclxuICAgICAgICAgIGN1cnJlbnQgPSBiZXRhICogeFtqICsgMV07XHJcbiAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHN0ZXAgNlxyXG4gICAgICBpZiAobGVuICE9PSAwKSB7XHJcbiAgICAgICAgaiA9IG9mZnNldCArIDE7XHJcbiAgICAgICAgY3VycmVudCA9IGFscGhhICogeFtqIC0gMV07XHJcbiAgICAgICAgZm9yIChuID0gbGVuOyBuLS07IGogKz0gMikge1xyXG4gICAgICAgICAgbmV4dCA9IGFscGhhICogeFtqICsgMV07XHJcbiAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xyXG4gICAgICAgICAgaWYgKG4tLSkge1xyXG4gICAgICAgICAgICBqICs9IDI7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBhbHBoYSAqIHhbaiArIDFdO1xyXG4gICAgICAgICAgICB4W2pdIC09IGN1cnJlbnQgKyBuZXh0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJcnJldmVyc2libGVUcmFuc2Zvcm07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gU2VjdGlvbiAzLjguMSBSZXZlcnNpYmxlIDUtMyBmaWx0ZXJcclxuICB2YXIgUmV2ZXJzaWJsZVRyYW5zZm9ybSA9IChmdW5jdGlvbiBSZXZlcnNpYmxlVHJhbnNmb3JtQ2xvc3VyZSgpIHtcclxuICAgIGZ1bmN0aW9uIFJldmVyc2libGVUcmFuc2Zvcm0oKSB7XHJcbiAgICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIFJldmVyc2libGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm0ucHJvdG90eXBlKTtcclxuICAgIFJldmVyc2libGVUcmFuc2Zvcm0ucHJvdG90eXBlLmZpbHRlciA9XHJcbiAgICAgIGZ1bmN0aW9uIHJldmVyc2libGVUcmFuc2Zvcm1GaWx0ZXIoeCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+PiAxO1xyXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xyXG4gICAgICB2YXIgaiwgbjtcclxuXHJcbiAgICAgIGZvciAoaiA9IG9mZnNldCwgbiA9IGxlbiArIDE7IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgeFtqXSAtPSAoeFtqIC0gMV0gKyB4W2ogKyAxXSArIDIpID4+IDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaiA9IG9mZnNldCArIDEsIG4gPSBsZW47IG4tLTsgaiArPSAyKSB7XHJcbiAgICAgICAgeFtqXSArPSAoeFtqIC0gMV0gKyB4W2ogKyAxXSkgPj4gMTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUmV2ZXJzaWJsZVRyYW5zZm9ybTtcclxuICB9KSgpO1xyXG5cclxuICByZXR1cm4gSnB4SW1hZ2U7XHJcbn0pKCk7XHJcblxyXG5cclxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cclxuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xyXG4vKiBDb3B5cmlnaHQgMjAxMiBNb3ppbGxhIEZvdW5kYXRpb25cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBRTSBDb2RlciBkZWNvZGluZyBhcyBkZWZpbmVkIGluXHJcbiAqICAgSlBFRyAyMDAwIFBhcnQgSSBGaW5hbCBDb21taXR0ZWUgRHJhZnQgVmVyc2lvbiAxLjBcclxuICogICBBbm5leCBDLjMgQXJpdGhtZXRpYyBkZWNvZGluZyBwcm9jZWR1cmUgXHJcbiAqIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmpwZWcub3JnL3B1YmxpYy9mY2QxNTQ0NC0xLnBkZlxyXG4gKiBcclxuICogVGhlIGFyaXRobWV0aWMgZGVjb2RlciBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggY29udGV4dCBtb2RlbHMgdG8gZGVjb2RlXHJcbiAqIEpQRUcyMDAwIGFuZCBKQklHMiBzdHJlYW1zLlxyXG4gKi9cclxudmFyIEFyaXRobWV0aWNEZWNvZGVyID0gKGZ1bmN0aW9uIEFyaXRobWV0aWNEZWNvZGVyQ2xvc3VyZSgpIHtcclxuICAvLyBUYWJsZSBDLTJcclxuICB2YXIgUWVUYWJsZSA9IFtcclxuICAgIHtxZTogMHg1NjAxLCBubXBzOiAxLCBubHBzOiAxLCBzd2l0Y2hGbGFnOiAxfSxcclxuICAgIHtxZTogMHgzNDAxLCBubXBzOiAyLCBubHBzOiA2LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxODAxLCBubXBzOiAzLCBubHBzOiA5LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwQUMxLCBubXBzOiA0LCBubHBzOiAxMiwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDUyMSwgbm1wczogNSwgbmxwczogMjksIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAyMjEsIG5tcHM6IDM4LCBubHBzOiAzMywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogNywgbmxwczogNiwgc3dpdGNoRmxhZzogMX0sXHJcbiAgICB7cWU6IDB4NTQwMSwgbm1wczogOCwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDQ4MDEsIG5tcHM6IDksIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgzODAxLCBubXBzOiAxMCwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDMwMDEsIG5tcHM6IDExLCBubHBzOiAxNywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MjQwMSwgbm1wczogMTIsIG5scHM6IDE4LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxQzAxLCBubXBzOiAxMywgbmxwczogMjAsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDE2MDEsIG5tcHM6IDI5LCBubHBzOiAyMSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NTYwMSwgbm1wczogMTUsIG5scHM6IDE0LCBzd2l0Y2hGbGFnOiAxfSxcclxuICAgIHtxZTogMHg1NDAxLCBubXBzOiAxNiwgbmxwczogMTQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDUxMDEsIG5tcHM6IDE3LCBubHBzOiAxNSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4NDgwMSwgbm1wczogMTgsIG5scHM6IDE2LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgzODAxLCBubXBzOiAxOSwgbmxwczogMTcsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDM0MDEsIG5tcHM6IDIwLCBubHBzOiAxOCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MzAwMSwgbm1wczogMjEsIG5scHM6IDE5LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgyODAxLCBubXBzOiAyMiwgbmxwczogMTksIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDI0MDEsIG5tcHM6IDIzLCBubHBzOiAyMCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MjIwMSwgbm1wczogMjQsIG5scHM6IDIxLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxQzAxLCBubXBzOiAyNSwgbmxwczogMjIsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDE4MDEsIG5tcHM6IDI2LCBubHBzOiAyMywgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MTYwMSwgbm1wczogMjcsIG5scHM6IDI0LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgxNDAxLCBubXBzOiAyOCwgbmxwczogMjUsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDEyMDEsIG5tcHM6IDI5LCBubHBzOiAyNiwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MTEwMSwgbm1wczogMzAsIG5scHM6IDI3LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwQUMxLCBubXBzOiAzMSwgbmxwczogMjgsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDA5QzEsIG5tcHM6IDMyLCBubHBzOiAyOSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDhBMSwgbm1wczogMzMsIG5scHM6IDMwLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwNTIxLCBubXBzOiAzNCwgbmxwczogMzEsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDA0NDEsIG5tcHM6IDM1LCBubHBzOiAzMiwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDJBMSwgbm1wczogMzYsIG5scHM6IDMzLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMjIxLCBubXBzOiAzNywgbmxwczogMzQsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAxNDEsIG5tcHM6IDM4LCBubHBzOiAzNSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDExMSwgbm1wczogMzksIG5scHM6IDM2LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMDg1LCBubXBzOiA0MCwgbmxwczogMzcsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAwNDksIG5tcHM6IDQxLCBubHBzOiAzOCwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDAyNSwgbm1wczogNDIsIG5scHM6IDM5LCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMDE1LCBubXBzOiA0MywgbmxwczogNDAsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDAwMDksIG5tcHM6IDQ0LCBubHBzOiA0MSwgc3dpdGNoRmxhZzogMH0sXHJcbiAgICB7cWU6IDB4MDAwNSwgbm1wczogNDUsIG5scHM6IDQyLCBzd2l0Y2hGbGFnOiAwfSxcclxuICAgIHtxZTogMHgwMDAxLCBubXBzOiA0NSwgbmxwczogNDMsIHN3aXRjaEZsYWc6IDB9LFxyXG4gICAge3FlOiAweDU2MDEsIG5tcHM6IDQ2LCBubHBzOiA0Niwgc3dpdGNoRmxhZzogMH1cclxuICBdO1xyXG5cclxuICAvLyBDLjMuNSBJbml0aWFsaXNhdGlvbiBvZiB0aGUgZGVjb2RlciAoSU5JVERFQylcclxuICBmdW5jdGlvbiBBcml0aG1ldGljRGVjb2RlcihkYXRhLCBzdGFydCwgZW5kKSB7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5icCA9IHN0YXJ0O1xyXG4gICAgdGhpcy5kYXRhRW5kID0gZW5kO1xyXG5cclxuICAgIHRoaXMuY2hpZ2ggPSBkYXRhW3N0YXJ0XTtcclxuICAgIHRoaXMuY2xvdyA9IDA7XHJcblxyXG4gICAgdGhpcy5ieXRlSW4oKTtcclxuXHJcbiAgICB0aGlzLmNoaWdoID0gKCh0aGlzLmNoaWdoIDw8IDcpICYgMHhGRkZGKSB8ICgodGhpcy5jbG93ID4+IDkpICYgMHg3Rik7XHJcbiAgICB0aGlzLmNsb3cgPSAodGhpcy5jbG93IDw8IDcpICYgMHhGRkZGO1xyXG4gICAgdGhpcy5jdCAtPSA3O1xyXG4gICAgdGhpcy5hID0gMHg4MDAwO1xyXG4gIH1cclxuXHJcbiAgQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlID0ge1xyXG4gICAgLy8gQy4zLjQgQ29tcHJlc3NlZCBkYXRhIGlucHV0IChCWVRFSU4pXHJcbiAgICBieXRlSW46IGZ1bmN0aW9uIEFyaXRobWV0aWNEZWNvZGVyX2J5dGVJbigpIHtcclxuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgIHZhciBicCA9IHRoaXMuYnA7XHJcbiAgICAgIGlmIChkYXRhW2JwXSA9PT0gMHhGRikge1xyXG4gICAgICAgIHZhciBiMSA9IGRhdGFbYnAgKyAxXTtcclxuICAgICAgICBpZiAoYjEgPiAweDhGKSB7XHJcbiAgICAgICAgICB0aGlzLmNsb3cgKz0gMHhGRjAwO1xyXG4gICAgICAgICAgdGhpcy5jdCA9IDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJwKys7XHJcbiAgICAgICAgICB0aGlzLmNsb3cgKz0gKGRhdGFbYnBdIDw8IDkpO1xyXG4gICAgICAgICAgdGhpcy5jdCA9IDc7XHJcbiAgICAgICAgICB0aGlzLmJwID0gYnA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJwKys7XHJcbiAgICAgICAgdGhpcy5jbG93ICs9IGJwIDwgdGhpcy5kYXRhRW5kID8gKGRhdGFbYnBdIDw8IDgpIDogMHhGRjAwO1xyXG4gICAgICAgIHRoaXMuY3QgPSA4O1xyXG4gICAgICAgIHRoaXMuYnAgPSBicDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jbG93ID4gMHhGRkZGKSB7XHJcbiAgICAgICAgdGhpcy5jaGlnaCArPSAodGhpcy5jbG93ID4+IDE2KTtcclxuICAgICAgICB0aGlzLmNsb3cgJj0gMHhGRkZGO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gQy4zLjIgRGVjb2RpbmcgYSBkZWNpc2lvbiAoREVDT0RFKVxyXG4gICAgcmVhZEJpdDogZnVuY3Rpb24gQXJpdGhtZXRpY0RlY29kZXJfcmVhZEJpdChjb250ZXh0cywgcG9zKSB7XHJcbiAgICAgIC8vIGNvbnRleHRzIGFyZSBwYWNrZWQgaW50byAxIGJ5dGU6XHJcbiAgICAgIC8vIGhpZ2hlc3QgNyBiaXRzIGNhcnJ5IGN4LmluZGV4LCBsb3dlc3QgYml0IGNhcnJpZXMgY3gubXBzXHJcbiAgICAgIHZhciBjeF9pbmRleCA9IGNvbnRleHRzW3Bvc10gPj4gMSwgY3hfbXBzID0gY29udGV4dHNbcG9zXSAmIDE7XHJcbiAgICAgIHZhciBxZVRhYmxlSWN4ID0gUWVUYWJsZVtjeF9pbmRleF07XHJcbiAgICAgIHZhciBxZUljeCA9IHFlVGFibGVJY3gucWU7XHJcbiAgICAgIHZhciBkO1xyXG4gICAgICB2YXIgYSA9IHRoaXMuYSAtIHFlSWN4O1xyXG5cclxuICAgICAgaWYgKHRoaXMuY2hpZ2ggPCBxZUljeCkge1xyXG4gICAgICAgIC8vIGV4Y2hhbmdlTHBzXHJcbiAgICAgICAgaWYgKGEgPCBxZUljeCkge1xyXG4gICAgICAgICAgYSA9IHFlSWN4O1xyXG4gICAgICAgICAgZCA9IGN4X21wcztcclxuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubXBzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gcWVJY3g7XHJcbiAgICAgICAgICBkID0gMSBeIGN4X21wcztcclxuICAgICAgICAgIGlmIChxZVRhYmxlSWN4LnN3aXRjaEZsYWcgPT09IDEpIHtcclxuICAgICAgICAgICAgY3hfbXBzID0gZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGN4X2luZGV4ID0gcWVUYWJsZUljeC5ubHBzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNoaWdoIC09IHFlSWN4O1xyXG4gICAgICAgIGlmICgoYSAmIDB4ODAwMCkgIT09IDApIHtcclxuICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgICByZXR1cm4gY3hfbXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleGNoYW5nZU1wc1xyXG4gICAgICAgIGlmIChhIDwgcWVJY3gpIHtcclxuICAgICAgICAgIGQgPSAxIF4gY3hfbXBzO1xyXG4gICAgICAgICAgaWYgKHFlVGFibGVJY3guc3dpdGNoRmxhZyA9PT0gMSkge1xyXG4gICAgICAgICAgICBjeF9tcHMgPSBkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3hfaW5kZXggPSBxZVRhYmxlSWN4Lm5scHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGQgPSBjeF9tcHM7XHJcbiAgICAgICAgICBjeF9pbmRleCA9IHFlVGFibGVJY3gubm1wcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gQy4zLjMgcmVub3JtRDtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIGlmICh0aGlzLmN0ID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLmJ5dGVJbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYSA8PD0gMTtcclxuICAgICAgICB0aGlzLmNoaWdoID0gKCh0aGlzLmNoaWdoIDw8IDEpICYgMHhGRkZGKSB8ICgodGhpcy5jbG93ID4+IDE1KSAmIDEpO1xyXG4gICAgICAgIHRoaXMuY2xvdyA9ICh0aGlzLmNsb3cgPDwgMSkgJiAweEZGRkY7XHJcbiAgICAgICAgdGhpcy5jdC0tO1xyXG4gICAgICB9IHdoaWxlICgoYSAmIDB4ODAwMCkgPT09IDApO1xyXG4gICAgICB0aGlzLmEgPSBhO1xyXG5cclxuICAgICAgY29udGV4dHNbcG9zXSA9IGN4X2luZGV4IDw8IDEgfCBjeF9tcHM7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBBcml0aG1ldGljRGVjb2RlcjtcclxufSkoKTtcclxuXHJcbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotICovXHJcbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cclxuLyogQ29weXJpZ2h0IDIwMTIgTW96aWxsYSBGb3VuZGF0aW9uXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyogZ2xvYmFscyBDbWQsIENvbG9yU3BhY2UsIERpY3QsIE1vekJsb2JCdWlsZGVyLCBOYW1lLCBQREZKUywgUmVmLCBVUkwsXHJcbiAgICAgICAgICAgUHJvbWlzZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdsb2JhbFNjb3BlID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMgOiB3aW5kb3c7XHJcblxyXG52YXIgaXNXb3JrZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpO1xyXG5cclxudmFyIEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XHJcblxyXG52YXIgVGV4dFJlbmRlcmluZ01vZGUgPSB7XHJcbiAgRklMTDogMCxcclxuICBTVFJPS0U6IDEsXHJcbiAgRklMTF9TVFJPS0U6IDIsXHJcbiAgSU5WSVNJQkxFOiAzLFxyXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXHJcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxyXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxyXG4gIEFERF9UT19QQVRIOiA3LFxyXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXHJcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxyXG59O1xyXG5cclxudmFyIEltYWdlS2luZCA9IHtcclxuICBHUkFZU0NBTEVfMUJQUDogMSxcclxuICBSR0JfMjRCUFA6IDIsXHJcbiAgUkdCQV8zMkJQUDogM1xyXG59O1xyXG5cclxudmFyIEFubm90YXRpb25UeXBlID0ge1xyXG4gIFdJREdFVDogMSxcclxuICBURVhUOiAyLFxyXG4gIExJTks6IDNcclxufTtcclxuXHJcbnZhciBTdHJlYW1UeXBlID0ge1xyXG4gIFVOS05PV046IDAsXHJcbiAgRkxBVEU6IDEsXHJcbiAgTFpXOiAyLFxyXG4gIERDVDogMyxcclxuICBKUFg6IDQsXHJcbiAgSkJJRzogNSxcclxuICBBODU6IDYsXHJcbiAgQUhYOiA3LFxyXG4gIENDRjogOCxcclxuICBSTDogOVxyXG59O1xyXG5cclxudmFyIEZvbnRUeXBlID0ge1xyXG4gIFVOS05PV046IDAsXHJcbiAgVFlQRTE6IDEsXHJcbiAgVFlQRTFDOiAyLFxyXG4gIENJREZPTlRUWVBFMDogMyxcclxuICBDSURGT05UVFlQRTBDOiA0LFxyXG4gIFRSVUVUWVBFOiA1LFxyXG4gIENJREZPTlRUWVBFMjogNixcclxuICBUWVBFMzogNyxcclxuICBPUEVOVFlQRTogOCxcclxuICBUWVBFMDogOSxcclxuICBNTVRZUEUxOiAxMFxyXG59O1xyXG5cclxuLy8gVGhlIGdsb2JhbCBQREZKUyBvYmplY3QgZXhwb3NlcyB0aGUgQVBJXHJcbi8vIEluIHByb2R1Y3Rpb24sIGl0IHdpbGwgYmUgZGVjbGFyZWQgb3V0c2lkZSBhIGdsb2JhbCB3cmFwcGVyXHJcbi8vIEluIGRldmVsb3BtZW50LCBpdCB3aWxsIGJlIGRlY2xhcmVkIGhlcmVcclxuaWYgKCFnbG9iYWxTY29wZS5QREZKUykge1xyXG4gIGdsb2JhbFNjb3BlLlBERkpTID0ge307XHJcbn1cclxuXHJcbmdsb2JhbFNjb3BlLlBERkpTLnBkZkJ1ZyA9IGZhbHNlO1xyXG5cclxuUERGSlMuVkVSQk9TSVRZX0xFVkVMUyA9IHtcclxuICBlcnJvcnM6IDAsXHJcbiAgd2FybmluZ3M6IDEsXHJcbiAgaW5mb3M6IDVcclxufTtcclxuXHJcbi8vIEFsbCB0aGUgcG9zc2libGUgb3BlcmF0aW9ucyBmb3IgYW4gb3BlcmF0b3IgbGlzdC5cclxudmFyIE9QUyA9IFBERkpTLk9QUyA9IHtcclxuICAvLyBJbnRlbnRpb25hbGx5IHN0YXJ0IGZyb20gMSBzbyBpdCBpcyBlYXN5IHRvIHNwb3QgYmFkIG9wZXJhdG9ycyB0aGF0IHdpbGwgYmVcclxuICAvLyAwJ3MuXHJcbiAgZGVwZW5kZW5jeTogMSxcclxuICBzZXRMaW5lV2lkdGg6IDIsXHJcbiAgc2V0TGluZUNhcDogMyxcclxuICBzZXRMaW5lSm9pbjogNCxcclxuICBzZXRNaXRlckxpbWl0OiA1LFxyXG4gIHNldERhc2g6IDYsXHJcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxyXG4gIHNldEZsYXRuZXNzOiA4LFxyXG4gIHNldEdTdGF0ZTogOSxcclxuICBzYXZlOiAxMCxcclxuICByZXN0b3JlOiAxMSxcclxuICB0cmFuc2Zvcm06IDEyLFxyXG4gIG1vdmVUbzogMTMsXHJcbiAgbGluZVRvOiAxNCxcclxuICBjdXJ2ZVRvOiAxNSxcclxuICBjdXJ2ZVRvMjogMTYsXHJcbiAgY3VydmVUbzM6IDE3LFxyXG4gIGNsb3NlUGF0aDogMTgsXHJcbiAgcmVjdGFuZ2xlOiAxOSxcclxuICBzdHJva2U6IDIwLFxyXG4gIGNsb3NlU3Ryb2tlOiAyMSxcclxuICBmaWxsOiAyMixcclxuICBlb0ZpbGw6IDIzLFxyXG4gIGZpbGxTdHJva2U6IDI0LFxyXG4gIGVvRmlsbFN0cm9rZTogMjUsXHJcbiAgY2xvc2VGaWxsU3Ryb2tlOiAyNixcclxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXHJcbiAgZW5kUGF0aDogMjgsXHJcbiAgY2xpcDogMjksXHJcbiAgZW9DbGlwOiAzMCxcclxuICBiZWdpblRleHQ6IDMxLFxyXG4gIGVuZFRleHQ6IDMyLFxyXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcclxuICBzZXRXb3JkU3BhY2luZzogMzQsXHJcbiAgc2V0SFNjYWxlOiAzNSxcclxuICBzZXRMZWFkaW5nOiAzNixcclxuICBzZXRGb250OiAzNyxcclxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZTogMzgsXHJcbiAgc2V0VGV4dFJpc2U6IDM5LFxyXG4gIG1vdmVUZXh0OiA0MCxcclxuICBzZXRMZWFkaW5nTW92ZVRleHQ6IDQxLFxyXG4gIHNldFRleHRNYXRyaXg6IDQyLFxyXG4gIG5leHRMaW5lOiA0MyxcclxuICBzaG93VGV4dDogNDQsXHJcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxyXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxyXG4gIG5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0OiA0NyxcclxuICBzZXRDaGFyV2lkdGg6IDQ4LFxyXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXHJcbiAgc2V0U3Ryb2tlQ29sb3JTcGFjZTogNTAsXHJcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxyXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcclxuICBzZXRTdHJva2VDb2xvck46IDUzLFxyXG4gIHNldEZpbGxDb2xvcjogNTQsXHJcbiAgc2V0RmlsbENvbG9yTjogNTUsXHJcbiAgc2V0U3Ryb2tlR3JheTogNTYsXHJcbiAgc2V0RmlsbEdyYXk6IDU3LFxyXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcclxuICBzZXRGaWxsUkdCQ29sb3I6IDU5LFxyXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXHJcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXHJcbiAgc2hhZGluZ0ZpbGw6IDYyLFxyXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxyXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcclxuICBlbmRJbmxpbmVJbWFnZTogNjUsXHJcbiAgcGFpbnRYT2JqZWN0OiA2NixcclxuICBtYXJrUG9pbnQ6IDY3LFxyXG4gIG1hcmtQb2ludFByb3BzOiA2OCxcclxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxyXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcclxuICBlbmRNYXJrZWRDb250ZW50OiA3MSxcclxuICBiZWdpbkNvbXBhdDogNzIsXHJcbiAgZW5kQ29tcGF0OiA3MyxcclxuICBwYWludEZvcm1YT2JqZWN0QmVnaW46IDc0LFxyXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxyXG4gIGJlZ2luR3JvdXA6IDc2LFxyXG4gIGVuZEdyb3VwOiA3NyxcclxuICBiZWdpbkFubm90YXRpb25zOiA3OCxcclxuICBlbmRBbm5vdGF0aW9uczogNzksXHJcbiAgYmVnaW5Bbm5vdGF0aW9uOiA4MCxcclxuICBlbmRBbm5vdGF0aW9uOiA4MSxcclxuICBwYWludEpwZWdYT2JqZWN0OiA4MixcclxuICBwYWludEltYWdlTWFza1hPYmplY3Q6IDgzLFxyXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcclxuICBwYWludEltYWdlWE9iamVjdDogODUsXHJcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6IDg2LFxyXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxyXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcclxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IDg5LFxyXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXHJcbiAgY29uc3RydWN0UGF0aDogOTFcclxufTtcclxuXHJcbi8vIEEgbm90aWNlIGZvciBkZXZzLiBUaGVzZSBhcmUgZ29vZCBmb3IgdGhpbmdzIHRoYXQgYXJlIGhlbHBmdWwgdG8gZGV2cywgc3VjaFxyXG4vLyBhcyB3YXJuaW5nIHRoYXQgV29ya2VycyB3ZXJlIGRpc2FibGVkLCB3aGljaCBpcyBpbXBvcnRhbnQgdG8gZGV2cyBidXQgbm90XHJcbi8vIGVuZCB1c2Vycy5cclxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcclxuICBpZiAoUERGSlMudmVyYm9zaXR5ID49IFBERkpTLlZFUkJPU0lUWV9MRVZFTFMuaW5mb3MpIHtcclxuICAgIGNvbnNvbGUubG9nKCdJbmZvOiAnICsgbXNnKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIE5vbi1mYXRhbCB3YXJuaW5ncy5cclxuZnVuY3Rpb24gd2Fybihtc2cpIHtcclxuICBpZiAoUERGSlMudmVyYm9zaXR5ID49IFBERkpTLlZFUkJPU0lUWV9MRVZFTFMud2FybmluZ3MpIHtcclxuICAgIGNvbnNvbGUubG9nKCdXYXJuaW5nOiAnICsgbXNnKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEZhdGFsIGVycm9ycyB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBmYWxsYmFjayBVSSBhbmQgaGFsdCBleGVjdXRpb24gYnlcclxuLy8gdGhyb3dpbmcgYW4gZXhjZXB0aW9uLlxyXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcclxuICAvLyBJZiBtdWx0aXBsZSBhcmd1bWVudHMgd2VyZSBwYXNzZWQsIHBhc3MgdGhlbSBhbGwgdG8gdGhlIGxvZyBmdW5jdGlvbi5cclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgIHZhciBsb2dBcmd1bWVudHMgPSBbJ0Vycm9yOiddO1xyXG4gICAgbG9nQXJndW1lbnRzLnB1c2guYXBwbHkobG9nQXJndW1lbnRzLCBhcmd1bWVudHMpO1xyXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbG9nQXJndW1lbnRzKTtcclxuICAgIC8vIEpvaW4gdGhlIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZyBmb3IgdGhlIGxpbmVzIGJlbG93LlxyXG4gICAgbXNnID0gW10uam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5sb2coJ0Vycm9yOiAnICsgbXNnKTtcclxuICB9XHJcbiAgY29uc29sZS5sb2coYmFja3RyYWNlKCkpO1xyXG4gIFVuc3VwcG9ydGVkTWFuYWdlci5ub3RpZnkoVU5TVVBQT1JURURfRkVBVFVSRVMudW5rbm93bik7XHJcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhY2t0cmFjZSgpIHtcclxuICB0cnkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGUuc3RhY2sgPyBlLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgyKS5qb2luKCdcXG4nKSA6ICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xyXG4gIGlmICghY29uZCkge1xyXG4gICAgZXJyb3IobXNnKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IFBERkpTLlVOU1VQUE9SVEVEX0ZFQVRVUkVTID0ge1xyXG4gIHVua25vd246ICd1bmtub3duJyxcclxuICBmb3JtczogJ2Zvcm1zJyxcclxuICBqYXZhU2NyaXB0OiAnamF2YVNjcmlwdCcsXHJcbiAgc21hc2s6ICdzbWFzaycsXHJcbiAgc2hhZGluZ1BhdHRlcm46ICdzaGFkaW5nUGF0dGVybicsXHJcbiAgZm9udDogJ2ZvbnQnXHJcbn07XHJcblxyXG52YXIgVW5zdXBwb3J0ZWRNYW5hZ2VyID0gUERGSlMuVW5zdXBwb3J0ZWRNYW5hZ2VyID1cclxuICAoZnVuY3Rpb24gVW5zdXBwb3J0ZWRNYW5hZ2VyQ2xvc3VyZSgpIHtcclxuICB2YXIgbGlzdGVuZXJzID0gW107XHJcbiAgcmV0dXJuIHtcclxuICAgIGxpc3RlbjogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgIGxpc3RlbmVycy5wdXNoKGNiKTtcclxuICAgIH0sXHJcbiAgICBub3RpZnk6IGZ1bmN0aW9uIChmZWF0dXJlSWQpIHtcclxuICAgICAgd2FybignVW5zdXBwb3J0ZWQgZmVhdHVyZSBcIicgKyBmZWF0dXJlSWQgKyAnXCInKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBsaXN0ZW5lcnNbaV0oZmVhdHVyZUlkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG4vLyBDb21iaW5lcyB0d28gVVJMcy4gVGhlIGJhc2VVcmwgc2hhbGwgYmUgYWJzb2x1dGUgVVJMLiBJZiB0aGUgdXJsIGlzIGFuXHJcbi8vIGFic29sdXRlIFVSTCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cclxuZnVuY3Rpb24gY29tYmluZVVybChiYXNlVXJsLCB1cmwpIHtcclxuICBpZiAoIXVybCkge1xyXG4gICAgcmV0dXJuIGJhc2VVcmw7XHJcbiAgfVxyXG4gIGlmICgvXlthLXpdW2EtejAtOStcXC0uXSo6L2kudGVzdCh1cmwpKSB7XHJcbiAgICByZXR1cm4gdXJsO1xyXG4gIH1cclxuICB2YXIgaTtcclxuICBpZiAodXJsLmNoYXJBdCgwKSA9PT0gJy8nKSB7XHJcbiAgICAvLyBhYnNvbHV0ZSBwYXRoXHJcbiAgICBpID0gYmFzZVVybC5pbmRleE9mKCc6Ly8nKTtcclxuICAgIGlmICh1cmwuY2hhckF0KDEpID09PSAnLycpIHtcclxuICAgICAgKytpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSA9IGJhc2VVcmwuaW5kZXhPZignLycsIGkgKyAzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlVXJsLnN1YnN0cmluZygwLCBpKSArIHVybDtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gcmVsYXRpdmUgcGF0aFxyXG4gICAgdmFyIHBhdGhMZW5ndGggPSBiYXNlVXJsLmxlbmd0aDtcclxuICAgIGkgPSBiYXNlVXJsLmxhc3RJbmRleE9mKCcjJyk7XHJcbiAgICBwYXRoTGVuZ3RoID0gaSA+PSAwID8gaSA6IHBhdGhMZW5ndGg7XHJcbiAgICBpID0gYmFzZVVybC5sYXN0SW5kZXhPZignPycsIHBhdGhMZW5ndGgpO1xyXG4gICAgcGF0aExlbmd0aCA9IGkgPj0gMCA/IGkgOiBwYXRoTGVuZ3RoO1xyXG4gICAgdmFyIHByZWZpeExlbmd0aCA9IGJhc2VVcmwubGFzdEluZGV4T2YoJy8nLCBwYXRoTGVuZ3RoKTtcclxuICAgIHJldHVybiBiYXNlVXJsLnN1YnN0cmluZygwLCBwcmVmaXhMZW5ndGggKyAxKSArIHVybDtcclxuICB9XHJcbn1cclxuXHJcbi8vIFZhbGlkYXRlcyBpZiBVUkwgaXMgc2FmZSBhbmQgYWxsb3dlZCwgZS5nLiB0byBhdm9pZCBYU1MuXHJcbmZ1bmN0aW9uIGlzVmFsaWRVcmwodXJsLCBhbGxvd1JlbGF0aXZlKSB7XHJcbiAgaWYgKCF1cmwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gUkZDIDM5ODYgKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjEpXHJcbiAgLy8gc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXHJcbiAgdmFyIHByb3RvY29sID0gL15bYS16XVthLXowLTkrXFwtLl0qKD89OikvaS5leGVjKHVybCk7XHJcbiAgaWYgKCFwcm90b2NvbCkge1xyXG4gICAgcmV0dXJuIGFsbG93UmVsYXRpdmU7XHJcbiAgfVxyXG4gIHByb3RvY29sID0gcHJvdG9jb2xbMF0udG9Mb3dlckNhc2UoKTtcclxuICBzd2l0Y2ggKHByb3RvY29sKSB7XHJcbiAgICBjYXNlICdodHRwJzpcclxuICAgIGNhc2UgJ2h0dHBzJzpcclxuICAgIGNhc2UgJ2Z0cCc6XHJcbiAgICBjYXNlICdtYWlsdG8nOlxyXG4gICAgY2FzZSAndGVsJzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblBERkpTLmlzVmFsaWRVcmwgPSBpc1ZhbGlkVXJsO1xyXG5cclxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7IHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UgfSk7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblBERkpTLnNoYWRvdyA9IHNoYWRvdztcclxuXHJcbnZhciBQYXNzd29yZFJlc3BvbnNlcyA9IFBERkpTLlBhc3N3b3JkUmVzcG9uc2VzID0ge1xyXG4gIE5FRURfUEFTU1dPUkQ6IDEsXHJcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXHJcbn07XHJcblxyXG52YXIgUGFzc3dvcmRFeGNlcHRpb24gPSAoZnVuY3Rpb24gUGFzc3dvcmRFeGNlcHRpb25DbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIFBhc3N3b3JkRXhjZXB0aW9uKG1zZywgY29kZSkge1xyXG4gICAgdGhpcy5uYW1lID0gJ1Bhc3N3b3JkRXhjZXB0aW9uJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgfVxyXG5cclxuICBQYXNzd29yZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBQYXNzd29yZEV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFBhc3N3b3JkRXhjZXB0aW9uO1xyXG5cclxuICByZXR1cm4gUGFzc3dvcmRFeGNlcHRpb247XHJcbn0pKCk7XHJcblBERkpTLlBhc3N3b3JkRXhjZXB0aW9uID0gUGFzc3dvcmRFeGNlcHRpb247XHJcblxyXG52YXIgVW5rbm93bkVycm9yRXhjZXB0aW9uID0gKGZ1bmN0aW9uIFVua25vd25FcnJvckV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gVW5rbm93bkVycm9yRXhjZXB0aW9uKG1zZywgZGV0YWlscykge1xyXG4gICAgdGhpcy5uYW1lID0gJ1Vua25vd25FcnJvckV4Y2VwdGlvbic7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XHJcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xyXG4gIH1cclxuXHJcbiAgVW5rbm93bkVycm9yRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIFVua25vd25FcnJvckV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIFVua25vd25FcnJvckV4Y2VwdGlvbjtcclxufSkoKTtcclxuUERGSlMuVW5rbm93bkVycm9yRXhjZXB0aW9uID0gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xyXG5cclxudmFyIEludmFsaWRQREZFeGNlcHRpb24gPSAoZnVuY3Rpb24gSW52YWxpZFBERkV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gSW52YWxpZFBERkV4Y2VwdGlvbihtc2cpIHtcclxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUERGRXhjZXB0aW9uJztcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICB9XHJcblxyXG4gIEludmFsaWRQREZFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbiAgSW52YWxpZFBERkV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEludmFsaWRQREZFeGNlcHRpb247XHJcblxyXG4gIHJldHVybiBJbnZhbGlkUERGRXhjZXB0aW9uO1xyXG59KSgpO1xyXG5QREZKUy5JbnZhbGlkUERGRXhjZXB0aW9uID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcclxuXHJcbnZhciBNaXNzaW5nUERGRXhjZXB0aW9uID0gKGZ1bmN0aW9uIE1pc3NpbmdQREZFeGNlcHRpb25DbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIE1pc3NpbmdQREZFeGNlcHRpb24obXNnKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1BERkV4Y2VwdGlvbic7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XHJcbiAgfVxyXG5cclxuICBNaXNzaW5nUERGRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG4gIE1pc3NpbmdQREZFeGNlcHRpb24uY29uc3RydWN0b3IgPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xyXG5cclxuICByZXR1cm4gTWlzc2luZ1BERkV4Y2VwdGlvbjtcclxufSkoKTtcclxuUERGSlMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IE1pc3NpbmdQREZFeGNlcHRpb247XHJcblxyXG52YXIgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID1cclxuICAgIChmdW5jdGlvbiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25DbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihtc2csIHN0YXR1cykge1xyXG4gICAgdGhpcy5uYW1lID0gJ1VuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbic7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICB9XHJcblxyXG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XHJcblxyXG4gIHJldHVybiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XHJcbn0pKCk7XHJcblBERkpTLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcclxuXHJcbnZhciBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbkNsb3N1cmUoKSB7XHJcbiAgZnVuY3Rpb24gTm90SW1wbGVtZW50ZWRFeGNlcHRpb24obXNnKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XHJcbiAgfVxyXG5cclxuICBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbic7XHJcbiAgTm90SW1wbGVtZW50ZWRFeGNlcHRpb24uY29uc3RydWN0b3IgPSBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIE5vdEltcGxlbWVudGVkRXhjZXB0aW9uO1xyXG59KSgpO1xyXG5cclxudmFyIE1pc3NpbmdEYXRhRXhjZXB0aW9uID0gKGZ1bmN0aW9uIE1pc3NpbmdEYXRhRXhjZXB0aW9uQ2xvc3VyZSgpIHtcclxuICBmdW5jdGlvbiBNaXNzaW5nRGF0YUV4Y2VwdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICB0aGlzLmJlZ2luID0gYmVnaW47XHJcbiAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgIHRoaXMubWVzc2FnZSA9ICdNaXNzaW5nIGRhdGEgWycgKyBiZWdpbiArICcsICcgKyBlbmQgKyAnKSc7XHJcbiAgfVxyXG5cclxuICBNaXNzaW5nRGF0YUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBNaXNzaW5nRGF0YUV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdNaXNzaW5nRGF0YUV4Y2VwdGlvbic7XHJcbiAgTWlzc2luZ0RhdGFFeGNlcHRpb24uY29uc3RydWN0b3IgPSBNaXNzaW5nRGF0YUV4Y2VwdGlvbjtcclxuXHJcbiAgcmV0dXJuIE1pc3NpbmdEYXRhRXhjZXB0aW9uO1xyXG59KSgpO1xyXG5cclxudmFyIFhSZWZQYXJzZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiBYUmVmUGFyc2VFeGNlcHRpb25DbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIFhSZWZQYXJzZUV4Y2VwdGlvbihtc2cpIHtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcclxuICB9XHJcblxyXG4gIFhSZWZQYXJzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuICBYUmVmUGFyc2VFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSAnWFJlZlBhcnNlRXhjZXB0aW9uJztcclxuICBYUmVmUGFyc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBYUmVmUGFyc2VFeGNlcHRpb247XHJcblxyXG4gIHJldHVybiBYUmVmUGFyc2VFeGNlcHRpb247XHJcbn0pKCk7XHJcblxyXG5cclxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xyXG4gIGFzc2VydChieXRlcyAhPT0gbnVsbCAmJiB0eXBlb2YgYnl0ZXMgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgIGJ5dGVzLmxlbmd0aCAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZycpO1xyXG4gIHZhciBsZW5ndGggPSBieXRlcy5sZW5ndGg7XHJcbiAgdmFyIE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XHJcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xyXG4gIH1cclxuICB2YXIgc3RyQnVmID0gW107XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XHJcbiAgICB2YXIgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xyXG4gICAgdmFyIGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xyXG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xyXG4gIH1cclxuICByZXR1cm4gc3RyQnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xyXG4gIGFzc2VydCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJywgJ0ludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXMnKTtcclxuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcclxuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGO1xyXG4gIH1cclxuICByZXR1cm4gYnl0ZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKHZhbHVlID4+IDI0KSAmIDB4ZmYsICh2YWx1ZSA+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA+PiA4KSAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gIHZhciBuID0gMSwgaSA9IDA7XHJcbiAgd2hpbGUgKHggPiBuKSB7XHJcbiAgICBuIDw8PSAxO1xyXG4gICAgaSsrO1xyXG4gIH1cclxuICByZXR1cm4gaTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZEludDgoZGF0YSwgc3RhcnQpIHtcclxuICByZXR1cm4gKGRhdGFbc3RhcnRdIDw8IDI0KSA+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpIHtcclxuICByZXR1cm4gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KSB7XHJcbiAgcmV0dXJuICgoZGF0YVtvZmZzZXRdIDw8IDI0KSB8IChkYXRhW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAgICAgIChkYXRhW29mZnNldCArIDJdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAzXSkgPj4+IDA7XHJcbn1cclxuXHJcbi8vIExhenkgdGVzdCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgcGxhdGZvcm1cclxuLy8gTk9URTogVGhpcyB3aWxsIGJlICd0cnVlJyBmb3Igc2ltdWxhdGVkIFR5cGVkQXJyYXlzXHJcbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xyXG4gIHZhciBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoMik7XHJcbiAgYnVmZmVyOFswXSA9IDE7XHJcbiAgdmFyIGJ1ZmZlcjE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjguYnVmZmVyKTtcclxuICByZXR1cm4gKGJ1ZmZlcjE2WzBdID09PSAxKTtcclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBERkpTLCAnaXNMaXR0bGVFbmRpYW4nLCB7XHJcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gUERGSlNfaXNMaXR0bGVFbmRpYW4oKSB7XHJcbiAgICByZXR1cm4gc2hhZG93KFBERkpTLCAnaXNMaXR0bGVFbmRpYW4nLCBpc0xpdHRsZUVuZGlhbigpKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLy8jaWYgIShGSVJFRk9YIHx8IE1PWkNFTlRSQUwgfHwgQjJHIHx8IENIUk9NRSlcclxuLy8vLyBMYXp5IHRlc3QgaWYgdGhlIHVzZXJBZ2FudCBzdXBwb3J0IENhbnZhc1R5cGVkQXJyYXlzXHJcbmZ1bmN0aW9uIGhhc0NhbnZhc1R5cGVkQXJyYXlzKCkge1xyXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcclxuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgdmFyIGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSk7XHJcbiAgcmV0dXJuICh0eXBlb2YgaW1hZ2VEYXRhLmRhdGEuYnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQREZKUywgJ2hhc0NhbnZhc1R5cGVkQXJyYXlzJywge1xyXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIFBERkpTX2hhc0NhbnZhc1R5cGVkQXJyYXlzKCkge1xyXG4gICAgcmV0dXJuIHNoYWRvdyhQREZKUywgJ2hhc0NhbnZhc1R5cGVkQXJyYXlzJywgaGFzQ2FudmFzVHlwZWRBcnJheXMoKSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBVaW50MzJBcnJheVZpZXcgPSAoZnVuY3Rpb24gVWludDMyQXJyYXlWaWV3Q2xvc3VyZSgpIHtcclxuXHJcbiAgZnVuY3Rpb24gVWludDMyQXJyYXlWaWV3KGJ1ZmZlciwgbGVuZ3RoKSB7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gKHRoaXMuYnl0ZUxlbmd0aCA+PiAyKSA6IGxlbmd0aDtcclxuICAgIGVuc3VyZVVpbnQzMkFycmF5Vmlld1Byb3BzKHRoaXMubGVuZ3RoKTtcclxuICB9XHJcbiAgVWludDMyQXJyYXlWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gIHZhciB1aW50MzJBcnJheVZpZXdTZXR0ZXJzID0gMDtcclxuICBmdW5jdGlvbiBjcmVhdGVVaW50MzJBcnJheVByb3AoaW5kZXgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlciwgb2Zmc2V0ID0gaW5kZXggPDwgMjtcclxuICAgICAgICByZXR1cm4gKGJ1ZmZlcltvZmZzZXRdIHwgKGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCA4KSB8XHJcbiAgICAgICAgICAoYnVmZmVyW29mZnNldCArIDJdIDw8IDE2KSB8IChidWZmZXJbb2Zmc2V0ICsgM10gPDwgMjQpKSA+Pj4gMDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsIG9mZnNldCA9IGluZGV4IDw8IDI7XHJcbiAgICAgICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gOCkgJiAyNTU7XHJcbiAgICAgICAgYnVmZmVyW29mZnNldCArIDJdID0gKHZhbHVlID4+IDE2KSAmIDI1NTtcclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KSAmIDI1NTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVuc3VyZVVpbnQzMkFycmF5Vmlld1Byb3BzKGxlbmd0aCkge1xyXG4gICAgd2hpbGUgKHVpbnQzMkFycmF5Vmlld1NldHRlcnMgPCBsZW5ndGgpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVpbnQzMkFycmF5Vmlldy5wcm90b3R5cGUsXHJcbiAgICAgICAgdWludDMyQXJyYXlWaWV3U2V0dGVycyxcclxuICAgICAgICBjcmVhdGVVaW50MzJBcnJheVByb3AodWludDMyQXJyYXlWaWV3U2V0dGVycykpO1xyXG4gICAgICB1aW50MzJBcnJheVZpZXdTZXR0ZXJzKys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gVWludDMyQXJyYXlWaWV3O1xyXG59KSgpO1xyXG4vLyNlbHNlXHJcbi8vUERGSlMuaGFzQ2FudmFzVHlwZWRBcnJheXMgPSB0cnVlO1xyXG4vLyNlbmRpZlxyXG5cclxudmFyIElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcclxuXHJcbnZhciBVdGlsID0gUERGSlMuVXRpbCA9IChmdW5jdGlvbiBVdGlsQ2xvc3VyZSgpIHtcclxuICBmdW5jdGlvbiBVdGlsKCkge31cclxuXHJcbiAgdmFyIHJnYkJ1ZiA9IFsncmdiKCcsIDAsICcsJywgMCwgJywnLCAwLCAnKSddO1xyXG5cclxuICAvLyBtYWtlQ3NzUmdiKCkgY2FuIGJlIGNhbGxlZCB0aG91c2FuZHMgb2YgdGltZXMuIFVzaW5nIHxyZ2JCdWZ8IGF2b2lkc1xyXG4gIC8vIGNyZWF0aW5nIG1hbnkgaW50ZXJtZWRpYXRlIHN0cmluZ3MuXHJcbiAgVXRpbC5tYWtlQ3NzUmdiID0gZnVuY3Rpb24gVXRpbF9tYWtlQ3NzUmdiKHIsIGcsIGIpIHtcclxuICAgIHJnYkJ1ZlsxXSA9IHI7XHJcbiAgICByZ2JCdWZbM10gPSBnO1xyXG4gICAgcmdiQnVmWzVdID0gYjtcclxuICAgIHJldHVybiByZ2JCdWYuam9pbignJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29uY2F0ZW5hdGVzIHR3byB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gIFV0aWwudHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF90cmFuc2Zvcm0obTEsIG0yKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSxcclxuICAgICAgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sXHJcbiAgICAgIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLFxyXG4gICAgICBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSxcclxuICAgICAgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSxcclxuICAgICAgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XVxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuICAvLyBGb3IgMmQgYWZmaW5lIHRyYW5zZm9ybXNcclxuICBVdGlsLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseVRyYW5zZm9ybShwLCBtKSB7XHJcbiAgICB2YXIgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcclxuICAgIHZhciB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xyXG4gICAgcmV0dXJuIFt4dCwgeXRdO1xyXG4gIH07XHJcblxyXG4gIFV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gVXRpbF9hcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xyXG4gICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xyXG4gICAgdmFyIHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XHJcbiAgICB2YXIgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XHJcbiAgICByZXR1cm4gW3h0LCB5dF07XHJcbiAgfTtcclxuXHJcbiAgLy8gQXBwbGllcyB0aGUgdHJhbnNmb3JtIHRvIHRoZSByZWN0YW5nbGUgYW5kIGZpbmRzIHRoZSBtaW5pbXVtIGF4aWFsbHlcclxuICAvLyBhbGlnbmVkIGJvdW5kaW5nIGJveC5cclxuICBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94ID1cclxuICAgIGZ1bmN0aW9uIFV0aWxfZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xyXG5cclxuICAgIHZhciBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XHJcbiAgICB2YXIgcDIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xyXG4gICAgdmFyIHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xyXG4gICAgdmFyIHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgTWF0aC5taW4ocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLFxyXG4gICAgICBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksXHJcbiAgICAgIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSxcclxuICAgICAgTWF0aC5tYXgocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIFV0aWwuaW52ZXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIFV0aWxfaW52ZXJzZVRyYW5zZm9ybShtKSB7XHJcbiAgICB2YXIgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XHJcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsXHJcbiAgICAgIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xyXG4gIH07XHJcblxyXG4gIC8vIEFwcGx5IGEgZ2VuZXJpYyAzZCBtYXRyaXggTSBvbiBhIDMtdmVjdG9yIHY6XHJcbiAgLy8gICB8IGEgYiBjIHwgICB8IFggfFxyXG4gIC8vICAgfCBkIGUgZiB8IHggfCBZIHxcclxuICAvLyAgIHwgZyBoIGkgfCAgIHwgWiB8XHJcbiAgLy8gTSBpcyBhc3N1bWVkIHRvIGJlIHNlcmlhbGl6ZWQgYXMgW2EsYixjLGQsZSxmLGcsaCxpXSxcclxuICAvLyB3aXRoIHYgYXMgW1gsWSxaXVxyXG4gIFV0aWwuYXBwbHkzZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIFV0aWxfYXBwbHkzZFRyYW5zZm9ybShtLCB2KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBtWzBdICogdlswXSArIG1bMV0gKiB2WzFdICsgbVsyXSAqIHZbMl0sXHJcbiAgICAgIG1bM10gKiB2WzBdICsgbVs0XSAqIHZbMV0gKyBtWzVdICogdlsyXSxcclxuICAgICAgbVs2XSAqIHZbMF0gKyBtWzddICogdlsxXSArIG1bOF0gKiB2WzJdXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoaXMgY2FsY3VsYXRpb24gdXNlcyBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uLlxyXG4gIC8vIFRoZSBTVkQgY2FuIGJlIHJlcHJlc2VudGVkIHdpdGggZm9ybXVsYSBBID0gVVNWLiBXZSBhcmUgaW50ZXJlc3RlZCBpbiB0aGVcclxuICAvLyBtYXRyaXggUyBoZXJlIGJlY2F1c2UgaXQgcmVwcmVzZW50cyB0aGUgc2NhbGUgdmFsdWVzLlxyXG4gIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUgPVxyXG4gICAgZnVuY3Rpb24gVXRpbF9zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XHJcblxyXG4gICAgdmFyIHRyYW5zcG9zZSA9IFttWzBdLCBtWzJdLCBtWzFdLCBtWzNdXTtcclxuXHJcbiAgICAvLyBNdWx0aXBseSBtYXRyaXggbSB3aXRoIGl0cyB0cmFuc3Bvc2UuXHJcbiAgICB2YXIgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xyXG4gICAgdmFyIGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcclxuICAgIHZhciBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XHJcbiAgICB2YXIgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xyXG5cclxuICAgIC8vIFNvbHZlIHRoZSBzZWNvbmQgZGVncmVlIHBvbHlub21pYWwgdG8gZ2V0IHJvb3RzLlxyXG4gICAgdmFyIGZpcnN0ID0gKGEgKyBkKSAvIDI7XHJcbiAgICB2YXIgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiAoYSArIGQpIC0gNCAqIChhICogZCAtIGMgKiBiKSkgLyAyO1xyXG4gICAgdmFyIHN4ID0gZmlyc3QgKyBzZWNvbmQgfHwgMTtcclxuICAgIHZhciBzeSA9IGZpcnN0IC0gc2Vjb25kIHx8IDE7XHJcblxyXG4gICAgLy8gU2NhbGUgdmFsdWVzIGFyZSB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBlaWdlbnZhbHVlcy5cclxuICAgIHJldHVybiBbTWF0aC5zcXJ0KHN4KSwgTWF0aC5zcXJ0KHN5KV07XHJcbiAgfTtcclxuXHJcbiAgLy8gTm9ybWFsaXplIHJlY3RhbmdsZSByZWN0PVt4MSwgeTEsIHgyLCB5Ml0gc28gdGhhdCAoeDEseTEpIDwgKHgyLHkyKVxyXG4gIC8vIEZvciBjb29yZGluYXRlIHN5c3RlbXMgd2hvc2Ugb3JpZ2luIGxpZXMgaW4gdGhlIGJvdHRvbS1sZWZ0LCB0aGlzXHJcbiAgLy8gbWVhbnMgbm9ybWFsaXphdGlvbiB0byAoQkwsVFIpIG9yZGVyaW5nLiBGb3Igc3lzdGVtcyB3aXRoIG9yaWdpbiBpbiB0aGVcclxuICAvLyB0b3AtbGVmdCwgdGhpcyBtZWFucyAoVEwsQlIpIG9yZGVyaW5nLlxyXG4gIFV0aWwubm9ybWFsaXplUmVjdCA9IGZ1bmN0aW9uIFV0aWxfbm9ybWFsaXplUmVjdChyZWN0KSB7XHJcbiAgICB2YXIgciA9IHJlY3Quc2xpY2UoMCk7IC8vIGNsb25lIHJlY3RcclxuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xyXG4gICAgICByWzBdID0gcmVjdFsyXTtcclxuICAgICAgclsyXSA9IHJlY3RbMF07XHJcbiAgICB9XHJcbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcclxuICAgICAgclsxXSA9IHJlY3RbM107XHJcbiAgICAgIHJbM10gPSByZWN0WzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIHJlY3RhbmdsZSBbeDEsIHkxLCB4MiwgeTJdIGNvcnJlc3BvbmRpbmcgdG8gdGhlXHJcbiAgLy8gaW50ZXJzZWN0aW9uIG9mIHJlY3QxIGFuZCByZWN0Mi4gSWYgbm8gaW50ZXJzZWN0aW9uLCByZXR1cm5zICdmYWxzZSdcclxuICAvLyBUaGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzIG9mIHJlY3QxLCByZWN0MiBzaG91bGQgYmUgW3gxLCB5MSwgeDIsIHkyXVxyXG4gIFV0aWwuaW50ZXJzZWN0ID0gZnVuY3Rpb24gVXRpbF9pbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9yZGVyIHBvaW50cyBhbG9uZyB0aGUgYXhlc1xyXG4gICAgdmFyIG9yZGVyZWRYID0gW3JlY3QxWzBdLCByZWN0MVsyXSwgcmVjdDJbMF0sIHJlY3QyWzJdXS5zb3J0KGNvbXBhcmUpLFxyXG4gICAgICAgIG9yZGVyZWRZID0gW3JlY3QxWzFdLCByZWN0MVszXSwgcmVjdDJbMV0sIHJlY3QyWzNdXS5zb3J0KGNvbXBhcmUpLFxyXG4gICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIHJlY3QxID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QxKTtcclxuICAgIHJlY3QyID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QyKTtcclxuXHJcbiAgICAvLyBYOiBmaXJzdCBhbmQgc2Vjb25kIHBvaW50cyBiZWxvbmcgdG8gZGlmZmVyZW50IHJlY3RhbmdsZXM/XHJcbiAgICBpZiAoKG9yZGVyZWRYWzBdID09PSByZWN0MVswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDJbMF0pIHx8XHJcbiAgICAgICAgKG9yZGVyZWRYWzBdID09PSByZWN0MlswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDFbMF0pKSB7XHJcbiAgICAgIC8vIEludGVyc2VjdGlvbiBtdXN0IGJlIGJldHdlZW4gc2Vjb25kIGFuZCB0aGlyZCBwb2ludHNcclxuICAgICAgcmVzdWx0WzBdID0gb3JkZXJlZFhbMV07XHJcbiAgICAgIHJlc3VsdFsyXSA9IG9yZGVyZWRYWzJdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFk6IGZpcnN0IGFuZCBzZWNvbmQgcG9pbnRzIGJlbG9uZyB0byBkaWZmZXJlbnQgcmVjdGFuZ2xlcz9cclxuICAgIGlmICgob3JkZXJlZFlbMF0gPT09IHJlY3QxWzFdICYmIG9yZGVyZWRZWzFdID09PSByZWN0MlsxXSkgfHxcclxuICAgICAgICAob3JkZXJlZFlbMF0gPT09IHJlY3QyWzFdICYmIG9yZGVyZWRZWzFdID09PSByZWN0MVsxXSkpIHtcclxuICAgICAgLy8gSW50ZXJzZWN0aW9uIG11c3QgYmUgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIHBvaW50c1xyXG4gICAgICByZXN1bHRbMV0gPSBvcmRlcmVkWVsxXTtcclxuICAgICAgcmVzdWx0WzNdID0gb3JkZXJlZFlbMl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICBVdGlsLnNpZ24gPSBmdW5jdGlvbiBVdGlsX3NpZ24obnVtKSB7XHJcbiAgICByZXR1cm4gbnVtIDwgMCA/IC0xIDogMTtcclxuICB9O1xyXG5cclxuICBVdGlsLmFwcGVuZFRvQXJyYXkgPSBmdW5jdGlvbiBVdGlsX2FwcGVuZFRvQXJyYXkoYXJyMSwgYXJyMikge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJyMSwgYXJyMik7XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5wcmVwZW5kVG9BcnJheSA9IGZ1bmN0aW9uIFV0aWxfcHJlcGVuZFRvQXJyYXkoYXJyMSwgYXJyMikge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYXJyMSwgYXJyMik7XHJcbiAgfTtcclxuXHJcbiAgVXRpbC5leHRlbmRPYmogPSBmdW5jdGlvbiBleHRlbmRPYmoob2JqMSwgb2JqMikge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iajIpIHtcclxuICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFV0aWwuZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIFV0aWxfZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eShkaWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lKSB7XHJcbiAgICB3aGlsZSAoZGljdCAmJiAhZGljdC5oYXMobmFtZSkpIHtcclxuICAgICAgZGljdCA9IGRpY3QuZ2V0KCdQYXJlbnQnKTtcclxuICAgIH1cclxuICAgIGlmICghZGljdCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBkaWN0LmdldChuYW1lKTtcclxuICB9O1xyXG5cclxuICBVdGlsLmluaGVyaXQgPSBmdW5jdGlvbiBVdGlsX2luaGVyaXQoc3ViLCBiYXNlLCBwcm90b3R5cGUpIHtcclxuICAgIHN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UucHJvdG90eXBlKTtcclxuICAgIHN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWI7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3RvdHlwZSkge1xyXG4gICAgICBzdWIucHJvdG90eXBlW3Byb3BdID0gcHJvdG90eXBlW3Byb3BdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFV0aWwubG9hZFNjcmlwdCA9IGZ1bmN0aW9uIFV0aWxfbG9hZFNjcmlwdChzcmMsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICB2YXIgbG9hZGVkID0gZmFsc2U7XHJcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIWxvYWRlZCkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVXRpbDtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBQREYgcGFnZSB2aWV3cG9ydCBjcmVhdGVkIGJhc2VkIG9uIHNjYWxlLCByb3RhdGlvbiBhbmQgb2Zmc2V0LlxyXG4gKiBAY2xhc3NcclxuICogQGFsaWFzIFBERkpTLlBhZ2VWaWV3cG9ydFxyXG4gKi9cclxudmFyIFBhZ2VWaWV3cG9ydCA9IFBERkpTLlBhZ2VWaWV3cG9ydCA9IChmdW5jdGlvbiBQYWdlVmlld3BvcnRDbG9zdXJlKCkge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHZpZXdCb3gge0FycmF5fSB4TWluLCB5TWluLCB4TWF4IGFuZCB5TWF4IGNvb3JkaW5hdGVzLlxyXG4gICAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSBzY2FsZSBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICogQHBhcmFtIHJvdGF0aW9uIHtudW1iZXJ9IHJvdGF0aW9ucyBvZiB0aGUgdmlld3BvcnQgaW4gZGVncmVlcy5cclxuICAgKiBAcGFyYW0gb2Zmc2V0WCB7bnVtYmVyfSBvZmZzZXQgWFxyXG4gICAqIEBwYXJhbSBvZmZzZXRZIHtudW1iZXJ9IG9mZnNldCBZXHJcbiAgICogQHBhcmFtIGRvbnRGbGlwIHtib29sZWFufSBpZiB0cnVlLCBheGlzIFkgd2lsbCBub3QgYmUgZmxpcHBlZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBQYWdlVmlld3BvcnQodmlld0JveCwgc2NhbGUsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZLCBkb250RmxpcCkge1xyXG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcclxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XHJcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xyXG5cclxuICAgIC8vIGNyZWF0aW5nIHRyYW5zZm9ybSB0byBjb252ZXJ0IHBkZiBjb29yZGluYXRlIHN5c3RlbSB0byB0aGUgbm9ybWFsXHJcbiAgICAvLyBjYW52YXMgbGlrZSBjb29yZGluYXRlcyB0YWtpbmcgaW4gYWNjb3VudCBzY2FsZSBhbmQgcm90YXRpb25cclxuICAgIHZhciBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XHJcbiAgICB2YXIgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xyXG4gICAgdmFyIHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XHJcbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uICUgMzYwO1xyXG4gICAgcm90YXRpb24gPSByb3RhdGlvbiA8IDAgPyByb3RhdGlvbiArIDM2MCA6IHJvdGF0aW9uO1xyXG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xyXG4gICAgICBjYXNlIDE4MDpcclxuICAgICAgICByb3RhdGVBID0gLTE7IHJvdGF0ZUIgPSAwOyByb3RhdGVDID0gMDsgcm90YXRlRCA9IDE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgOTA6XHJcbiAgICAgICAgcm90YXRlQSA9IDA7IHJvdGF0ZUIgPSAxOyByb3RhdGVDID0gMTsgcm90YXRlRCA9IDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjcwOlxyXG4gICAgICAgIHJvdGF0ZUEgPSAwOyByb3RhdGVCID0gLTE7IHJvdGF0ZUMgPSAtMTsgcm90YXRlRCA9IDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIC8vY2FzZSAwOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJvdGF0ZUEgPSAxOyByb3RhdGVCID0gMDsgcm90YXRlQyA9IDA7IHJvdGF0ZUQgPSAtMTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZG9udEZsaXApIHtcclxuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDOyByb3RhdGVEID0gLXJvdGF0ZUQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XHJcbiAgICB2YXIgd2lkdGgsIGhlaWdodDtcclxuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XHJcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XHJcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XHJcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XHJcbiAgICAgIGhlaWdodCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcclxuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcclxuICAgICAgd2lkdGggPSBNYXRoLmFicyh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcclxuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XHJcbiAgICB9XHJcbiAgICAvLyBjcmVhdGluZyB0cmFuc2Zvcm0gZm9yIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcclxuICAgIC8vIHRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpLCByb3RhdGUgYW5kIGZsaXAgdmVydGljYWxseSxcclxuICAgIC8vIHNjYWxlLCBhbmQgdHJhbnNsYXRlKG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1kpXHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtcclxuICAgICAgcm90YXRlQSAqIHNjYWxlLFxyXG4gICAgICByb3RhdGVCICogc2NhbGUsXHJcbiAgICAgIHJvdGF0ZUMgKiBzY2FsZSxcclxuICAgICAgcm90YXRlRCAqIHNjYWxlLFxyXG4gICAgICBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksXHJcbiAgICAgIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWVxyXG4gICAgXTtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRoaXMuZm9udFNjYWxlID0gc2NhbGU7XHJcbiAgfVxyXG4gIFBhZ2VWaWV3cG9ydC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIFBERkpTLlBhZ2VWaWV3cG9ydC5wcm90b3R5cGUgKi8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZXMgdmlld3BvcnQgd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gYXJncyB7T2JqZWN0fSAob3B0aW9uYWwpIElmIHNwZWNpZmllZCwgbWF5IGNvbnRhaW4gdGhlICdzY2FsZScgb3JcclxuICAgICAqICdyb3RhdGlvbicgcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIGluXHJcbiAgICAgKiB0aGUgY2xvbmVkIHZpZXdwb3J0LlxyXG4gICAgICogQHJldHVybnMge1BERkpTLlBhZ2VWaWV3cG9ydH0gQ2xvbmVkIHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gUGFnZVZpZXdQb3J0X2Nsb25lKGFyZ3MpIHtcclxuICAgICAgYXJncyA9IGFyZ3MgfHwge307XHJcbiAgICAgIHZhciBzY2FsZSA9ICdzY2FsZScgaW4gYXJncyA/IGFyZ3Muc2NhbGUgOiB0aGlzLnNjYWxlO1xyXG4gICAgICB2YXIgcm90YXRpb24gPSAncm90YXRpb24nIGluIGFyZ3MgPyBhcmdzLnJvdGF0aW9uIDogdGhpcy5yb3RhdGlvbjtcclxuICAgICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQodGhpcy52aWV3Qm94LnNsaWNlKCksIHNjYWxlLCByb3RhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIGFyZ3MuZG9udEZsaXApO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgUERGIHBvaW50IHRvIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlcy4gRm9yIGV4YW1wbGVzLCB1c2VmdWwgZm9yXHJcbiAgICAgKiBjb252ZXJ0aW5nIFBERiBsb2NhdGlvbiBpbnRvIGNhbnZhcyBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFkgY29vcmRpbmF0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB0aGF0IGNvbnRhaW5zICd4JyBhbmQgJ3knIHByb3BlcnRpZXMgb2YgdGhlXHJcbiAgICAgKiBwb2ludCBpbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cclxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1BkZlBvaW50fVxyXG4gICAgICogQHNlZSB7QGxpbmsgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQ6IGZ1bmN0aW9uIFBhZ2VWaWV3cG9ydF9jb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcclxuICAgICAgcmV0dXJuIFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBQREYgcmVjdGFuZ2xlIHRvIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSByZWN0IHtBcnJheX0geE1pbiwgeU1pbiwgeE1heCBhbmQgeU1heCBjb29yZGluYXRlcy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQ29udGFpbnMgY29ycmVzcG9uZGluZyBjb29yZGluYXRlcyBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBpbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cclxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlOlxyXG4gICAgICBmdW5jdGlvbiBQYWdlVmlld3BvcnRfY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xyXG4gICAgICB2YXIgdGwgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICB2YXIgYnIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICByZXR1cm4gW3RsWzBdLCB0bFsxXSwgYnJbMF0sIGJyWzFdXTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIHRoZSBQREYgbG9jYXRpb24uIEZvciBleGFtcGxlcywgdXNlZnVsXHJcbiAgICAgKiBmb3IgY29udmVydGluZyBjYW52YXMgcGl4ZWwgbG9jYXRpb24gaW50byBQREYgb25lLlxyXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRoYXQgY29udGFpbnMgJ3gnIGFuZCAneScgcHJvcGVydGllcyBvZiB0aGVcclxuICAgICAqIHBvaW50IGluIHRoZSBQREYgY29vcmRpbmF0ZSBzcGFjZS5cclxuICAgICAqIEBzZWUge0BsaW5rIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1BkZlBvaW50OiBmdW5jdGlvbiBQYWdlVmlld3BvcnRfY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xyXG4gICAgICByZXR1cm4gVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gUGFnZVZpZXdwb3J0O1xyXG59KSgpO1xyXG5cclxudmFyIFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gW1xyXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgMHgyRDgsIDB4MkM3LCAweDJDNiwgMHgyRDksIDB4MkRELCAweDJEQiwgMHgyREEsIDB4MkRDLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxyXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxyXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LFxyXG4gIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM0EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMUUsIDB4MjAxQyxcclxuICAweDIwMUQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMUEsIDB4MjEyMiwgMHhGQjAxLCAweEZCMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsXHJcbiAgMHgxNzgsIDB4MTdELCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN0UsIDAsIDB4MjBBQ1xyXG5dO1xyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyKSB7XHJcbiAgdmFyIGksIG4gPSBzdHIubGVuZ3RoLCBzdHJCdWYgPSBbXTtcclxuICBpZiAoc3RyWzBdID09PSAnXFx4RkUnICYmIHN0clsxXSA9PT0gJ1xceEZGJykge1xyXG4gICAgLy8gVVRGMTZCRSBCT01cclxuICAgIGZvciAoaSA9IDI7IGkgPCBuOyBpICs9IDIpIHtcclxuICAgICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShcclxuICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzdHIuY2hhckNvZGVBdChpICsgMSkpKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICB2YXIgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW3N0ci5jaGFyQ29kZUF0KGkpXTtcclxuICAgICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xyXG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQm9vbCh2KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnYm9vbGVhbic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzSW50KHYpIHtcclxuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInICYmICgodiB8IDApID09PSB2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOdW0odikge1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHYpIHtcclxuICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc051bGwodikge1xyXG4gIHJldHVybiB2ID09PSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc05hbWUodikge1xyXG4gIHJldHVybiB2IGluc3RhbmNlb2YgTmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNDbWQodiwgY21kKSB7XHJcbiAgcmV0dXJuIHYgaW5zdGFuY2VvZiBDbWQgJiYgKGNtZCA9PT0gdW5kZWZpbmVkIHx8IHYuY21kID09PSBjbWQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RpY3QodiwgdHlwZSkge1xyXG4gIGlmICghKHYgaW5zdGFuY2VvZiBEaWN0KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoIXR5cGUpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICB2YXIgZGljdFR5cGUgPSB2LmdldCgnVHlwZScpO1xyXG4gIHJldHVybiBpc05hbWUoZGljdFR5cGUpICYmIGRpY3RUeXBlLm5hbWUgPT09IHR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXkodikge1xyXG4gIHJldHVybiB2IGluc3RhbmNlb2YgQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyZWFtKHYpIHtcclxuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiYgdi5nZXRCeXRlcyAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHYpIHtcclxuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiYgdi5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUmVmKHYpIHtcclxuICByZXR1cm4gdiBpbnN0YW5jZW9mIFJlZjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb21pc2UgQ2FwYWJpbGl0eSBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb21pc2VDYXBhYmlsaXR5XHJcbiAqIEBwcm9wZXJ0eSB7UHJvbWlzZX0gcHJvbWlzZSAtIEEgcHJvbWlzZSBvYmplY3QuXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlc29sdmUgLSBGdWxsZmlsbHMgdGhlIHByb21pc2UuXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlamVjdCAtIFJlamVjdHMgdGhlIHByb21pc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBwcm9taXNlIGNhcGFiaWxpdHkgb2JqZWN0LlxyXG4gKiBAYWxpYXMgUERGSlMuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHlcclxuICpcclxuICogQHJldHVybiB7UHJvbWlzZUNhcGFiaWxpdHl9IEEgY2FwYWJpbGl0eSBvYmplY3QgY29udGFpbnM6XHJcbiAqIC0gYSBQcm9taXNlLCByZXNvbHZlIGFuZCByZWplY3QgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KCkge1xyXG4gIHZhciBjYXBhYmlsaXR5ID0ge307XHJcbiAgY2FwYWJpbGl0eS5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgIGNhcGFiaWxpdHkucmVqZWN0ID0gcmVqZWN0O1xyXG4gIH0pO1xyXG4gIHJldHVybiBjYXBhYmlsaXR5O1xyXG59XHJcblxyXG5QREZKUy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xyXG5cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGZvciBQcm9taXNlczpcclxuICogVGhlIGZvbGxvd2luZyBwcm9taXNlIGltcGxlbWVudGF0aW9uIHRyaWVzIHRvIGdlbmVyYWxseSBpbXBsZW1lbnQgdGhlXHJcbiAqIFByb21pc2UvQSsgc3BlYy4gU29tZSBub3RhYmxlIGRpZmZlcmVuY2VzIGZyb20gb3RoZXIgcHJvbWlzZSBsaWJhcmllcyBhcmU6XHJcbiAqIC0gVGhlcmUgY3VycmVudGx5IGlzbid0IGEgc2VwZXJhdGUgZGVmZXJyZWQgYW5kIHByb21pc2Ugb2JqZWN0LlxyXG4gKiAtIFVuaGFuZGxlZCByZWplY3Rpb25zIGV2ZW50dWFsbHkgc2hvdyBhbiBlcnJvciBpZiB0aGV5IGFyZW4ndCBoYW5kbGVkLlxyXG4gKlxyXG4gKiBCYXNlZCBvZmYgb2YgdGhlIHdvcmsgaW46XHJcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTgxMDQ5MFxyXG4gKi9cclxuKGZ1bmN0aW9uIFByb21pc2VDbG9zdXJlKCkge1xyXG4gIGlmIChnbG9iYWxTY29wZS5Qcm9taXNlKSB7XHJcbiAgICAvLyBQcm9taXNlcyBleGlzdGluZyBpbiB0aGUgRE9NL1dvcmtlciwgY2hlY2tpbmcgcHJlc2VuY2Ugb2YgYWxsL3Jlc29sdmVcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5hbGwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZ2xvYmFsU2NvcGUuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwLCByZXN1bHRzID0gW10sIHJlc29sdmUsIHJlamVjdDtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlXywgcmVqZWN0Xykge1xyXG4gICAgICAgICAgcmVzb2x2ZSA9IHJlc29sdmVfO1xyXG4gICAgICAgICAgcmVqZWN0ID0gcmVqZWN0XztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdGVyYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XHJcbiAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgY291bnQtLTtcclxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZS5Qcm9taXNlLnJlc29sdmUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZWplY3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZ2xvYmFsU2NvcGUuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZS5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBnbG9iYWxTY29wZS5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxTY29wZS5Qcm9taXNlLnByb3RvdHlwZS50aGVuKHVuZGVmaW5lZCwgb25SZWplY3QpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuLy8jaWYgIU1PWkNFTlRSQUxcclxuICB2YXIgU1RBVFVTX1BFTkRJTkcgPSAwO1xyXG4gIHZhciBTVEFUVVNfUkVTT0xWRUQgPSAxO1xyXG4gIHZhciBTVEFUVVNfUkVKRUNURUQgPSAyO1xyXG5cclxuICAvLyBJbiBhbiBhdHRlbXB0IHRvIGF2b2lkIHNpbGVudCBleGNlcHRpb25zLCB1bmhhbmRsZWQgcmVqZWN0aW9ucyBhcmVcclxuICAvLyB0cmFja2VkIGFuZCBpZiB0aGV5IGFyZW4ndCBoYW5kbGVkIGluIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZSBhblxyXG4gIC8vIGVycm9yIGlzIGxvZ2dlZC5cclxuICB2YXIgUkVKRUNUSU9OX1RJTUVPVVQgPSA1MDA7XHJcblxyXG4gIHZhciBIYW5kbGVyTWFuYWdlciA9IHtcclxuICAgIGhhbmRsZXJzOiBbXSxcclxuICAgIHJ1bm5pbmc6IGZhbHNlLFxyXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uczogW10sXHJcbiAgICBwZW5kaW5nUmVqZWN0aW9uQ2hlY2s6IGZhbHNlLFxyXG5cclxuICAgIHNjaGVkdWxlSGFuZGxlcnM6IGZ1bmN0aW9uIHNjaGVkdWxlSGFuZGxlcnMocHJvbWlzZSkge1xyXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdHVzID09PSBTVEFUVVNfUEVORElORykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuY29uY2F0KHByb21pc2UuX2hhbmRsZXJzKTtcclxuICAgICAgcHJvbWlzZS5faGFuZGxlcnMgPSBbXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIHNldFRpbWVvdXQodGhpcy5ydW5IYW5kbGVycy5iaW5kKHRoaXMpLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgcnVuSGFuZGxlcnM6IGZ1bmN0aW9uIHJ1bkhhbmRsZXJzKCkge1xyXG4gICAgICB2YXIgUlVOX1RJTUVPVVQgPSAxOyAvLyBtc1xyXG4gICAgICB2YXIgdGltZW91dEF0ID0gRGF0ZS5ub3coKSArIFJVTl9USU1FT1VUO1xyXG4gICAgICB3aGlsZSAodGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIHZhciBuZXh0U3RhdHVzID0gaGFuZGxlci50aGlzUHJvbWlzZS5fc3RhdHVzO1xyXG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBoYW5kbGVyLnRoaXNQcm9taXNlLl92YWx1ZTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChuZXh0U3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uUmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgIG5leHRWYWx1ZSA9IGhhbmRsZXIub25SZXNvbHZlKG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIub25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICBuZXh0VmFsdWUgPSBoYW5kbGVyLm9uUmVqZWN0KG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgbmV4dFN0YXR1cyA9IFNUQVRVU19SRVNPTFZFRDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGhhbmRsZXIudGhpc1Byb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmhhbmRlbGVkUmVqZWN0aW9uKGhhbmRsZXIudGhpc1Byb21pc2UpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgbmV4dFN0YXR1cyA9IFNUQVRVU19SRUpFQ1RFRDtcclxuICAgICAgICAgIG5leHRWYWx1ZSA9IGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaGFuZGxlci5uZXh0UHJvbWlzZS5fdXBkYXRlU3RhdHVzKG5leHRTdGF0dXMsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKERhdGUubm93KCkgPj0gdGltZW91dEF0KSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmhhbmRsZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucnVuSGFuZGxlcnMuYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkVW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiBhZGRVbmhhbmRsZWRSZWplY3Rpb24ocHJvbWlzZSkge1xyXG4gICAgICB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcclxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnNjaGVkdWxlUmVqZWN0aW9uQ2hlY2soKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlVW5oYW5kZWxlZFJlamVjdGlvbjogZnVuY3Rpb24gcmVtb3ZlVW5oYW5kZWxlZFJlamVjdGlvbihwcm9taXNlKSB7XHJcbiAgICAgIHByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnNbaV0ucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xyXG4gICAgICAgICAgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShpKTtcclxuICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2NoZWR1bGVSZWplY3Rpb25DaGVjazogZnVuY3Rpb24gc2NoZWR1bGVSZWplY3Rpb25DaGVjaygpIHtcclxuICAgICAgaWYgKHRoaXMucGVuZGluZ1JlamVjdGlvbkNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGVuZGluZ1JlamVjdGlvbkNoZWNrID0gdHJ1ZTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiByZWplY3Rpb25DaGVjaygpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZWplY3Rpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAobm93IC0gdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zW2ldLnRpbWUgPiBSRUpFQ1RJT05fVElNRU9VVCkge1xyXG4gICAgICAgICAgICB2YXIgdW5oYW5kbGVkID0gdGhpcy51bmhhbmRsZWRSZWplY3Rpb25zW2ldLnByb21pc2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuaGFuZGxlZCByZWplY3Rpb246ICcgKyB1bmhhbmRsZWQ7XHJcbiAgICAgICAgICAgIGlmICh1bmhhbmRsZWQuc3RhY2spIHtcclxuICAgICAgICAgICAgICBtc2cgKz0gJ1xcbicgKyB1bmhhbmRsZWQuc3RhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICB0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGkpO1xyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVqZWN0aW9uQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0uYmluZCh0aGlzKSwgUkVKRUNUSU9OX1RJTUVPVVQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcclxuICAgIHRoaXMuX3N0YXR1cyA9IFNUQVRVU19QRU5ESU5HO1xyXG4gICAgdGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlc29sdmVyLmNhbGwodGhpcywgdGhpcy5fcmVzb2x2ZS5iaW5kKHRoaXMpLCB0aGlzLl9yZWplY3QuYmluZCh0aGlzKSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRoaXMuX3JlamVjdChlKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIHRoZSBwYXNzZWQgaW4gcHJvbWlzZXMgYXJlXHJcbiAgICogcmVzb2x2ZWQuXHJcbiAgICogQHBhcmFtIHthcnJheX0gYXJyYXkgb2YgZGF0YSBhbmQvb3IgcHJvbWlzZXMgdG8gd2FpdCBmb3IuXHJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gTmV3IGRlcGVuZGFudCBwcm9taXNlLlxyXG4gICAqL1xyXG4gIFByb21pc2UuYWxsID0gZnVuY3Rpb24gUHJvbWlzZV9hbGwocHJvbWlzZXMpIHtcclxuICAgIHZhciByZXNvbHZlQWxsLCByZWplY3RBbGw7XHJcbiAgICB2YXIgZGVmZXJyZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgIHJlc29sdmVBbGwgPSByZXNvbHZlO1xyXG4gICAgICByZWplY3RBbGwgPSByZWplY3Q7XHJcbiAgICB9KTtcclxuICAgIHZhciB1bnJlc29sdmVkID0gcHJvbWlzZXMubGVuZ3RoO1xyXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgIGlmICh1bnJlc29sdmVkID09PSAwKSB7XHJcbiAgICAgIHJlc29sdmVBbGwocmVzdWx0cyk7XHJcbiAgICAgIHJldHVybiBkZWZlcnJlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcclxuICAgICAgaWYgKGRlZmVycmVkLl9zdGF0dXMgPT09IFNUQVRVU19SRUpFQ1RFRCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHRzID0gW107XHJcbiAgICAgIHJlamVjdEFsbChyZWFzb24pO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcHJvbWlzZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xyXG4gICAgICB2YXIgcmVzb2x2ZSA9IChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoZGVmZXJyZWQuX3N0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlc3VsdHNbaV0gPSB2YWx1ZTtcclxuICAgICAgICAgIHVucmVzb2x2ZWQtLTtcclxuICAgICAgICAgIGlmICh1bnJlc29sdmVkID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVBbGwocmVzdWx0cyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfSkoaSk7XHJcbiAgICAgIGlmIChQcm9taXNlLmlzUHJvbWlzZShwcm9taXNlKSkge1xyXG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmUocHJvbWlzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWZlcnJlZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGxpa2VseSBhIHByb21pc2UgKGhhcyBhICd0aGVuJyBmdW5jdGlvbikuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWx1ZSBpcyB0aGVuYWJsZVxyXG4gICAqL1xyXG4gIFByb21pc2UuaXNQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZV9pc1Byb21pc2UodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHJlc29sdmVkIHByb21pc2VcclxuICAgKiBAcGFyYW0gdmFsdWUgcmVzb2x2ZSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAqL1xyXG4gIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uIFByb21pc2VfcmVzb2x2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHJlamVjdGVkIHByb21pc2VcclxuICAgKiBAcGFyYW0gcmVhc29uIHJlamVjdGlvbiB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAqL1xyXG4gIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gUHJvbWlzZV9yZWplY3QocmVhc29uKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZWplY3QocmVhc29uKTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgUHJvbWlzZS5wcm90b3R5cGUgPSB7XHJcbiAgICBfc3RhdHVzOiBudWxsLFxyXG4gICAgX3ZhbHVlOiBudWxsLFxyXG4gICAgX2hhbmRsZXJzOiBudWxsLFxyXG4gICAgX3VuaGFuZGxlZFJlamVjdGlvbjogbnVsbCxcclxuXHJcbiAgICBfdXBkYXRlU3RhdHVzOiBmdW5jdGlvbiBQcm9taXNlX191cGRhdGVTdGF0dXMoc3RhdHVzLCB2YWx1ZSkge1xyXG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQgfHxcclxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdHVzID09PSBTVEFUVVNfUkVTT0xWRUQgJiZcclxuICAgICAgICAgIFByb21pc2UuaXNQcm9taXNlKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlLnRoZW4odGhpcy5fdXBkYXRlU3RhdHVzLmJpbmQodGhpcywgU1RBVFVTX1JFU09MVkVEKSxcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cy5iaW5kKHRoaXMsIFNUQVRVU19SRUpFQ1RFRCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgICAgaWYgKHN0YXR1cyA9PT0gU1RBVFVTX1JFSkVDVEVEICYmIHRoaXMuX2hhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX3VuaGFuZGxlZFJlamVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgSGFuZGxlck1hbmFnZXIuYWRkVW5oYW5kbGVkUmVqZWN0aW9uKHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBIYW5kbGVyTWFuYWdlci5zY2hlZHVsZUhhbmRsZXJzKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVzb2x2ZTogZnVuY3Rpb24gUHJvbWlzZV9yZXNvbHZlKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cyhTVEFUVVNfUkVTT0xWRUQsIHZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3JlamVjdDogZnVuY3Rpb24gUHJvbWlzZV9yZWplY3QocmVhc29uKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXR1cyhTVEFUVVNfUkVKRUNURUQsIHJlYXNvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIHRoZW46IGZ1bmN0aW9uIFByb21pc2VfdGhlbihvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgIHZhciBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5faGFuZGxlcnMucHVzaCh7XHJcbiAgICAgICAgdGhpc1Byb21pc2U6IHRoaXMsXHJcbiAgICAgICAgb25SZXNvbHZlOiBvblJlc29sdmUsXHJcbiAgICAgICAgb25SZWplY3Q6IG9uUmVqZWN0LFxyXG4gICAgICAgIG5leHRQcm9taXNlOiBuZXh0UHJvbWlzZVxyXG4gICAgICB9KTtcclxuICAgICAgSGFuZGxlck1hbmFnZXIuc2NoZWR1bGVIYW5kbGVycyh0aGlzKTtcclxuICAgICAgcmV0dXJuIG5leHRQcm9taXNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYXRjaDogZnVuY3Rpb24gUHJvbWlzZV9jYXRjaChvblJlamVjdCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3QpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGdsb2JhbFNjb3BlLlByb21pc2UgPSBQcm9taXNlO1xyXG4vLyNlbHNlXHJcbi8vdGhyb3cgbmV3IEVycm9yKCdET00gUHJvbWlzZSBpcyBub3QgcHJlc2VudCcpO1xyXG4vLyNlbmRpZlxyXG59KSgpO1xyXG5cclxudmFyIFN0YXRUaW1lciA9IChmdW5jdGlvbiBTdGF0VGltZXJDbG9zdXJlKCkge1xyXG4gIGZ1bmN0aW9uIHJwYWQoc3RyLCBwYWQsIGxlbmd0aCkge1xyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHtcclxuICAgICAgc3RyICs9IHBhZDtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIFN0YXRUaW1lcigpIHtcclxuICAgIHRoaXMuc3RhcnRlZCA9IHt9O1xyXG4gICAgdGhpcy50aW1lcyA9IFtdO1xyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgU3RhdFRpbWVyLnByb3RvdHlwZSA9IHtcclxuICAgIHRpbWU6IGZ1bmN0aW9uIFN0YXRUaW1lcl90aW1lKG5hbWUpIHtcclxuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgd2FybignVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAnICsgbmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcclxuICAgIH0sXHJcbiAgICB0aW1lRW5kOiBmdW5jdGlvbiBTdGF0VGltZXJfdGltZUVuZChuYW1lKSB7XHJcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xyXG4gICAgICAgIHdhcm4oJ1RpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAnICsgbmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50aW1lcy5wdXNoKHtcclxuICAgICAgICAnbmFtZSc6IG5hbWUsXHJcbiAgICAgICAgJ3N0YXJ0JzogdGhpcy5zdGFydGVkW25hbWVdLFxyXG4gICAgICAgICdlbmQnOiBEYXRlLm5vdygpXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBSZW1vdmUgdGltZXIgZnJvbSBzdGFydGVkIHNvIGl0IGNhbiBiZSBjYWxsZWQgYWdhaW4uXHJcbiAgICAgIGRlbGV0ZSB0aGlzLnN0YXJ0ZWRbbmFtZV07XHJcbiAgICB9LFxyXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIFN0YXRUaW1lcl90b1N0cmluZygpIHtcclxuICAgICAgdmFyIGksIGlpO1xyXG4gICAgICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xyXG4gICAgICB2YXIgb3V0ID0gJyc7XHJcbiAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3QgbmFtZSBmb3IgcGFkZGluZyBwdXJwb3Nlcy5cclxuICAgICAgdmFyIGxvbmdlc3QgPSAwO1xyXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHRpbWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHRpbWVzW2ldWyduYW1lJ107XHJcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gbG9uZ2VzdCkge1xyXG4gICAgICAgICAgbG9uZ2VzdCA9IG5hbWUubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHRpbWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICB2YXIgc3BhbiA9IHRpbWVzW2ldO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHNwYW4uZW5kIC0gc3Bhbi5zdGFydDtcclxuICAgICAgICBvdXQgKz0gcnBhZChzcGFuWyduYW1lJ10sICcgJywgbG9uZ2VzdCkgKyAnICcgKyBkdXJhdGlvbiArICdtc1xcbic7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBTdGF0VGltZXI7XHJcbn0pKCk7XHJcblxyXG5QREZKUy5jcmVhdGVCbG9iID0gZnVuY3Rpb24gY3JlYXRlQmxvYihkYXRhLCBjb250ZW50VHlwZSkge1xyXG4gIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogY29udGVudFR5cGUgfSk7XHJcbiAgfVxyXG4gIC8vIEJsb2IgYnVpbGRlciBpcyBkZXByZWNhdGVkIGluIEZGMTQgYW5kIHJlbW92ZWQgaW4gRkYxOC5cclxuICB2YXIgYmIgPSBuZXcgTW96QmxvYkJ1aWxkZXIoKTtcclxuICBiYi5hcHBlbmQoZGF0YSk7XHJcbiAgcmV0dXJuIGJiLmdldEJsb2IoY29udGVudFR5cGUpO1xyXG59O1xyXG5cclxuUERGSlMuY3JlYXRlT2JqZWN0VVJMID0gKGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTENsb3N1cmUoKSB7XHJcbiAgLy8gQmxvYi9jcmVhdGVPYmplY3RVUkwgaXMgbm90IGF2YWlsYWJsZSwgZmFsbGluZyBiYWNrIHRvIGRhdGEgc2NoZW1hLlxyXG4gIHZhciBkaWdpdHMgPVxyXG4gICAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBjb250ZW50VHlwZSkge1xyXG4gICAgaWYgKCFQREZKUy5kaXNhYmxlQ3JlYXRlT2JqZWN0VVJMICYmXHJcbiAgICAgICAgdHlwZW9mIFVSTCAhPT0gJ3VuZGVmaW5lZCcgJiYgVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xyXG4gICAgICB2YXIgYmxvYiA9IFBERkpTLmNyZWF0ZUJsb2IoZGF0YSwgY29udGVudFR5cGUpO1xyXG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYnVmZmVyID0gJ2RhdGE6JyArIGNvbnRlbnRUeXBlICsgJztiYXNlNjQsJztcclxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xyXG4gICAgICB2YXIgYjEgPSBkYXRhW2ldICYgMHhGRjtcclxuICAgICAgdmFyIGIyID0gZGF0YVtpICsgMV0gJiAweEZGO1xyXG4gICAgICB2YXIgYjMgPSBkYXRhW2kgKyAyXSAmIDB4RkY7XHJcbiAgICAgIHZhciBkMSA9IGIxID4+IDIsIGQyID0gKChiMSAmIDMpIDw8IDQpIHwgKGIyID4+IDQpO1xyXG4gICAgICB2YXIgZDMgPSBpICsgMSA8IGlpID8gKChiMiAmIDB4RikgPDwgMikgfCAoYjMgPj4gNikgOiA2NDtcclxuICAgICAgdmFyIGQ0ID0gaSArIDIgPCBpaSA/IChiMyAmIDB4M0YpIDogNjQ7XHJcbiAgICAgIGJ1ZmZlciArPSBkaWdpdHNbZDFdICsgZGlnaXRzW2QyXSArIGRpZ2l0c1tkM10gKyBkaWdpdHNbZDRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXIobmFtZSwgY29tT2JqKSB7XHJcbiAgdGhpcy5uYW1lID0gbmFtZTtcclxuICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcclxuICB0aGlzLmNhbGxiYWNrSW5kZXggPSAxO1xyXG4gIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xyXG4gIHZhciBjYWxsYmFja3NDYXBhYmlsaXRpZXMgPSB0aGlzLmNhbGxiYWNrc0NhcGFiaWxpdGllcyA9IHt9O1xyXG4gIHZhciBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlciA9IHt9O1xyXG5cclxuICBhaFsnY29uc29sZV9sb2cnXSA9IFtmdW5jdGlvbiBhaENvbnNvbGVMb2coZGF0YSkge1xyXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgZGF0YSk7XHJcbiAgfV07XHJcbiAgYWhbJ2NvbnNvbGVfZXJyb3InXSA9IFtmdW5jdGlvbiBhaENvbnNvbGVFcnJvcihkYXRhKSB7XHJcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGRhdGEpO1xyXG4gIH1dO1xyXG4gIGFoWydfdW5zdXBwb3J0ZWRfZmVhdHVyZSddID0gW2Z1bmN0aW9uIGFoX3Vuc3VwcG9ydGVkRmVhdHVyZShkYXRhKSB7XHJcbiAgICBVbnN1cHBvcnRlZE1hbmFnZXIubm90aWZ5KGRhdGEpO1xyXG4gIH1dO1xyXG5cclxuICBjb21PYmoub25tZXNzYWdlID0gZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJDb21PYmpPbk1lc3NhZ2UoZXZlbnQpIHtcclxuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcclxuICAgIGlmIChkYXRhLmlzUmVwbHkpIHtcclxuICAgICAgdmFyIGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XHJcbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQgaW4gY2FsbGJhY2tzQ2FwYWJpbGl0aWVzKSB7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xyXG4gICAgICAgIGRlbGV0ZSBjYWxsYmFja3NDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XHJcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gZGF0YSkge1xyXG4gICAgICAgICAgY2FsbGJhY2sucmVqZWN0KGRhdGEuZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKGRhdGEuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVycm9yKCdDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAnICsgY2FsbGJhY2tJZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gaW4gYWgpIHtcclxuICAgICAgdmFyIGFjdGlvbiA9IGFoW2RhdGEuYWN0aW9uXTtcclxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGFjdGlvblswXS5jYWxsKGFjdGlvblsxXSwgZGF0YS5kYXRhKTtcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIGlzUmVwbHk6IHRydWUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcclxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICBpc1JlcGx5OiB0cnVlLFxyXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXHJcbiAgICAgICAgICAgIGVycm9yOiByZWFzb25cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFjdGlvblswXS5jYWxsKGFjdGlvblsxXSwgZGF0YS5kYXRhKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXJyb3IoJ1Vua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAnICsgZGF0YS5hY3Rpb24pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbk1lc3NhZ2VIYW5kbGVyLnByb3RvdHlwZSA9IHtcclxuICBvbjogZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJPbihhY3Rpb25OYW1lLCBoYW5kbGVyLCBzY29wZSkge1xyXG4gICAgdmFyIGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xyXG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XHJcbiAgICAgIGVycm9yKCdUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJyArIGFjdGlvbk5hbWUgKyAnXCInKTtcclxuICAgIH1cclxuICAgIGFoW2FjdGlvbk5hbWVdID0gW2hhbmRsZXIsIHNjb3BlXTtcclxuICB9LFxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgY29tT2JqIHRvIGludm9rZSB0aGUgYWN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGRhdGEuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbk5hbWUgQWN0aW9uIHRvIGNhbGwuXHJcbiAgICogQHBhcmFtIHtKU09OfSBkYXRhIEpTT04gZGF0YSB0byBzZW5kLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2ZlcnNdIE9wdGlvbmFsIGxpc3Qgb2YgdHJhbnNmZXJzL0FycmF5QnVmZmVyc1xyXG4gICAqL1xyXG4gIHNlbmQ6IGZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyU2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcclxuICAgIHZhciBtZXNzYWdlID0ge1xyXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXHJcbiAgICAgIGRhdGE6IGRhdGFcclxuICAgIH07XHJcbiAgICB0aGlzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XHJcbiAgfSxcclxuICAvKipcclxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIGNvbU9iaiB0byBpbnZva2UgdGhlIGFjdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBkYXRhLlxyXG4gICAqIEV4cGVjdHMgdGhhdCBvdGhlciBzaWRlIHdpbGwgY2FsbGJhY2sgd2l0aCB0aGUgcmVzcG9uc2UuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbk5hbWUgQWN0aW9uIHRvIGNhbGwuXHJcbiAgICogQHBhcmFtIHtKU09OfSBkYXRhIEpTT04gZGF0YSB0byBzZW5kLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2ZlcnNdIE9wdGlvbmFsIGxpc3Qgb2YgdHJhbnNmZXJzL0FycmF5QnVmZmVycy5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0byBiZSByZXNvbHZlZCB3aXRoIHJlc3BvbnNlIGRhdGEuXHJcbiAgICovXHJcbiAgc2VuZFdpdGhQcm9taXNlOlxyXG4gICAgZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXJTZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XHJcbiAgICB2YXIgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJbmRleCsrO1xyXG4gICAgdmFyIG1lc3NhZ2UgPSB7XHJcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcclxuICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgY2FsbGJhY2tJZDogY2FsbGJhY2tJZFxyXG4gICAgfTtcclxuICAgIHZhciBjYXBhYmlsaXR5ID0gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkoKTtcclxuICAgIHRoaXMuY2FsbGJhY2tzQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJzKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgcmF3IG1lc3NhZ2UgdG8gdGhlIGNvbU9iai5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtPYmplY3R9IFJhdyBtZXNzYWdlLlxyXG4gICAqIEBwYXJhbSB0cmFuc2ZlcnMgTGlzdCBvZiB0cmFuc2ZlcnMvQXJyYXlCdWZmZXJzLCBvciB1bmRlZmluZWQuXHJcbiAgICovXHJcbiAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2ZlcnMpIHtcclxuICAgIGlmICh0cmFuc2ZlcnMgJiYgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycykge1xyXG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xyXG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKcHhJbWFnZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEpwZWdTdHJlYW0oaWQsIGltYWdlVXJsLCBvYmpzKSB7XHJcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gIGltZy5vbmxvYWQgPSAoZnVuY3Rpb24gbG9hZEpwZWdTdHJlYW1fb25sb2FkQ2xvc3VyZSgpIHtcclxuICAgIG9ianMucmVzb2x2ZShpZCwgaW1nKTtcclxuICB9KTtcclxuICBpbWcub25lcnJvciA9IChmdW5jdGlvbiBsb2FkSnBlZ1N0cmVhbV9vbmVycm9yQ2xvc3VyZSgpIHtcclxuICAgIG9ianMucmVzb2x2ZShpZCwgbnVsbCk7XHJcbiAgICB3YXJuKCdFcnJvciBkdXJpbmcgSlBFRyBpbWFnZSBsb2FkaW5nJyk7XHJcbiAgfSk7XHJcbiAgaW1nLnNyYyA9IGltYWdlVXJsO1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgZG9lc24ndCB3b3J0aCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uYSBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICBjYXNlIEhFQUQ6XG4gICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cblxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGTEFHUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVElNRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAvLz09PVxuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBPUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWExFTjpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhUUkE6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbmQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBOQU1FOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT01NRU5UOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEhDUkM6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRElDVElEOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESUNUOlxuICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAvLy0tLVxuICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEU6XG4gICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFRE86XG4gICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICBiaXRzIC09IDE7XG4gICAgICAvLy0tLS8vXG5cbiAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMjtcbiAgICAgIGJpdHMgLT0gMjtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RPUkVEOlxuICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgLy8tLS0vL1xuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWV86XG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFk6XG4gICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBUQUJMRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICBiaXRzIC09IDU7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICBiaXRzIC09IDU7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5MRU5TOlxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU46XG4gICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAvLy0tLVxuICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAvLy0tLVxuXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5FWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1Q6XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNURVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBNQVRDSDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgZG8ge1xuICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTElUOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgbGVmdC0tO1xuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ0hFQ0s6XG4gICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgLy8gVXNlICd8JyBpbnNkZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgIH1cbiAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkdUSDpcbiAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERPTkU6XG4gICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgY2FzZSBCQUQ6XG4gICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgY2FzZSBNRU06XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgY2FzZSBTWU5DOlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnNkZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCJ2YXIgbXNnID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9tZXNzYWdlcycpO1xudmFyIHpzdHJlYW0gPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL3pzdHJlYW0nKTtcbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL2RlZmxhdGUuanMnKTtcbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL2luZmxhdGUuanMnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL2NvbnN0YW50cycpO1xuXG5mb3IgKHZhciBrZXkgaW4gY29uc3RhbnRzKSB7XG4gIGV4cG9ydHNba2V5XSA9IGNvbnN0YW50c1trZXldO1xufVxuXG4vLyB6bGliIG1vZGVzXG5leHBvcnRzLk5PTkUgPSAwO1xuZXhwb3J0cy5ERUZMQVRFID0gMTtcbmV4cG9ydHMuSU5GTEFURSA9IDI7XG5leHBvcnRzLkdaSVAgPSAzO1xuZXhwb3J0cy5HVU5aSVAgPSA0O1xuZXhwb3J0cy5ERUZMQVRFUkFXID0gNTtcbmV4cG9ydHMuSU5GTEFURVJBVyA9IDY7XG5leHBvcnRzLlVOWklQID0gNztcblxuLyoqXG4gKiBFbXVsYXRlIE5vZGUncyB6bGliIEMrKyBsYXllciBmb3IgdXNlIGJ5IHRoZSBKUyBsYXllciBpbiBpbmRleC5qc1xuICovXG5mdW5jdGlvbiBabGliKG1vZGUpIHtcbiAgaWYgKG1vZGUgPCBleHBvcnRzLkRFRkxBVEUgfHwgbW9kZSA+IGV4cG9ydHMuVU5aSVApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJhZCBhcmd1bWVudFwiKTtcbiAgICBcbiAgdGhpcy5tb2RlID0gbW9kZTtcbiAgdGhpcy5pbml0X2RvbmUgPSBmYWxzZTtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgdGhpcy53aW5kb3dCaXRzID0gMDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMubWVtTGV2ZWwgPSAwO1xuICB0aGlzLnN0cmF0ZWd5ID0gMDtcbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbn1cblxuWmxpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdpbmRvd0JpdHMsIGxldmVsLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpIHtcbiAgdGhpcy53aW5kb3dCaXRzID0gd2luZG93Qml0cztcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLm1lbUxldmVsID0gbWVtTGV2ZWw7XG4gIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgLy8gZGljdGlvbmFyeSBub3Qgc3VwcG9ydGVkLlxuICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HVU5aSVApXG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDE2O1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLlVOWklQKVxuICAgIHRoaXMud2luZG93Qml0cyArPSAzMjtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXKVxuICAgIHRoaXMud2luZG93Qml0cyA9IC10aGlzLndpbmRvd0JpdHM7XG4gICAgXG4gIHRoaXMuc3RybSA9IG5ldyB6c3RyZWFtKCk7XG4gIFxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgICAgIHRoaXMuc3RybSxcbiAgICAgICAgdGhpcy5sZXZlbCxcbiAgICAgICAgZXhwb3J0cy5aX0RFRkxBVEVELFxuICAgICAgICB0aGlzLndpbmRvd0JpdHMsXG4gICAgICAgIHRoaXMubWVtTGV2ZWwsXG4gICAgICAgIHRoaXMuc3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICAgIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICAgICAgdGhpcy5zdHJtLFxuICAgICAgICB0aGlzLndpbmRvd0JpdHNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtb2RlIFwiICsgdGhpcy5tb2RlKTtcbiAgfVxuICBcbiAgaWYgKHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcImRlZmxhdGVQYXJhbXMgTm90IHN1cHBvcnRlZFwiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl93cml0ZUNoZWNrID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pbml0X2RvbmUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGUgYmVmb3JlIGluaXRcIik7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuTk9ORSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICBcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGUgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKTtcbiAgICBcbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbG9zZSBpcyBwZW5kaW5nXCIpO1xufTtcblxuWmxpYi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHsgICAgXG4gIHRoaXMuX3dyaXRlQ2hlY2soKTtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG4gIFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICAgIHZhciByZXMgPSBzZWxmLl93cml0ZShmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xuICAgIHNlbGYuY2FsbGJhY2socmVzWzBdLCByZXNbMV0pO1xuICAgIFxuICAgIGlmIChzZWxmLnBlbmRpbmdfY2xvc2UpXG4gICAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgbWV0aG9kIGZvciBOb2RlIGJ1ZmZlcnMsIHVzZWQgYnkgcGFrb1xuZnVuY3Rpb24gYnVmZmVyU2V0KGRhdGEsIG9mZnNldCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gZGF0YVtpXTtcbiAgfVxufVxuXG5abGliLnByb3RvdHlwZS53cml0ZVN5bmMgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy5fd3JpdGVDaGVjaygpO1xuICByZXR1cm4gdGhpcy5fd3JpdGUoZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gdHJ1ZTtcbiAgXG4gIGlmIChmbHVzaCAhPT0gZXhwb3J0cy5aX05PX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX1BBUlRJQUxfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfU1lOQ19GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9GVUxMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZJTklTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9CTE9DSykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmx1c2ggdmFsdWVcIik7XG4gIH1cbiAgXG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgaW5wdXQgPSBuZXcgQnVmZmVyKDApO1xuICAgIGluX2xlbiA9IDA7XG4gICAgaW5fb2ZmID0gMDtcbiAgfVxuICBcbiAgaWYgKG91dC5fc2V0KVxuICAgIG91dC5zZXQgPSBvdXQuX3NldDtcbiAgZWxzZVxuICAgIG91dC5zZXQgPSBidWZmZXJTZXQ7XG4gIFxuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgc3RybS5hdmFpbF9pbiA9IGluX2xlbjtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLm5leHRfaW4gPSBpbl9vZmY7XG4gIHN0cm0uYXZhaWxfb3V0ID0gb3V0X2xlbjtcbiAgc3RybS5vdXRwdXQgPSBvdXQ7XG4gIHN0cm0ubmV4dF9vdXQgPSBvdXRfb2ZmO1xuICBcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBmbHVzaCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBmbHVzaCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtb2RlIFwiICsgdGhpcy5tb2RlKTtcbiAgfVxuICBcbiAgaWYgKHN0YXR1cyAhPT0gZXhwb3J0cy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICB9XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHJldHVybiBbc3RybS5hdmFpbF9pbiwgc3RybS5hdmFpbF9vdXRdO1xufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnBlbmRpbmdfY2xvc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLkRFRkxBVEUgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLkdaSVAgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLkRFRkxBVEVSQVcpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICB9IGVsc2Uge1xuICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH1cbiAgXG4gIHRoaXMubW9kZSA9IGV4cG9ydHMuTk9ORTtcbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVSZXNldCh0aGlzLnN0cm0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVSZXNldCh0aGlzLnN0cm0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICB0aGlzLm9uZXJyb3IobXNnW3N0YXR1c10gKyAnOiAnICsgdGhpcy5zdHJtLm1zZywgc3RhdHVzKTtcbiAgXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSlcbiAgICB0aGlzLmNsb3NlKCk7XG59O1xuXG5leHBvcnRzLlpsaWIgPSBabGliO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdfc3RyZWFtX3RyYW5zZm9ybScpO1xuXG52YXIgYmluZGluZyA9IHJlcXVpcmUoJy4vYmluZGluZycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jykub2s7XG5cbi8vIHpsaWIgZG9lc24ndCBwcm92aWRlIHRoZXNlLCBzbyBrbHVkZ2UgdGhlbSBpbiBmb2xsb3dpbmcgdGhlIHNhbWVcbi8vIGNvbnN0IG5hbWluZyBzY2hlbWUgemxpYiB1c2VzLlxuYmluZGluZy5aX01JTl9XSU5ET1dCSVRTID0gODtcbmJpbmRpbmcuWl9NQVhfV0lORE9XQklUUyA9IDE1O1xuYmluZGluZy5aX0RFRkFVTFRfV0lORE9XQklUUyA9IDE1O1xuXG4vLyBmZXdlciB0aGFuIDY0IGJ5dGVzIHBlciBjaHVuayBpcyBzdHVwaWQuXG4vLyB0ZWNobmljYWxseSBpdCBjb3VsZCB3b3JrIHdpdGggYXMgZmV3IGFzIDgsIGJ1dCBldmVuIDY0IGJ5dGVzXG4vLyBpcyBhYnN1cmRseSBsb3cuICBVc3VhbGx5IGEgTUIgb3IgbW9yZSBpcyBiZXN0LlxuYmluZGluZy5aX01JTl9DSFVOSyA9IDY0O1xuYmluZGluZy5aX01BWF9DSFVOSyA9IEluZmluaXR5O1xuYmluZGluZy5aX0RFRkFVTFRfQ0hVTksgPSAoMTYgKiAxMDI0KTtcblxuYmluZGluZy5aX01JTl9NRU1MRVZFTCA9IDE7XG5iaW5kaW5nLlpfTUFYX01FTUxFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMID0gODtcblxuYmluZGluZy5aX01JTl9MRVZFTCA9IC0xO1xuYmluZGluZy5aX01BWF9MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9MRVZFTCA9IGJpbmRpbmcuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuXG4vLyBleHBvc2UgYWxsIHRoZSB6bGliIGNvbnN0YW50c1xuT2JqZWN0LmtleXMoYmluZGluZykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGlmIChrLm1hdGNoKC9eWi8pKSBleHBvcnRzW2tdID0gYmluZGluZ1trXTtcbn0pO1xuXG4vLyB0cmFuc2xhdGlvbiB0YWJsZSBmb3IgcmV0dXJuIGNvZGVzLlxuZXhwb3J0cy5jb2RlcyA9IHtcbiAgWl9PSzogYmluZGluZy5aX09LLFxuICBaX1NUUkVBTV9FTkQ6IGJpbmRpbmcuWl9TVFJFQU1fRU5ELFxuICBaX05FRURfRElDVDogYmluZGluZy5aX05FRURfRElDVCxcbiAgWl9FUlJOTzogYmluZGluZy5aX0VSUk5PLFxuICBaX1NUUkVBTV9FUlJPUjogYmluZGluZy5aX1NUUkVBTV9FUlJPUixcbiAgWl9EQVRBX0VSUk9SOiBiaW5kaW5nLlpfREFUQV9FUlJPUixcbiAgWl9NRU1fRVJST1I6IGJpbmRpbmcuWl9NRU1fRVJST1IsXG4gIFpfQlVGX0VSUk9SOiBiaW5kaW5nLlpfQlVGX0VSUk9SLFxuICBaX1ZFUlNJT05fRVJST1I6IGJpbmRpbmcuWl9WRVJTSU9OX0VSUk9SXG59O1xuXG5PYmplY3Qua2V5cyhleHBvcnRzLmNvZGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgZXhwb3J0cy5jb2Rlc1tleHBvcnRzLmNvZGVzW2tdXSA9IGs7XG59KTtcblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLkd6aXAgPSBHemlwO1xuZXhwb3J0cy5HdW56aXAgPSBHdW56aXA7XG5leHBvcnRzLkRlZmxhdGVSYXcgPSBEZWZsYXRlUmF3O1xuZXhwb3J0cy5JbmZsYXRlUmF3ID0gSW5mbGF0ZVJhdztcbmV4cG9ydHMuVW56aXAgPSBVbnppcDtcblxuZXhwb3J0cy5jcmVhdGVEZWZsYXRlID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IERlZmxhdGUobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZVJhdyA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBEZWZsYXRlUmF3KG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVJbmZsYXRlUmF3ID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEluZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUd6aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgR3ppcChvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3VuemlwID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEd1bnppcChvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlVW56aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgVW56aXAobyk7XG59O1xuXG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZHMuXG4vLyBjb21wcmVzcy9kZWNvbXByZXNzIGEgc3RyaW5nIG9yIGJ1ZmZlciBpbiBvbmUgc3RlcC5cbmV4cG9ydHMuZGVmbGF0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgRGVmbGF0ZShvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3ppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3ppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd6aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgR3ppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXdTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMudW56aXAgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IFVuemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMudW56aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgVW56aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmluZmxhdGUgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmd1bnppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgSW5mbGF0ZVJhdyhvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmluZmxhdGVSYXdTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXIoZW5naW5lLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBucmVhZCA9IDA7XG5cbiAgZW5naW5lLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICBlbmdpbmUub24oJ2VuZCcsIG9uRW5kKTtcblxuICBlbmdpbmUuZW5kKGJ1ZmZlcik7XG4gIGZsb3coKTtcblxuICBmdW5jdGlvbiBmbG93KCkge1xuICAgIHZhciBjaHVuaztcbiAgICB3aGlsZSAobnVsbCAhPT0gKGNodW5rID0gZW5naW5lLnJlYWQoKSkpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIGVuZ2luZS5vbmNlKCdyZWFkYWJsZScsIGZsb3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICBlbmdpbmUucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICBlbmdpbmUucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgZmxvdyk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICBidWZmZXJzID0gW107XG4gICAgY2FsbGJhY2sobnVsbCwgYnVmKTtcbiAgICBlbmdpbmUuY2xvc2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB6bGliQnVmZmVyU3luYyhlbmdpbmUsIGJ1ZmZlcikge1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIHN0cmluZyBvciBidWZmZXInKTtcblxuICB2YXIgZmx1c2hGbGFnID0gYmluZGluZy5aX0ZJTklTSDtcblxuICByZXR1cm4gZW5naW5lLl9wcm9jZXNzQ2h1bmsoYnVmZmVyLCBmbHVzaEZsYWcpO1xufVxuXG4vLyBnZW5lcmljIHpsaWJcbi8vIG1pbmltYWwgMi1ieXRlIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFKTtcbn1cblxuXG5cbi8vIGd6aXAgLSBiaWdnZXIgaGVhZGVyLCBzYW1lIGRlZmxhdGUgY29tcHJlc3Npb25cbmZ1bmN0aW9uIEd6aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3ppcCkpIHJldHVybiBuZXcgR3ppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuR1pJUCk7XG59XG5cbmZ1bmN0aW9uIEd1bnppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHdW56aXApKSByZXR1cm4gbmV3IEd1bnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuR1VOWklQKTtcbn1cblxuXG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlUmF3KSkgcmV0dXJuIG5ldyBEZWZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFUkFXKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlUmF3KSkgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFUkFXKTtcbn1cblxuXG4vLyBhdXRvLWRldGVjdCBoZWFkZXIuXG5mdW5jdGlvbiBVbnppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVbnppcCkpIHJldHVybiBuZXcgVW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLlVOWklQKTtcbn1cblxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuXG5mdW5jdGlvbiBabGliKG9wdHMsIG1vZGUpIHtcbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLl9jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCBleHBvcnRzLlpfREVGQVVMVF9DSFVOSztcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAob3B0cy5mbHVzaCkge1xuICAgIGlmIChvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfTk9fRkxVU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX1BBUlRJQUxfRkxVU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX1NZTkNfRkxVU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX0ZVTExfRkxVU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX0ZJTklTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfQkxPQ0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCBmbGFnOiAnICsgb3B0cy5mbHVzaCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX2ZsdXNoRmxhZyA9IG9wdHMuZmx1c2ggfHwgYmluZGluZy5aX05PX0ZMVVNIO1xuXG4gIGlmIChvcHRzLmNodW5rU2l6ZSkge1xuICAgIGlmIChvcHRzLmNodW5rU2l6ZSA8IGV4cG9ydHMuWl9NSU5fQ0hVTksgfHxcbiAgICAgICAgb3B0cy5jaHVua1NpemUgPiBleHBvcnRzLlpfTUFYX0NIVU5LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2h1bmsgc2l6ZTogJyArIG9wdHMuY2h1bmtTaXplKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy53aW5kb3dCaXRzKSB7XG4gICAgaWYgKG9wdHMud2luZG93Qml0cyA8IGV4cG9ydHMuWl9NSU5fV0lORE9XQklUUyB8fFxuICAgICAgICBvcHRzLndpbmRvd0JpdHMgPiBleHBvcnRzLlpfTUFYX1dJTkRPV0JJVFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB3aW5kb3dCaXRzOiAnICsgb3B0cy53aW5kb3dCaXRzKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5sZXZlbCkge1xuICAgIGlmIChvcHRzLmxldmVsIDwgZXhwb3J0cy5aX01JTl9MRVZFTCB8fFxuICAgICAgICBvcHRzLmxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgb3B0cy5sZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubWVtTGV2ZWwpIHtcbiAgICBpZiAob3B0cy5tZW1MZXZlbCA8IGV4cG9ydHMuWl9NSU5fTUVNTEVWRUwgfHxcbiAgICAgICAgb3B0cy5tZW1MZXZlbCA+IGV4cG9ydHMuWl9NQVhfTUVNTEVWRUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZW1MZXZlbDogJyArIG9wdHMubWVtTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLnN0cmF0ZWd5KSB7XG4gICAgaWYgKG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJTFRFUkVEICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklYRUQgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgb3B0cy5zdHJhdGVneSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuZGljdGlvbmFyeSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdHMuZGljdGlvbmFyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWN0aW9uYXJ5OiBpdCBzaG91bGQgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9iaW5kaW5nID0gbmV3IGJpbmRpbmcuWmxpYihtb2RlKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2hhZEVycm9yID0gZmFsc2U7XG4gIHRoaXMuX2JpbmRpbmcub25lcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGVycm5vKSB7XG4gICAgLy8gdGhlcmUgaXMgbm8gd2F5IHRvIGNsZWFubHkgcmVjb3Zlci5cbiAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgc2VsZi5fYmluZGluZyA9IG51bGw7XG4gICAgc2VsZi5faGFkRXJyb3IgPSB0cnVlO1xuXG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLmVycm5vID0gZXJybm87XG4gICAgZXJyb3IuY29kZSA9IGV4cG9ydHMuY29kZXNbZXJybm9dO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH07XG5cbiAgdmFyIGxldmVsID0gZXhwb3J0cy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG4gIGlmICh0eXBlb2Ygb3B0cy5sZXZlbCA9PT0gJ251bWJlcicpIGxldmVsID0gb3B0cy5sZXZlbDtcblxuICB2YXIgc3RyYXRlZ3kgPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWTtcbiAgaWYgKHR5cGVvZiBvcHRzLnN0cmF0ZWd5ID09PSAnbnVtYmVyJykgc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuXG4gIHRoaXMuX2JpbmRpbmcuaW5pdChvcHRzLndpbmRvd0JpdHMgfHwgZXhwb3J0cy5aX0RFRkFVTFRfV0lORE9XQklUUyxcbiAgICAgICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgb3B0cy5tZW1MZXZlbCB8fCBleHBvcnRzLlpfREVGQVVMVF9NRU1MRVZFTCxcbiAgICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgb3B0cy5kaWN0aW9uYXJ5KTtcblxuICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuX2NodW5rU2l6ZSk7XG4gIHRoaXMuX29mZnNldCA9IDA7XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICB0aGlzLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuXG4gIHRoaXMub25jZSgnZW5kJywgdGhpcy5jbG9zZSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoWmxpYiwgVHJhbnNmb3JtKTtcblxuWmxpYi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24obGV2ZWwsIHN0cmF0ZWd5LCBjYWxsYmFjaykge1xuICBpZiAobGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8XG4gICAgICBsZXZlbCA+IGV4cG9ydHMuWl9NQVhfTEVWRUwpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBjb21wcmVzc2lvbiBsZXZlbDogJyArIGxldmVsKTtcbiAgfVxuICBpZiAoc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJTFRFUkVEICYmXG4gICAgICBzdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmXG4gICAgICBzdHJhdGVneSAhPSBleHBvcnRzLlpfUkxFICYmXG4gICAgICBzdHJhdGVneSAhPSBleHBvcnRzLlpfRklYRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIHN0cmF0ZWd5KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9sZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5fc3RyYXRlZ3kgIT09IHN0cmF0ZWd5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmx1c2goYmluZGluZy5aX1NZTkNfRkxVU0gsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fYmluZGluZy5wYXJhbXMobGV2ZWwsIHN0cmF0ZWd5KTtcbiAgICAgIGlmICghc2VsZi5faGFkRXJyb3IpIHtcbiAgICAgICAgc2VsZi5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgc2VsZi5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYmluZGluZy5yZXNldCgpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgX2ZsdXNoIGZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgdHJhbnNmb3JtIGNsYXNzLFxuLy8gaW50ZXJuYWxseSwgd2hlbiB0aGUgbGFzdCBjaHVuayBoYXMgYmVlbiB3cml0dGVuLlxuWmxpYi5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fdHJhbnNmb3JtKG5ldyBCdWZmZXIoMCksICcnLCBjYWxsYmFjayk7XG59O1xuXG5abGliLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKGtpbmQsIGNhbGxiYWNrKSB7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBraW5kID09PSAnZnVuY3Rpb24nIHx8IChraW5kID09PSB2b2lkIDAgJiYgIWNhbGxiYWNrKSkge1xuICAgIGNhbGxiYWNrID0ga2luZDtcbiAgICBraW5kID0gYmluZGluZy5aX0ZVTExfRkxVU0g7XG4gIH1cblxuICBpZiAod3MuZW5kZWQpIHtcbiAgICBpZiAoY2FsbGJhY2spXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh3cy5lbmRpbmcpIHtcbiAgICBpZiAoY2FsbGJhY2spXG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh3cy5uZWVkRHJhaW4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5mbHVzaChjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZmx1c2hGbGFnID0ga2luZDtcbiAgICB0aGlzLndyaXRlKG5ldyBCdWZmZXIoMCksICcnLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKVxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuXG4gIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cbiAgdGhpcy5fYmluZGluZy5jbG9zZSgpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIGZsdXNoRmxhZztcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIGVuZGluZyA9IHdzLmVuZGluZyB8fCB3cy5lbmRlZDtcbiAgdmFyIGxhc3QgPSBlbmRpbmcgJiYgKCFjaHVuayB8fCB3cy5sZW5ndGggPT09IGNodW5rLmxlbmd0aCk7XG5cbiAgaWYgKCFjaHVuayA9PT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIGlucHV0JykpO1xuXG4gIC8vIElmIGl0J3MgdGhlIGxhc3QgY2h1bmssIG9yIGEgZmluYWwgZmx1c2gsIHdlIHVzZSB0aGUgWl9GSU5JU0ggZmx1c2ggZmxhZy5cbiAgLy8gSWYgaXQncyBleHBsaWNpdGx5IGZsdXNoaW5nIGF0IHNvbWUgb3RoZXIgdGltZSwgdGhlbiB3ZSB1c2VcbiAgLy8gWl9GVUxMX0ZMVVNILiBPdGhlcndpc2UsIHVzZSBaX05PX0ZMVVNIIGZvciBtYXhpbXVtIGNvbXByZXNzaW9uXG4gIC8vIGdvb2RuZXNzLlxuICBpZiAobGFzdClcbiAgICBmbHVzaEZsYWcgPSBiaW5kaW5nLlpfRklOSVNIO1xuICBlbHNlIHtcbiAgICBmbHVzaEZsYWcgPSB0aGlzLl9mbHVzaEZsYWc7XG4gICAgLy8gb25jZSB3ZSd2ZSBmbHVzaGVkIHRoZSBsYXN0IG9mIHRoZSBxdWV1ZSwgc3RvcCBmbHVzaGluZyBhbmRcbiAgICAvLyBnbyBiYWNrIHRvIHRoZSBub3JtYWwgYmVoYXZpb3IuXG4gICAgaWYgKGNodW5rLmxlbmd0aCA+PSB3cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2ZsdXNoRmxhZyA9IHRoaXMuX29wdHMuZmx1c2ggfHwgYmluZGluZy5aX05PX0ZMVVNIO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcsIGNiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgZmx1c2hGbGFnLCBjYikge1xuICB2YXIgYXZhaWxJbkJlZm9yZSA9IGNodW5rICYmIGNodW5rLmxlbmd0aDtcbiAgdmFyIGF2YWlsT3V0QmVmb3JlID0gdGhpcy5fY2h1bmtTaXplIC0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYXN5bmMgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIG5yZWFkID0gMDtcblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVyKSB7XG4gICAgICBlcnJvciA9IGVyO1xuICAgIH0pO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX2JpbmRpbmcud3JpdGVTeW5jKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZiwgLy8gaW5fb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuICAgIH0gd2hpbGUgKCF0aGlzLl9oYWRFcnJvciAmJiBjYWxsYmFjayhyZXNbMF0sIHJlc1sxXSkpO1xuXG4gICAgaWYgKHRoaXMuX2hhZEVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHZhciByZXEgPSB0aGlzLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssIC8vIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuXG4gIHJlcS5idWZmZXIgPSBjaHVuaztcbiAgcmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soYXZhaWxJbkFmdGVyLCBhdmFpbE91dEFmdGVyKSB7XG4gICAgaWYgKHNlbGYuX2hhZEVycm9yKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGhhdmUgPSBhdmFpbE91dEJlZm9yZSAtIGF2YWlsT3V0QWZ0ZXI7XG4gICAgYXNzZXJ0KGhhdmUgPj0gMCwgJ2hhdmUgc2hvdWxkIG5vdCBnbyBkb3duJyk7XG5cbiAgICBpZiAoaGF2ZSA+IDApIHtcbiAgICAgIHZhciBvdXQgPSBzZWxmLl9idWZmZXIuc2xpY2Uoc2VsZi5fb2Zmc2V0LCBzZWxmLl9vZmZzZXQgKyBoYXZlKTtcbiAgICAgIHNlbGYuX29mZnNldCArPSBoYXZlO1xuICAgICAgLy8gc2VydmUgc29tZSBvdXRwdXQgdG8gdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIHNlbGYucHVzaChvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKG91dCk7XG4gICAgICAgIG5yZWFkICs9IG91dC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXhoYXVzdGVkIHRoZSBvdXRwdXQgYnVmZmVyLCBvciB1c2VkIGFsbCB0aGUgaW5wdXQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCB8fCBzZWxmLl9vZmZzZXQgPj0gc2VsZi5fY2h1bmtTaXplKSB7XG4gICAgICBhdmFpbE91dEJlZm9yZSA9IHNlbGYuX2NodW5rU2l6ZTtcbiAgICAgIHNlbGYuX29mZnNldCA9IDA7XG4gICAgICBzZWxmLl9idWZmZXIgPSBuZXcgQnVmZmVyKHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDApIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiAgTmVlZCB0byByZXByb2Nlc3MuXG4gICAgICAvLyBBbHNvLCB1cGRhdGUgdGhlIGF2YWlsSW5CZWZvcmUgdG8gdGhlIGF2YWlsSW5BZnRlciB2YWx1ZSxcbiAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgLy8gaXQnbGwgaGF2ZSB0aGUgY29ycmVjdCBieXRlIGNvdW50cy5cbiAgICAgIGluT2ZmICs9IChhdmFpbEluQmVmb3JlIC0gYXZhaWxJbkFmdGVyKTtcbiAgICAgIGF2YWlsSW5CZWZvcmUgPSBhdmFpbEluQWZ0ZXI7XG5cbiAgICAgIGlmICghYXN5bmMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgbmV3UmVxID0gc2VsZi5fYmluZGluZy53cml0ZShmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxJbkJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2J1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgICBuZXdSZXEuY2FsbGJhY2sgPSBjYWxsYmFjazsgLy8gdGhpcyBzYW1lIGZ1bmN0aW9uXG4gICAgICBuZXdSZXEuYnVmZmVyID0gY2h1bms7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhc3luYylcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGZpbmlzaGVkIHdpdGggdGhlIGNodW5rLlxuICAgIGNiKCk7XG4gIH1cbn07XG5cbnV0aWwuaW5oZXJpdHMoRGVmbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEluZmxhdGUsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHemlwLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoR3VuemlwLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoRGVmbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKEluZmxhdGVSYXcsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhVbnppcCwgWmxpYik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTE9BVDMyX1ZJRVcgPSBuZXcgRmxvYXQzMkFycmF5KCAxICk7XG52YXIgVUlOVDMyX1ZJRVcgPSBuZXcgVWludDMyQXJyYXkoIEZMT0FUMzJfVklFVy5idWZmZXIgKTtcblxuLy8gMSAxMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiA0Mjg2NTc4Njg4ID0+IDB4ZmY4MDAwMDAgKHNlZSBJRUVFIDc1NC0yMDA4KVxudmFyIE5JTkYgPSAweGZmODAwMDAwO1xuXG4vLyBTZXQgdGhlIEFycmF5QnVmZmVyIGJpdCBzZXF1ZW5jZTpcblVJTlQzMl9WSUVXWyAwIF0gPSBOSU5GO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDMyX1ZJRVdbIDAgXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVkFSSUFCTEVTIC8vXG5cbnZhciBGTE9BVDMyX1ZJRVcgPSBuZXcgRmxvYXQzMkFycmF5KCAxICk7XG52YXIgVUlOVDMyX1ZJRVcgPSBuZXcgVWludDMyQXJyYXkoIEZMT0FUMzJfVklFVy5idWZmZXIgKTtcblxuLy8gMCAxMTExMTExMSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCA9PiAyMTM5MDk1MDQwID0+IDB4N2Y4MDAwMDAgKHNlZSBJRUVFIDc1NC0yMDA4KVxudmFyIFBJTkYgPSAweDdmODAwMDAwO1xuXG4vLyBTZXQgdGhlIEFycmF5QnVmZmVyIGJpdCBzZXF1ZW5jZTpcblVJTlQzMl9WSUVXWyAwIF0gPSBQSU5GO1xuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBGTE9BVDMyX1ZJRVdbIDAgXTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qISBkaWNvbS1wYXJzZXIgLSB2MS43LjMgLSAyMDE2LTA4LTE4IHwgKGMpIDIwMTQgQ2hyaXMgSGFmZXkgfCBodHRwczovL2dpdGh1Yi5jb20vY2hhZmV5L2RpY29tUGFyc2VyICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICAgIC8vIG5vZGUuanNcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIGlmKHR5cGVvZiBjb3JuZXJzdG9uZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcblxuICAgICAgICAgICAgLy8gbWV0ZW9yXG4gICAgICAgICAgICBpZiAodHlwZW9mIFBhY2thZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5kaWNvbVBhcnNlciA9IGRpY29tUGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpY29tUGFyc2VyID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vKipcbiAqIFBhcnNlcyBhIERJQ09NIFAxMCBieXRlIGFycmF5IGFuZCByZXR1cm5zIGEgRGF0YVNldCBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIGVsZW1lbnRzLiAgSWYgdGhlIG9wdGlvbnNcbiAqIGFyZ3VtZW50IGlzIHN1cHBsaWVkIGFuZCBpdCBjb250YWlucyB0aGUgdW50aWxUYWcgcHJvcGVydHksIHBhcnNpbmcgd2lsbCBzdG9wIG9uY2UgdGhhdFxuICogdGFnIGlzIGVuY291dGVyZWQuICBUaGlzIGNhbiBiZSB1c2VkIHRvIHBhcnNlIHBhcnRpYWwgYnl0ZSBzdHJlYW1zLlxuICpcbiAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB0byBjb250cm9sIHBhcnNpbmcgYmVoYXZpb3IgKG9wdGlvbmFsKVxuICogQHJldHVybnMge0RhdGFTZXR9XG4gKiBAdGhyb3dzIGVycm9yIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBwYXJzaW5nLiAgVGhlIGV4Y2VwdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIGEgcHJvcGVydHkgZGF0YVNldCB3aXRoIHRoZVxuICogICAgICAgICBlbGVtZW50cyBzdWNjZXNzZnVsbHkgcGFyc2VkIGJlZm9yZSB0aGUgZXJyb3IuXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbihkaWNvbVBhcnNlcikge1xuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb20gPSBmdW5jdGlvbihieXRlQXJyYXksIG9wdGlvbnMpIHtcblxuICAgICAgICBpZihieXRlQXJyYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5J1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZFRyYW5zZmVyU3ludGF4KG1ldGFIZWFkZXJEYXRhU2V0KSB7XG4gICAgICAgICAgICBpZihtZXRhSGVhZGVyRGF0YVNldC5lbGVtZW50cy54MDAwMjAwMTAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5wYXJzZURpY29tOiBtaXNzaW5nIHJlcXVpcmVkIG1ldGEgaGVhZGVyIGF0dHJpYnV0ZSAwMDAyLDAwMTAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYW5zZmVyU3ludGF4RWxlbWVudCA9IG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzLngwMDAyMDAxMDtcbiAgICAgICAgICAgIHJldHVybiBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcoYnl0ZUFycmF5LCB0cmFuc2ZlclN5bnRheEVsZW1lbnQuZGF0YU9mZnNldCwgdHJhbnNmZXJTeW50YXhFbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0V4cGxpY2l0KHRyYW5zZmVyU3ludGF4KSB7XG4gICAgICAgICAgICBpZih0cmFuc2ZlclN5bnRheCA9PT0gJzEuMi44NDAuMTAwMDguMS4yJykgLy8gaW1wbGljaXQgbGl0dGxlIGVuZGlhblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2ZlciBzeW50YXhlcyBzaG91bGQgYmUgZXhwbGljaXRcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGF0YVNldEJ5dGVTdHJlYW0odHJhbnNmZXJTeW50YXgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZih0cmFuc2ZlclN5bnRheCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjEuOTknKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGlmIGFuIGluZmFsdGVyIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQsIHVzZSBpdFxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5mbGF0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxCeXRlQXJyYXlDYWxsYmFjayA9IG9wdGlvbnMuaW5mbGF0ZXIoYnl0ZUFycmF5LCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGZ1bGxCeXRlQXJyYXlDYWxsYmFjaywgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHJ1bm5pbmcgb24gbm9kZSwgdXNlIHRoZSB6bGliIGxpYnJhcnkgdG8gaW5mbGF0ZVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDIyNDYwNi9ob3ctdG8tY2hlY2std2hldGhlci1hLXNjcmlwdC1pcy1ydW5uaW5nLXVuZGVyLW5vZGUtanNcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm1vZHVsZSAhPT0gbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZmxhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZsYXRlZEJ1ZmZlciA9IGRpY29tUGFyc2VyLnNoYXJlZENvcHkoYnl0ZUFycmF5LCBwb3NpdGlvbiwgYnl0ZUFycmF5Lmxlbmd0aCAtIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGVkQnVmZmVyID0gemxpYi5pbmZsYXRlUmF3U3luYyhkZWZsYXRlZEJ1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2luZ2xlIGJ5dGUgYXJyYXkgd2l0aCB0aGUgZnVsbCBoZWFkZXIgYnl0ZXMgYW5kIHRoZSBpbmZsYXRlZCBieXRlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEJ5dGVBcnJheUJ1ZmZlciA9IGRpY29tUGFyc2VyLmFsbG9jKGJ5dGVBcnJheSwgaW5mbGF0ZWRCdWZmZXIubGVuZ3RoICsgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkuY29weShmdWxsQnl0ZUFycmF5QnVmZmVyLCAwLCAwLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGluZmxhdGVkQnVmZmVyLmNvcHkoZnVsbEJ5dGVBcnJheUJ1ZmZlciwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBmdWxsQnl0ZUFycmF5QnVmZmVyLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgcGFrbyBpcyBkZWZpbmVkIC0gdXNlIGl0LiAgVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrb1xuICAgICAgICAgICAgICAgIGVsc2UgaWYodHlwZW9mIHBha28gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5mbGF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZWQgPSBieXRlQXJyYXkuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZWQgPSBwYWtvLmluZmxhdGVSYXcoZGVmbGF0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHNpbmdsZSBieXRlIGFycmF5IHdpdGggdGhlIGZ1bGwgaGVhZGVyIGJ5dGVzIGFuZCB0aGUgaW5mbGF0ZWQgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxCeXRlQXJyYXkgPSBkaWNvbVBhcnNlci5hbGxvYyhieXRlQXJyYXksIGluZmxhdGVkLmxlbmd0aCArIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEJ5dGVBcnJheS5zZXQoYnl0ZUFycmF5LnNsaWNlKDAsIHBvc2l0aW9uKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxCeXRlQXJyYXkuc2V0KGluZmxhdGVkLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbShkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIsIGZ1bGxCeXRlQXJyYXksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBleGNlcHRpb24gc2luY2Ugbm8gaW5mbGF0ZXIgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5wYXJzZURpY29tOiBubyBpbmZsYXRlciBhdmFpbGFibGUgdG8gaGFuZGxlIGRlZmxhdGUgdHJhbnNmZXIgc3ludGF4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0cmFuc2ZlclN5bnRheCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjInKSAvLyBleHBsaWNpdCBiaWcgZW5kaWFuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmJpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5LCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zZmVyIHN5bnRheGVzIGFyZSBsaXR0bGUgZW5kaWFuOyBvbmx5IHRoZSBwaXhlbCBlbmNvZGluZyBkaWZmZXJzXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBhIG5ldyBzdHJlYW0gc28gdGhlIG1ldGFoZWFkZXIgd2FybmluZ3MgZG9uJ3QgY29tZSBhbG9uZyBmb3IgdGhlIHJpZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGljb21QYXJzZXIubGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLCBieXRlQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlRGF0YVNldHMobWV0YUhlYWRlckRhdGFTZXQsIGluc3RhbmNlRGF0YVNldClcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZURhdGFTZXQuZWxlbWVudHNbcHJvcGVydHlOYW1lXSA9IG1ldGFIZWFkZXJEYXRhU2V0LmVsZW1lbnRzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFIZWFkZXJEYXRhU2V0Lndhcm5pbmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURhdGFTZXQud2FybmluZ3MgPSBtZXRhSGVhZGVyRGF0YVNldC53YXJuaW5ncy5jb25jYXQoaW5zdGFuY2VEYXRhU2V0Lndhcm5pbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZURhdGFTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkRGF0YVNldChtZXRhSGVhZGVyRGF0YVNldClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRyYW5zZmVyU3ludGF4ID0gcmVhZFRyYW5zZmVyU3ludGF4KG1ldGFIZWFkZXJEYXRhU2V0KTtcbiAgICAgICAgICAgIHZhciBleHBsaWNpdCA9IGlzRXhwbGljaXQodHJhbnNmZXJTeW50YXgpO1xuICAgICAgICAgICAgdmFyIGRhdGFTZXRCeXRlU3RyZWFtID0gZ2V0RGF0YVNldEJ5dGVTdHJlYW0odHJhbnNmZXJTeW50YXgsIG1ldGFIZWFkZXJEYXRhU2V0LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG4gICAgICAgICAgICB2YXIgZGF0YVNldCA9IG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGRhdGFTZXRCeXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgZGF0YVNldEJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgICAgICAgICBkYXRhU2V0Lndhcm5pbmdzID0gZGF0YVNldEJ5dGVTdHJlYW0ud2FybmluZ3M7XG5cbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBpZihleHBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEV4cGxpY2l0KGRhdGFTZXQsIGRhdGFTZXRCeXRlU3RyZWFtLCBkYXRhU2V0Qnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdChkYXRhU2V0LCBkYXRhU2V0Qnl0ZVN0cmVhbSwgZGF0YVNldEJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHZhciBleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uOiBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhU2V0OiBkYXRhU2V0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFpbiBmdW5jdGlvbiBoZXJlXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlVGhlQnl0ZVN0cmVhbSgpIHtcbiAgICAgICAgICAgIHZhciBtZXRhSGVhZGVyRGF0YVNldCA9IGRpY29tUGFyc2VyLnJlYWRQYXJ0MTBIZWFkZXIoYnl0ZUFycmF5LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFTZXQgPSByZWFkRGF0YVNldChtZXRhSGVhZGVyRGF0YVNldCk7XG5cbiAgICAgICAgICAgIHJldHVybiBtZXJnZURhdGFTZXRzKG1ldGFIZWFkZXJEYXRhU2V0LCBkYXRhU2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgd2UgYWN0dWFsbHkgc3RhcnQgcGFyc2luZ1xuICAgICAgICByZXR1cm4gcGFyc2VUaGVCeXRlU3RyZWFtKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0pKGRpY29tUGFyc2VyKTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGJhc2ljIG9mZnNldCB0YWJsZSBmb3IgSlBFRyB0cmFuc2ZlciBzeW50YXhlc1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgLy8gRWFjaCBKUEVHIGltYWdlIGhhcyBhbiBlbmQgb2YgaW1hZ2UgbWFya2VyIDB4RkZEOVxuICBmdW5jdGlvbiBpc0VuZE9mSW1hZ2VNYXJrZXIoZGF0YVNldCwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gKGRhdGFTZXQuYnl0ZUFycmF5W3Bvc2l0aW9uXSA9PT0gMHhGRiAmJlxuICAgIGRhdGFTZXQuYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV0gPT09IDB4RDkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGcmFnbWVudEVuZE9mSW1hZ2UoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhZ21lbnRJbmRleCkge1xuICAgIHZhciBmcmFnbWVudCA9IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzW2ZyYWdtZW50SW5kZXhdO1xuICAgIC8vIE5lZWQgdG8gY2hlY2sgdGhlIGxhc3QgdHdvIGJ5dGVzIGFuZCB0aGUgbGFzdCB0aHJlZSBieXRlcyBmb3IgbWFya2VyIHNpbmNlIG9kZCBsZW5ndGhcbiAgICAvLyBmcmFnbWVudHMgYXJlIHplcm8gcGFkZGVkXG4gICAgaWYoaXNFbmRPZkltYWdlTWFya2VyKGRhdGFTZXQsIGZyYWdtZW50LnBvc2l0aW9uICsgZnJhZ21lbnQubGVuZ3RoIC0gMikgfHxcbiAgICAgIGlzRW5kT2ZJbWFnZU1hcmtlcihkYXRhU2V0LCBmcmFnbWVudC5wb3NpdGlvbiArIGZyYWdtZW50Lmxlbmd0aCAtIDMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZExhc3RJbWFnZUZyYW1lRnJhZ21lbnRJbmRleChkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBzdGFydEZyYWdtZW50KSB7XG4gICAgZm9yKHZhciBmcmFnbWVudEluZGV4PXN0YXJ0RnJhZ21lbnQ7IGZyYWdtZW50SW5kZXggPCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGg7IGZyYWdtZW50SW5kZXgrKykge1xuICAgICAgaWYoaXNGcmFnbWVudEVuZE9mSW1hZ2UoZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhZ21lbnRJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBiYXNpYyBvZmZzZXQgdGFibGUgYnkgc2Nhbm5pbmcgZnJhZ21lbnRzIGZvciBKUEVHIHN0YXJ0IG9mIGltYWdlIGFuZCBlbmQgT2YgSW1hZ2UgbWFya2Vyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVNldCAtIHRoZSBwYXJzZWQgZGljb20gZGF0YXNldFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGl4ZWxEYXRhRWxlbWVudCAtIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnRcbiAgICogQHBhcmFtIFtmcmFnbWVudHNdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggZnJhZ21lbnQgKG9mZnNldCwgcG9zaXRpb24sIGxlbmd0aClcbiAgICogQHJldHVybnMge0FycmF5fSBiYXNpYyBvZmZzZXQgdGFibGUgKGFycmF5IG9mIG9mZnNldHMgdG8gYmVnaW5uaW5nIG9mIGVhY2ggZnJhbWUpXG4gICAqL1xuICBkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZSA9IGZ1bmN0aW9uKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYWdtZW50cykge1xuICAgIC8vIFZhbGlkYXRlIHBhcmFtZXRlcnNcbiAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93ICdkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgZGF0YVNldCc7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBwaXhlbERhdGFFbGVtZW50JztcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC50YWcgIT09ICd4N2ZlMDAwMTAnKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmNyZWF0ZUpQRUdCYXNpY09mZnNldFRhYmxlOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBub24gcGl4ZWwgZGF0YSB0YWcgKGV4cGVjdGVkIHRhZyA9IHg3ZmUwMDAxMCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jcmVhdGVKUEVHQmFzaWNPZmZzZXRUYWJsZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihmcmFnbWVudHMgJiYgZnJhZ21lbnRzLmxlbmd0aCA8PTApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuY3JlYXRlSlBFR0Jhc2ljT2Zmc2V0VGFibGU6IHBhcmFtZXRlciAnZnJhZ21lbnRzJyBtdXN0IG5vdCBiZSB6ZXJvIGxlbmd0aFwiO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdmFsdWVzXG4gICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzIHx8IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzO1xuXG4gICAgdmFyIGJhc2ljT2Zmc2V0VGFibGUgPSBbXTtcblxuICAgIHZhciBzdGFydEZyYWdtZW50SW5kZXggPSAwO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgLy8gQWRkIHRoZSBvZmZzZXQgZm9yIHRoZSBzdGFydCBmcmFnbWVudFxuICAgICAgYmFzaWNPZmZzZXRUYWJsZS5wdXNoKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzW3N0YXJ0RnJhZ21lbnRJbmRleF0ub2Zmc2V0KTtcbiAgICAgIHZhciBlbmRGcmFnbWVudEluZGV4ID0gZmluZExhc3RJbWFnZUZyYW1lRnJhZ21lbnRJbmRleChkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBzdGFydEZyYWdtZW50SW5kZXgpO1xuICAgICAgaWYoZW5kRnJhZ21lbnRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGVuZEZyYWdtZW50SW5kZXggPT09IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzLmxlbmd0aCAtMSkge1xuICAgICAgICByZXR1cm4gYmFzaWNPZmZzZXRUYWJsZTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0RnJhZ21lbnRJbmRleCA9IGVuZEZyYWdtZW50SW5kZXggKyAxO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGFuIGV4cGxpY2l0IGRhdGFTZXQgdG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgICAqIEBwYXJhbSBkYXRhU2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5leHBsaWNpdERhdGFTZXRUb0pTID0gZnVuY3Rpb24gKGRhdGFTZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZihkYXRhU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5leHBsaWNpdERhdGFTZXRUb0pTOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBkYXRhU2V0JztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgIG9taXRQcml2YXRlQXR0aWJ1dGVzOiB0cnVlLCAvLyB0cnVlIGlmIHByaXZhdGUgZWxlbWVudHMgc2hvdWxkIGJlIG9taXR0ZWRcbiAgICAgICAgICAgIG1heEVsZW1lbnRMZW5ndGggOiAxMjggICAgICAvLyBtYXhpbXVtIGVsZW1lbnQgbGVuZ3RoIHRvIHRyeSBhbmQgY29udmVydCB0byBzdHJpbmcgZm9ybWF0XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGZvcih2YXIgdGFnIGluIGRhdGFTZXQuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGF0YVNldC5lbGVtZW50c1t0YWddO1xuXG4gICAgICAgICAgICAvLyBza2lwIHRoaXMgZWxlbWVudCBpZiBpdCBhIHByaXZhdGUgZWxlbWVudCBhbmQgb3VyIG9wdGlvbnMgc3BlY2lmeSB0aGF0IHdlIHNob3VsZFxuICAgICAgICAgICAgaWYob3B0aW9ucy5vbWl0UHJpdmF0ZUF0dGlidXRlcyA9PT0gdHJ1ZSAmJiBkaWNvbVBhcnNlci5pc1ByaXZhdGVUYWcodGFnKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZWxlbWVudC5pdGVtcykge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2VJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIDwgZWxlbWVudC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUl0ZW1zLnB1c2goZGljb21QYXJzZXIuZXhwbGljaXREYXRhU2V0VG9KUyhlbGVtZW50Lml0ZW1zW2ldLmRhdGFTZXQsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W3RhZ10gPSBzZXF1ZW5jZUl0ZW1zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNTdHJpbmc7XG4gICAgICAgICAgICAgICAgYXNTdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPCBvcHRpb25zLm1heEVsZW1lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNTdHJpbmcgPSBkaWNvbVBhcnNlci5leHBsaWNpdEVsZW1lbnRUb1N0cmluZyhkYXRhU2V0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihhc1N0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFt0YWddID0gYXNTdHJpbmc7XG4gICAgICAgICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFt0YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogZWxlbWVudC5kYXRhT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDogZWxlbWVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gZXhwbGljaXQgVlIgZWxlbWVudCB0byBhIHN0cmluZyBvciB1bmRlZmluZWQgaWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNvbnZlcnQuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGFuIGltcGxpY2l0IGVsZW1lbnQgaXMgc3VwcGxpZWRcbiAgICAgKiBAcGFyYW0gZGF0YVNldFxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuZXhwbGljaXRFbGVtZW50VG9TdHJpbmcgPSBmdW5jdGlvbihkYXRhU2V0LCBlbGVtZW50KVxuICAgIHtcbiAgICAgICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmV4cGxpY2l0RWxlbWVudFRvU3RyaW5nOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcnMnO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQudnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLmV4cGxpY2l0RWxlbWVudFRvU3RyaW5nOiBjYW5ub3QgY29udmVydCBpbXBsaWNpdCBlbGVtZW50IHRvIHN0cmluZyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZyID0gZWxlbWVudC52cjtcbiAgICAgICAgdmFyIHRhZyA9IGVsZW1lbnQudGFnO1xuXG4gICAgICAgIHZhciB0ZXh0UmVzdWx0O1xuXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpRWxlbWVudFRvU3RyaW5nKG51bUl0ZW1zLCBmdW5jKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGZ1bmMuY2FsbChkYXRhU2V0LCB0YWcsIGkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGljb21QYXJzZXIuaXNTdHJpbmdWcih2cikgPT09IHRydWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBkYXRhU2V0LnN0cmluZyh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZyID09ICdBVCcpIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBkYXRhU2V0LnVpbnQzMih0YWcpO1xuICAgICAgICAgICAgaWYobnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bSA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtID0gMHhGRkZGRkZGRiArIG51bSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAneCcgKyBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodnIgPT0gJ1VTJylcbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dFJlc3VsdCA9IG11bHRpRWxlbWVudFRvU3RyaW5nKGVsZW1lbnQubGVuZ3RoIC8gMiwgZGF0YVNldC51aW50MTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodnIgPT09ICdTUycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDIsIGRhdGFTZXQuaW50MTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZyID09ICdVTCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDQsIGRhdGFTZXQudWludDMyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHZyID09PSAnU0wnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0UmVzdWx0ID0gbXVsdGlFbGVtZW50VG9TdHJpbmcoZWxlbWVudC5sZW5ndGggLyA0LCBkYXRhU2V0LmludDMyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHZyID09ICdGRCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDgsIGRhdGFTZXQuZG91YmxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHZyID09ICdGTCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRleHRSZXN1bHQgPSBtdWx0aUVsZW1lbnRUb1N0cmluZyhlbGVtZW50Lmxlbmd0aCAvIDQsIGRhdGFTZXQuZmxvYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRSZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggRElDT01cbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8vIGFsZ29yaXRobSBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MzMwMzAvdmFsaWRhdGUtbnVtYmVyLW9mLWRheXMtaW4tYS1naXZlbi1tb250aFxuICBmdW5jdGlvbiBkYXlzSW5Nb250aChtLCB5KSB7IC8vIG0gaXMgMCBpbmRleGVkOiAwLTExXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDIgOlxuICAgICAgICByZXR1cm4gKHkgJSA0ID09IDAgJiYgeSAlIDEwMCkgfHwgeSAlIDQwMCA9PSAwID8gMjkgOiAyODtcbiAgICAgIGNhc2UgOSA6IGNhc2UgNCA6IGNhc2UgNiA6IGNhc2UgMTEgOlxuICAgICAgcmV0dXJuIDMwO1xuICAgICAgZGVmYXVsdCA6XG4gICAgICAgIHJldHVybiAzMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREYXRlKGQsIG0sIHkpIHtcbiAgICAvLyBtYWtlIHllYXIgaXMgYSBudW1iZXJcbiAgICBpZihpc05hTih5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbSA+IDAgJiYgbSA8PSAxMiAmJiBkID4gMCAmJiBkIDw9IGRheXNJbk1vbnRoKG0sIHkpO1xuICB9XG5cblxuICAvKipcbiAgICogUGFyc2VzIGEgREEgZm9ybWF0dGVkIHN0cmluZyBpbnRvIGEgSmF2YXNjcmlwdCBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGUgYSBzdHJpbmcgaW4gdGhlIERBIFZSIGZvcm1hdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWxpZGF0ZV0gLSB0cnVlIGlmIGFuIGV4Y2VwdGlvbiBzaG91bGQgYmUgdGhyb3duIGlmIHRoZSBkYXRlIGlzIGludmFsaWRcbiAgICogQHJldHVybnMgeyp9IEphdmFzY3JpcHQgb2JqZWN0IHdpdGggcHJvcGVydGllcyB5ZWFyLCBtb250aCBhbmQgZGF5IG9yIHVuZGVmaW5lZCBpZiBub3QgcHJlc2VudCBvciBub3QgOCBieXRlcyBsb25nXG4gICAqL1xuICBkaWNvbVBhcnNlci5wYXJzZURBID0gZnVuY3Rpb24oZGF0ZSwgdmFsaWRhdGUpXG4gIHtcbiAgICBpZihkYXRlICYmIGRhdGUubGVuZ3RoID09PSA4KVxuICAgIHtcbiAgICAgIHZhciB5eXl5ID0gcGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoMCwgNCksIDEwKTtcbiAgICAgIHZhciBtbSA9IHBhcnNlSW50KGRhdGUuc3Vic3RyaW5nKDQsIDYpLCAxMCk7XG4gICAgICB2YXIgZGQgPSBwYXJzZUludChkYXRlLnN1YnN0cmluZyg2LCA4KSwgMTApO1xuXG4gICAgICBpZih2YWxpZGF0ZSkge1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUoZGQsIG1tLCB5eXl5KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IFwiaW52YWxpZCBEQSAnXCIgKyBkYXRlICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHl5eXksXG4gICAgICAgIG1vbnRoOiBtbSxcbiAgICAgICAgZGF5OiBkZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYodmFsaWRhdGUpIHtcbiAgICAgIHRocm93IFwiaW52YWxpZCBEQSAnXCIgKyBkYXRlICsgXCInXCI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERJQ09NXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgVE0gZm9ybWF0dGVkIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZvciBob3VycywgbWludXRlcywgc2Vjb25kcyBhbmQgZnJhY3Rpb25hbFNlY29uZHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWUgLSBhIHN0cmluZyBpbiB0aGUgVE0gVlIgZm9ybWF0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlXSAtIHRydWUgaWYgYW4gZXhjZXB0aW9uIHNob3VsZCBiZSB0aHJvd24gaWYgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgKiBAcmV0dXJucyB7Kn0gamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZvciBob3VycywgbWludXRlcywgc2Vjb25kcyBhbmQgZnJhY3Rpb25hbFNlY29uZHMgb3IgdW5kZWZpbmVkIGlmIG5vIGVsZW1lbnQgb3IgZGF0YS4gIE1pc3NpbmcgZmllbGRzIGFyZSBzZXQgdG8gdW5kZWZpbmVkXG4gICAqL1xuICBkaWNvbVBhcnNlci5wYXJzZVRNID0gZnVuY3Rpb24odGltZSwgdmFsaWRhdGUpIHtcblxuICAgIGlmICh0aW1lLmxlbmd0aCA+PSAyKSAvLyBtdXN0IGF0IGxlYXN0IGhhdmUgSEhcbiAgICB7XG4gICAgICAvLyAwMTIzNDU2Nzg5XG4gICAgICAvLyBISE1NU1MuRkZGRkZGXG4gICAgICB2YXIgaGggPSBwYXJzZUludCh0aW1lLnN1YnN0cmluZygwLCAyKSwgMTApO1xuICAgICAgdmFyIG1tID0gdGltZS5sZW5ndGggPj0gNCA/IHBhcnNlSW50KHRpbWUuc3Vic3RyaW5nKDIsIDQpLCAxMCkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc3MgPSB0aW1lLmxlbmd0aCA+PSA2ID8gcGFyc2VJbnQodGltZS5zdWJzdHJpbmcoNCwgNiksIDEwKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmZmZmZmYgPSB0aW1lLmxlbmd0aCA+PSA4ID8gcGFyc2VJbnQodGltZS5zdWJzdHJpbmcoNywgMTMpLCAxMCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmKHZhbGlkYXRlKSB7XG4gICAgICAgIGlmKChpc05hTihoaCkpIHx8XG4gICAgICAgICAgKG1tICE9PSB1bmRlZmluZWQgJiYgaXNOYU4obW0pKSB8fFxuICAgICAgICAgIChzcyAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKHNzKSkgfHxcbiAgICAgICAgICAoZmZmZmZmICE9PSB1bmRlZmluZWQgJiYgaXNOYU4oZmZmZmZmKSkgfHxcbiAgICAgICAgICAoaGggPCAwIHx8IGhoID4gMjMpIHx8XG4gICAgICAgICAgKG1tICYmIChtbSA8MCB8fCBtbSA+IDU5KSkgIHx8XG4gICAgICAgICAgKHNzICYmIChzcyA8MCB8fCBzcyA+IDU5KSkgIHx8XG4gICAgICAgICAgKGZmZmZmZiAmJiAoZmZmZmZmIDwwIHx8IGZmZmZmZiA+IDk5OTk5OSkpKVxuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIFRNICdcIiArIHRpbWUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBob3VyczogaGgsXG4gICAgICAgIG1pbnV0ZXM6IG1tLFxuICAgICAgICBzZWNvbmRzOiBzcyxcbiAgICAgICAgZnJhY3Rpb25hbFNlY29uZHM6IGZmZmZmZlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZih2YWxpZGF0ZSkge1xuICAgICAgdGhyb3cgXCJpbnZhbGlkIFRNICdcIiArIHRpbWUgKyBcIidcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBESUNPTVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nVnJzID0ge1xuICAgICAgICBBRTogdHJ1ZSxcbiAgICAgICAgQVM6IHRydWUsXG4gICAgICAgIEFUOiBmYWxzZSxcbiAgICAgICAgQ1M6IHRydWUsXG4gICAgICAgIERBOiB0cnVlLFxuICAgICAgICBEUzogdHJ1ZSxcbiAgICAgICAgRFQ6IHRydWUsXG4gICAgICAgIEZMOiBmYWxzZSxcbiAgICAgICAgRkQ6IGZhbHNlLFxuICAgICAgICBJUzogdHJ1ZSxcbiAgICAgICAgTE86IHRydWUsXG4gICAgICAgIExUOiB0cnVlLFxuICAgICAgICBPQjogZmFsc2UsXG4gICAgICAgIE9EOiBmYWxzZSxcbiAgICAgICAgT0Y6IGZhbHNlLFxuICAgICAgICBPVzogZmFsc2UsXG4gICAgICAgIFBOOiB0cnVlLFxuICAgICAgICBTSDogdHJ1ZSxcbiAgICAgICAgU0w6IGZhbHNlLFxuICAgICAgICBTUTogZmFsc2UsXG4gICAgICAgIFNTOiBmYWxzZSxcbiAgICAgICAgU1Q6IHRydWUsXG4gICAgICAgIFRNOiB0cnVlLFxuICAgICAgICBVSTogdHJ1ZSxcbiAgICAgICAgVUw6IGZhbHNlLFxuICAgICAgICBVTjogdW5kZWZpbmVkLCAvLyBkdW5ub1xuICAgICAgICBVUjogdHJ1ZSxcbiAgICAgICAgVVM6IGZhbHNlLFxuICAgICAgICBVVDogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyB0byBzZWUgaWYgdnIgaXMgYSBzdHJpbmcgb3Igbm90LlxuICAgICAqIEBwYXJhbSB2clxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgc3RyaW5nLCBmYWxzZSBpdCBub3Qgc3RyaW5nLCB1bmRlZmluZWQgaWYgdW5rbm93biB2ciBvciBVTiB0eXBlXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuaXNTdHJpbmdWciA9IGZ1bmN0aW9uKHZyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1Zyc1t2cl07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRvIHNlZSBpZiBhIGdpdmVuIHRhZyBpbiB0aGUgZm9ybWF0IHhnZ2dnZWVlZSBpcyBhIHByaXZhdGUgdGFnIG9yIG5vdFxuICAgICAqIEBwYXJhbSB0YWdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5pc1ByaXZhdGVUYWcgPSBmdW5jdGlvbih0YWcpXG4gICAge1xuICAgICAgICB2YXIgbGFzdEdyb3VwRGlnaXQgPSBwYXJzZUludCh0YWdbNF0pO1xuICAgICAgICB2YXIgZ3JvdXBJc09kZCA9IChsYXN0R3JvdXBEaWdpdCAlIDIpID09PSAxO1xuICAgICAgICByZXR1cm4gZ3JvdXBJc09kZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgUE4gZm9ybWF0dGVkIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZvciBnaXZlbk5hbWUsIGZhbWlseU5hbWUsIG1pZGRsZU5hbWUsIHByZWZpeCBhbmQgc3VmZml4XG4gICAgICogQHBhcmFtIHBlcnNvbk5hbWUgYSBzdHJpbmcgaW4gdGhlIFBOIFZSIGZvcm1hdFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEByZXR1cm5zIHsqfSBqYXZhc2NyaXB0IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZm9yIGdpdmVuTmFtZSwgZmFtaWx5TmFtZSwgbWlkZGxlTmFtZSwgcHJlZml4IGFuZCBzdWZmaXggb3IgdW5kZWZpbmVkIGlmIG5vIGVsZW1lbnQgb3IgZGF0YVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnBhcnNlUE4gPSBmdW5jdGlvbihwZXJzb25OYW1lKSB7XG4gICAgICAgIGlmKHBlcnNvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nVmFsdWVzID0gcGVyc29uTmFtZS5zcGxpdCgnXicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmFtaWx5TmFtZTogc3RyaW5nVmFsdWVzWzBdLFxuICAgICAgICAgICAgZ2l2ZW5OYW1lOiBzdHJpbmdWYWx1ZXNbMV0sXG4gICAgICAgICAgICBtaWRkbGVOYW1lOiBzdHJpbmdWYWx1ZXNbMl0sXG4gICAgICAgICAgICBwcmVmaXg6IHN0cmluZ1ZhbHVlc1szXSxcbiAgICAgICAgICAgIHN1ZmZpeDogc3RyaW5nVmFsdWVzWzRdXG4gICAgICAgIH07XG4gICAgfTtcblxuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEZ1bmN0aW9uYWxpdHkgZm9yIGV4dHJhY3RpbmcgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0ZWROb3RpY2VMb2dnZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBpeGVsIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgZnJhbWUgaW4gYW4gZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGEgZWxlbWVudC4gIElmIG5vIGJhc2ljIG9mZnNldFxuICAgICAqIHRhYmxlIGlzIHByZXNlbnQsIGl0IGFzc3VtZXMgdGhhdCBhbGwgZnJhZ21lbnRzIGFyZSBmb3Igb25lIGZyYW1lLiAgTm90ZSB0aGF0IHRoaXMgYXNzdW1wdGlvbi9sb2dpYyBpcyBub3RcbiAgICAgKiB2YWxpZCBmb3IgbXVsdGktZnJhbWUgaW5zdGFuY2VzIHNvIHRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBldmVudHVhbGx5IGJlIHJlbW92ZWQuICBDb2RlXG4gICAgICogc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzKCkgb3IgcmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWUoKVxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjYgLSB1c2UgcmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoKSBvciByZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZSgpXG4gICAgICogQHBhcmFtIGRhdGFTZXQgLSB0aGUgZGF0YVNldCBjb250YWluaW5nIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgICAqIEBwYXJhbSBwaXhlbERhdGFFbGVtZW50IC0gdGhlIHBpeGVsIGRhdGEgZWxlbWVudCAoeDdmZTAwMDEwKSB0byBleHRyYWN0IHRoZSBmcmFtZSBmcm9tXG4gICAgICogQHBhcmFtIGZyYW1lIC0gdGhlIHplcm8gYmFzZWQgZnJhbWUgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB3aXRoIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICAgICAqL1xuXG5cbiAgICBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgZnJhbWUpXG4gICAge1xuICAgICAgICBpZighZGVwcmVjYXRlZE5vdGljZUxvZ2dlZCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlZE5vdGljZUxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICBpZihjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKCkgaGFzIGJlZW4gZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZGF0YVNldCdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VsZW1lbnQnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZnJhbWUnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC50YWcgIT09ICd4N2ZlMDAwMTAnKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGE6IHBhcmFtZXRlciAnZWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2VsZW1lbnQnIHJlZmVycyB0byBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBkb2VzIG5vdCBoYXZlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YTogcGFyYW1ldGVyICdlbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZyYW1lIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBwYXJhbWV0ZXIgJ2ZyYW1lJyBtdXN0IGJlID49IDBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBiYXNpYyBvZmZzZXQgdGFibGUgaXMgbm90IGVtcHR5LCB3ZSBjYW4gZXh0cmFjdCB0aGUgZnJhbWVcbiAgICAgICAgaWYocGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlLmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5vIGJhc2ljIG9mZnNldCB0YWJsZSwgYXNzdW1lIGFsbCBmcmFnbWVudHMgYXJlIGZvciBvbmUgZnJhbWUgLSBOT1RFIHRoYXQgdGhpcyBpcyBOT1QgYSB2YWxpZFxuICAgICAgICAgICAgLy8gYXNzdW1wdGlvbiBidXQgaXMgdGhlIG9yaWdpbmFsIGJlaGF2aW9yIHNvIHdlIGFyZSBrZWVwaW5nIGl0IGZvciBub3dcbiAgICAgICAgICAgIHJldHVybiBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cyhkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCAwLCBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcblxuLyoqXG4gKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGFsbG9jYXRlIG5ldyBieXRlQXJyYXkgYnVmZmVyc1xuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJ5dGVBcnJheSBvZiB0aGUgc2FtZSB0eXBlIChVaW50OEFycmF5IG9yIEJ1ZmZlcikgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIHVuZGVybHlpbmcgYnl0ZUFycmF5IChlaXRoZXIgVWludDhBcnJheSBvciBCdWZmZXIpXG4gICAqIEBwYXJhbSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBCeXRlIEFycmF5XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBieXRlQXJyYXlcbiAgICovXG4gIGRpY29tUGFyc2VyLmFsbG9jID0gZnVuY3Rpb24oYnl0ZUFycmF5LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZUFycmF5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYoYnl0ZUFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdkaWNvbVBhcnNlci5hbGxvYzogdW5rbm93biB0eXBlIGZvciBieXRlQXJyYXknO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgZGlmZmVyZW50IHR5cGVzIGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIuYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAxNiBmcm9tIGEgYmlnLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAxNlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRVaW50MTY6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDE2OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgMiA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTY6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChieXRlQXJyYXlbcG9zaXRpb25dIDw8IDgpICsgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcnNlcyBhIHNpZ25lZCBpbnQgMTYgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCBzaWduZWQgaW50IDE2XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEludDE2OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgMiA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQxNjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW50MTYgPSAoYnl0ZUFycmF5W3Bvc2l0aW9uXSA8PCA4KSArIGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgLy8gZml4IHNpZ25cbiAgICAgICAgICAgIGlmIChpbnQxNiAmIDB4ODAwMCkge1xuICAgICAgICAgICAgICAgIGludDE2ID0gaW50MTYgLSAweEZGRkYgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludDE2O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDMyIGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDMyXG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFVpbnQzMjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzI6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkVWludDMyOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVpbnQzMiA9ICgyNTYgKiAoMjU2ICogKDI1NiAqIGJ5dGVBcnJheVtwb3NpdGlvbl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXlbcG9zaXRpb24gKyAzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB1aW50MzI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhIHNpZ25lZCBpbnQgMzIgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCBzaWduZWQgaW50IDMyXG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyA0ID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdiaWdFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDMyOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludDMyID0gKChieXRlQXJyYXlbcG9zaXRpb25dIDw8IDI0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdIDw8IDgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5W3Bvc2l0aW9uICsgM10pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyAzMi1iaXQgZmxvYXQgZnJvbSBhIGJpZy1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCAzMi1iaXQgZmxvYXRcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uIChieXRlQXJyYXksIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRmxvYXQ6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDQgPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRmxvYXQ6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJIGFtIHN1cmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRoYW4gdGhpcyBidXQgdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzNdID0gYnl0ZUFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsyXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzFdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMF0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAzXTtcbiAgICAgICAgICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdEFycmF5WzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgNjQtYml0IGZsb2F0IGZyb20gYSBiaWctZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgNjQtYml0IGZsb2F0XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZERvdWJsZTogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnYmlnRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWREb3VibGU6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiArIDggPiBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2JpZ0VuZGlhbkJ5dGVBcnJheVBhcnNlci5yZWFkRG91YmxlOiBhdHRlbXB0IHRvIHJlYWQgcGFzdCBlbmQgb2YgYnVmZmVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSSBhbSBzdXJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0aGFuIHRoaXMgYnV0IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgICAgICAgIHZhciBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs3XSA9IGJ5dGVBcnJheVtwb3NpdGlvbl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs1XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDJdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzRdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgM107XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbM10gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA0XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsyXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDVdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzFdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMF0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA3XTtcbiAgICAgICAgICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheShieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdEFycmF5WzBdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBjb21tb24gdG8gcGFyc2luZyBieXRlIGFycmF5cyBvZiBhbnkgdHlwZVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyBvZiA4LWJpdCBjaGFyYWN0ZXJzIGZyb20gYW4gYXJyYXkgb2YgYnl0ZXMgYW5kIGFkdmFuY2VzXG4gICAgICogdGhlIHBvc2l0aW9uIGJ5IGxlbmd0aCBieXRlcy4gIEEgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgZW5kIHRoZSBzdHJpbmdcbiAgICAgKiBidXQgd2lsbCBub3QgZWZmZWN0IGFkdmFuY2VtZW50IG9mIHRoZSBwb3NpdGlvbi4gIFRyYWlsaW5nIGFuZCBsZWFkaW5nXG4gICAgICogc3BhY2VzIGFyZSBwcmVzZXJ2ZWQgKG5vdCB0cmltbWVkKVxuICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGVBcnJheSB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBhcnNlZCBzdHJpbmdcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgcG9zaXRpb24sIGxlbmd0aClcbiAgICB7XG4gICAgICAgIGlmKGxlbmd0aCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93ICdkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcgLSBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBvc2l0aW9uICsgbGVuZ3RoID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZzogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIGJ5dGU7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgICAgIGlmKGJ5dGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKlxuICogSW50ZXJuYWwgaGVscGVyIGNsYXNzIHRvIGFzc2lzdCB3aXRoIHBhcnNpbmcuIFN1cHBvcnRzIHJlYWRpbmcgZnJvbSBhIGJ5dGVcbiAqIHN0cmVhbSBjb250YWluZWQgaW4gYSBVaW50OEFycmF5LiAgRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgdmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAqICB2YXIgYnl0ZVN0cmVhbSA9IG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5KTtcbiAqXG4gKiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBCeXRlU3RyZWFtIG9iamVjdHMuXG4gICAgICogQHBhcmFtIGJ5dGVBcnJheVBhcnNlciBhIHBhcnNlciBmb3IgcGFyc2luZyB0aGUgYnl0ZSBhcnJheVxuICAgICAqIEBwYXJhbSBieXRlQXJyYXkgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIGJ5dGUgc3RyZWFtXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIChvcHRpb25hbCkgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHJlYWRpbmcgZnJvbS4gIDAgaWYgbm90IHNwZWNpZmllZFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYnl0ZUFycmF5UGFyc2VyIHBhcmFtZXRlciBpcyBub3QgcHJlc2VudFxuICAgICAqIEB0aHJvd3Mgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYnl0ZUFycmF5IHBhcmFtZXRlciBpcyBub3QgcHJlc2VudCBvciBpbnZhbGlkXG4gICAgICogQHRocm93cyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBwb3NpdGlvbiBwYXJhbWV0ZXIgaXMgbm90IGluc2lkZSB0aGUgYnl0ZSBhcnJheVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0gPSBmdW5jdGlvbihieXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYoYnl0ZUFycmF5UGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVBcnJheVBhcnNlcidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihieXRlQXJyYXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5CeXRlU3RyZWFtOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZUFycmF5J1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKChieXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAoYnl0ZUFycmF5IGluc3RhbmNlb2YgQnVmZmVyKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICB0aHJvdyAnZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogcGFyYW1ldGVyIGJ5dGVBcnJheSBpcyBub3Qgb2YgdHlwZSBVaW50OEFycmF5IG9yIEJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYocG9zaXRpb24gPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLkJ5dGVTdHJlYW06IHBhcmFtZXRlciAncG9zaXRpb24nIGNhbm5vdCBiZSBsZXNzIHRoYW4gMFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBvc2l0aW9uID49IGJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbTogcGFyYW1ldGVyICdwb3NpdGlvbicgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAnYnl0ZUFycmF5JyBsZW5ndGhcIjtcblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZUFycmF5UGFyc2VyID0gYnl0ZUFycmF5UGFyc2VyO1xuICAgICAgICB0aGlzLmJ5dGVBcnJheSA9IGJ5dGVBcnJheTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uID8gcG9zaXRpb24gOiAwO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107IC8vIGFycmF5IG9mIHN0cmluZyB3YXJuaW5ncyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhZmVseSBzZWVrcyB0aHJvdWdoIHRoZSBieXRlIHN0cmVhbS4gIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHRcbiAgICAgKiBpcyBtYWRlIHRvIHNlZWsgb3V0c2lkZSBvZiB0aGUgYnl0ZSBhcnJheS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWRkIHRvIHRoZSBwb3NpdGlvblxuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgc2VlayB3b3VsZCBjYXVzZSBwb3NpdGlvbiB0byBiZSBvdXRzaWRlIG9mIHRoZSBieXRlQXJyYXlcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24ob2Zmc2V0KVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5wb3NpdGlvbiArIG9mZnNldCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUuc2VlazogY2Fubm90IHNlZWsgdG8gcG9zaXRpb24gPCAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBvZmZzZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgQnl0ZVN0cmVhbSBvYmplY3QgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgb2YgdGhlIHJlcXVlc3RlZCBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKiBAcGFyYW0gbnVtQnl0ZXMgdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZSBhcnJheSBmb3IgdGhlIEJ5dGVTdHJlYW0gdG8gY29udGFpblxuICAgICAqIEByZXR1cm5zIHtkaWNvbVBhcnNlci5CeXRlU3RyZWFtfVxuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuQnl0ZVN0cmVhbS5wcm90b3R5cGUucmVhZEJ5dGVTdHJlYW0gPSBmdW5jdGlvbihudW1CeXRlcylcbiAgICB7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gKyBudW1CeXRlcyA+IHRoaXMuYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ2RpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlU3RyZWFtOiByZWFkQnl0ZVN0cmVhbSAtIGJ1ZmZlciBvdmVycmVhZCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVBcnJheVZpZXcgPSBkaWNvbVBhcnNlci5zaGFyZWRDb3B5KHRoaXMuYnl0ZUFycmF5LCB0aGlzLnBvc2l0aW9uLCBudW1CeXRlcyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbnVtQnl0ZXM7XG4gICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuQnl0ZVN0cmVhbSh0aGlzLmJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5Vmlldyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUGFyc2VzIGFuIHVuc2lnbmVkIGludCAxNiBmcm9tIGEgYnl0ZSBhcnJheSBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgMiBieXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDE2XG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTYodGhpcy5ieXRlQXJyYXksIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMzIgZnJvbSBhIGJ5dGUgYXJyYXkgYW5kIGFkdmFuY2VzXG4gICAgICogdGhlIHBvc2l0aW9uIGJ5IDIgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2UgdW5zaWduZWQgaW50IDMyXG4gICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5CeXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzIodGhpcy5ieXRlQXJyYXksIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgc3RyaW5nIG9mIDgtYml0IGNoYXJhY3RlcnMgZnJvbSBhbiBhcnJheSBvZiBieXRlcyBhbmQgYWR2YW5jZXNcbiAgICAgKiB0aGUgcG9zaXRpb24gYnkgbGVuZ3RoIGJ5dGVzLiAgQSBudWxsIHRlcm1pbmF0b3Igd2lsbCBlbmQgdGhlIHN0cmluZ1xuICAgICAqIGJ1dCB3aWxsIG5vdCBlZmZlY3QgYWR2YW5jZW1lbnQgb2YgdGhlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBhcnNlZCBzdHJpbmdcbiAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0ucHJvdG90eXBlLnJlYWRGaXhlZFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aClcbiAgICB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcodGhpcy5ieXRlQXJyYXksIHRoaXMucG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqXG4gKiBUaGUgRGF0YVNldCBjbGFzcyBlbmNhcHN1bGF0ZXMgYSBjb2xsZWN0aW9uIG9mIERJQ09NIEVsZW1lbnRzIGFuZCBwcm92aWRlcyB2YXJpb3VzIGZ1bmN0aW9uc1xuICogdG8gYWNjZXNzIHRoZSBkYXRhIGluIHRob3NlIGVsZW1lbnRzXG4gKlxuICogUnVsZXMgZm9yIGhhbmRsaW5nIHBhZGRlZCBzcGFjZXM6XG4gKiBEUyA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogRFQgPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqIElTID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBQTiA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogVE0gPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqIEFFID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBDUyA9IFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICogU0ggPSBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAqIExPID0gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gKiBMVCA9IFN0cmlwIHRyYWlsaW5nIHNwYWNlc1xuICogU1QgPSBTdHJpcCB0cmFpbGluZyBzcGFjZXNcbiAqIFVUID0gU3RyaXAgdHJhaWxpbmcgc3BhY2VzXG4gKlxuICovXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qnl0ZUFycmF5UGFyc2VyKGVsZW1lbnQsIGRlZmF1bHRQYXJzZXIpXG4gICAge1xuICAgICAgICByZXR1cm4gKGVsZW1lbnQucGFyc2VyICE9PSB1bmRlZmluZWQgPyBlbGVtZW50LnBhcnNlciA6IGRlZmF1bHRQYXJzZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGF0YVNldCBnaXZlbiBieXRlQXJyYXkgYW5kIGNvbGxlY3Rpb24gb2YgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0gYnl0ZUFycmF5UGFyc2VyXG4gICAgICogQHBhcmFtIGJ5dGVBcnJheVxuICAgICAqIEBwYXJhbSBlbGVtZW50c1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQgPSBmdW5jdGlvbihieXRlQXJyYXlQYXJzZXIsIGJ5dGVBcnJheSwgZWxlbWVudHMpXG4gICAge1xuICAgICAgICB0aGlzLmJ5dGVBcnJheVBhcnNlciA9IGJ5dGVBcnJheVBhcnNlcjtcbiAgICAgICAgdGhpcy5ieXRlQXJyYXkgPSBieXRlQXJyYXk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhbiB1bnNpZ25lZCBpbnQgMTYgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdW5zaWduZWQgaW50IDE2IG9yIHVuZGVmaW5lZCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50IG9yIGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUudWludDE2ID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZFVpbnQxNih0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICoyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhbiBzaWduZWQgaW50IDE2IGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IHNpZ25lZCBpbnQgMTYgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIGRhdGEgb2YgbGVuZ3RoIDBcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5pbnQxNiA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWRJbnQxNih0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbGVtZW50IGZvciB0YWcgYW5kIHJldHVybnMgYW4gdW5zaWduZWQgaW50IDMyIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGRhdGFcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpbiBhIG11bHRpdmFsdWVkIGVsZW1lbnQuICBEZWZhdWx0IGlzIGluZGV4IDAgaWYgbm90IHN1cHBsaWVkXG4gICAgICogQHJldHVybnMgeyp9IHVuc2lnbmVkIGludCAzMiBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlQXJyYXlQYXJzZXIoZWxlbWVudCwgdGhpcy5ieXRlQXJyYXlQYXJzZXIpLnJlYWRVaW50MzIodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCArIChpbmRleCAqIDQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZWxlbWVudCBmb3IgdGFnIGFuZCByZXR1cm5zIGFuIHNpZ25lZCBpbnQgMzIgaWYgaXQgZXhpc3RzIGFuZCBoYXMgZGF0YVxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIGluIGEgbXVsdGl2YWx1ZWQgZWxlbWVudC4gIERlZmF1bHQgaXMgaW5kZXggMCBpZiBub3Qgc3VwcGxpZWRcbiAgICAgKiBAcmV0dXJucyB7Kn0gc2lnbmVkIGludCAzMiBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZEludDMyKHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhIDMyIGJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgKFZSPUZMKSBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSBmbG9hdCBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBoYXMgZGF0YSBvZiBsZW5ndGggMFxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZEZsb2F0KHRoaXMuYnl0ZUFycmF5LCBlbGVtZW50LmRhdGFPZmZzZXQgKyAoaW5kZXggKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVsZW1lbnQgZm9yIHRhZyBhbmQgcmV0dXJucyBhIDY0IGJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgKFZSPUZEKSBpZiBpdCBleGlzdHMgYW5kIGhhcyBkYXRhXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgaW4gYSBtdWx0aXZhbHVlZCBlbGVtZW50LiAgRGVmYXVsdCBpcyBpbmRleCAwIGlmIG5vdCBzdXBwbGllZFxuICAgICAqIEByZXR1cm5zIHsqfSBmbG9hdCBvciB1bmRlZmluZWQgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCBvciBkb2Vzbid0IGhhcyBkYXRhIG9mIGxlbmd0aCAwXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpbmRleCA9IChpbmRleCAhPT0gdW5kZWZpbmVkKSA/IGluZGV4IDogMDtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJ5dGVBcnJheVBhcnNlcihlbGVtZW50LCB0aGlzLmJ5dGVBcnJheVBhcnNlcikucmVhZERvdWJsZSh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0ICsgKGluZGV4ICogOCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBzdHJpbmcgdmFsdWVzIGZvciB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgbnVtYmVyIG9mIHN0cmluZyB2YWx1ZXMgb3IgdW5kZWZpbmVkIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQgb3IgaGFzIHplcm8gbGVuZ3RoIGRhdGFcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5udW1TdHJpbmdWYWx1ZXMgPSBmdW5jdGlvbih0YWcpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFN0cmluZyA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbnVtTWF0Y2hpbmcgPSBmaXhlZFN0cmluZy5tYXRjaCgvXFxcXC9nKTtcbiAgICAgICAgICAgIGlmKG51bU1hdGNoaW5nID09PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bU1hdGNoaW5nLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBmb3IgdGhlIGVsZW1lbnQuICBJZiBpbmRleCBpcyBwcm92aWRlZCwgdGhlIGVsZW1lbnQgaXMgYXNzdW1lZCB0byBiZVxuICAgICAqIG11bHRpLXZhbHVlZCBhbmQgd2lsbCByZXR1cm4gdGhlIGNvbXBvbmVudCBzcGVjaWZpZWQgYnkgaW5kZXguICBVbmRlZmluZWQgaXMgcmV0dXJuZWRcbiAgICAgKiBpZiB0aGVyZSBpcyBubyBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4LCB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdCBvciBpcyB6ZXJvIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIGZvciBWUiB0eXBlcyBvZiBBRSwgQ1MsIFNIIGFuZCBMT1xuICAgICAqXG4gICAgICogQHBhcmFtIHRhZyBUaGUgRElDT00gdGFnIGluIHRoZSBmb3JtYXQgeEdHR0dFRUVFXG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZGVzaXJlZCB2YWx1ZSBpbiBhIG11bHRpIHZhbHVlZCBzdHJpbmcgb3IgdW5kZWZpbmVkIGZvciB0aGUgZW50aXJlIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFN0cmluZyA9IGRpY29tUGFyc2VyLnJlYWRGaXhlZFN0cmluZyh0aGlzLmJ5dGVBcnJheSwgZWxlbWVudC5kYXRhT2Zmc2V0LCBlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBmaXhlZFN0cmluZy5zcGxpdCgnXFxcXCcpO1xuICAgICAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleF0udHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIGxlYWRpbmcgc3BhY2VzIHByZXNlcnZlZCBhbmQgdHJhaWxpbmcgc3BhY2VzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBhY2Nlc3MgZGF0YSBmb3IgVlJzIG9mIHR5cGUgVVQsIFNUIGFuZCBMVFxuICAgICAqXG4gICAgICogQHBhcmFtIHRhZ1xuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLkRhdGFTZXQucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0YWcsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RhZ107XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZml4ZWRTdHJpbmcgPSBkaWNvbVBhcnNlci5yZWFkRml4ZWRTdHJpbmcodGhpcy5ieXRlQXJyYXksIGVsZW1lbnQuZGF0YU9mZnNldCwgZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYoaW5kZXggPj0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gZml4ZWRTdHJpbmcuc3BsaXQoJ1xcXFwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2luZGV4XS5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpeGVkU3RyaW5nLnJlcGxhY2UoLyArJC8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgdG8gYSBmbG9hdCBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBpbiBhIG11bHRpLXZhbHVlZCBlbGVtZW50LiAgSWYgaW5kZXggaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiB0aGUgZmlyc3QgdmFsdWUgaW4gYSBtdWx0aS12YWx1ZWQgVlIgd2lsbCBiZSBwYXJzZWQgaWYgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gdGFnIFRoZSBESUNPTSB0YWcgaW4gdGhlIGZvcm1hdCB4R0dHR0VFRUVcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBkZXNpcmVkIHZhbHVlIGluIGEgbXVsdGkgdmFsdWVkIHN0cmluZyBvciB1bmRlZmluZWQgZm9yIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBvciB1bmRlZmluZWQgaWYgbm90IHByZXNlbnQgb3IgZGF0YSBub3QgbG9uZyBlbm91Z2hcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5EYXRhU2V0LnByb3RvdHlwZS5mbG9hdFN0cmluZyA9IGZ1bmN0aW9uKHRhZywgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGFnXTtcbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50Lmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZGV4ID0gKGluZGV4ICE9PSB1bmRlZmluZWQpID8gaW5kZXggOiAwO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHJpbmcodGFnLCBpbmRleCk7XG4gICAgICAgICAgICBpZih2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyB0byBhbiBpbnRlZ2VyIGZvciB0aGUgc3BlY2lmaWVkIGluZGV4IGluIGEgbXVsdGktdmFsdWVkIGVsZW1lbnQuICBJZiBpbmRleCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIHRoZSBmaXJzdCB2YWx1ZSBpbiBhIG11bHRpLXZhbHVlZCBWUiB3aWxsIGJlIHBhcnNlZCBpZiBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB0YWcgVGhlIERJQ09NIHRhZyBpbiB0aGUgZm9ybWF0IHhHR0dHRUVFRVxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIGRlc2lyZWQgdmFsdWUgaW4gYSBtdWx0aSB2YWx1ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBmb3IgdGhlIGZpcnN0IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IGFuIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50IG9yIGRhdGEgbm90IGxvbmcgZW5vdWdoXG4gICAgICovXG4gICAgZGljb21QYXJzZXIuRGF0YVNldC5wcm90b3R5cGUuaW50U3RyaW5nID0gZnVuY3Rpb24odGFnLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1t0YWddO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5kZXggPSAoaW5kZXggIT09IHVuZGVmaW5lZCkgPyBpbmRleCA6IDA7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0cmluZyh0YWcsIGluZGV4KTtcbiAgICAgICAgICAgIGlmKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8vZGljb21QYXJzZXIuRGF0YVNldCA9IERhdGFTZXQ7XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWFkcyBmcm9tIHRoZSBieXRlIHN0cmVhbSB1bnRpbCBpdCBmaW5kcyB0aGUgbWFnaWMgbnVtYmVyIGZvciB0aGUgU2VxdWVuY2UgRGVsaW1pdGF0aW9uIEl0ZW0gaXRlbVxuICAgKiBhbmQgdGhlbiBzZXRzIHRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIGJ5dGVTdHJlYW1cbiAgICogQHBhcmFtIGVsZW1lbnRcbiAgICovXG4gIGRpY29tUGFyc2VyLmZpbmRBbmRTZXRVTkVsZW1lbnRMZW5ndGggPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50KVxuICB7XG4gICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIuZmluZEFuZFNldFVORWxlbWVudExlbmd0aDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1EZWxpbWl0YXRpb25JdGVtTGVuZ3RoID0gODsgLy8gZ3JvdXAsIGVsZW1lbnQsIGxlbmd0aFxuICAgIHZhciBtYXhQb3NpdGlvbiA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGl0ZW1EZWxpbWl0YXRpb25JdGVtTGVuZ3RoO1xuICAgIHdoaWxlKGJ5dGVTdHJlYW0ucG9zaXRpb24gPD0gbWF4UG9zaXRpb24pXG4gICAge1xuICAgICAgdmFyIGdyb3VwTnVtYmVyO1xuICAgICAgZ3JvdXBOdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgIGlmKGdyb3VwTnVtYmVyID09PSAweGZmZmUpXG4gICAgICB7XG4gICAgICAgIHZhciBlbGVtZW50TnVtYmVyO1xuICAgICAgICBlbGVtZW50TnVtYmVyID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgIGlmKGVsZW1lbnROdW1iZXIgPT09IDB4ZTBkZClcbiAgICAgICAge1xuICAgICAgICAgIC8vIE5PVEU6IEl0IHdvdWxkIGJlIGJldHRlciB0byBhbHNvIGNoZWNrIGZvciB0aGUgbGVuZ3RoIHRvIGJlIDAgYXMgcGFydCBvZiB0aGUgY2hlY2sgYWJvdmVcbiAgICAgICAgICAvLyBidXQgd2Ugd2lsbCBqdXN0IGxvZyBhIHdhcm5pbmcgZm9yIG5vd1xuICAgICAgICAgIHZhciBpdGVtRGVsaW1pdGVyTGVuZ3RoO1xuICAgICAgICAgIGl0ZW1EZWxpbWl0ZXJMZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTsgLy8gdGhlIGxlbmd0aFxuICAgICAgICAgIGlmKGl0ZW1EZWxpbWl0ZXJMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MoJ2VuY291bnRlcmVkIG5vbiB6ZXJvIGxlbmd0aCBmb2xsb3dpbmcgaXRlbSBkZWxpbWl0ZXIgYXQgcG9zaXRpb24nICsgYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIDQgKyBcIiB3aGlsZSByZWFkaW5nIGVsZW1lbnQgb2YgdW5kZWZpbmVkIGxlbmd0aCB3aXRoIHRhZyAnICsgZWxlbWVudC50YWdcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBpdGVtIGRlbGltaXRhdGlvbiBpdGVtIC0gc2lsZW50bHkgc2V0IHRoZSBsZW5ndGggdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlIHBvc2l0aW9uIHBhc3QgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgYnl0ZVN0cmVhbS5zZWVrKGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGJ5dGVTdHJlYW0ucG9zaXRpb24pO1xuICB9O1xuXG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhIGVsZW1lbnQgYW5kIGFkZHMgYW4gYXJyYXkgb2YgZnJhZ21lbnRzIHRvIHRoZSBlbGVtZW50XG4gICAgICogY29udGFpbmluZyB0aGUgb2Zmc2V0IGFuZCBsZW5ndGggb2YgZWFjaCBmcmFnbWVudCBhbmQgYW55IG9mZnNldHMgZnJvbSB0aGUgYmFzaWMgb2Zmc2V0XG4gICAgICogdGFibGVcbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgZGljb21QYXJzZXIuZmluZEVuZE9mRW5jYXBzdWxhdGVkRWxlbWVudCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLmZpbmRFbmRPZkVuY2Fwc3VsYXRlZEVsZW1lbnQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZWxlbWVudCdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZW5jYXBzdWxhdGVkUGl4ZWxEYXRhID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5iYXNpY09mZnNldFRhYmxlID0gW107XG4gICAgICAgIGVsZW1lbnQuZnJhZ21lbnRzID0gW107XG4gICAgICAgIHZhciBiYXNpY09mZnNldFRhYmxlSXRlbVRhZyA9IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSk7XG4gICAgICAgIGlmKGJhc2ljT2Zmc2V0VGFibGVJdGVtVGFnICE9PSAneGZmZmVlMDAwJykge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50OiBiYXNpYyBvZmZzZXQgdGFibGUgbm90IGZvdW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2ljT2Zmc2V0VGFibGVJdGVtbGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgIHZhciBudW1GcmFnbWVudHMgPSBiYXNpY09mZnNldFRhYmxlSXRlbWxlbmd0aCAvIDQ7XG4gICAgICAgIGZvcih2YXIgaSA9MDsgaSA8IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBlbGVtZW50LmJhc2ljT2Zmc2V0VGFibGUucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlT2Zmc2V0ID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBieXRlU3RyZWFtLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGlmKHRhZyA9PT0gJ3hmZmZlZTBkZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGFnID09PSAneGZmZmVlMDAwJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBieXRlU3RyZWFtLnBvc2l0aW9uIC0gYmFzZU9mZnNldCAtIDgsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIDogYnl0ZVN0cmVhbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDogbGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih3YXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCd1bmV4cGVjdGVkIHRhZyAnICsgdGFnICsgJyB3aGlsZSBzZWFyY2hpbmcgZm9yIGVuZCBvZiBwaXhlbCBkYXRhIGVsZW1lbnQgd2l0aCB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGxlbmd0aCA+IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGJ5dGVTdHJlYW0ucG9zaXRpb24pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXggbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZnJhZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBiYXNlT2Zmc2V0IC0gOCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gOiBieXRlU3RyZWFtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggOiBsZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBlbGVtZW50LmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBieXRlU3RyZWFtLnNlZWsobGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKFwicGl4ZWwgZGF0YSBlbGVtZW50IFwiICsgZWxlbWVudC50YWcgKyBcIiBtaXNzaW5nIHNlcXVlbmNlIGRlbGltaXRlciB0YWcgeGZmZmVlMGRkXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlYWRzIGZyb20gdGhlIGJ5dGUgc3RyZWFtIHVudGlsIGl0IGZpbmRzIHRoZSBtYWdpYyBudW1iZXJzIGZvciB0aGUgaXRlbSBkZWxpbWl0YXRpb24gaXRlbVxuICAgICAqIGFuZCB0aGVuIHNldHMgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5maW5kSXRlbURlbGltaXRhdGlvbkl0ZW1BbmRTZXRFbGVtZW50TGVuZ3RoID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudClcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50SW1wbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1EZWxpbWl0YXRpb25JdGVtTGVuZ3RoID0gODsgLy8gZ3JvdXAsIGVsZW1lbnQsIGxlbmd0aFxuICAgICAgICB2YXIgbWF4UG9zaXRpb24gPSBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGggLSBpdGVtRGVsaW1pdGF0aW9uSXRlbUxlbmd0aDtcbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8PSBtYXhQb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyb3VwTnVtYmVyID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICBpZihncm91cE51bWJlciA9PT0gMHhmZmZlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50TnVtYmVyID0gYnl0ZVN0cmVhbS5yZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudE51bWJlciA9PT0gMHhlMDBkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogSXQgd291bGQgYmUgYmV0dGVyIHRvIGFsc28gY2hlY2sgZm9yIHRoZSBsZW5ndGggdG8gYmUgMCBhcyBwYXJ0IG9mIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2Ugd2lsbCBqdXN0IGxvZyBhIHdhcm5pbmcgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbURlbGltaXRlckxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpOyAvLyB0aGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW1EZWxpbWl0ZXJMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MoJ2VuY291bnRlcmVkIG5vbiB6ZXJvIGxlbmd0aCBmb2xsb3dpbmcgaXRlbSBkZWxpbWl0ZXIgYXQgcG9zaXRpb24nICsgYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIDQgKyBcIiB3aGlsZSByZWFkaW5nIGVsZW1lbnQgb2YgdW5kZWZpbmVkIGxlbmd0aCB3aXRoIHRhZyAnICsgZWxlbWVudC50YWdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gaXRlbSBkZWxpbWl0YXRpb24gaXRlbSAtIHNpbGVudGx5IHNldCB0aGUgbGVuZ3RoIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBhbmQgc2V0IHRoZSBwb3NpdGlvbiBwYXN0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCAtIGJ5dGVTdHJlYW0ucG9zaXRpb24pO1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBkaWZmZXJlbnQgdHlwZXMgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBkaWNvbVBhcnNlci5saXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJzZXMgYW4gdW5zaWduZWQgaW50IDE2IGZyb20gYSBsaXR0bGUtZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ5dGVBcnJheSB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSB0byByZWFkIGZyb21cbiAgICAgICAgICogQHJldHVybnMgeyp9IHRoZSBwYXJzZWQgdW5zaWduZWQgaW50IDE2XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFVpbnQxNjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MTY6IHBvc2l0aW9uIGNhbm5vdCBiZSBsZXNzIHRoYW4gMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyAyID4gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQxNjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZUFycmF5W3Bvc2l0aW9uXSArIChieXRlQXJyYXlbcG9zaXRpb24gKyAxXSAqIDI1Nik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcnNlcyBhIHNpZ25lZCBpbnQgMTYgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCBzaWduZWQgaW50IDE2XG4gICAgICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgYnVmZmVyIG92ZXJyZWFkIHdvdWxkIG9jY3VyXG4gICAgICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEludDE2OiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZEludDE2OiBwb3NpdGlvbiBjYW5ub3QgYmUgbGVzcyB0aGFuIDAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgMiA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQxNjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW50MTYgPSBieXRlQXJyYXlbcG9zaXRpb25dICsgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdIDw8IDgpO1xuICAgICAgICAgICAgLy8gZml4IHNpZ25cbiAgICAgICAgICAgIGlmIChpbnQxNiAmIDB4ODAwMCkge1xuICAgICAgICAgICAgICAgIGludDE2ID0gaW50MTYgLSAweEZGRkYgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludDE2O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyBhbiB1bnNpZ25lZCBpbnQgMzIgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCB1bnNpZ25lZCBpbnQgMzJcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVWludDMyOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZFVpbnQzMjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRVaW50MzI6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWludDMyID0gKGJ5dGVBcnJheVtwb3NpdGlvbl0gK1xuICAgICAgICAgICAgKGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdICogMjU2KSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl0gKiAyNTYgKiAyNTYpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAzXSAqIDI1NiAqIDI1NiAqIDI1NiApKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVpbnQzMjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGEgc2lnbmVkIGludCAzMiBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIHVuc2lnbmVkIGludCAzMlxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRJbnQzMjogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQzMjogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRJbnQzMjogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnQzMiA9IChieXRlQXJyYXlbcG9zaXRpb25dICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAxXSA8PCA4KSArXG4gICAgICAgICAgICAoYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlQXJyYXlbcG9zaXRpb24gKyAzXSA8PCAyNCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIDMyLWJpdCBmbG9hdCBmcm9tIGEgbGl0dGxlLWVuZGlhbiBieXRlIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gaW4gdGhlIGJ5dGUgYXJyYXkgdG8gcmVhZCBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcGFyc2VkIDMyLWJpdCBmbG9hdFxuICAgICAgICAgKiBAdGhyb3dzIGVycm9yIGlmIGJ1ZmZlciBvdmVycmVhZCB3b3VsZCBvY2N1clxuICAgICAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGbG9hdDogZnVuY3Rpb24gKGJ5dGVBcnJheSwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgNCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWRGbG9hdDogYXR0ZW1wdCB0byByZWFkIHBhc3QgZW5kIG9mIGJ1ZmZlcic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEkgYW0gc3VyZSB0aGVyZSBpcyBhIGJldHRlciB3YXkgdGhhbiB0aGlzIGJ1dCB0aGlzIHNob3VsZCBiZSBzYWZlXG4gICAgICAgICAgICB2YXIgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMF0gPSBieXRlQXJyYXlbcG9zaXRpb25dO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzFdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbMl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFszXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDNdO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlcyA2NC1iaXQgZmxvYXQgZnJvbSBhIGxpdHRsZS1lbmRpYW4gYnl0ZSBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZUFycmF5IHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHRoZSBieXRlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIHBhcnNlZCA2NC1iaXQgZmxvYXRcbiAgICAgICAgICogQHRocm93cyBlcnJvciBpZiBidWZmZXIgb3ZlcnJlYWQgd291bGQgb2NjdXJcbiAgICAgICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRG91YmxlOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdsaXR0bGVFbmRpYW5CeXRlQXJyYXlQYXJzZXIucmVhZERvdWJsZTogcG9zaXRpb24gY2Fubm90IGJlIGxlc3MgdGhhbiAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgOCA+IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyLnJlYWREb3VibGU6IGF0dGVtcHQgdG8gcmVhZCBwYXN0IGVuZCBvZiBidWZmZXInO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJIGFtIHN1cmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRoYW4gdGhpcyBidXQgdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdCA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzBdID0gYnl0ZUFycmF5W3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFsxXSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzJdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgMl07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbM10gPSBieXRlQXJyYXlbcG9zaXRpb24gKyAzXTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs0XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDRdO1xuICAgICAgICAgICAgYnl0ZUFycmF5Rm9yUGFyc2luZ0Zsb2F0WzVdID0gYnl0ZUFycmF5W3Bvc2l0aW9uICsgNV07XG4gICAgICAgICAgICBieXRlQXJyYXlGb3JQYXJzaW5nRmxvYXRbNl0gPSBieXRlQXJyYXlbcG9zaXRpb24gKyA2XTtcbiAgICAgICAgICAgIGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdFs3XSA9IGJ5dGVBcnJheVtwb3NpdGlvbiArIDddO1xuICAgICAgICAgICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KGJ5dGVBcnJheUZvclBhcnNpbmdGbG9hdC5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGltcGxpY2l0IGFuZCBleHBsaWNpdCBESUNPTSBkYXRhIHNldHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVhZHMgYW4gZXhwbGljaXQgZGF0YSBzZXRcbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbSB0aGUgYnl0ZSBzdHJlYW0gdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIG1heFBvc2l0aW9uIHRoZSBtYXhpbXVtIHBvc2l0aW9uIHRvIHJlYWQgdXAgdG8gKG9wdGlvbmFsIC0gb25seSBuZWVkZWQgd2hlbiByZWFkaW5nIHNlcXVlbmNlIGl0ZW1zKVxuICAgICAqL1xuICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQgPSBmdW5jdGlvbiAoZGF0YVNldCwgYnl0ZVN0cmVhbSwgbWF4UG9zaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBtYXhQb3NpdGlvbiA9IChtYXhQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCA6IG1heFBvc2l0aW9uIDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0RXhwbGljaXQ6IG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyICdieXRlU3RyZWFtJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1heFBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5wb3NpdGlvbiB8fCBtYXhQb3NpdGlvbiA+IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEV4cGxpY2l0OiBpbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ21heFBvc2l0aW9uJ1wiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGRhdGFTZXQuZWxlbWVudHM7XG5cbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdChieXRlU3RyZWFtLCBkYXRhU2V0Lndhcm5pbmdzLCBvcHRpb25zLnVudGlsVGFnKTtcbiAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnQudGFnXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gb3B0aW9ucy51bnRpbFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihieXRlU3RyZWFtLnBvc2l0aW9uID4gbWF4UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXI6cGFyc2VEaWNvbURhdGFTZXRFeHBsaWNpdDogYnVmZmVyIG92ZXJydW5cIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZWFkcyBhbiBpbXBsaWNpdCBkYXRhIHNldFxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlIHN0cmVhbSB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gbWF4UG9zaXRpb24gdGhlIG1heGltdW0gcG9zaXRpb24gdG8gcmVhZCB1cCB0byAob3B0aW9uYWwgLSBvbmx5IG5lZWRlZCB3aGVuIHJlYWRpbmcgc2VxdWVuY2UgaXRlbXMpXG4gICAgICovXG4gICAgZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdCA9IGZ1bmN0aW9uKGRhdGFTZXQsIGJ5dGVTdHJlYW0sIG1heFBvc2l0aW9uLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgbWF4UG9zaXRpb24gPSAobWF4UG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyBkYXRhU2V0LmJ5dGVBcnJheS5sZW5ndGggOiBtYXhQb3NpdGlvbiA7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihtYXhQb3NpdGlvbiA8IGJ5dGVTdHJlYW0ucG9zaXRpb24gfHwgbWF4UG9zaXRpb24gPiBieXRlU3RyZWFtLmJ5dGVBcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucGFyc2VEaWNvbURhdGFTZXRJbXBsaWNpdDogaW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdtYXhQb3NpdGlvbidcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50cyA9IGRhdGFTZXQuZWxlbWVudHM7XG5cbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdChieXRlU3RyZWFtLCBvcHRpb25zLnVudGlsVGFnLCBvcHRpb25zLnZyQ2FsbGJhY2spO1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQudGFnID09PSBvcHRpb25zLnVudGlsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zIGZvciBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRhTGVuZ3RoU2l6ZUluQnl0ZXNGb3JWUih2cilcbiAgICB7XG4gICAgICAgIGlmKCB2ciA9PT0gJ09CJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdPVycgfHxcbiAgICAgICAgICAgIHZyID09PSAnU1EnIHx8XG4gICAgICAgICAgICB2ciA9PT0gJ09GJyB8fFxuICAgICAgICAgICAgdnIgPT09ICdVVCcgfHxcbiAgICAgICAgICAgIHZyID09PSAnVU4nKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgd2FybmluZ3MsIHVudGlsVGFnKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRFeHBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIHRhZyA6IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSksXG4gICAgICAgICAgICB2ciA6IGJ5dGVTdHJlYW0ucmVhZEZpeGVkU3RyaW5nKDIpXG4gICAgICAgICAgICAvLyBsZW5ndGggc2V0IGJlbG93IGJhc2VkIG9uIFZSXG4gICAgICAgICAgICAvLyBkYXRhT2Zmc2V0IHNldCBiZWxvdyBiYXNlZCBvbiBWUiBhbmQgc2l6ZSBvZiBsZW5ndGhcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YUxlbmd0aFNpemVCeXRlcyA9IGdldERhdGFMZW5ndGhTaXplSW5CeXRlc0ZvclZSKGVsZW1lbnQudnIpO1xuICAgICAgICBpZihkYXRhTGVuZ3RoU2l6ZUJ5dGVzID09PSAyKVxuICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50Lmxlbmd0aCA9IGJ5dGVTdHJlYW0ucmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgZWxlbWVudC5kYXRhT2Zmc2V0ID0gYnl0ZVN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJ5dGVTdHJlYW0uc2VlaygyKTtcbiAgICAgICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGFPZmZzZXQgPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVsZW1lbnQudGFnID09PSB1bnRpbFRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBWUiBpcyBTUSwgcGFyc2UgdGhlIHNlcXVlbmNlIGl0ZW1zXG4gICAgICAgIGlmKGVsZW1lbnQudnIgPT09ICdTUScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zRXhwbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKGVsZW1lbnQubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihlbGVtZW50LnRhZyA9PT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5maW5kRW5kT2ZFbmNhcHN1bGF0ZWRFbGVtZW50KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHdhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH0gICBlbHNlIGlmKGVsZW1lbnQudnIgPT09ICdVTicpIHtcbiAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5maW5kQW5kU2V0VU5FbGVtZW50TGVuZ3RoKGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vZGljb21QYXJzZXIuZmluZEl0ZW1EZWxpbWl0YXRpb25JdGVtQW5kU2V0RWxlbWVudExlbmd0aChieXRlU3RyZWFtLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVTdHJlYW0uc2VlayhlbGVtZW50Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIGZvciBwYXJzaW5nIERJQ09NIGVsZW1lbnRzXG4gKi9cblxudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBkaWNvbVBhcnNlciA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2VxdWVuY2UoZWxlbWVudCwgYnl0ZVN0cmVhbSwgdnJDYWxsYmFjaykge1xuICAgICAgICAvLyBpZiBhIGRhdGEgZGljdGlvbmFyeSBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIHZlcmlmeSB0aGF0IHRoZSBlbGVtZW50IGlzIGEgc2VxdWVuY2UuXG4gICAgICAgIGlmICh0eXBlb2YgdnJDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAodnJDYWxsYmFjayhlbGVtZW50LnRhZykgPT09ICdTUScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoYnl0ZVN0cmVhbS5wb3NpdGlvbiArIDQpIDw9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHRUYWcgPSBkaWNvbVBhcnNlci5yZWFkVGFnKGJ5dGVTdHJlYW0pO1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKC00KTtcbiAgICAgICAgICAgIC8vIEl0ZW0gc3RhcnQgdGFnIChmZmZlLGUwMDApIG9yIHNlcXVlbmNlIGRlbGltaXRlciAoaS5lLiBlbmQgb2Ygc2VxdWVuY2UpIHRhZyAoMGZmZmUsZTBkZClcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgdGFncyB0aGF0IGNvdWxkIHBvdGVudGlhbGx5IGJlIGZvdW5kIGRpcmVjdGx5IGFmdGVyIGEgc2VxdWVuY2Ugc3RhcnQgdGFnICh0aGUgZGVsaW1pdGVyXG4gICAgICAgICAgICAvLyBpcyBmb3VuZCBpbiB0aGUgY2FzZSBvZiBhbiBlbXB0eSBzZXF1ZW5jZSkuIFRoaXMgaXMgbm90IDEwMCUgc2FmZSBiZWNhdXNlIGEgbm9uLXNlcXVlbmNlIGl0ZW1cbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgZGF0YSB0aGF0IGhhcyB0aGVzZSBieXRlcywgYnV0IHRoaXMgaXMgaG93IHRvIGRvIGl0IHdpdGhvdXQgYSBkYXRhIGRpY3Rpb25hcnkuXG4gICAgICAgICAgICByZXR1cm4gKG5leHRUYWcgPT09ICd4ZmZmZWUwMDAnKSB8fCAobmV4dFRhZyA9PT0gJ3hmZmZlZTBkZCcpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIHNlcXVlbmNlIGl0ZW0gdGFnIG9yIHNlcXVlbmNlIGRlbGltaXRlciB0YWcgaW4gcGVla2luZyB0byBkZXRlcm1pbmUgVlInKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdCA9IGZ1bmN0aW9uKGJ5dGVTdHJlYW0sIHVudGlsVGFnLCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgaWYoYnl0ZVN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVTdHJlYW0nXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIHRhZyA6IGRpY29tUGFyc2VyLnJlYWRUYWcoYnl0ZVN0cmVhbSksXG4gICAgICAgICAgICBsZW5ndGg6IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpLFxuICAgICAgICAgICAgZGF0YU9mZnNldCA6ICBieXRlU3RyZWFtLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaGFkVW5kZWZpbmVkTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVsZW1lbnQudGFnID09PSB1bnRpbFRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNTZXF1ZW5jZShlbGVtZW50LCBieXRlU3RyZWFtLCB2ckNhbGxiYWNrKSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBlbGVtZW50IGlzIG5vdCBhIHNlcXVlbmNlIGFuZCBoYXMgdW5kZWZpbmVkIGxlbmd0aCwgd2UgaGF2ZSB0b1xuICAgICAgICAvLyBzY2FuIHRoZSBkYXRhIGZvciBhIG1hZ2ljIG51bWJlciB0byBmaWd1cmUgb3V0IHdoZW4gaXQgZW5kcy5cbiAgICAgICAgaWYoZWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLmZpbmRJdGVtRGVsaW1pdGF0aW9uSXRlbUFuZFNldEVsZW1lbnRMZW5ndGgoYnl0ZVN0cmVhbSwgZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vbiBzZXF1ZW5jZSBlbGVtZW50IHdpdGgga25vd24gbGVuZ3RoLCBza2lwIG92ZXIgdGhlIGRhdGEgcGFydFxuICAgICAgICBieXRlU3RyZWFtLnNlZWsoZWxlbWVudC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEZ1bmN0aW9uYWxpdHkgZm9yIGV4dHJhY3RpbmcgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRGcmFnbWVudEluZGV4V2l0aE9mZnNldChmcmFnbWVudHMsIG9mZnNldCkge1xuICAgIGZvcih2YXIgaT0wOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihmcmFnbWVudHNbaV0ub2Zmc2V0ID09PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyT2ZGcmFnbWVudHNGb3JGcmFtZShmcmFtZUluZGV4LCBiYXNpY09mZnNldFRhYmxlLCBmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnRJbmRleCkge1xuICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgbGFzdCBmcmFtZVxuICAgIGlmKGZyYW1lSW5kZXggPT09IGJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoIC0xKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnRzLmxlbmd0aCAtIHN0YXJ0RnJhZ21lbnRJbmRleDtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCBmcmFnbWVudCBsb29raW5nIGZvciB0aGUgb25lIG1hdGNoaW5nIHRoZSBvZmZzZXQgZm9yIHRoZSBuZXh0IGZyYW1lXG4gICAgdmFyIG5leHRGcmFtZU9mZnNldCA9IGJhc2ljT2Zmc2V0VGFibGVbZnJhbWVJbmRleCArIDFdO1xuICAgIGZvcih2YXIgaT1zdGFydEZyYWdtZW50SW5kZXggKyAxOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihmcmFnbWVudHNbaV0ub2Zmc2V0ID09PSBuZXh0RnJhbWVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGkgLSBzdGFydEZyYWdtZW50SW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgXCJkaWNvbVBhcnNlci5jYWxjdWxhdGVOdW1iZXJPZkZyYWdtZW50c0ZvckZyYW1lOiBjb3VsZCBub3QgZmluZCBmcmFnbWVudCB3aXRoIG9mZnNldCBtYXRjaGluZyBiYXNpYyBvZmZzZXQgdGFibGVcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaXhlbCBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGZyYW1lIGluIGFuIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhIGVsZW1lbnQgdGhhdCBoYXMgYSBub25cbiAgICogZW1wdHkgYmFzaWMgb2Zmc2V0IHRhYmxlLiAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBmYWlsIGlmIHRoZSBiYXNpYyBvZmZzZXQgdGFibGUgaXMgZW1wdHkgLSBpbiB0aGF0XG4gICAqIGNhc2UgeW91IG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZyYWdtZW50cyBtYXAgdG8gd2hpY2ggZnJhbWVzIGFuZCByZWFkIHRoZW0gdXNpbmdcbiAgICogcmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHMoKS4gIEFsc28gc2VlIHRoZSBmdW5jdGlvbiBjcmVhdGVKRVBHQmFzaWNPZmZzZXRUYWJsZSgpIHRvIHNlZVxuICAgKiBob3cgYSBiYXNpYyBvZmZzZXQgdGFibGUgY2FuIGJlIGNyZWF0ZWQgZm9yIEpQRUcgaW1hZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhU2V0IC0gdGhlIGRhdGFTZXQgY29udGFpbmluZyB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICogQHBhcmFtIHBpeGVsRGF0YUVsZW1lbnQgLSB0aGUgcGl4ZWwgZGF0YSBlbGVtZW50ICh4N2ZlMDAwMTApIHRvIGV4dHJhY3QgdGhlIGZyYW1lIGZyb21cbiAgICogQHBhcmFtIGZyYW1lSW5kZXggLSB0aGUgemVybyBiYXNlZCBmcmFtZSBpbmRleFxuICAgKiBAcGFyYW0gW2Jhc2ljT2Zmc2V0VGFibGVdIC0gb3B0aW9uYWwgYXJyYXkgb2Ygc3RhcnRpbmcgb2Zmc2V0cyBmb3IgZnJhbWVzXG4gICAqIEBwYXJhbSBbZnJhZ21lbnRzXSAtIG9wdGlvbmFsIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBlYWNoIGZyYWdtZW50IChvZmZzZXQsIHBvc2l0aW9uLCBsZW5ndGgpXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHdpdGggdGhlIGVuY2Fwc3VsYXRlZCBwaXhlbCBkYXRhXG4gICAqL1xuICBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZSA9IGZ1bmN0aW9uKGRhdGFTZXQsIHBpeGVsRGF0YUVsZW1lbnQsIGZyYW1lSW5kZXgsIGJhc2ljT2Zmc2V0VGFibGUsIGZyYWdtZW50cylcbiAge1xuICAgIC8vIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgIGJhc2ljT2Zmc2V0VGFibGUgPSBiYXNpY09mZnNldFRhYmxlIHx8IHBpeGVsRGF0YUVsZW1lbnQuYmFzaWNPZmZzZXRUYWJsZTtcbiAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMgfHwgcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHM7XG5cbiAgICAvLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG4gICAgaWYoZGF0YVNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZGF0YVNldCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCdcIjtcbiAgICB9XG4gICAgaWYoZnJhbWVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnZnJhbWVJbmRleCdcIjtcbiAgICB9XG4gICAgaWYoYmFzaWNPZmZzZXRUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIGRvZXMgbm90IGhhdmUgYmFzaWNPZmZzZXRUYWJsZVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LnRhZyAhPT0gJ3g3ZmUwMDAxMCcpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIG5vbiBwaXhlbCBkYXRhIHRhZyAoZXhwZWN0ZWQgdGFnID0geDdmZTAwMDEwJ1wiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmVuY2Fwc3VsYXRlZFBpeGVsRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmhhZFVuZGVmaW5lZExlbmd0aCAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkSW1hZ2VGcmFtZTogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSB1bmRlZmluZWQgbGVuZ3RoXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZnJhZ21lbnRzXCI7XG4gICAgfVxuICAgIGlmKGJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiBiYXNpY09mZnNldFRhYmxlIGhhcyB6ZXJvIGVudHJpZXNcIjtcbiAgICB9XG4gICAgaWYoZnJhbWVJbmRleCA8IDApIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAnZnJhbWVJbmRleCcgbXVzdCBiZSA+PSAwXCI7XG4gICAgfVxuICAgIGlmKGZyYW1lSW5kZXggPj0gYmFzaWNPZmZzZXRUYWJsZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZEltYWdlRnJhbWU6IHBhcmFtZXRlciAnZnJhbWVJbmRleCcgbXVzdCBiZSA8IGJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoXCI7XG4gICAgfVxuXG4gICAgLy8gZmluZCBzdGFydGluZyBmcmFnbWVudCBiYXNlZCBvbiB0aGUgb2Zmc2V0IGZvciB0aGUgZnJhbWUgaW4gdGhlIGJhc2ljIG9mZnNldCB0YWJsZVxuICAgIHZhciBvZmZzZXQgPSBiYXNpY09mZnNldFRhYmxlW2ZyYW1lSW5kZXhdO1xuICAgIHZhciBzdGFydEZyYWdtZW50SW5kZXggPSBmaW5kRnJhZ21lbnRJbmRleFdpdGhPZmZzZXQoZnJhZ21lbnRzLCBvZmZzZXQpO1xuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRJbWFnZUZyYW1lOiB1bmFibGUgdG8gZmluZCBmcmFnbWVudCB0aGF0IG1hdGNoZXMgYmFzaWMgb2Zmc2V0IHRhYmxlIGVudHJ5XCI7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGlzIGZyYW1lXG4gICAgdmFyIG51bUZyYWdtZW50cyA9IGNhbGN1bGF0ZU51bWJlck9mRnJhZ21lbnRzRm9yRnJhbWUoZnJhbWVJbmRleCwgYmFzaWNPZmZzZXRUYWJsZSwgZnJhZ21lbnRzLCBzdGFydEZyYWdtZW50SW5kZXgpO1xuXG4gICAgLy8gbm93IGV4dHJhY3QgdGhlIGZyYW1lIGZyb20gdGhlIGZyYWdtZW50c1xuICAgIHJldHVybiBkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50cyhkYXRhU2V0LCBwaXhlbERhdGFFbGVtZW50LCBzdGFydEZyYWdtZW50SW5kZXgsIG51bUZyYWdtZW50cywgZnJhZ21lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG5cbi8qKlxuICogRnVuY3Rpb25hbGl0eSBmb3IgZXh0cmFjdGluZyBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVxuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmKGRpY29tUGFyc2VyID09PSB1bmRlZmluZWQpXG4gIHtcbiAgICBkaWNvbVBhcnNlciA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlQnVmZmVyU2l6ZShmcmFnbWVudHMsIHN0YXJ0RnJhZ21lbnQsIG51bUZyYWdtZW50cykge1xuICAgIHZhciBidWZmZXJTaXplID0gMDtcbiAgICBmb3IodmFyIGk9c3RhcnRGcmFnbWVudDsgaSA8IHN0YXJ0RnJhZ21lbnQgKyBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgYnVmZmVyU2l6ZSArPSBmcmFnbWVudHNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZnJhZ21lbnRzLiAgVXNlIHRoaXMgZnVuY3Rpb24gd2hlbiB5b3Uga25vd1xuICAgKiB0aGUgZnJhZ21lbnRzIHlvdSB3YW50IHRvIGV4dHJhY3QgZGF0YSBmcm9tLiAgU2VlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhU2V0IC0gdGhlIGRhdGFTZXQgY29udGFpbmluZyB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICogQHBhcmFtIHBpeGVsRGF0YUVsZW1lbnQgLSB0aGUgcGl4ZWwgZGF0YSBlbGVtZW50ICh4N2ZlMDAwMTApIHRvIGV4dHJhY3QgdGhlIGZyYWdtZW50IGRhdGEgZnJvbVxuICAgKiBAcGFyYW0gc3RhcnRGcmFnbWVudEluZGV4IC0gemVybyBiYXNlZCBpbmRleCBvZiB0aGUgZmlyc3QgZnJhZ21lbnQgdG8gZXh0cmFjdCBmcm9tXG4gICAqIEBwYXJhbSBbbnVtRnJhZ21lbnRzXSAtIHRoZSBudW1iZXIgb2YgZnJhZ21lbnRzIHRvIGV4dHJhY3QgZnJvbSwgZGVmYXVsdCBpcyAxXG4gICAqIEBwYXJhbSBbZnJhZ21lbnRzXSAtIG9wdGlvbmFsIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBlYWNoIGZyYWdtZW50IChvZmZzZXQsIHBvc2l0aW9uLCBsZW5ndGgpXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGJ5dGUgYXJyYXkgd2l0aCB0aGUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcbiAgICovXG4gIGRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzID0gZnVuY3Rpb24oZGF0YVNldCwgcGl4ZWxEYXRhRWxlbWVudCwgc3RhcnRGcmFnbWVudEluZGV4LCBudW1GcmFnbWVudHMsIGZyYWdtZW50cylcbiAge1xuICAgIC8vIGRlZmF1bHQgdmFsdWVzXG4gICAgbnVtRnJhZ21lbnRzID0gbnVtRnJhZ21lbnRzIHx8IDE7XG4gICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzIHx8IHBpeGVsRGF0YUVsZW1lbnQuZnJhZ21lbnRzO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmKGRhdGFTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RhdGFTZXQnXCI7XG4gICAgfVxuICAgIGlmKHBpeGVsRGF0YUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnXCI7XG4gICAgfVxuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudEluZGV4J1wiO1xuICAgIH1cbiAgICBpZihudW1GcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ251bUZyYWdtZW50cydcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC50YWcgIT09ICd4N2ZlMDAwMTAnKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3BpeGVsRGF0YUVsZW1lbnQnIHJlZmVycyB0byBub24gcGl4ZWwgZGF0YSB0YWcgKGV4cGVjdGVkIHRhZyA9IHg3ZmUwMDAxMCdcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5lbmNhcHN1bGF0ZWRQaXhlbERhdGEgIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5oYWRVbmRlZmluZWRMZW5ndGggIT09IHRydWUpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5iYXNpY09mZnNldFRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAncGl4ZWxEYXRhRWxlbWVudCcgcmVmZXJzIHRvIHBpeGVsIGRhdGEgZWxlbWVudCB0aGF0IGRvZXMgbm90IGhhdmUgZW5jYXBzdWxhdGVkIHBpeGVsIGRhdGFcIjtcbiAgICB9XG4gICAgaWYocGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhRnJvbUZyYWdtZW50czogcGFyYW1ldGVyICdwaXhlbERhdGFFbGVtZW50JyByZWZlcnMgdG8gcGl4ZWwgZGF0YSBlbGVtZW50IHRoYXQgZG9lcyBub3QgaGF2ZSBlbmNhcHN1bGF0ZWQgcGl4ZWwgZGF0YVwiO1xuICAgIH1cbiAgICBpZihzdGFydEZyYWdtZW50SW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3N0YXJ0RnJhZ21lbnRJbmRleCcgbXVzdCBiZSA+PSAwXCI7XG4gICAgfVxuICAgIGlmKHN0YXJ0RnJhZ21lbnRJbmRleCA+PSBwaXhlbERhdGFFbGVtZW50LmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YUZyb21GcmFnbWVudHM6IHBhcmFtZXRlciAnc3RhcnRGcmFnbWVudEluZGV4JyBtdXN0IGJlIDwgbnVtYmVyIG9mIGZyYWdtZW50c1wiO1xuICAgIH1cbiAgICBpZihudW1GcmFnbWVudHMgPCAxKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ251bUZyYWdtZW50cycgbXVzdCBiZSA+IDBcIjtcbiAgICB9XG4gICAgaWYoc3RhcnRGcmFnbWVudEluZGV4ICsgbnVtRnJhZ21lbnRzID4gcGl4ZWxEYXRhRWxlbWVudC5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBcImRpY29tUGFyc2VyLnJlYWRFbmNhcHN1bGF0ZWRQaXhlbERhdGFGcm9tRnJhZ21lbnRzOiBwYXJhbWV0ZXIgJ3N0YXJ0RnJhZ21lbnQnICsgJ251bUZyYWdtZW50cycgPCBudW1iZXIgb2YgZnJhZ21lbnRzXCI7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGJ5dGUgc3RyZWFtIG9uIHRoZSBkYXRhIGZvciB0aGlzIHBpeGVsIGRhdGEgZWxlbWVudFxuICAgIHZhciBieXRlU3RyZWFtID0gbmV3IGRpY29tUGFyc2VyLkJ5dGVTdHJlYW0oZGF0YVNldC5ieXRlQXJyYXlQYXJzZXIsIGRhdGFTZXQuYnl0ZUFycmF5LCBwaXhlbERhdGFFbGVtZW50LmRhdGFPZmZzZXQpO1xuXG4gICAgLy8gc2VlayBwYXN0IHRoZSBiYXNpYyBvZmZzZXQgdGFibGUgKG5vIG5lZWQgdG8gcGFyc2UgaXQgYWdhaW4gc2luY2Ugd2UgYWxyZWFkeSBoYXZlKVxuICAgIHZhciBiYXNpY09mZnNldFRhYmxlID0gZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbShieXRlU3RyZWFtKTtcbiAgICBpZihiYXNpY09mZnNldFRhYmxlLnRhZyAhPT0gJ3hmZmZlZTAwMCcpXG4gICAge1xuICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhOiBtaXNzaW5nIGJhc2ljIG9mZnNldCB0YWJsZSB4ZmZmZWUwMDBcIjtcbiAgICB9XG4gICAgYnl0ZVN0cmVhbS5zZWVrKGJhc2ljT2Zmc2V0VGFibGUubGVuZ3RoKTtcblxuICAgIHZhciBmcmFnbWVudFplcm9Qb3NpdGlvbiA9IGJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgdmFyIGZyYWdtZW50SGVhZGVyU2l6ZSA9IDg7IC8vIHRhZyArIGxlbmd0aFxuXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgZnJhZ21lbnQsIHJldHVybiBhIHZpZXcgb24gdGhpcyBhcnJheSB0byBhdm9pZCBjb3B5aW5nXG4gICAgaWYobnVtRnJhZ21lbnRzID09PSAxKSB7XG4gICAgICByZXR1cm4gZGljb21QYXJzZXIuc2hhcmVkQ29weShieXRlU3RyZWFtLmJ5dGVBcnJheSwgZnJhZ21lbnRaZXJvUG9zaXRpb24gKyBmcmFnbWVudHNbc3RhcnRGcmFnbWVudEluZGV4XS5vZmZzZXQgKyBmcmFnbWVudEhlYWRlclNpemUsIGZyYWdtZW50c1tzdGFydEZyYWdtZW50SW5kZXhdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gbW9yZSB0aGFuIG9uZSBmcmFnbWVudCwgY29tYmluZSBhbGwgb2YgdGhlIGZyYWdtZW50cyBpbnRvIG9uZSBidWZmZXJcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZUJ1ZmZlclNpemUoZnJhZ21lbnRzLCBzdGFydEZyYWdtZW50SW5kZXgsIG51bUZyYWdtZW50cyk7XG5cbiAgICB2YXIgcGl4ZWxEYXRhID0gZGljb21QYXJzZXIuYWxsb2MoYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGJ1ZmZlclNpemUpO1xuXG4gICAgdmFyIHBpeGVsRGF0YUluZGV4ID0gMDtcbiAgICBmb3IodmFyIGk9c3RhcnRGcmFnbWVudEluZGV4OyBpIDwgc3RhcnRGcmFnbWVudEluZGV4ICsgbnVtRnJhZ21lbnRzOyBpKyspIHtcbiAgICAgIHZhciBmcmFnbWVudE9mZnNldCA9IGZyYWdtZW50WmVyb1Bvc2l0aW9uICsgZnJhZ21lbnRzW2ldLm9mZnNldCArIGZyYWdtZW50SGVhZGVyU2l6ZTtcbiAgICAgIGZvcih2YXIgaj0wOyBqIDwgZnJhZ21lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBpeGVsRGF0YVtwaXhlbERhdGFJbmRleCsrXSA9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5W2ZyYWdtZW50T2Zmc2V0KytdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwaXhlbERhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuXG4vKipcbiAqIFBhcnNlcyBhIERJQ09NIFAxMCBieXRlIGFycmF5IGFuZCByZXR1cm5zIGEgRGF0YVNldCBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIGVsZW1lbnRzLiAgSWYgdGhlIG9wdGlvbnNcbiAqIGFyZ3VtZW50IGlzIHN1cHBsaWVkIGFuZCBpdCBjb250YWlucyB0aGUgdW50aWxUYWcgcHJvcGVydHksIHBhcnNpbmcgd2lsbCBzdG9wIG9uY2UgdGhhdFxuICogdGFnIGlzIGVuY291dGVyZWQuICBUaGlzIGNhbiBiZSB1c2VkIHRvIHBhcnNlIHBhcnRpYWwgYnl0ZSBzdHJlYW1zLlxuICpcbiAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB0byBjb250cm9sIHBhcnNpbmcgYmVoYXZpb3IgKG9wdGlvbmFsKVxuICogQHJldHVybnMge0RhdGFTZXR9XG4gKiBAdGhyb3dzIGVycm9yIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBwYXJzaW5nLiAgVGhlIGV4Y2VwdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIGEgcHJvcGVydHkgZGF0YVNldCB3aXRoIHRoZVxuICogICAgICAgICBlbGVtZW50cyBzdWNjZXNzZnVsbHkgcGFyc2VkIGJlZm9yZSB0aGUgZXJyb3IuXG4gKi9cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbihkaWNvbVBhcnNlcikge1xuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIGRpY29tUGFyc2VyLnJlYWRQYXJ0MTBIZWFkZXIgPSBmdW5jdGlvbihieXRlQXJyYXksIG9wdGlvbnMpIHtcblxuICAgIGlmKGJ5dGVBcnJheSA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFBhcnQxMEhlYWRlcjogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J5dGVBcnJheSdcIjtcbiAgICB9XG5cbiAgICB2YXIgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbSA9IG5ldyBkaWNvbVBhcnNlci5CeXRlU3RyZWFtKGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlciwgYnl0ZUFycmF5KTtcblxuICAgIGZ1bmN0aW9uIHJlYWRQcmVmaXgoKVxuICAgIHtcbiAgICAgIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0uc2VlaygxMjgpO1xuICAgICAgdmFyIHByZWZpeCA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucmVhZEZpeGVkU3RyaW5nKDQpO1xuICAgICAgaWYocHJlZml4ICE9PSBcIkRJQ01cIilcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkUGFydDEwSGVhZGVyOiBESUNNIHByZWZpeCBub3QgZm91bmQgYXQgbG9jYXRpb24gMTMyIC0gdGhpcyBpcyBub3QgYSB2YWxpZCBESUNPTSBQMTAgZmlsZS5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWluIGZ1bmN0aW9uIGhlcmVcbiAgICBmdW5jdGlvbiByZWFkVGhlSGVhZGVyKCkge1xuICAgICAgLy8gUGVyIHRoZSBESUNPTSBzdGFuZGFyZCwgdGhlIGhlYWRlciBpcyBhbHdheXMgZW5jb2RlZCBpbiBFeHBsaWNpdCBWUiBMaXR0bGUgRW5kaWFuIChzZWUgUFMzLjEwLCBzZWN0aW9uIDcuMSlcbiAgICAgIC8vIHNvIHVzZSBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtIHRocm91Z2hvdXQgdGhpcyBtZXRob2QgcmVnYXJkbGVzcyBvZiB0aGUgdHJhbnNmZXIgc3ludGF4XG4gICAgICByZWFkUHJlZml4KCk7XG5cbiAgICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgICAgdmFyIGVsZW1lbnRzID0ge307XG4gICAgICB3aGlsZShsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnBvc2l0aW9uIDwgbGl0dGxlRW5kaWFuQnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb247XG4gICAgICAgIHZhciBlbGVtZW50ID0gZGljb21QYXJzZXIucmVhZERpY29tRWxlbWVudEV4cGxpY2l0KGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgaWYoZWxlbWVudC50YWcgPiAneDAwMDJmZmZmJykge1xuICAgICAgICAgIGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0ucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWNoZSB0aGUgbGl0dGxlRW5kaWFuQnl0ZUFycmF5UGFyc2VyIGZvciBtZXRhIGhlYWRlciBlbGVtZW50cywgc2luY2UgdGhlIHJlc3Qgb2YgdGhlIGRhdGEgc2V0IG1heSBiZSBiaWcgZW5kaWFuXG4gICAgICAgIC8vIGFuZCB0aGlzIHBhcnNlciB3aWxsIGJlIG5lZWRlZCBsYXRlciBpZiB0aGUgbWV0YSBoZWFkZXIgdmFsdWVzIGFyZSB0byBiZSByZWFkLlxuICAgICAgICBlbGVtZW50LnBhcnNlciA9IGRpY29tUGFyc2VyLmxpdHRsZUVuZGlhbkJ5dGVBcnJheVBhcnNlcjtcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHZhciBtZXRhSGVhZGVyRGF0YVNldCA9IG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGxpdHRsZUVuZGlhbkJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgICAgbWV0YUhlYWRlckRhdGFTZXQud2FybmluZ3MgPSBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLndhcm5pbmdzO1xuICAgICAgbWV0YUhlYWRlckRhdGFTZXQucG9zaXRpb24gPSBsaXR0bGVFbmRpYW5CeXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgcmV0dXJuIG1ldGFIZWFkZXJEYXRhU2V0O1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgd2hlcmUgd2UgYWN0dWFsbHkgc3RhcnQgcGFyc2luZ1xuICAgIHJldHVybiByZWFkVGhlSGVhZGVyKCk7XG4gIH07XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufSkoZGljb21QYXJzZXIpO1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZERpY29tRGF0YVNldEV4cGxpY2l0VW5kZWZpbmVkTGVuZ3RoKGJ5dGVTdHJlYW0sIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG5cbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkaWNvbVBhcnNlci5yZWFkRGljb21FbGVtZW50RXhwbGljaXQoYnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcblxuICAgICAgICAgICAgLy8gd2UgaGl0IGFuIGl0ZW0gZGVsaW1pdGVyIHRhZywgcmV0dXJuIHRoZSBjdXJyZW50IG9mZnNldCB0byBtYXJrXG4gICAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoaXMgc2VxdWVuY2UgaXRlbVxuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09ICd4ZmZmZWUwMGQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW9mIGVuY291bnRlcmVkIC0gbG9nIGEgd2FybmluZyBhbmQgcmV0dXJuIHdoYXQgd2UgaGF2ZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgd2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIGl0ZW0gZGVsaW1pdGVyIHRhZyB3aGlsZSByZWFkaW5nIHNlcXVlbmNlIGl0ZW0gb2YgdW5kZWZpbmVkIGxlbmd0aCcpO1xuICAgICAgICByZXR1cm4gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCBlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNlcXVlbmNlSXRlbUV4cGxpY2l0KGJ5dGVTdHJlYW0sIHdhcm5pbmdzKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtKGJ5dGVTdHJlYW0pO1xuXG4gICAgICAgIGlmKGl0ZW0ubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtLmhhZFVuZGVmaW5lZExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICBpdGVtLmRhdGFTZXQgPSByZWFkRGljb21EYXRhU2V0RXhwbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgd2FybmluZ3MpO1xuICAgICAgICAgICAgaXRlbS5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gaXRlbS5kYXRhT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaXRlbS5kYXRhU2V0ID0gbmV3IGRpY29tUGFyc2VyLkRhdGFTZXQoYnl0ZVN0cmVhbS5ieXRlQXJyYXlQYXJzZXIsIGJ5dGVTdHJlYW0uYnl0ZUFycmF5LCB7fSk7XG4gICAgICAgICAgICBkaWNvbVBhcnNlci5wYXJzZURpY29tRGF0YVNldEV4cGxpY2l0KGl0ZW0uZGF0YVNldCwgYnl0ZVN0cmVhbSwgYnl0ZVN0cmVhbS5wb3NpdGlvbiArIGl0ZW0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU1FFbGVtZW50VW5kZWZpbmVkTGVuZ3RoRXhwbGljaXQoYnl0ZVN0cmVhbSwgZWxlbWVudCwgd2FybmluZ3MpXG4gICAge1xuICAgICAgICB3aGlsZSgoYnl0ZVN0cmVhbS5wb3NpdGlvbiArIDQpIDw9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVuZCByZWFkaW5nIHRoaXMgc2VxdWVuY2UgaWYgdGhlIG5leHQgdGFnIGlzIHRoZSBzZXF1ZW5jZSBkZWxpbWl0YXRpb24gaXRlbVxuICAgICAgICAgIHZhciBuZXh0VGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoLTQpO1xuICAgICAgICAgIGlmIChuZXh0VGFnID09PSAneGZmZmVlMGRkJykge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKDgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlYWRTZXF1ZW5jZUl0ZW1FeHBsaWNpdChieXRlU3RyZWFtLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICBlbGVtZW50Lml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIHNlcXVlbmNlIGRlbGltaXRhdGlvbiB0YWcgd2hpbGUgcmVhZGluZyBzZXF1ZW5jZSBvZiB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5wb3NpdGlvbiAtIGVsZW1lbnQuZGF0YU9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU1FFbGVtZW50S25vd25MZW5ndGhFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGVsZW1lbnQuZGF0YU9mZnNldCArIGVsZW1lbnQubGVuZ3RoO1xuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgbWF4UG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcmVhZFNlcXVlbmNlSXRlbUV4cGxpY2l0KGJ5dGVTdHJlYW0sIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpY29tUGFyc2VyLnJlYWRTZXF1ZW5jZUl0ZW1zRXhwbGljaXQgPSBmdW5jdGlvbihieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncylcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0V4cGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihlbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNFeHBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VsZW1lbnQnXCI7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50Lml0ZW1zID0gW107XG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWRTUUVsZW1lbnRVbmRlZmluZWRMZW5ndGhFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZWFkU1FFbGVtZW50S25vd25MZW5ndGhFeHBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB3YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbnMgZm9yIHBhcnNpbmcgRElDT00gZWxlbWVudHNcbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIGRpY29tUGFyc2VyID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZERpY29tRGF0YVNldEltcGxpY2l0VW5kZWZpbmVkTGVuZ3RoKGJ5dGVTdHJlYW0sIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICB3aGlsZShieXRlU3RyZWFtLnBvc2l0aW9uIDwgYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRpY29tUGFyc2VyLnJlYWREaWNvbUVsZW1lbnRJbXBsaWNpdChieXRlU3RyZWFtLCB1bmRlZmluZWQsIHZyQ2FsbGJhY2spO1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudC50YWddID0gZWxlbWVudDtcblxuICAgICAgICAgICAgLy8gd2UgaGl0IGFuIGl0ZW0gZGVsaW1pdGVyIHRhZywgcmV0dXJuIHRoZSBjdXJyZW50IG9mZnNldCB0byBtYXJrXG4gICAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoaXMgc2VxdWVuY2UgaXRlbVxuICAgICAgICAgICAgaWYoZWxlbWVudC50YWcgPT09ICd4ZmZmZWUwMGQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIGVsZW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlb2YgZW5jb3VudGVyZWQgLSBsb2cgYSB3YXJuaW5nIGFuZCByZXR1cm4gd2hhdCB3ZSBoYXZlIGZvciB0aGUgZWxlbWVudFxuICAgICAgICBieXRlU3RyZWFtLndhcm5pbmdzLnB1c2goJ2VvZiBlbmNvdW50ZXJlZCBiZWZvcmUgZmluZGluZyBzZXF1ZW5jZSBpdGVtIGRlbGltaXRlciBpbiBzZXF1ZW5jZSBpdGVtIG9mIHVuZGVmaW5lZCBsZW5ndGgnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBkaWNvbVBhcnNlci5EYXRhU2V0KGJ5dGVTdHJlYW0uYnl0ZUFycmF5UGFyc2VyLCBieXRlU3RyZWFtLmJ5dGVBcnJheSwgZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTZXF1ZW5jZUl0ZW1JbXBsaWNpdChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtKGJ5dGVTdHJlYW0pO1xuXG4gICAgICAgIGlmKGl0ZW0ubGVuZ3RoID09PSA0Mjk0OTY3Mjk1KVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtLmhhZFVuZGVmaW5lZExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICBpdGVtLmRhdGFTZXQgPSByZWFkRGljb21EYXRhU2V0SW1wbGljaXRVbmRlZmluZWRMZW5ndGgoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjayk7XG4gICAgICAgICAgICBpdGVtLmxlbmd0aCA9IGJ5dGVTdHJlYW0ucG9zaXRpb24gLSBpdGVtLmRhdGFPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpdGVtLmRhdGFTZXQgPSBuZXcgZGljb21QYXJzZXIuRGF0YVNldChieXRlU3RyZWFtLmJ5dGVBcnJheVBhcnNlciwgYnl0ZVN0cmVhbS5ieXRlQXJyYXksIHt9KTtcbiAgICAgICAgICAgIGRpY29tUGFyc2VyLnBhcnNlRGljb21EYXRhU2V0SW1wbGljaXQoaXRlbS5kYXRhU2V0LCBieXRlU3RyZWFtLCBieXRlU3RyZWFtLnBvc2l0aW9uICsgaXRlbS5sZW5ndGgsIHt2ckNhbGxiYWNrOiB2ckNhbGxiYWNrfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFNRRWxlbWVudFVuZGVmaW5lZExlbmd0aEltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICB3aGlsZSgoYnl0ZVN0cmVhbS5wb3NpdGlvbiArIDQpIDw9IGJ5dGVTdHJlYW0uYnl0ZUFycmF5Lmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVuZCByZWFkaW5nIHRoaXMgc2VxdWVuY2UgaWYgdGhlIG5leHQgdGFnIGlzIHRoZSBzZXF1ZW5jZSBkZWxpbWl0YXRpb24gaXRlbVxuICAgICAgICAgIHZhciBuZXh0VGFnID0gZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKTtcbiAgICAgICAgICBieXRlU3RyZWFtLnNlZWsoLTQpO1xuICAgICAgICAgIGlmIChuZXh0VGFnID09PSAneGZmZmVlMGRkJykge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgZWxlbWVudC5sZW5ndGggPSBieXRlU3RyZWFtLnBvc2l0aW9uIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKDgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGl0ZW0gPSByZWFkU2VxdWVuY2VJdGVtSW1wbGljaXQoYnl0ZVN0cmVhbSwgdnJDYWxsYmFjayk7XG4gICAgICAgICAgZWxlbWVudC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVTdHJlYW0ud2FybmluZ3MucHVzaCgnZW9mIGVuY291bnRlcmVkIGJlZm9yZSBmaW5kaW5nIHNlcXVlbmNlIGRlbGltaXRlciBpbiBzZXF1ZW5jZSBvZiB1bmRlZmluZWQgbGVuZ3RoJyk7XG4gICAgICAgIGVsZW1lbnQubGVuZ3RoID0gYnl0ZVN0cmVhbS5ieXRlQXJyYXkubGVuZ3RoIC0gZWxlbWVudC5kYXRhT2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spXG4gICAge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb24gPSBlbGVtZW50LmRhdGFPZmZzZXQgKyBlbGVtZW50Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUoYnl0ZVN0cmVhbS5wb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlYWRTZXF1ZW5jZUl0ZW1JbXBsaWNpdChieXRlU3RyZWFtLCB2ckNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsZW1lbnQuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHNlcXVlbmNlIGl0ZW1zIGZvciBhbiBlbGVtZW50IGluIGFuIGltcGxpY2l0IGxpdHRsZSBlbmRpYW4gYnl0ZSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbSB0aGUgaW1wbGljaXQgbGl0dGxlIGVuZGlhbiBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHJlYWQgdGhlIHNlcXVlbmNlIGl0ZW1zIGZvclxuICAgICAqIEBwYXJhbSB2ckNhbGxiYWNrIGFuIG9wdGlvbmFsIG1ldGhvZCB0aGF0IHJldHVybnMgYSBWUiBzdHJpbmcgZ2l2ZW4gYSB0YWdcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0ID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSwgZWxlbWVudCwgdnJDYWxsYmFjaylcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtc0ltcGxpY2l0OiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihlbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IFwiZGljb21QYXJzZXIucmVhZFNlcXVlbmNlSXRlbXNJbXBsaWNpdDogbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VsZW1lbnQnXCI7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50Lml0ZW1zID0gW107XG5cbiAgICAgICAgaWYoZWxlbWVudC5sZW5ndGggPT09IDQyOTQ5NjcyOTUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWRTUUVsZW1lbnRVbmRlZmluZWRMZW5ndGhJbXBsaWNpdChieXRlU3RyZWFtLCBlbGVtZW50LCB2ckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWRTUUVsZW1lbnRLbm93bkxlbmd0aEltcGxpY2l0KGJ5dGVTdHJlYW0sIGVsZW1lbnQsIHZyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgdGFnIGFuZCBsZW5ndGggb2YgYSBzZXF1ZW5jZSBpdGVtIGFuZCByZXR1cm5zIHRoZW0gYXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXG4gICAgICogIHRhZyA6IHN0cmluZyBmb3IgdGhlIHRhZyBvZiB0aGlzIGVsZW1lbnQgaW4gdGhlIGZvcm1hdCB4Z2dnZ2VlZWVcbiAgICAgKiAgbGVuZ3RoOiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgaXRlbSBvciA0Mjk0OTY3Mjk1IGlmIHVuZGVmaW5lZFxuICAgICAqICBkYXRhT2Zmc2V0OiB0aGUgb2Zmc2V0IGludG8gdGhlIGJ5dGVTdHJlYW0gb2YgdGhlIGRhdGEgZm9yIHRoaXMgaXRlbVxuICAgICAqIEBwYXJhbSBieXRlU3RyZWFtIHRoZSBieXRlXG4gICAgICogQHJldHVybnMge3t0YWc6IHN0cmluZywgbGVuZ3RoOiBpbnRlZ2VyLCBkYXRhT2Zmc2V0OiBpbnRlZ2VyfX1cbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSlcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgdGFnIDogZGljb21QYXJzZXIucmVhZFRhZyhieXRlU3RyZWFtKSxcbiAgICAgICAgICAgIGxlbmd0aCA6IGJ5dGVTdHJlYW0ucmVhZFVpbnQzMigpLFxuICAgICAgICAgICAgZGF0YU9mZnNldCA6ICBieXRlU3RyZWFtLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVsZW1lbnQudGFnICE9PSAneGZmZmVlMDAwJykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSBieXRlU3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkU2VxdWVuY2VJdGVtOiBpdGVtIHRhZyAoRkZGRSxFMDAwKSBub3QgZm91bmQgYXQgb2Zmc2V0IFwiICsgc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBESUNPTSBlbGVtZW50c1xuICovXG5cbnZhciBkaWNvbVBhcnNlciA9IChmdW5jdGlvbiAoZGljb21QYXJzZXIpXG57XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgZGljb21QYXJzZXIgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAoZ3JvdXAgbnVtYmVyIGFuZCBlbGVtZW50IG51bWJlcikgZnJvbSBhIGJ5dGVTdHJlYW1cbiAgICAgKiBAcGFyYW0gYnl0ZVN0cmVhbSB0aGUgYnl0ZSBzdHJlYW0gdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHRhZyBpbiBmb3JtYXQgeGdnZ2dlZWVlIHdoZXJlIGdnZ2cgaXMgdGhlIGxvd2VyY2FzZSBoZXggdmFsdWUgb2YgdGhlIGdyb3VwIG51bWJlclxuICAgICAqIGFuZCBlZWVlIGlzIHRoZSBsb3dlciBjYXNlIGhleCB2YWx1ZSBvZiB0aGUgZWxlbWVudCBudW1iZXJcbiAgICAgKi9cbiAgICBkaWNvbVBhcnNlci5yZWFkVGFnID0gZnVuY3Rpb24oYnl0ZVN0cmVhbSlcbiAgICB7XG4gICAgICAgIGlmKGJ5dGVTdHJlYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJkaWNvbVBhcnNlci5yZWFkVGFnOiBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnYnl0ZVN0cmVhbSdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cE51bWJlciA9ICBieXRlU3RyZWFtLnJlYWRVaW50MTYoKSAqIDI1NiAqIDI1NjtcbiAgICAgICAgdmFyIGVsZW1lbnROdW1iZXIgPSBieXRlU3RyZWFtLnJlYWRVaW50MTYoKTtcbiAgICAgICAgdmFyIHRhZyA9IFwieFwiICsgKCcwMDAwMDAwMCcgKyAoZ3JvdXBOdW1iZXIgKyBlbGVtZW50TnVtYmVyKS50b1N0cmluZygxNikpLnN1YnN0cigtOCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfTtcblxuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0oZGljb21QYXJzZXIpKTtcbi8qKlxuICpcbiAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzaGFyZWQgY29weSBvZiBhIGJ5dGVBcnJheVxuICpcbiAqL1xudmFyIGRpY29tUGFyc2VyID0gKGZ1bmN0aW9uIChkaWNvbVBhcnNlcilcbntcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYoZGljb21QYXJzZXIgPT09IHVuZGVmaW5lZClcbiAge1xuICAgIGRpY29tUGFyc2VyID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHZpZXcgb2YgdGhlIHVuZGVybHlpbmcgYnl0ZUFycmF5LiAgVGhlIHZpZXcgaXMgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgYnl0ZUFycmF5IChlLmcuXG4gICAqIFVpbnQ4QXJyYXkgb3IgQnVmZmVyKSBhbmQgc2hhcmVzIHRoZSBzYW1lIHVuZGVybHlpbmcgbWVtb3J5IChjaGFuZ2luZyBvbmUgY2hhbmdlcyB0aGUgb3RoZXIpXG4gICAqIEBwYXJhbSBieXRlQXJyYXkgdGhlIHVuZGVybHlpbmcgYnl0ZUFycmF5IChlaXRoZXIgVWludDhBcnJheSBvciBCdWZmZXIpXG4gICAqIEBwYXJhbSBieXRlT2Zmc2V0IG9mZnNldCBpbnRvIHRoZSB1bmRlcmx5aW5nIGJ5dGVBcnJheSB0byBjcmVhdGUgdGhlIHZpZXcgb2ZcbiAgICogQHBhcmFtIGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIHZpZXdcbiAgICogQHJldHVybnMge29iamVjdH0gVWludDhBcnJheSBvciBCdWZmZXIgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGJ5dGVBcnJheVxuICAgKi9cbiAgZGljb21QYXJzZXIuc2hhcmVkQ29weSA9IGZ1bmN0aW9uKGJ5dGVBcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVBcnJheSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ5dGVBcnJheS5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZihieXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5LmJ1ZmZlciwgYnl0ZUFycmF5LmJ5dGVPZmZzZXQgKyBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnZGljb21QYXJzZXIuZnJvbTogdW5rbm93biB0eXBlIGZvciBieXRlQXJyYXknO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGljb21QYXJzZXI7XG59KGRpY29tUGFyc2VyKSk7XG4vKipcbiAqIFZlcnNpb25cbiAqL1xuXG52YXIgZGljb21QYXJzZXIgPSAoZnVuY3Rpb24gKGRpY29tUGFyc2VyKVxue1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZihkaWNvbVBhcnNlciA9PT0gdW5kZWZpbmVkKVxuICB7XG4gICAgZGljb21QYXJzZXIgPSB7fTtcbiAgfVxuXG4gIGRpY29tUGFyc2VyLnZlcnNpb24gPSBcIjEuNy4zXCI7XG5cbiAgcmV0dXJuIGRpY29tUGFyc2VyO1xufShkaWNvbVBhcnNlcikpO1xuICAgIHJldHVybiBkaWNvbVBhcnNlcjtcbn0pKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyA9IGpwZWcubG9zc2xlc3MuQ29tcG9uZW50U3BlYyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oU2FtcCA9IDA7IC8vIEhvcml6b250YWwgc2FtcGxpbmcgZmFjdG9yXG4gICAgdGhpcy5xdWFudFRhYmxlU2VsID0gMDsgLy8gUXVhbnRpemF0aW9uIHRhYmxlIGRlc3RpbmF0aW9uIHNlbGVjdG9yXG4gICAgdGhpcy52U2FtcCA9IDA7IC8vIFZlcnRpY2FsXG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWM7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBEYXRhVmlldyhkYXRhLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgdGhpcy5pbmRleCA9IDA7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtLnByb3RvdHlwZS5nZXQxNiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmJ1ZmZlci5nZXRVaW50MTYodGhpcy5pbmRleCwgZmFsc2UpO1xuICAgIHRoaXMuaW5kZXggKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtLnByb3RvdHlwZS5nZXQ4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuYnVmZmVyLmdldFVpbnQ4KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcbmpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSA9IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL2RhdGEtc3RyZWFtLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlID0ganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9odWZmbWFuLXRhYmxlLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vcXVhbnRpemF0aW9uLXRhYmxlLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3NjYW4taGVhZGVyLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgPSBqcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZnJhbWUtaGVhZGVyLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbHMuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyID0ganBlZy5sb3NzbGVzcy5EZWNvZGVyIHx8IGZ1bmN0aW9uIChidWZmZXIsIG51bUJ5dGVzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5mcmFtZSA9IG5ldyBqcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyKCk7XG4gICAgdGhpcy5odWZmVGFibGUgPSBuZXcganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUoKTtcbiAgICB0aGlzLnF1YW50VGFibGUgPSBuZXcganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSgpO1xuICAgIHRoaXMuc2NhbiA9IG5ldyBqcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIoKTtcbiAgICB0aGlzLkRVID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSgxMCwgNCwgNjQpOyAvLyBhdCBtb3N0IDEwIGRhdGEgdW5pdHMgaW4gYSBNQ1UsIGF0IG1vc3QgNCBkYXRhIHVuaXRzIGluIG9uZSBjb21wb25lbnRcbiAgICB0aGlzLkh1ZmZUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDQsIDIsIDUwICogMjU2KTtcbiAgICB0aGlzLklEQ1RfU291cmNlID0gW107XG4gICAgdGhpcy5uQmxvY2sgPSBbXTsgLy8gbnVtYmVyIG9mIGJsb2NrcyBpbiB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICAgIHRoaXMuYWNUYWIgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDEwLCAxKTsgLy8gYWMgSHVmZlRhYiBmb3IgdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgICB0aGlzLmRjVGFiID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSgxMCwgMSk7IC8vIGRjIEh1ZmZUYWIgZm9yIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gICAgdGhpcy5xVGFiID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheSgxMCwgMSk7IC8vIHF1YW50aXphdGlvbiB0YWJsZSBmb3IgdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgICB0aGlzLm1hcmtlciA9IDA7XG4gICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgdGhpcy5udW1Db21wID0gMDtcbiAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IDA7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSAwO1xuICAgIHRoaXMueERpbSA9IDA7XG4gICAgdGhpcy55RGltID0gMDtcbiAgICB0aGlzLnhMb2MgPSAwO1xuICAgIHRoaXMueUxvYyA9IDA7XG4gICAgdGhpcy5udW1CeXRlcyA9IDA7XG4gICAgdGhpcy5vdXRwdXREYXRhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1hc2sgPSAwO1xuXG4gICAgaWYgKHR5cGVvZiBudW1CeXRlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm51bUJ5dGVzID0gbnVtQnl0ZXM7XG4gICAgfVxufTtcblxuXG4vKioqIFN0YXRpYyBQc2V1ZG8tY29uc3RhbnRzICoqKi9cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLklEQ1RfUCA9IFswLCA1LCA0MCwgMTYsIDQ1LCAyLCA3LCA0MiwgMjEsIDU2LCA4LCA2MSwgMTgsIDQ3LCAxLCA0LCA0MSwgMjMsIDU4LCAxMywgMzIsIDI0LCAzNywgMTAsIDYzLCAxNywgNDQsIDMsIDYsIDQzLCAyMCxcbiAgICA1NywgMTUsIDM0LCAyOSwgNDgsIDUzLCAyNiwgMzksIDksIDYwLCAxOSwgNDYsIDIyLCA1OSwgMTIsIDMzLCAzMSwgNTAsIDU1LCAyNSwgMzYsIDExLCA2MiwgMTQsIDM1LCAyOCwgNDksIDUyLCAyNywgMzgsIDMwLCA1MSwgNTRdO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyLlRBQkxFID0gWzAsIDEsIDUsIDYsIDE0LCAxNSwgMjcsIDI4LCAyLCA0LCA3LCAxMywgMTYsIDI2LCAyOSwgNDIsIDMsIDgsIDEyLCAxNywgMjUsIDMwLCA0MSwgNDMsIDksIDExLCAxOCwgMjQsIDMxLCA0MCwgNDQsIDUzLFxuICAgIDEwLCAxOSwgMjMsIDMyLCAzOSwgNDUsIDUyLCA1NCwgMjAsIDIyLCAzMywgMzgsIDQ2LCA1MSwgNTUsIDYwLCAyMSwgMzQsIDM3LCA0NywgNTAsIDU2LCA1OSwgNjEsIDM1LCAzNiwgNDgsIDQ5LCA1NywgNTgsIDYyLCA2M107XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuTUFYX0hVRkZNQU5fU1VCVFJFRSA9IDUwO1xuanBlZy5sb3NzbGVzcy5EZWNvZGVyLk1TQiA9IDB4ODAwMDAwMDA7XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfQkVHSU4gPSAweEZGRDA7XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIuUkVTVEFSVF9NQVJLRVJfRU5EID0gMHhGRkQ3O1xuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvbXByZXNzID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGUoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkuYnVmZmVyO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG51bUJ5dGVzKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGN1cnJlbnQsIHNjYW5OdW0gPSAwLCBwcmVkID0gW10sIGksIGNvbXBOLCB0ZW1wID0gW10sIGluZGV4ID0gW10sIG1jdU51bTtcblxuICAgIGlmICh0eXBlb2YgYnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtQnl0ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5udW1CeXRlcyA9IG51bUJ5dGVzO1xuICAgIH1cblxuICAgIHRoaXMuc3RyZWFtID0gbmV3IGpwZWcubG9zc2xlc3MuRGF0YVN0cmVhbSh0aGlzLmJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMueExvYyA9IDA7XG4gICAgdGhpcy55TG9jID0gMDtcbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcblxuICAgIGlmIChjdXJyZW50ICE9PSAweEZGRDgpIHsgLy8gU09JXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIEpQRUcgZmlsZVwiKTtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcblxuICAgIHdoaWxlICgoKChjdXJyZW50ID4+IDQpICE9PSAweDBGRkMpIHx8IChjdXJyZW50ID09PSAweEZGQzQpKSkgeyAvLyBTT0YgMH4xNVxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgMHhGRkM0OiAvLyBESFRcbiAgICAgICAgICAgICAgICB0aGlzLmh1ZmZUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCB0aGlzLkh1ZmZUYWIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweEZGQ0M6IC8vIERBQ1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW0gZG9lc24ndCBzdXBwb3J0IGFyaXRobWV0aWMgY29kaW5nLiAoZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbilcIik7XG4gICAgICAgICAgICBjYXNlIDB4RkZEQjpcbiAgICAgICAgICAgICAgICB0aGlzLnF1YW50VGFibGUucmVhZCh0aGlzLnN0cmVhbSwganBlZy5sb3NzbGVzcy5EZWNvZGVyLlRBQkxFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRkREOlxuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEludGVydmFsID0gdGhpcy5yZWFkTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4RkZFMDpcbiAgICAgICAgICAgIGNhc2UgMHhGRkUxOlxuICAgICAgICAgICAgY2FzZSAweEZGRTI6XG4gICAgICAgICAgICBjYXNlIDB4RkZFMzpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU0OlxuICAgICAgICAgICAgY2FzZSAweEZGRTU6XG4gICAgICAgICAgICBjYXNlIDB4RkZFNjpcbiAgICAgICAgICAgIGNhc2UgMHhGRkU3OlxuICAgICAgICAgICAgY2FzZSAweEZGRTg6XG4gICAgICAgICAgICBjYXNlIDB4RkZFOTpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVBOlxuICAgICAgICAgICAgY2FzZSAweEZGRUI6XG4gICAgICAgICAgICBjYXNlIDB4RkZFQzpcbiAgICAgICAgICAgIGNhc2UgMHhGRkVEOlxuICAgICAgICAgICAgY2FzZSAweEZGRUU6XG4gICAgICAgICAgICBjYXNlIDB4RkZFRjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRBcHAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHhGRkZFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50ID4+IDgpICE9PSAweEZGKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uISAoZGVjb2RlKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICB9XG5cbiAgICBpZiAoKGN1cnJlbnQgPCAweEZGQzApIHx8IChjdXJyZW50ID4gMHhGRkM3KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogY291bGQgbm90IGhhbmRsZSBhcml0aG1ldGljIGNvZGUhXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWUucmVhZCh0aGlzLnN0cmVhbSk7XG4gICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG5cbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSAweDBGRkRBKSB7IC8vIFNPU1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGQzQ6IC8vIERIVFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmh1ZmZUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCB0aGlzLkh1ZmZUYWIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZDQzogLy8gREFDXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW0gZG9lc24ndCBzdXBwb3J0IGFyaXRobWV0aWMgY29kaW5nLiAoZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbilcIik7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGREI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhbnRUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCBqcGVnLmxvc3NsZXNzLkRlY29kZXIuVEFCTEUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZERDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPSB0aGlzLnJlYWROdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTA6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTE6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTI6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTM6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTQ6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTU6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTY6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTc6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTg6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRTk6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUE6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUI6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUM6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUQ6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUU6XG4gICAgICAgICAgICAgICAgY2FzZSAweEZGRUY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEFwcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4RkZGRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnQgPj4gOCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uISAoUGFyc2VyLmRlY29kZSlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHRoaXMuZnJhbWUucHJlY2lzaW9uO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB0aGlzLmZyYW1lLmNvbXBvbmVudHM7XG5cbiAgICAgICAgaWYgKCF0aGlzLm51bUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLm51bUJ5dGVzID0gcGFyc2VJbnQoTWF0aC5jZWlsKHRoaXMucHJlY2lzaW9uIC8gOCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubnVtQnl0ZXMgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5tYXNrID0gMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFzayA9IDB4RkZGRjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nhbi5yZWFkKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgdGhpcy5udW1Db21wID0gdGhpcy5zY2FuLm51bUNvbXA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zY2FuLnNlbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5udW1CeXRlcyA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubnVtQ29tcCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5nZXRWYWx1ZVJHQjtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRlciA9IHRoaXMuc2V0VmFsdWVSR0I7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFJHQjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLmdldFZhbHVlODtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRlciA9IHRoaXMuc2V0VmFsdWU4O1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXRTaW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IHRoaXMuZ2V0VmFsdWUxNjtcbiAgICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZTE2O1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFNpbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2NhbkNvbXBzID0gdGhpcy5zY2FuLmNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMucXVhbnRUYWJsZXMgPSB0aGlzLnF1YW50VGFibGUucXVhbnRUYWJsZXM7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtQ29tcDsgaSs9MSkge1xuICAgICAgICAgICAgY29tcE4gPSB0aGlzLnNjYW5Db21wc1tpXS5zY2FuQ29tcFNlbDtcbiAgICAgICAgICAgIHRoaXMucVRhYltpXSA9IHRoaXMucXVhbnRUYWJsZXNbdGhpcy5jb21wb25lbnRzW2NvbXBOXS5xdWFudFRhYmxlU2VsXTtcbiAgICAgICAgICAgIHRoaXMubkJsb2NrW2ldID0gdGhpcy5jb21wb25lbnRzW2NvbXBOXS52U2FtcCAqIHRoaXMuY29tcG9uZW50c1tjb21wTl0uaFNhbXA7XG4gICAgICAgICAgICB0aGlzLmRjVGFiW2ldID0gdGhpcy5IdWZmVGFiW3RoaXMuc2NhbkNvbXBzW2ldLmRjVGFiU2VsXVswXTtcbiAgICAgICAgICAgIHRoaXMuYWNUYWJbaV0gPSB0aGlzLkh1ZmZUYWJbdGhpcy5zY2FuQ29tcHNbaV0uYWNUYWJTZWxdWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54RGltID0gdGhpcy5mcmFtZS5kaW1YO1xuICAgICAgICB0aGlzLnlEaW0gPSB0aGlzLmZyYW1lLmRpbVk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIodGhpcy54RGltICogdGhpcy55RGltICogdGhpcy5udW1CeXRlcyAqIHRoaXMubnVtQ29tcCkpO1xuXG4gICAgICAgIHNjYW5OdW0rPTE7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHsgLy8gRGVjb2RlIG9uZSBzY2FuXG4gICAgICAgICAgICB0ZW1wWzBdID0gMDtcbiAgICAgICAgICAgIGluZGV4WzBdID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEwOyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgcHJlZFtpXSA9ICgxIDw8ICh0aGlzLnByZWNpc2lvbiAtIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucmVzdGFydEludGVydmFsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZGVjb2RlVW5pdChwcmVkLCB0ZW1wLCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgPT09IDApICYmICgodGhpcy54TG9jIDwgdGhpcy54RGltKSAmJiAodGhpcy55TG9jIDwgdGhpcy55RGltKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQocHJlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmRlY29kZVVuaXQocHJlZCwgdGVtcCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrOyAvL2N1cnJlbnQ9TUFSS0VSXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobWN1TnVtID0gMDsgbWN1TnVtIDwgdGhpcy5yZXN0YXJ0SW50ZXJ2YWw7IG1jdU51bSs9MSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydGluZyA9IChtY3VOdW0gPT0gMCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZGVjb2RlVW5pdChwcmVkLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQocHJlZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICgweEZGMDAgfCB0aGlzLm1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoKGN1cnJlbnQgPj0ganBlZy5sb3NzbGVzcy5EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOKSAmJlxuICAgICAgICAgICAgICAgIChjdXJyZW50IDw9IGpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9FTkQpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvL2N1cnJlbnQ9TUFSS0VSXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGN1cnJlbnQgPT09IDB4RkZEQykgJiYgKHNjYW5OdW0gPT09IDEpKSB7IC8vRE5MXG4gICAgICAgICAgICB0aGlzLnJlYWROdW1iZXIoKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoKGN1cnJlbnQgIT09IDB4RkZEOSkgJiYgKCh0aGlzLnhMb2MgPCB0aGlzLnhEaW0pICYmICh0aGlzLnlMb2MgPCB0aGlzLnlEaW0pKSAmJiAoc2Nhbk51bSA9PT0gMCkpO1xuXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RGF0YTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmRlY29kZVVuaXQgPSBmdW5jdGlvbiAocHJldiwgdGVtcCwgaW5kZXgpIHtcbiAgICBpZiAodGhpcy5udW1Db21wID09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlU2luZ2xlKHByZXYsIHRlbXAsIGluZGV4KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubnVtQ29tcCA9PSAzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZVJHQihwcmV2LCB0ZW1wLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDEgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDIgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDMgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3Q0ID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpICsgdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCkpIC0gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2VsZWN0NSA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpICsgKCh0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSAtIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KSkgPj4gMSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZWxlY3Q2ID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCkgKyAoKHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpIC0gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpKSA+PiAxKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNlbGVjdDcgPSBmdW5jdGlvbiAoY29tcE9mZnNldCkge1xuICAgIHJldHVybiAoKHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpICsgdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCkpIC8gMik7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVSR0IgPSBmdW5jdGlvbiAocHJldiwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgdmFsdWUsIGFjdGFiLCBkY3RhYiwgcXRhYiwgY3RyQywgaSwgaywgajtcblxuICAgIHByZXZbMF0gPSB0aGlzLnNlbGVjdG9yKDApO1xuICAgIHByZXZbMV0gPSB0aGlzLnNlbGVjdG9yKDEpO1xuICAgIHByZXZbMl0gPSB0aGlzLnNlbGVjdG9yKDIpO1xuXG4gICAgZm9yIChjdHJDID0gMDsgY3RyQyA8IHRoaXMubnVtQ29tcDsgY3RyQys9MSkge1xuICAgICAgICBxdGFiID0gdGhpcy5xVGFiW2N0ckNdO1xuICAgICAgICBhY3RhYiA9IHRoaXMuYWNUYWJbY3RyQ107XG4gICAgICAgIGRjdGFiID0gdGhpcy5kY1RhYltjdHJDXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubkJsb2NrW2N0ckNdOyBpKz0xKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdGhpcy5JRENUX1NvdXJjZS5sZW5ndGg7IGsrPTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLklEQ1RfU291cmNlW2tdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZShkY3RhYiwgdGVtcCwgaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMHhGRjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2W2N0ckNdID0gdGhpcy5JRENUX1NvdXJjZVswXSA9IHByZXZbY3RyQ10gKyB0aGlzLmdldG4oaW5kZXgsIHZhbHVlLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLklEQ1RfU291cmNlWzBdICo9IHF0YWJbMF07XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCA2NDsgais9MSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRIdWZmbWFuVmFsdWUoYWN0YWIsIHRlbXAsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweEZGMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGogKz0gKHZhbHVlID4+IDQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MEYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPj4gNCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5JRENUX1NvdXJjZVtqcGVnLmxvc3NsZXNzLkRlY29kZXIuSURDVF9QW2pdXSA9IHRoaXMuZ2V0bihpbmRleCwgdmFsdWUgJiAweDBGLCB0ZW1wLCBpbmRleCkgKiBxdGFiW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlU2luZ2xlID0gZnVuY3Rpb24gKHByZXYsIHRlbXAsIGluZGV4KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIHZhbHVlLCBpLCBuLCBuUmVzdGFydDtcblxuICAgIGlmICh0aGlzLnJlc3RhcnRpbmcpIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHByZXZbMF0gPSAoMSA8PCAodGhpcy5mcmFtZS5wcmVjaXNpb24gLSAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlswXSA9IHRoaXMuc2VsZWN0b3IoKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5uQmxvY2tbMF07IGkrPTEpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZSh0aGlzLmRjVGFiWzBdLCB0ZW1wLCBpbmRleCk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEZGMDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4gPSB0aGlzLmdldG4ocHJldiwgdmFsdWUsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgblJlc3RhcnQgPSAobiA+PiA4KTtcblxuICAgICAgICBpZiAoKG5SZXN0YXJ0ID49IGpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9CRUdJTikgJiYgKG5SZXN0YXJ0IDw9IGpwZWcubG9zc2xlc3MuRGVjb2Rlci5SRVNUQVJUX01BUktFUl9FTkQpKSB7XG4gICAgICAgICAgICByZXR1cm4gblJlc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2WzBdICs9IG47XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5cblxuLy9cdEh1ZmZtYW4gdGFibGUgZm9yIGZhc3Qgc2VhcmNoOiAoSHVmZlRhYikgOC1iaXQgTG9vayB1cCB0YWJsZSAyLWxheWVyIHNlYXJjaCBhcmNoaXRlY3R1cmUsIDFzdC1sYXllciByZXByZXNlbnQgMjU2IG5vZGUgKDggYml0cykgaWYgY29kZXdvcmQtbGVuZ3RoID4gOFxuLy9cdGJpdHMsIHRoZW4gdGhlIGVudHJ5IG9mIDFzdC1sYXllciA9ICgjIG9mIDJuZC1sYXllciB0YWJsZSkgfCBNU0IgYW5kIGl0IGlzIHN0b3JlZCBpbiB0aGUgMm5kLWxheWVyIFNpemUgb2YgdGFibGVzIGluIGVhY2ggbGF5ZXIgYXJlIDI1Ni5cbi8vXHRIdWZmVGFiWypdWypdWzAtMjU2XSBpcyBhbHdheXMgdGhlIG9ubHkgMXN0LWxheWVyIHRhYmxlLlxuLy9cbi8vXHRBbiBlbnRyeSBjYW4gYmU6ICgxKSAoIyBvZiAybmQtbGF5ZXIgdGFibGUpIHwgTVNCICwgZm9yIGNvZGUgbGVuZ3RoID4gOCBpbiAxc3QtbGF5ZXIgKDIpIChDb2RlIGxlbmd0aCkgPDwgOCB8IEh1ZmZWYWxcbi8vXG4vL1x0SHVmZm1hblZhbHVlKHRhYmxlICAgSHVmZlRhYlt4XVt5XSAoZXgpIEh1ZmZtYW5WYWx1ZShIdWZmVGFiWzFdWzBdLC4uLilcbi8vXHQgICAgICAgICAgICAgICAgKTpcbi8vXHQgICAgcmV0dXJuOiBIdWZmbWFuIFZhbHVlIG9mIHRhYmxlXG4vL1x0ICAgICAgICAgICAgMHhGRj8/IGlmIGl0IHJlY2VpdmVzIGEgTUFSS0VSXG4vL1x0ICAgIFBhcmFtZXRlcjogIHRhYmxlICAgSHVmZlRhYlt4XVt5XSAoZXgpIEh1ZmZtYW5WYWx1ZShIdWZmVGFiWzFdWzBdLC4uLilcbi8vXHQgICAgICAgICAgICAgICAgdGVtcCAgICB0ZW1wIHN0b3JhZ2UgZm9yIHJlbWFpbmRlZCBiaXRzXG4vL1x0ICAgICAgICAgICAgICAgIGluZGV4ICAgaW5kZXggdG8gYml0IG9mIHRlbXBcbi8vXHQgICAgICAgICAgICAgICAgaW4gICAgICBGSUxFIHBvaW50ZXJcbi8vXHQgICAgRWZmZWN0OlxuLy9cdCAgICAgICAgdGVtcCAgc3RvcmUgbmV3IHJlbWFpbmRlZCBiaXRzXG4vL1x0ICAgICAgICBpbmRleCBjaGFuZ2UgdG8gbmV3IGluZGV4XG4vL1x0ICAgICAgICBpbiAgICBjaGFuZ2UgdG8gbmV3IHBvc2l0aW9uXG4vL1x0ICAgIE5PVEU6XG4vL1x0ICAgICAgSW5pdGlhbCBieSAgIHRlbXA9MDsgaW5kZXg9MDtcbi8vXHQgICAgTk9URTogKGV4cGxhaW4gdGVtcCBhbmQgaW5kZXgpXG4vL1x0ICAgICAgdGVtcDogaXMgYWx3YXlzIGluIHRoZSBmb3JtIGF0IGNhbGxpbmcgdGltZSBvciByZXR1cm5pbmcgdGltZVxuLy9cdCAgICAgICB8ICBieXRlIDQgIHwgIGJ5dGUgMyAgfCAgYnl0ZSAyICB8ICBieXRlIDEgIHxcbi8vXHQgICAgICAgfCAgICAgMCAgICB8ICAgICAwICAgIHwgMDAwMDAwMDAgfCAwMDAwMD8/PyB8ICBpZiBub3QgYSBNQVJLRVJcbi8vXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5pbmRleD0zIChmcm9tIDAgdG8gMTUpXG4vL1x0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMjFcbi8vXHQgICAgTk9URSAobWFya2VyIGFuZCBtYXJrZXJfaW5kZXgpOlxuLy9cdCAgICAgIElmIGdldCBhIE1BUktFUiBmcm9tICdpbicsIG1hcmtlcj10aGUgbG93LWJ5dGUgb2YgdGhlIE1BUktFUlxuLy9cdCAgICAgICAgYW5kIG1hcmtlcl9pbmRleD05XG4vL1x0ICAgICAgSWYgbWFya2VyX2luZGV4PTkgdGhlbiBpbmRleCBpcyBhbHdheXMgPiA4LCBvciBIdWZmbWFuVmFsdWUoKVxuLy9cdCAgICAgICAgd2lsbCBub3QgYmUgY2FsbGVkXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldEh1ZmZtYW5WYWx1ZSA9IGZ1bmN0aW9uICh0YWJsZSwgdGVtcCwgaW5kZXgpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY29kZSwgaW5wdXQsIG1hc2s7XG4gICAgbWFzayA9IDB4RkZGRjtcblxuICAgIGlmIChpbmRleFswXSA8IDgpIHtcbiAgICAgICAgdGVtcFswXSA8PD0gODtcbiAgICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wWzBdIHw9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4WzBdIC09IDg7XG4gICAgfVxuXG4gICAgY29kZSA9IHRhYmxlW3RlbXBbMF0gPj4gaW5kZXhbMF1dO1xuXG4gICAgaWYgKChjb2RlICYganBlZy5sb3NzbGVzcy5EZWNvZGVyLk1TQikgIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2VySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIDB4RkYwMCB8IHRoaXMubWFya2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcFswXSAmPSAobWFzayA+PiAoMTYgLSBpbmRleFswXSkpO1xuICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IDB4RkYpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wWzBdIHw9IGlucHV0O1xuICAgICAgICBjb2RlID0gdGFibGVbKChjb2RlICYgMHhGRikgKiAyNTYpICsgKHRlbXBbMF0gPj4gaW5kZXhbMF0pXTtcbiAgICAgICAgaW5kZXhbMF0gKz0gODtcbiAgICB9XG5cbiAgICBpbmRleFswXSArPSA4IC0gKGNvZGUgPj4gOCk7XG5cbiAgICBpZiAoaW5kZXhbMF0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXhbMF0gKyBcIiB0ZW1wPVwiICsgdGVtcFswXSArIFwiIGNvZGU9XCIgKyBjb2RlICsgXCIgaW4gSHVmZm1hblZhbHVlKClcIik7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4WzBdIDwgdGhpcy5tYXJrZXJJbmRleCkge1xuICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIDB4RkYwMCB8IHRoaXMubWFya2VyO1xuICAgIH1cblxuICAgIHRlbXBbMF0gJj0gKG1hc2sgPj4gKDE2IC0gaW5kZXhbMF0pKTtcbiAgICByZXR1cm4gY29kZSAmIDB4RkY7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRuID0gZnVuY3Rpb24gKFBSRUQsIG4sIHRlbXAsIGluZGV4KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIHJlc3VsdCwgb25lLCBuX29uZSwgbWFzaywgaW5wdXQ7XG4gICAgb25lID0gMTtcbiAgICBuX29uZSA9IC0xO1xuICAgIG1hc2sgPSAweEZGRkY7XG5cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAobiA9PT0gMTYpIHtcbiAgICAgICAgaWYgKFBSRURbMF0gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0zMjc2ODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAzMjc2ODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4WzBdIC09IG47XG5cbiAgICBpZiAoaW5kZXhbMF0gPj0gMCkge1xuICAgICAgICBpZiAoKGluZGV4WzBdIDwgdGhpcy5tYXJrZXJJbmRleCkgJiYgIXRoaXMuaXNMYXN0UGl4ZWwoKSkgeyAvLyB0aGlzIHdhcyBjb3JydXB0aW5nIHRoZSBsYXN0IHBpeGVsIGluIHNvbWUgY2FzZXNcbiAgICAgICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuICgweEZGMDAgfCB0aGlzLm1hcmtlcikgPDwgODtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRlbXBbMF0gPj4gaW5kZXhbMF07XG4gICAgICAgIHRlbXBbMF0gJj0gKG1hc2sgPj4gKDE2IC0gaW5kZXhbMF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IDB4RkYpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wWzBdIHw9IGlucHV0O1xuICAgICAgICBpbmRleFswXSArPSA4O1xuXG4gICAgICAgIGlmIChpbmRleFswXSA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlckluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgweEZGMDAgfCB0aGlzLm1hcmtlcikgPDwgODtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVtcFswXSA8PD0gODtcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IDB4RkYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZW1wWzBdIHw9IGlucHV0O1xuICAgICAgICAgICAgaW5kZXhbMF0gKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleFswXSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXhbMF0gKyBcIiBpbiBnZXRuKClcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiAoMHhGRjAwIHwgdGhpcy5tYXJrZXIpIDw8IDg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0ZW1wWzBdID4+IGluZGV4WzBdO1xuICAgICAgICB0ZW1wWzBdICY9IChtYXNrID4+ICgxNiAtIGluZGV4WzBdKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA8IChvbmUgPDwgKG4gLSAxKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IChuX29uZSA8PCBuKSArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFByZXZpb3VzWCA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgaWYgKHRoaXMueExvYyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCgoKHRoaXMueUxvYyAqIHRoaXMueERpbSkgKyB0aGlzLnhMb2MpIC0gMSksIGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy55TG9jID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgxIDw8ICh0aGlzLmZyYW1lLnByZWNpc2lvbiAtIDEpKTtcbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5nZXRQcmV2aW91c1hZID0gZnVuY3Rpb24gKGNvbXBPZmZzZXQpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICBpZiAoKHRoaXMueExvYyA+IDApICYmICh0aGlzLnlMb2MgPiAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoKCgoKHRoaXMueUxvYyAtIDEpICogdGhpcy54RGltKSArIHRoaXMueExvYykgLSAxKSwgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpO1xuICAgIH1cbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFByZXZpb3VzWSA9IGZ1bmN0aW9uIChjb21wT2Zmc2V0KSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgaWYgKHRoaXMueUxvYyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCgoKHRoaXMueUxvYyAtIDEpICogdGhpcy54RGltKSArIHRoaXMueExvYyksIGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KTtcbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5pc0xhc3RQaXhlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMueExvYyA9PT0gKHRoaXMueERpbSAtIDEpKSAmJiAodGhpcy55TG9jID09PSAodGhpcy55RGltIC0gMSkpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUub3V0cHV0U2luZ2xlID0gZnVuY3Rpb24gKFBSRUQpIHtcbiAgICBpZiAoKHRoaXMueExvYyA8IHRoaXMueERpbSkgJiYgKHRoaXMueUxvYyA8IHRoaXMueURpbSkpIHtcbiAgICAgICAgdGhpcy5zZXR0ZXIoKCgodGhpcy55TG9jICogdGhpcy54RGltKSArIHRoaXMueExvYykpLCB0aGlzLm1hc2sgJiBQUkVEWzBdKTtcblxuICAgICAgICB0aGlzLnhMb2MrPTE7XG5cbiAgICAgICAgaWYgKHRoaXMueExvYyA+PSB0aGlzLnhEaW0pIHtcbiAgICAgICAgICAgIHRoaXMueUxvYys9MTtcbiAgICAgICAgICAgIHRoaXMueExvYyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5vdXRwdXRSR0IgPSBmdW5jdGlvbiAoUFJFRCkge1xuICAgIHZhciBvZmZzZXQgPSAoKHRoaXMueUxvYyAqIHRoaXMueERpbSkgKyB0aGlzLnhMb2MpO1xuXG4gICAgaWYgKCh0aGlzLnhMb2MgPCB0aGlzLnhEaW0pICYmICh0aGlzLnlMb2MgPCB0aGlzLnlEaW0pKSB7XG4gICAgICAgIHRoaXMuc2V0dGVyKG9mZnNldCwgUFJFRFswXSwgMCk7XG4gICAgICAgIHRoaXMuc2V0dGVyKG9mZnNldCwgUFJFRFsxXSwgMSk7XG4gICAgICAgIHRoaXMuc2V0dGVyKG9mZnNldCwgUFJFRFsyXSwgMik7XG5cbiAgICAgICAgdGhpcy54TG9jKz0xO1xuXG4gICAgICAgIGlmICh0aGlzLnhMb2MgPj0gdGhpcy54RGltKSB7XG4gICAgICAgICAgICB0aGlzLnlMb2MrPTE7XG4gICAgICAgICAgICB0aGlzLnhMb2MgPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuc2V0VmFsdWUxNiA9IGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gICAgdGhpcy5vdXRwdXREYXRhLnNldEludDE2KGluZGV4ICogMiwgdmFsLCB0cnVlKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFZhbHVlMTYgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhLmdldEludDE2KGluZGV4ICogMiwgdHJ1ZSk7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5zZXRWYWx1ZTggPSBmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xuICAgIHRoaXMub3V0cHV0RGF0YS5zZXRJbnQ4KGluZGV4LCB2YWwpO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUuZ2V0VmFsdWU4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RGF0YS5nZXRJbnQ4KGluZGV4KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnNldFZhbHVlUkdCID0gZnVuY3Rpb24gKGluZGV4LCB2YWwsIGNvbXBPZmZzZXQpIHtcbiAgICB0aGlzLm91dHB1dERhdGEuc2V0VWludDgoaW5kZXggKiAzICsgY29tcE9mZnNldCwgdmFsKTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLmdldFZhbHVlUkdCID0gZnVuY3Rpb24gKGluZGV4LCBjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RGF0YS5nZXRVaW50OChpbmRleCAqIDMgKyBjb21wT2Zmc2V0KTtcbn07XG5cblxuXG5qcGVnLmxvc3NsZXNzLkRlY29kZXIucHJvdG90eXBlLnJlYWRBcHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSAwLCBsZW5ndGggPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcblxuXG5cbmpwZWcubG9zc2xlc3MuRGVjb2Rlci5wcm90b3R5cGUucmVhZENvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNiID0gXCJcIiwgY291bnQgPSAwLCBsZW5ndGg7XG5cbiAgICBsZW5ndGggPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgICAgc2IgKz0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBjb3VudCs9MTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2I7XG59O1xuXG5cblxuanBlZy5sb3NzbGVzcy5EZWNvZGVyLnByb3RvdHlwZS5yZWFkTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIExkID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcblxuICAgIGlmIChMZCAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogRGVmaW5lIG51bWJlciBmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uIFtMZCE9NF1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtLmdldDE2KCk7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuRGVjb2Rlcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjID0ganBlZy5sb3NzbGVzcy5Db21wb25lbnRTcGVjIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vY29tcG9uZW50LXNwZWMuanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5GcmFtZUhlYWRlciA9IGpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdOyAvLyBDb21wb25lbnRzXG4gICAgdGhpcy5kaW1YID0gMDsgLy8gTnVtYmVyIG9mIHNhbXBsZXMgcGVyIGxpbmVcbiAgICB0aGlzLmRpbVkgPSAwOyAvLyBOdW1iZXIgb2YgbGluZXNcbiAgICB0aGlzLm51bUNvbXAgPSAwOyAvLyBOdW1iZXIgb2YgY29tcG9uZW50IGluIHRoZSBmcmFtZVxuICAgIHRoaXMucHJlY2lzaW9uID0gMDsgLy8gU2FtcGxlIFByZWNpc2lvbiAoZnJvbSB0aGUgb3JpZ2luYWwgaW1hZ2UpXG59O1xuXG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCwgaSwgYywgdGVtcDtcblxuICAgIGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCs9MTtcblxuICAgIHRoaXMuZGltWSA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgdGhpcy5kaW1YID0gZGF0YS5nZXQxNigpO1xuICAgIGNvdW50ICs9IDI7XG5cbiAgICB0aGlzLm51bUNvbXAgPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCs9MTtcbiAgICBmb3IgKGkgPSAxOyBpIDw9IHRoaXMubnVtQ29tcDsgaSs9MSkge1xuICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmcmFtZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuXG4gICAgICAgIGlmIChjb3VudCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmcmFtZSBmb3JtYXQgZXJyb3IgW2M+PUxmXVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudHNbY10pIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tjXSA9IG5ldyBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tjXS5oU2FtcCA9IHRlbXAgPj4gNDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2NdLnZTYW1wID0gdGVtcCAmIDB4MEY7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tjXS5xdWFudFRhYmxlU2VsID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuICAgIH1cblxuICAgIGlmIChjb3VudCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmcmFtZSBmb3JtYXQgZXJyb3IgW0xmIT1jb3VudF1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlV0aWxzID0ganBlZy5sb3NzbGVzcy5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxzLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlID0ganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubCA9IGpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkoNCwgMiwgMTYpO1xuICAgIHRoaXMudGggPSBbXTtcbiAgICB0aGlzLnYgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDQsIDIsIDE2LCAyMDApO1xuICAgIHRoaXMudGMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDQsIDIpO1xuXG4gICAgdGhpcy50Y1swXVswXSA9IDA7XG4gICAgdGhpcy50Y1sxXVswXSA9IDA7XG4gICAgdGhpcy50Y1syXVswXSA9IDA7XG4gICAgdGhpcy50Y1szXVswXSA9IDA7XG4gICAgdGhpcy50Y1swXVsxXSA9IDA7XG4gICAgdGhpcy50Y1sxXVsxXSA9IDA7XG4gICAgdGhpcy50Y1syXVsxXSA9IDA7XG4gICAgdGhpcy50Y1szXVsxXSA9IDA7XG4gICAgdGhpcy50aFswXSA9IDA7XG4gICAgdGhpcy50aFsxXSA9IDA7XG4gICAgdGhpcy50aFsyXSA9IDA7XG4gICAgdGhpcy50aFszXSA9IDA7XG59O1xuXG5cblxuLyoqKiBTdGF0aWMgUHNldWRvLWNvbnN0YW50cyAqKiovXG5cbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlLk1TQiA9IDB4ODAwMDAwMDA7XG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oZGF0YSwgSHVmZlRhYikge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCwgdGVtcCwgdCwgYywgaSwgajtcblxuICAgIGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgICAgIHQgPSB0ZW1wICYgMHgwRjtcbiAgICAgICAgaWYgKHQgPiAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBJRCA+IDNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjID0gdGVtcCA+PiA0O1xuICAgICAgICBpZiAoYyA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIFtUYWJsZSBjbGFzcyA+IDIgXVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGhbdF0gPSAxO1xuICAgICAgICB0aGlzLnRjW3RdW2NdID0gMTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrPTEpIHtcbiAgICAgICAgICAgIHRoaXMubFt0XVtjXVtpXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICAgICAgY291bnQrPTE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrPTEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmxbdF1bY11baV07IGorPTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgZm9ybWF0IGVycm9yIFtjb3VudD5MaF1cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy52W3RdW2NdW2ldW2pdID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgICAgICAgICAgY291bnQrPTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBmb3JtYXQgZXJyb3IgW2NvdW50IT1MZl1cIik7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrPTEpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDI7IGorPTEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRjW2ldW2pdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEh1ZmZUYWJsZShIdWZmVGFiW2ldW2pdLCB0aGlzLmxbaV1bal0sIHRoaXMudltpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cblxuXG4vL1x0QnVpbGRfSHVmZlRhYigpXG4vL1x0UGFyYW1ldGVyOiAgdCAgICAgICB0YWJsZSBJRFxuLy9cdCAgICAgICAgICAgIGMgICAgICAgdGFibGUgY2xhc3MgKCAwIGZvciBEQywgMSBmb3IgQUMgKVxuLy9cdCAgICAgICAgICAgIExbaV0gICAgIyBvZiBjb2Rld29yZHMgd2hpY2ggbGVuZ3RoIGlzIGlcbi8vXHQgICAgICAgICAgICBWW2ldW2pdIEh1ZmZtYW4gVmFsdWUgKGxlbmd0aD1pKVxuLy9cdEVmZmVjdDpcbi8vXHQgICAgYnVpbGQgdXAgSHVmZlRhYlt0XVtjXSB1c2luZyBMIGFuZCBWLlxuanBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUucHJvdG90eXBlLmJ1aWxkSHVmZlRhYmxlID0gZnVuY3Rpb24odGFiLCBMLCBWKSB7XG4gICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG4gICAgdmFyIGN1cnJlbnRUYWJsZSwgdGVtcCwgaywgaSwgaiwgbjtcbiAgICB0ZW1wID0gMjU2O1xuICAgIGsgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDg7IGkrPTEpIHsgLy8gaSsxIGlzIENvZGUgbGVuZ3RoXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBMW2ldOyBqKz0xKSB7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgKHRlbXAgPj4gKGkgKyAxKSk7IG4rPTEpIHtcbiAgICAgICAgICAgICAgICB0YWJba10gPSBWW2ldW2pdIHwgKChpICsgMSkgPDwgOCk7XG4gICAgICAgICAgICAgICAgays9MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDE7IGsgPCAyNTY7IGkrPTEsIGsrPTEpIHtcbiAgICAgICAgdGFiW2tdID0gaSB8IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlLk1TQjtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFibGUgPSAxO1xuICAgIGsgPSAwO1xuXG4gICAgZm9yIChpID0gODsgaSA8IDE2OyBpKz0xKSB7IC8vIGkrMSBpcyBDb2RlIGxlbmd0aFxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgTFtpXTsgais9MSkge1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8ICh0ZW1wID4+IChpIC0gNykpOyBuKz0xKSB7XG4gICAgICAgICAgICAgICAgdGFiWyhjdXJyZW50VGFibGUgKiAyNTYpICsga10gPSBWW2ldW2pdIHwgKChpICsgMSkgPDwgOCk7XG4gICAgICAgICAgICAgICAgays9MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGsgPj0gMjU2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPiAyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgZXJyb3IoMSkhXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYWJsZSs9MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlO1xufVxuIiwiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgPSBqcGVnLmxvc3NsZXNzLkNvbXBvbmVudFNwZWMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9jb21wb25lbnQtc3BlYy5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLkRlY29kZXIgPSBqcGVnLmxvc3NsZXNzLkRlY29kZXIgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kZWNvZGVyLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuRnJhbWVIZWFkZXIgPSBqcGVnLmxvc3NsZXNzLkZyYW1lSGVhZGVyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZnJhbWUtaGVhZGVyLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuSHVmZm1hblRhYmxlID0ganBlZy5sb3NzbGVzcy5IdWZmbWFuVGFibGUgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9odWZmbWFuLXRhYmxlLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuUXVhbnRpemF0aW9uVGFibGUgPSBqcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vcXVhbnRpemF0aW9uLXRhYmxlLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCA9IGpwZWcubG9zc2xlc3MuU2NhbkNvbXBvbmVudCB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3NjYW4tY29tcG9uZW50LmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciA9IGpwZWcubG9zc2xlc3MuU2NhbkhlYWRlciB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3NjYW4taGVhZGVyLmpzJykgOiBudWxsKTtcbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vdXRpbHMuanMnKSA6IG51bGwpO1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuanBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtID0ganBlZy5sb3NzbGVzcy5EYXRhU3RyZWFtIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vZGF0YS1zdHJlYW0uanMnKSA6IG51bGwpO1xuanBlZy5sb3NzbGVzcy5VdGlscyA9IGpwZWcubG9zc2xlc3MuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlscy5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLlF1YW50aXphdGlvblRhYmxlID0ganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBbXTsgLy8gUXVhbnRpemF0aW9uIHByZWNpc2lvbiA4IG9yIDE2XG4gICAgdGhpcy50cSA9IFtdOyAvLyAxOiB0aGlzIHRhYmxlIGlzIHByZXNlbnRlZFxuICAgIHRoaXMucXVhbnRUYWJsZXMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyZWF0ZUFycmF5KDQsIDY0KTsgLy8gVGFibGVzXG5cbiAgICB0aGlzLnRxWzBdID0gMDtcbiAgICB0aGlzLnRxWzFdID0gMDtcbiAgICB0aGlzLnRxWzJdID0gMDtcbiAgICB0aGlzLnRxWzNdID0gMDtcbn07XG5cblxuXG4vKioqIFN0YXRpYyBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZS5lbmhhbmNlUXVhbnRpemF0aW9uVGFibGUgPSBmdW5jdGlvbihxdGFiLCB0YWJsZSkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDg7IGkrPTEpIHtcbiAgICAgICAgcXRhYlt0YWJsZVsoMCAqIDgpICsgaV1dICo9IDkwO1xuICAgICAgICBxdGFiW3RhYmxlWyg0ICogOCkgKyBpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbKDIgKiA4KSArIGldXSAqPSAxMTg7XG4gICAgICAgIHF0YWJbdGFibGVbKDYgKiA4KSArIGldXSAqPSA0OTtcbiAgICAgICAgcXRhYlt0YWJsZVsoNSAqIDgpICsgaV1dICo9IDcxO1xuICAgICAgICBxdGFiW3RhYmxlWygxICogOCkgKyBpXV0gKj0gMTI2O1xuICAgICAgICBxdGFiW3RhYmxlWyg3ICogOCkgKyBpXV0gKj0gMjU7XG4gICAgICAgIHF0YWJbdGFibGVbKDMgKiA4KSArIGldXSAqPSAxMDY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDg7IGkrPTEpIHtcbiAgICAgICAgcXRhYlt0YWJsZVswICsgKDggKiBpKV1dICo9IDkwO1xuICAgICAgICBxdGFiW3RhYmxlWzQgKyAoOCAqIGkpXV0gKj0gOTA7XG4gICAgICAgIHF0YWJbdGFibGVbMiArICg4ICogaSldXSAqPSAxMTg7XG4gICAgICAgIHF0YWJbdGFibGVbNiArICg4ICogaSldXSAqPSA0OTtcbiAgICAgICAgcXRhYlt0YWJsZVs1ICsgKDggKiBpKV1dICo9IDcxO1xuICAgICAgICBxdGFiW3RhYmxlWzEgKyAoOCAqIGkpXV0gKj0gMTI2O1xuICAgICAgICBxdGFiW3RhYmxlWzcgKyAoOCAqIGkpXV0gKj0gMjU7XG4gICAgICAgIHF0YWJbdGFibGVbMyArICg4ICogaSldXSAqPSAxMDY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKz0xKSB7XG4gICAgICAgIHF0YWJbaV0gPj49IDY7XG4gICAgfVxufTtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuanBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhLCB0YWJsZSkge1xuICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuICAgIHZhciBjb3VudCA9IDAsIGxlbmd0aCwgdGVtcCwgdCwgaTtcblxuICAgIGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG4gICAgICAgIHQgPSB0ZW1wICYgMHgwRjtcblxuICAgICAgICBpZiAodCA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgSUQgPiAzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVjaXNpb25bdF0gPSB0ZW1wID4+IDQ7XG5cbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvblt0XSA9IDg7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb25bdF0gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uW3RdID0gMTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIHByZWNpc2lvbiBlcnJvclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHFbdF0gPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvblt0XSA9PT0gOCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgZm9ybWF0IGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucXVhbnRUYWJsZXNbdF1baV0gPSBkYXRhLmdldDgoKTtcbiAgICAgICAgICAgICAgICBjb3VudCs9MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZS5lbmhhbmNlUXVhbnRpemF0aW9uVGFibGUodGhpcy5xdWFudFRhYmxlc1t0XSwgdGFibGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKz0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgZm9ybWF0IGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucXVhbnRUYWJsZXNbdF1baV0gPSBkYXRhLmdldDE2KCk7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZS5lbmhhbmNlUXVhbnRpemF0aW9uVGFibGUodGhpcy5xdWFudFRhYmxlc1t0XSwgdGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBlcnJvciBbY291bnQhPUxxXVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5RdWFudGl6YXRpb25UYWJsZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgTWljaGFlbCBNYXJ0aW5lelxuICogQ2hhbmdlczogQWRkZWQgc3VwcG9ydCBmb3Igc2VsZWN0aW9uIHZhbHVlcyAyLTcsIGZpeGVkIG1pbm9yIGJ1Z3MgJlxuICogd2FybmluZ3MsIHNwbGl0IGludG8gbXVsdGlwbGUgY2xhc3MgZmlsZXMsIGFuZCBnZW5lcmFsIGNsZWFuIHVwLlxuICpcbiAqIDA4LTI1LTIwMTU6IEhlbG11dCBEZXJzY2ggYWdyZWVkIHRvIGEgbGljZW5zZSBjaGFuZ2UgZnJvbSBMR1BMIHRvIE1JVC5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChDKSBIZWxtdXQgRGVyc2NoXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cbnZhciBqcGVnID0ganBlZyB8fCB7fTtcbmpwZWcubG9zc2xlc3MgPSBqcGVnLmxvc3NsZXNzIHx8IHt9O1xuXG5cbi8qKiogQ29uc3RydWN0b3IgKioqL1xuanBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50ID0ganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50IHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjVGFiU2VsID0gMDsgLy8gQUMgdGFibGUgc2VsZWN0b3JcbiAgICB0aGlzLmRjVGFiU2VsID0gMDsgLy8gREMgdGFibGUgc2VsZWN0b3JcbiAgICB0aGlzLnNjYW5Db21wU2VsID0gMDsgLy8gU2NhbiBjb21wb25lbnQgc2VsZWN0b3Jcbn07XG5cblxuXG4vKioqIEV4cG9ydHMgKioqL1xuXG52YXIgbW9kdWxlVHlwZSA9IHR5cGVvZiBtb2R1bGU7XG5pZiAoKG1vZHVsZVR5cGUgIT09ICd1bmRlZmluZWQnKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNSBNaWNoYWVsIE1hcnRpbmV6XG4gKiBDaGFuZ2VzOiBBZGRlZCBzdXBwb3J0IGZvciBzZWxlY3Rpb24gdmFsdWVzIDItNywgZml4ZWQgbWlub3IgYnVncyAmXG4gKiB3YXJuaW5ncywgc3BsaXQgaW50byBtdWx0aXBsZSBjbGFzcyBmaWxlcywgYW5kIGdlbmVyYWwgY2xlYW4gdXAuXG4gKlxuICogMDgtMjUtMjAxNTogSGVsbXV0IERlcnNjaCBhZ3JlZWQgdG8gYSBsaWNlbnNlIGNoYW5nZSBmcm9tIExHUEwgdG8gTUlULlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKEMpIEhlbG11dCBEZXJzY2hcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xudmFyIGpwZWcgPSBqcGVnIHx8IHt9O1xuanBlZy5sb3NzbGVzcyA9IGpwZWcubG9zc2xlc3MgfHwge307XG5qcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gPSBqcGVnLmxvc3NsZXNzLkRhdGFTdHJlYW0gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9kYXRhLXN0cmVhbS5qcycpIDogbnVsbCk7XG5qcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgPSBqcGVnLmxvc3NsZXNzLlNjYW5Db21wb25lbnQgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9zY2FuLWNvbXBvbmVudC5qcycpIDogbnVsbCk7XG5cblxuLyoqKiBDb25zdHJ1Y3RvciAqKiovXG5qcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgPSBqcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXIgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWggPSAwO1xuICAgIHRoaXMuYWwgPSAwO1xuICAgIHRoaXMubnVtQ29tcCA9IDA7IC8vIE51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBzY2FuXG4gICAgdGhpcy5zZWxlY3Rpb24gPSAwOyAvLyBTdGFydCBvZiBzcGVjdHJhbCBvciBwcmVkaWN0b3Igc2VsZWN0aW9uXG4gICAgdGhpcy5zcGVjdHJhbEVuZCA9IDA7IC8vIEVuZCBvZiBzcGVjdHJhbCBzZWxlY3Rpb25cbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcbn07XG5cblxuLyoqKiBQcm90b3R5cGUgTWV0aG9kcyAqKiovXG5cbmpwZWcubG9zc2xlc3MuU2NhbkhlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cbiAgICB2YXIgY291bnQgPSAwLCBsZW5ndGgsIGksIHRlbXA7XG5cbiAgICBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcblxuICAgIHRoaXMubnVtQ29tcCA9IGRhdGEuZ2V0OCgpO1xuICAgIGNvdW50Kz0xO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtQ29tcDsgaSs9MSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbaV0gPSBuZXcganBlZy5sb3NzbGVzcy5TY2FuQ29tcG9uZW50KCk7XG5cbiAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogc2NhbiBoZWFkZXIgZm9ybWF0IGVycm9yXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2ldLnNjYW5Db21wU2VsID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgIGNvdW50Kz0xO1xuXG4gICAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgICAgY291bnQrPTE7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2ldLmRjVGFiU2VsID0gKHRlbXAgPj4gNCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tpXS5hY1RhYlNlbCA9ICh0ZW1wICYgMHgwRik7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3Rpb24gPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCs9MTtcblxuICAgIHRoaXMuc3BlY3RyYWxFbmQgPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCs9MTtcblxuICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICB0aGlzLmFoID0gKHRlbXAgPj4gNCk7XG4gICAgdGhpcy5hbCA9ICh0ZW1wICYgMHgwRik7XG4gICAgY291bnQrPTE7XG5cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogc2NhbiBoZWFkZXIgZm9ybWF0IGVycm9yIFtjb3VudCE9TnNdXCIpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlNjYW5IZWFkZXI7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChDKSAyMDE1IE1pY2hhZWwgTWFydGluZXpcbiAqIENoYW5nZXM6IEFkZGVkIHN1cHBvcnQgZm9yIHNlbGVjdGlvbiB2YWx1ZXMgMi03LCBmaXhlZCBtaW5vciBidWdzICZcbiAqIHdhcm5pbmdzLCBzcGxpdCBpbnRvIG11bHRpcGxlIGNsYXNzIGZpbGVzLCBhbmQgZ2VuZXJhbCBjbGVhbiB1cC5cbiAqXG4gKiAwOC0yNS0yMDE1OiBIZWxtdXQgRGVyc2NoIGFncmVlZCB0byBhIGxpY2Vuc2UgY2hhbmdlIGZyb20gTEdQTCB0byBNSVQuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoQykgSGVsbXV0IERlcnNjaFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG52YXIganBlZyA9IGpwZWcgfHwge307XG5qcGVnLmxvc3NsZXNzID0ganBlZy5sb3NzbGVzcyB8fCB7fTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cbmpwZWcubG9zc2xlc3MuVXRpbHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzIHx8IHt9O1xuXG5cbi8qKiogU3RhdGljIG1ldGhvZHMgKioqL1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk2NjIyNS9ob3ctY2FuLWktY3JlYXRlLWEtdHdvLWRpbWVuc2lvbmFsLWFycmF5LWluLWphdmFzY3JpcHRcbmpwZWcubG9zc2xlc3MuVXRpbHMuY3JlYXRlQXJyYXkgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW5ndGggfHwgMCksXG4gICAgICAgIGkgPSBsZW5ndGg7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB3aGlsZShpLS0pIGFycltsZW5ndGgtMSAtIGldID0ganBlZy5sb3NzbGVzcy5VdGlscy5jcmVhdGVBcnJheS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NjM4OTAwL2phdmFzY3JpcHQtY3JjMzJcbmpwZWcubG9zc2xlc3MuVXRpbHMubWFrZUNSQ1RhYmxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYztcbiAgICB2YXIgY3JjVGFibGUgPSBbXTtcbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JjVGFibGVbbl0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gY3JjVGFibGU7XG59O1xuXG5qcGVnLmxvc3NsZXNzLlV0aWxzLmNyYzMyID0gZnVuY3Rpb24oZGF0YVZpZXcpIHtcbiAgICB2YXIgY3JjVGFibGUgPSBqcGVnLmxvc3NsZXNzLlV0aWxzLmNyY1RhYmxlIHx8IChqcGVnLmxvc3NsZXNzLlV0aWxzLmNyY1RhYmxlID0ganBlZy5sb3NzbGVzcy5VdGlscy5tYWtlQ1JDVGFibGUoKSk7XG4gICAgdmFyIGNyYyA9IDAgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVmlldy5ieXRlTGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gY3JjVGFibGVbKGNyYyBeIGRhdGFWaWV3LmdldFVpbnQ4KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSkgPj4+IDA7XG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqcGVnLmxvc3NsZXNzLlV0aWxzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGFicyggeCApXG4qXHRDb21wdXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGFic29sdXRlIHZhbHVlXG4qL1xuZnVuY3Rpb24gYWJzKCB4ICkge1xuXHRpZiAoIHggPCAwICkge1xuXHRcdHJldHVybiAteDtcblx0fVxuXHRpZiAoIHggPT09IDAgKSB7XG5cdFx0cmV0dXJuIDA7IC8vIGhhbmRsZSBuZWdhdGl2ZSB6ZXJvXG5cdH1cblx0cmV0dXJuIHg7XG59IC8vIGVuZCBGVU5DVElPTiBhYnMoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBhYnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmNlaWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGZsb29yID0gcmVxdWlyZSggJ21hdGgtZmxvb3InICk7XG5cblxuLy8gRElWMiAvL1xuXG4vKipcbiogRlVOQ1RJT046IGRpdjIoIHggKVxuKlx0Q29udmVydHMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyIHRvIGEgbGl0ZXJhbCBiaXQgcmVwcmVzZW50YXRpb24gdXNpbmcgdGhlIGRpdmlkZS1ieS0yIGFsZ29yaXRobS5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IHggLSBub25uZWdhdGl2ZSBpbnRlZ2VyXG4qIEByZXR1cm5zIHtTdHJpbmd9IGJpdCByZXByZXNlbnRhdGlvblxuKi9cbmZ1bmN0aW9uIGRpdjIoIHggKSB7XG5cdHZhciBzdHIgPSAnJztcblx0dmFyIHk7XG5cblx0Ly8gV2UgcmVwZWF0ZWRseSBkaXZpZGUgYnkgMiBhbmQgY2hlY2sgZm9yIGEgcmVtYWluZGVyLiBJZiBhIHJlbWFpbmRlciBleGlzdHMsIHRoZSBudW1iZXIgaXMgb2RkIGFuZCB3ZSBhZGQgYSAnMScgYml0Li4uXG5cdHdoaWxlICggeCA+IDAgKSB7XG5cdFx0eSA9IHggLyAyO1xuXHRcdHggPSBmbG9vciggeSApO1xuXHRcdGlmICggeSA9PT0geCApIHtcblx0XHRcdHN0ciA9ICcwJyArIHN0cjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RyID0gJzEnICsgc3RyO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufSAvLyBlbmQgRlVOQ1RJT04gZGl2MigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpdjI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIHBpbmYgPSByZXF1aXJlKCAnY29uc3QtcGluZi1mbG9hdDMyJyApO1xudmFyIG5pbmYgPSByZXF1aXJlKCAnY29uc3QtbmluZi1mbG9hdDMyJyApO1xudmFyIGFicyA9IHJlcXVpcmUoICdtYXRoLWFicycgKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoICdtYXRoLWZsb29yJyApO1xudmFyIHJwYWQgPSByZXF1aXJlKCAndXRpbHMtcmlnaHQtcGFkLXN0cmluZycgKTtcbnZhciBscGFkID0gcmVxdWlyZSggJ3V0aWxzLWxlZnQtcGFkLXN0cmluZycgKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCAndXRpbHMtcmVwZWF0LXN0cmluZycgKTtcbnZhciBkaXYyID0gcmVxdWlyZSggJy4vZGl2Mi5qcycgKTtcbnZhciBtdWx0MiA9IHJlcXVpcmUoICcuL211bHQyLmpzJyApO1xuXG5cbi8vIENPTlNUQU5UUyAvL1xuXG52YXIgQklBUyA9IDEyNzsgLy8gZXhwb25lbnQgYmlhcyA9PiAoMioqOCkvMiAtIDFcblxuXG4vLyBCSU5BUlkgU1RSSU5HIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogYmluYXJ5U3RyaW5nKCB4IClcbipcdFJldHVybnMgYSBzdHJpbmcgZ2l2aW5nIHRoZSBsaXRlcmFsIGJpdCByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuKlxuKiBAcGFyYW0ge051bWJlcn0geCAtIGlucHV0IHZhbHVlXG4qIEByZXR1cm5zIHtTdHJpbmd9IGJpdCByZXByZXNlbnRhdGlvblxuKi9cbmZ1bmN0aW9uIGJpbmFyeVN0cmluZyggeCApIHtcblx0dmFyIG5iaXRzO1xuXHR2YXIgc2lnbjtcblx0dmFyIHN0cjtcblx0dmFyIGV4cDtcblx0dmFyIG47XG5cdHZhciBmO1xuXHR2YXIgaTtcblxuXHQvLyBDaGVjayBmb3IgYSBuZWdhdGl2ZSB2YWx1ZSBvciBuZWdhdGl2ZSB6ZXJvLi4uXG5cdGlmICggeCA8IDAgfHwgMS94ID09PSBuaW5mICkge1xuXHRcdHNpZ24gPSAnMSc7XG5cdH0gZWxzZSB7XG5cdFx0c2lnbiA9ICcwJztcblx0fVxuXHQvLyBTcGVjaWFsIGNhc2U6ICstaW5maW5pdHlcblx0aWYgKCB4ID09PSBwaW5mIHx8IHggPT09IG5pbmYgKSB7XG5cdFx0Ly8gQmFzZWQgb24gSUVFRSA3NTQtMjAwOC4uLlxuXHRcdGV4cCA9IHJlcGVhdCggJzEnLCA4ICk7IC8vIGFsbCAxc1xuXHRcdHN0ciA9IHJlcGVhdCggJzAnLCAyMyApOyAvLyBhbGwgMHNcblx0XHRyZXR1cm4gc2lnbiArIGV4cCArIHN0cjtcblx0fVxuXHQvLyBTcGVjaWFsIGNhc2U6IE5hTlxuXHRpZiAoIHggIT09IHggKSB7XG5cdFx0Ly8gQmFzZWQgb24gSUVFRSA3NTQtMjAwOC4uLlxuXHRcdGV4cCA9IHJlcGVhdCggJzEnLCA4ICk7IC8vIGFsbCAxc1xuXHRcdHN0ciA9ICcxJyArIHJlcGVhdCggJzAnLCAyMiApOyAvLyBjYW4ndCBiZSBhbGwgMHNcblx0XHRyZXR1cm4gc2lnbiArIGV4cCArIHN0cjtcblx0fVxuXHQvLyBTcGVjaWFsIGNhc2U6ICstMFxuXHRpZiAoIHggPT09IDAgKSB7XG5cdFx0Ly8gQmFzZWQgb24gSUVFRSA3NTQtMjAwOC4uLlxuXHRcdGV4cCA9IHJlcGVhdCggJzAnLCA4ICk7IC8vIGFsbCAwc1xuXHRcdHN0ciA9IHJlcGVhdCggJzAnLCAyMyApOyAvLyBhbGwgMHNcblx0XHRyZXR1cm4gc2lnbiArIGV4cCArIHN0cjtcblx0fVxuXHR4ID0gYWJzKCB4ICk7XG5cblx0Ly8gSXNvbGF0ZSB0aGUgaW50ZWdlciBwYXJ0IChkaWdpdHMgYmVmb3JlIHRoZSBkZWNpbWFsKTpcblx0biA9IGZsb29yKCB4ICk7XG5cblx0Ly8gSXNvbGF0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0IChkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwpOlxuXHRmID0geCAtIG47XG5cblx0Ly8gQ29udmVydCB0aGUgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBwYXJ0cyB0byBiaXQgc3RyaW5nczpcblx0biA9IGRpdjIoIG4gKTtcblx0ZiA9IG11bHQyKCBmICk7XG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBleHBvbmVudCBuZWVkZWQgdG8gbm9ybWFsaXplIHRoZSBpbnRlZ2VyK2ZyYWN0aW9uYWwgcGFydHMuLi5cblx0aWYgKCBuICkge1xuXHRcdC8vIE1vdmUgdGhlIGRlY2ltYWwgYGRgIGRpZ2l0cyB0byB0aGUgbGVmdDpcblx0XHRleHAgPSBuLmxlbmd0aCAtIDE7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRmluZCB0aGUgZmlyc3QgJzEnIGJpdC4uLlxuXHRcdGZvciAoIGkgPSAwOyBpIDwgZi5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggZlsgaSBdID09PSAnMScgKSB7XG5cdFx0XHRcdG5iaXRzID0gaSArIDE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBNb3ZlIHRoZSBkZWNpbWFsIGBkYCBkaWdpdHMgdG8gdGhlIHJpZ2h0OlxuXHRcdGV4cCA9IC1uYml0cztcblx0fVxuXHQvLyBOb3JtYWxpemUgdGhlIGNvbWJpbmVkIGludGVnZXIrZnJhY3Rpb25hbCBzdHJpbmcuLi5cblx0c3RyID0gbiArIGY7XG5cdGlmICggZXhwIDwgMCApIHtcblx0XHQvLyBIYW5kbGUgc3Vibm9ybWFscy4uLlxuXHRcdGlmICggZXhwIDw9IC1CSUFTICkge1xuXHRcdFx0Ly8gQ2FwIHRoZSBudW1iZXIgb2YgYml0cyByZW1vdmVkOlxuXHRcdFx0bmJpdHMgPSBCSUFTIC0gMTtcblx0XHR9XG5cdFx0Ly8gUmVtb3ZlIGFsbCBsZWFkaW5nIHplcm9zIGFuZCB0aGUgZmlyc3QgJzEnIGZvciBub3JtYWwgdmFsdWVzLCBhbmQsIGZvciBzdWJub3JtYWxzLCByZW1vdmUgYXQgbW9zdCBCSUFTLTEgbGVhZGluZyBiaXRzOlxuXHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoIG5iaXRzICk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUmVtb3ZlIHRoZSBsZWFkaW5nICcxJyAoaW1wbGljaXQvaGlkZGVuIGJpdCk6XG5cdFx0c3RyID0gc3RyLnN1YnN0cmluZyggMSApO1xuXHR9XG5cdC8vIENvbnZlcnQgdGhlIGV4cG9uZW50IHRvIGEgYml0IHN0cmluZzpcblx0ZXhwID0gZGl2MiggZXhwICsgQklBUyApO1xuXHRleHAgPSBscGFkKCBleHAsIDgsICcwJyApO1xuXG5cdC8vIEZpbGwgaW4gYW55IHRyYWlsaW5nIHplcm9zIGFuZCBlbnN1cmUgd2UgaGF2ZSBvbmx5IDIzIGZyYWN0aW9uIGJpdHM6XG5cdHN0ciA9IHJwYWQoIHN0ciwgMjMsICcwJyApLnN1YnN0cmluZyggMCwgMjMgKTtcblxuXHQvLyBSZXR1cm4gYSBiaXQgcmVwcmVzZW50YXRpb246XG5cdHJldHVybiBzaWduICsgZXhwICsgc3RyO1xufSAvLyBlbmQgRlVOQ1RJT04gYmluYXJ5U3RyaW5nKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gYmluYXJ5U3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBWQVJJQUJMRVMgLy9cblxudmFyIE1BWF9JVEVSID0gMTQ5OyAvLyAxMjcrMjIgKHN1Ym5vcm1hbHMpXG52YXIgTUFYX0JJVFMgPSAyNDsgLy8gb25seSAyMyBiaXRzIGZvciBmcmFjdGlvblxuXG5cbi8vIE1VTFQyIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogbXVsdDIoIHggKVxuKlx0Q29udmVydHMgYSBmcmFjdGlvbiB0byBhIGxpdGVyYWwgYml0IHJlcHJlc2VudGF0aW9uIHVzaW5nIHRoZSBtdWx0aXBseS1ieS0yIGFsZ29yaXRobS5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IHggLSBudW1iZXIgbGVzcyB0aGFuIDFcbiogQHJldHVybnMge1N0cmluZ30gYml0IHJlcHJlc2VudGF0aW9uXG4qL1xuZnVuY3Rpb24gbXVsdDIoIHggKSB7XG5cdHZhciBzdHI7XG5cdHZhciB5O1xuXHR2YXIgaTtcblx0dmFyIGo7XG5cblx0c3RyID0gJyc7XG5cdGlmICggeCA9PT0gMCApIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cdGogPSBNQVhfSVRFUjtcblxuXHQvLyBFYWNoIHRpbWUgd2UgbXVsdGlwbHkgYnkgMiBhbmQgZmluZCBhIG9uZXMgZGlnaXQsIGFkZCBhICcxJzsgb3RoZXJ3aXNlLCBhZGQgYSAnMCcuLlxuXHRmb3IgKCBpID0gMDsgaSA8IE1BWF9JVEVSOyBpKysgKSB7XG5cdFx0eSA9IHggKiAyO1xuXHRcdGlmICggeSA+PSAxICkge1xuXHRcdFx0eCA9IHkgLSAxO1xuXHRcdFx0c3RyICs9ICcxJztcblx0XHRcdGlmICggaiA9PT0gTUFYX0lURVIgKSB7XG5cdFx0XHRcdGogPSBpOyAvLyBmaXJzdCAnMSdcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHk7XG5cdFx0XHRzdHIgKz0gJzAnO1xuXHRcdH1cblx0XHQvLyBTdG9wIHdoZW4gd2UgaGF2ZSBubyBtb3JlIGRlY2ltYWxzIHRvIHByb2Nlc3Mgb3IgaW4gdGhlIGV2ZW50IHdlIGZvdW5kIGEgZnJhY3Rpb24gd2hpY2ggY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIGEgZmluaXRlIG51bWJlciBvZiBiaXRzLi4uXG5cdFx0aWYgKCB5ID09PSAxIHx8IGktaiA+IE1BWF9CSVRTICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBtdWx0MigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHQyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mbG9vcjtcbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xuXG4vKipcbiAqIG5pZnRpXG4gKiBAdHlwZSB7Knx7fX1cbiAqL1xudmFyIG5pZnRpID0gbmlmdGkgfHwge307XG5uaWZ0aS5OSUZUSTEgPSBuaWZ0aS5OSUZUSTEgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi9uaWZ0aTEuanMnKSA6IG51bGwpO1xubmlmdGkuTklGVEkyID0gbmlmdGkuTklGVEkyIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vbmlmdGkyLmpzJykgOiBudWxsKTtcbm5pZnRpLlV0aWxzID0gbmlmdGkuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlsaXRpZXMuanMnKSA6IG51bGwpO1xuXG52YXIgcGFrbyA9IHBha28gfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgncGFrbycpIDogbnVsbCk7XG5cblxuXG4vKioqIFN0YXRpYyBNZXRob2RzICoqKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIHJlcHJlc2VudHMgYSBOSUZUSS0xIGhlYWRlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5pc05JRlRJMSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGJ1ZiwgbWFnMSwgbWFnMiwgbWFnMztcblxuICAgIGJ1ZiA9IG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgICBtYWcxID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJfTE9DQVRJT04pO1xuICAgIG1hZzIgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUl9MT0NBVElPTiArIDEpO1xuICAgIG1hZzMgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUl9MT0NBVElPTiArIDIpO1xuXG4gICAgcmV0dXJuICEhKChtYWcxID09PSBuaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSWzBdKSAmJiAobWFnMiA9PT0gbmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUlsxXSkgJiZcbiAgICAgICAgKG1hZzMgPT09IG5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVJbMl0pKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkYXRhIHJlcHJlc2VudHMgYSBOSUZUSS0yIGhlYWRlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5uaWZ0aS5pc05JRlRJMiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGJ1ZiwgbWFnMSwgbWFnMiwgbWFnMztcblxuICAgIGJ1ZiA9IG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgICBtYWcxID0gYnVmLmdldFVpbnQ4KG5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVJfTE9DQVRJT04pO1xuICAgIG1hZzIgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUl9MT0NBVElPTiArIDEpO1xuICAgIG1hZzMgPSBidWYuZ2V0VWludDgobmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUl9MT0NBVElPTiArIDIpO1xuXG4gICAgcmV0dXJuICEhKChtYWcxID09PSBuaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSWzBdKSAmJiAobWFnMiA9PT0gbmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUlsxXSkgJiZcbiAgICAobWFnMyA9PT0gbmlmdGkuTklGVEkyLk1BR0lDX05VTUJFUlsyXSkpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0YSByZXByZXNlbnRzIGEgTklGVEkgaGVhZGVyLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmlzTklGVEkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAobmlmdGkuaXNOSUZUSTEoZGF0YSkgfHwgbmlmdGkuaXNOSUZUSTIoZGF0YSkpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZGF0YSBpcyBHWklQIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubmlmdGkuaXNDb21wcmVzc2VkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYnVmLCBtYWdpY0Nvb2tpZTEsIG1hZ2ljQ29va2llMjtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBEYXRhVmlldyhkYXRhKTtcblxuICAgICAgICBtYWdpY0Nvb2tpZTEgPSBidWYuZ2V0VWludDgoMCk7XG4gICAgICAgIG1hZ2ljQ29va2llMiA9IGJ1Zi5nZXRVaW50OCgxKTtcblxuICAgICAgICBpZiAobWFnaWNDb29raWUxID09PSBuaWZ0aS5VdGlscy5HVU5aSVBfTUFHSUNfQ09PS0lFMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFnaWNDb29raWUyID09PSBuaWZ0aS5VdGlscy5HVU5aSVBfTUFHSUNfQ09PS0lFMikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGRlY29tcHJlc3NlZCBkYXRhLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5uaWZ0aS5kZWNvbXByZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gcGFrby5pbmZsYXRlKGRhdGEpLmJ1ZmZlcjtcbn07XG5cblxuXG4vKipcbiAqIFJlYWRzIGFuZCByZXR1cm5zIHRoZSBoZWFkZXIgb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ8bnVsbH1cbiAqL1xubmlmdGkucmVhZEhlYWRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGhlYWRlciA9IG51bGw7XG5cbiAgICBpZiAobmlmdGkuaXNDb21wcmVzc2VkKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBuaWZ0aS5kZWNvbXByZXNzKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChuaWZ0aS5pc05JRlRJMShkYXRhKSkge1xuICAgICAgICBoZWFkZXIgPSBuZXcgbmlmdGkuTklGVEkxKCk7XG4gICAgfSBlbHNlIGlmIChuaWZ0aS5pc05JRlRJMihkYXRhKSkge1xuICAgICAgICBoZWFkZXIgPSBuZXcgbmlmdGkuTklGVEkyKCk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgICBoZWFkZXIucmVhZEhlYWRlcihkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhhdCBmaWxlIGRvZXMgbm90IGFwcGVhciB0byBiZSBOSUZUSSFcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcjtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGhlYWRlciBjb250YWlucyBhbiBleHRlbnNpb24uXG4gKiBAcGFyYW0ge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ9IGhlYWRlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm5pZnRpLmhhc0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICByZXR1cm4gKGhlYWRlci5leHRlbnNpb25GbGFnWzBdICE9IDApO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW1hZ2UgZGF0YS5cbiAqIEBwYXJhbSB7bmlmdGkuTklGVEkxfG5pZnRpLk5JRlRJMn0gaGVhZGVyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbm5pZnRpLnJlYWRJbWFnZSA9IGZ1bmN0aW9uIChoZWFkZXIsIGRhdGEpIHtcbiAgICB2YXIgaW1hZ2VPZmZzZXQgPSBoZWFkZXIudm94X29mZnNldCxcbiAgICAgICAgdGltZURpbSA9IDEsXG4gICAgICAgIHN0YXREaW0gPSAxO1xuXG4gICAgaWYgKGhlYWRlci5kaW1zWzRdKSB7XG4gICAgICAgIHRpbWVEaW0gPSBoZWFkZXIuZGltc1s0XTtcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLmRpbXNbNV0pIHtcbiAgICAgICAgc3RhdERpbSA9IGhlYWRlci5kaW1zWzVdO1xuICAgIH1cblxuICAgIHZhciBpbWFnZVNpemUgPSBoZWFkZXIuZGltc1sxXSAqIGhlYWRlci5kaW1zWzJdICogaGVhZGVyLmRpbXNbM10gKiB0aW1lRGltICogc3RhdERpbSAqIChoZWFkZXIubnVtQml0c1BlclZveGVsIC8gOCk7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoaW1hZ2VPZmZzZXQsIGltYWdlT2Zmc2V0ICsgaW1hZ2VTaXplKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBkYXRhIChpbmNsdWRpbmcgZXh0ZW5zaW9uIGhlYWRlcikuXG4gKiBAcGFyYW0ge25pZnRpLk5JRlRJMXxuaWZ0aS5OSUZUSTJ9IGhlYWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5uaWZ0aS5yZWFkRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGhlYWRlciwgZGF0YSkge1xuICAgIHZhciBsb2MgPSBoZWFkZXIuZ2V0RXh0ZW5zaW9uTG9jYXRpb24oKSxcbiAgICAgICAgc2l6ZSA9IGhlYWRlci5leHRlbnNpb25TaXplO1xuXG4gICAgcmV0dXJuIGRhdGEuc2xpY2UobG9jLCBsb2MgKyBzaXplKTtcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBkYXRhLlxuICogQHBhcmFtIHtuaWZ0aS5OSUZUSTF8bmlmdGkuTklGVEkyfSBoZWFkZXJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAqL1xubmlmdGkucmVhZEV4dGVuc2lvbkRhdGEgPSBmdW5jdGlvbiAoaGVhZGVyLCBkYXRhKSB7XG4gICAgdmFyIGxvYyA9IGhlYWRlci5nZXRFeHRlbnNpb25Mb2NhdGlvbigpLFxuICAgICAgICBzaXplID0gaGVhZGVyLmV4dGVuc2lvblNpemU7XG5cbiAgICByZXR1cm4gZGF0YS5zbGljZShsb2MgKyA4LCBsb2MgKyBzaXplIC0gOCk7XG59O1xuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuaWZ0aTtcbn1cbiIsIlxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiogSW1wb3J0cyAqKiovXG5cbnZhciBuaWZ0aSA9IG5pZnRpIHx8IHt9O1xubmlmdGkuVXRpbHMgPSBuaWZ0aS5VdGlscyB8fCAoKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykgPyByZXF1aXJlKCcuL3V0aWxpdGllcy5qcycpIDogbnVsbCk7XG5cblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cblxuLyoqXG4gKiBUaGUgTklGVEkxIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpdHRsZUVuZGlhblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpbV9pbmZvXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBkaW1zIC0gaW1hZ2UgZGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wMVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wM1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YXR5cGVDb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtQml0c1BlclZveGVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2Vfc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9lbmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBwaXhEaW1zIC0gdm94ZWwgZGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHZveF9vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY2xfc2xvcGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY2xfaW50ZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4eXp0X3VuaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21heFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbF9taW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9kdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvZmZzZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF1eF9maWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW50ZW50X25hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2Zvcm1fY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fYlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5feFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5feVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5felxuICogQHByb3BlcnR5IHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBhZmZpbmVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYWdpY1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0hEUiAtIGlmIGhkci9pbWcgZm9ybWF0XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBleHRlbnNpb25GbGFnXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXh0ZW5zaW9uU2l6ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGV4dGVuc2lvbkNvZGVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xubmlmdGkuTklGVEkxID0gbmlmdGkuTklGVEkxIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xuICAgIHRoaXMuZGltX2luZm8gPSAwO1xuICAgIHRoaXMuZGltcyA9IFtdO1xuICAgIHRoaXMuaW50ZW50X3AxID0gMDtcbiAgICB0aGlzLmludGVudF9wMiA9IDA7XG4gICAgdGhpcy5pbnRlbnRfcDMgPSAwO1xuICAgIHRoaXMuaW50ZW50X2NvZGUgPSAwO1xuICAgIHRoaXMuZGF0YXR5cGVDb2RlID0gMDtcbiAgICB0aGlzLm51bUJpdHNQZXJWb3hlbCA9IDA7XG4gICAgdGhpcy5zbGljZV9zdGFydCA9IDA7XG4gICAgdGhpcy5zbGljZV9lbmQgPSAwO1xuICAgIHRoaXMuc2xpY2VfY29kZSA9IDA7XG4gICAgdGhpcy5waXhEaW1zID0gW107XG4gICAgdGhpcy52b3hfb2Zmc2V0ID0gMDtcbiAgICB0aGlzLnNjbF9zbG9wZSA9IDE7XG4gICAgdGhpcy5zY2xfaW50ZXIgPSAwO1xuICAgIHRoaXMueHl6dF91bml0cyA9IDA7XG4gICAgdGhpcy5jYWxfbWF4ID0gMDtcbiAgICB0aGlzLmNhbF9taW4gPSAwO1xuICAgIHRoaXMuc2xpY2VfZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG9mZnNldCA9IDA7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiXCI7XG4gICAgdGhpcy5hdXhfZmlsZSA9IFwiXCI7XG4gICAgdGhpcy5pbnRlbnRfbmFtZSA9IFwiXCI7XG4gICAgdGhpcy5xZm9ybV9jb2RlID0gMDtcbiAgICB0aGlzLnNmb3JtX2NvZGUgPSAwO1xuICAgIHRoaXMucXVhdGVybl9iID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fYyA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2QgPSAwO1xuICAgIHRoaXMucW9mZnNldF94ID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeSA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3ogPSAwO1xuICAgIHRoaXMuYWZmaW5lID0gW1sxLCAwLCAwLCAwXSwgWzAsIDEsIDAsIDBdLCBbMCwgMCwgMSwgMF0sIFswLCAwLCAwLCAxXV07XG4gICAgdGhpcy5tYWdpYyA9IDA7XG4gICAgdGhpcy5pc0hEUiA9IGZhbHNlO1xuICAgIHRoaXMuZXh0ZW5zaW9uRmxhZyA9IFswLCAwLCAwLCAwXTtcbiAgICB0aGlzLmV4dGVuc2lvblNpemUgPSAwO1xuICAgIHRoaXMuZXh0ZW5zaW9uQ29kZSA9IDA7XG59O1xuXG5cblxuLyoqKiBTdGF0aWMgUHNldWRvLWNvbnN0YW50cyAqKiovXG5cbi8vIGRhdGF0eXBlIGNvZGVzXG5uaWZ0aS5OSUZUSTEuVFlQRV9OT05FICAgICAgICAgICAgPSAwO1xubmlmdGkuTklGVEkxLlRZUEVfQklOQVJZICAgICAgICAgID0gMTtcbm5pZnRpLk5JRlRJMS5UWVBFX1VJTlQ4ICAgICAgICAgICA9IDI7XG5uaWZ0aS5OSUZUSTEuVFlQRV9JTlQxNiAgICAgICAgICAgPSA0O1xubmlmdGkuTklGVEkxLlRZUEVfSU5UMzIgICAgICAgICAgID0gODtcbm5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUMzIgICAgICAgID0gMTY7XG5uaWZ0aS5OSUZUSTEuVFlQRV9DT01QTEVYNjQgICAgICA9IDMyO1xubmlmdGkuTklGVEkxLlRZUEVfRkxPQVQ2NCAgICAgICAgPSA2NDtcbm5pZnRpLk5JRlRJMS5UWVBFX1JHQjI0ICAgICAgICAgPSAxMjg7XG5uaWZ0aS5OSUZUSTEuVFlQRV9JTlQ4ICAgICAgICAgID0gMjU2O1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDE2ICAgICAgICA9IDUxMjtcbm5pZnRpLk5JRlRJMS5UWVBFX1VJTlQzMiAgICAgICAgPSA3Njg7XG5uaWZ0aS5OSUZUSTEuVFlQRV9JTlQ2NCAgICAgICAgPSAxMDI0O1xubmlmdGkuTklGVEkxLlRZUEVfVUlOVDY0ICAgICAgID0gMTI4MDtcbm5pZnRpLk5JRlRJMS5UWVBFX0ZMT0FUMTI4ICAgICA9IDE1MzY7XG5uaWZ0aS5OSUZUSTEuVFlQRV9DT01QTEVYMTI4ICAgPSAxNzkyO1xubmlmdGkuTklGVEkxLlRZUEVfQ09NUExFWDI1NiAgID0gMjA0ODtcblxuLy8gdHJhbnNmb3JtIGNvZGVzXG5uaWZ0aS5OSUZUSTEuWEZPUk1fVU5LTk9XTiAgICAgICAgPSAwO1xubmlmdGkuTklGVEkxLlhGT1JNX1NDQU5ORVJfQU5BVCAgID0gMTtcbm5pZnRpLk5JRlRJMS5YRk9STV9BTElHTkVEX0FOQVQgICA9IDI7XG5uaWZ0aS5OSUZUSTEuWEZPUk1fVEFMQUlSQUNIICAgICAgPSAzO1xubmlmdGkuTklGVEkxLlhGT1JNX01OSV8xNTIgICAgICAgID0gNDtcblxuLy8gdW5pdCBjb2Rlc1xubmlmdGkuTklGVEkxLlNQQVRJQUxfVU5JVFNfTUFTSyA9IDB4MDc7XG5uaWZ0aS5OSUZUSTEuVEVNUE9SQUxfVU5JVFNfTUFTSyA9IDB4Mzg7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfVU5LTk9XTiAgICAgICAgPSAwO1xubmlmdGkuTklGVEkxLlVOSVRTX01FVEVSICAgICAgICAgID0gMTtcbm5pZnRpLk5JRlRJMS5VTklUU19NTSAgICAgICAgICAgICA9IDI7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfTUlDUk9OICAgICAgICAgPSAzO1xubmlmdGkuTklGVEkxLlVOSVRTX1NFQyAgICAgICAgICAgID0gODtcbm5pZnRpLk5JRlRJMS5VTklUU19NU0VDICAgICAgICAgID0gMTY7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfVVNFQyAgICAgICAgICA9IDI0O1xubmlmdGkuTklGVEkxLlVOSVRTX0haICAgICAgICAgICAgPSAzMjtcbm5pZnRpLk5JRlRJMS5VTklUU19QUE0gICAgICAgICAgID0gNDA7XG5uaWZ0aS5OSUZUSTEuVU5JVFNfUkFEUyAgICAgICAgICA9IDQ4O1xuXG4vLyBuaWZ0aTEgY29kZXNcbm5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUgPSAzNDg7XG5uaWZ0aS5OSUZUSTEuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OID0gMzQ0O1xubmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUiA9IFsweDZFLCAweDJCLCAweDMxXTsgIC8vIG4rMSAoLm5paSlcbm5pZnRpLk5JRlRJMS5NQUdJQ19OVU1CRVIyID0gWzB4NkUsIDB4NjksIDB4MzFdOyAgLy8gbmkxICguaGRyLy5pbWcpXG5uaWZ0aS5OSUZUSTEuRVhURU5TSU9OX0hFQURFUl9TSVpFID0gODtcblxuXG4vKioqIFByb3RvdHlwZSBNZXRob2RzICoqKi9cblxuLyoqXG4gKiBSZWFkcyB0aGUgaGVhZGVyIGRhdGEuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUucmVhZEhlYWRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHJhd0RhdGEgPSBuZXcgRGF0YVZpZXcoZGF0YSksXG4gICAgICAgIG1hZ2ljQ29va2llVmFsID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMCwgdGhpcy5saXR0bGVFbmRpYW4pLFxuICAgICAgICBjdHIsXG4gICAgICAgIGN0ck91dCxcbiAgICAgICAgY3RySW4sXG4gICAgICAgIGluZGV4O1xuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFKSB7ICAvLyB0cnkgYXMgbGl0dGxlIGVuZGlhblxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgICAgIG1hZ2ljQ29va2llVmFsID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChtYWdpY0Nvb2tpZVZhbCAhPT0gbmlmdGkuTklGVEkxLk1BR0lDX0NPT0tJRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIE5JRlRJIGZpbGUhXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZGltX2luZm8gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzkpO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBpbmRleCA9IDQwICsgKGN0ciAqIDIpO1xuICAgICAgICB0aGlzLmRpbXNbY3RyXSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVudF9wMSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgNTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9wMiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgNjAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9wMyA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgNjQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCA2OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDcwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5udW1CaXRzUGVyVm94ZWwgPSBuaWZ0aS5VdGlscy5nZXRTaG9ydEF0KHJhd0RhdGEsIDcyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX3N0YXJ0ID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCA3NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBpbmRleCA9IDc2ICsgKGN0ciAqIDQpO1xuICAgICAgICB0aGlzLnBpeERpbXNbY3RyXSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICB0aGlzLnZveF9vZmZzZXQgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEwOCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zY2xfc2xvcGUgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDExMiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2NsX2ludGVyID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2xpY2VfZW5kID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAxMjAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnNsaWNlX2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMTIyKTtcblxuICAgIHRoaXMueHl6dF91bml0cyA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAxMjMpO1xuXG4gICAgdGhpcy5jYWxfbWF4ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMjQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmNhbF9taW4gPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDEyOCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9kdXJhdGlvbiA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMTMyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy50b2Zmc2V0ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAxMzYsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAxNDgsIDIyOCk7XG4gICAgdGhpcy5hdXhfZmlsZSA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDIyOCwgMjUyKTtcblxuICAgIHRoaXMucWZvcm1fY29kZSA9IG5pZnRpLlV0aWxzLmdldFNob3J0QXQocmF3RGF0YSwgMjUyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zZm9ybV9jb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAyNTQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMucXVhdGVybl9iID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNTYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnF1YXRlcm5fYyA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjYwLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xdWF0ZXJuX2QgPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI2NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF94ID0gbmlmdGkuVXRpbHMuZ2V0RmxvYXRBdChyYXdEYXRhLCAyNjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgMjcyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ogPSBuaWZ0aS5VdGlscy5nZXRGbG9hdEF0KHJhd0RhdGEsIDI3NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgZm9yIChjdHJPdXQgPSAwOyBjdHJPdXQgPCAzOyBjdHJPdXQgKz0gMSkge1xuICAgICAgICBmb3IgKGN0ckluID0gMDsgY3RySW4gPCA0OyBjdHJJbiArPSAxKSB7XG4gICAgICAgICAgICBpbmRleCA9IDI4MCArICgoKGN0ck91dCAqIDQpICsgY3RySW4pICogNCk7XG4gICAgICAgICAgICB0aGlzLmFmZmluZVtjdHJPdXRdW2N0ckluXSA9IG5pZnRpLlV0aWxzLmdldEZsb2F0QXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZmaW5lWzNdWzBdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsxXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bMl0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzNdID0gMTtcblxuICAgIHRoaXMuaW50ZW50X25hbWUgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAzMjgsIDM0NCk7XG4gICAgdGhpcy5tYWdpYyA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDM0NCwgMzQ4KTtcblxuICAgIHRoaXMuaXNIRFIgPSAodGhpcy5tYWdpYyA9PT0gbmlmdGkuTklGVEkxLk1BR0lDX05VTUJFUjIpO1xuXG4gICAgaWYgKHJhd0RhdGEuYnl0ZUxlbmd0aCA+IG5pZnRpLk5JRlRJMS5NQUdJQ19DT09LSUUpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzBdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM0OCk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1sxXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCAzNDggKyAxKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzJdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDM0OCArIDIpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbM10gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgMzQ4ICsgMyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9uRmxhZ1swXSkge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25TaXplID0gdGhpcy5nZXRFeHRlbnNpb25TaXplKHJhd0RhdGEpO1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25Db2RlID0gdGhpcy5nZXRFeHRlbnNpb25Db2RlKHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIG9mIGhlYWRlciBmaWVsZHMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLnRvRm9ybWF0dGVkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbXQgPSBuaWZ0aS5VdGlscy5mb3JtYXROdW1iZXIsXG4gICAgICAgIHN0cmluZyA9IFwiXCI7XG5cbiAgICBzdHJpbmcgKz0gKFwiRGltIEluZm8gPSBcIiArIHRoaXMuZGltX2luZm8gKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbWFnZSBEaW1lbnNpb25zICgxLTgpOiBcIiArXG4gICAgICAgIHRoaXMuZGltc1swXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1sxXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1syXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1szXSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s0XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s1XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s2XSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuZGltc1s3XSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBQYXJhbWV0ZXJzICgxLTMpOiBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AxICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDIgKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMykgKyBcIlxcblwiO1xuXG4gICAgc3RyaW5nICs9IChcIkludGVudCBDb2RlID0gXCIgKyB0aGlzLmludGVudF9jb2RlICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRhdGF0eXBlID0gXCIgKyB0aGlzLmRhdGF0eXBlQ29kZSArICBcIiAoXCIgKyB0aGlzLmdldERhdGF0eXBlQ29kZVN0cmluZyh0aGlzLmRhdGF0eXBlQ29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkJpdHMgUGVyIFZveGVsID0gXCIgKyB0aGlzLm51bUJpdHNQZXJWb3hlbCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTbGljZSBTdGFydCA9IFwiICsgdGhpcy5zbGljZV9zdGFydCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJWb3hlbCBEaW1lbnNpb25zICgxLTgpOiBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1sxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzJdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbM10pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s0XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzVdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s3XSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbWFnZSBPZmZzZXQgPSBcIiArIHRoaXMudm94X29mZnNldCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEYXRhIFNjYWxlOiAgU2xvcGUgPSBcIiArIGZtdCh0aGlzLnNjbF9zbG9wZSkgKyBcIiAgSW50ZXJjZXB0ID0gXCIgKyBmbXQodGhpcy5zY2xfaW50ZXIpICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIEVuZCA9IFwiICsgdGhpcy5zbGljZV9lbmQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgQ29kZSA9IFwiICsgdGhpcy5zbGljZV9jb2RlICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlVuaXRzIENvZGUgPSBcIiArIHRoaXMueHl6dF91bml0cyArIFwiIChcIiArIHRoaXMuZ2V0VW5pdHNDb2RlU3RyaW5nKG5pZnRpLk5JRlRJMS5TUEFUSUFMX1VOSVRTX01BU0sgJiB0aGlzLnh5enRfdW5pdHMpICsgXCIsIFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlRFTVBPUkFMX1VOSVRTX01BU0sgJiB0aGlzLnh5enRfdW5pdHMpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEaXNwbGF5IFJhbmdlOiAgTWF4ID0gXCIgKyBmbXQodGhpcy5jYWxfbWF4KSArIFwiICBNaW4gPSBcIiArIGZtdCh0aGlzLmNhbF9taW4pICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlNsaWNlIER1cmF0aW9uID0gXCIgKyB0aGlzLnNsaWNlX2R1cmF0aW9uICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlRpbWUgQXhpcyBTaGlmdCA9IFwiICsgdGhpcy50b2Zmc2V0ICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRlc2NyaXB0aW9uOiBcXFwiXCIgKyB0aGlzLmRlc2NyaXB0aW9uICsgXCJcXFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJBdXhpbGlhcnkgRmlsZTogXFxcIlwiICsgdGhpcy5hdXhfZmlsZSArIFwiXFxcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUS1Gb3JtIENvZGUgPSBcIiArIHRoaXMucWZvcm1fY29kZSArIFwiIChcIiArIHRoaXMuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyh0aGlzLnFmb3JtX2NvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gQ29kZSA9IFwiICsgdGhpcy5zZm9ybV9jb2RlICsgXCIgKFwiICsgdGhpcy5nZXRUcmFuc2Zvcm1Db2RlU3RyaW5nKHRoaXMuc2Zvcm1fY29kZSkgKyBcIilcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlF1YXRlcm5pb24gUGFyYW1ldGVyczogIFwiICtcbiAgICAgICAgXCJiID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2IpICsgXCIgIFwiICtcbiAgICAgICAgXCJjID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2MpICsgXCIgIFwiICtcbiAgICAgICAgXCJkID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2QpICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUXVhdGVybmlvbiBPZmZzZXRzOiAgXCIgK1xuICAgICAgICBcInggPSBcIiArIHRoaXMucW9mZnNldF94ICsgXCIgIFwiICtcbiAgICAgICAgXCJ5ID0gXCIgKyB0aGlzLnFvZmZzZXRfeSArIFwiICBcIiArXG4gICAgICAgIFwieiA9IFwiICsgdGhpcy5xb2Zmc2V0X3ogKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBYOiBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVswXVswXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMF1bMV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzBdWzJdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVswXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBZOiBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsxXVswXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMV1bMV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzFdWzJdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsxXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBaOiBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsyXVswXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5hZmZpbmVbMl1bMV0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMuYWZmaW5lWzJdWzJdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLmFmZmluZVsyXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgTmFtZTogXFxcIlwiICsgdGhpcy5pbnRlbnRfbmFtZSArIFwiXFxcIlxcblwiKTtcblxuICAgIGlmICh0aGlzLmV4dGVuc2lvbkZsYWdbMF0pIHtcbiAgICAgICAgc3RyaW5nICs9IChcIkV4dGVuc2lvbjogU2l6ZSA9IFwiICsgdGhpcy5leHRlbnNpb25TaXplICsgXCIgIENvZGUgPSBcIiArIHRoaXMuZXh0ZW5zaW9uQ29kZSArIFwiXFxuXCIpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIG9mIGRhdGF0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDgpIHtcbiAgICAgICAgcmV0dXJuIFwiMS1CeXRlIFVuc2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX0lOVDE2KSB7XG4gICAgICAgIHJldHVybiBcIjItQnl0ZSBTaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfSU5UMzIpIHtcbiAgICAgICAgcmV0dXJuIFwiNC1CeXRlIFNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9GTE9BVDMyKSB7XG4gICAgICAgIHJldHVybiBcIjQtQnl0ZSBGbG9hdFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfRkxPQVQ2NCkge1xuICAgICAgICByZXR1cm4gXCI4LUJ5dGUgRmxvYXRcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX1JHQjI0KSB7XG4gICAgICAgIHJldHVybiBcIlJHQlwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfSU5UOCkge1xuICAgICAgICByZXR1cm4gXCIxLUJ5dGUgU2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX1VJTlQxNikge1xuICAgICAgICByZXR1cm4gXCIyLUJ5dGUgVW5zaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlRZUEVfVUlOVDMyKSB7XG4gICAgICAgIHJldHVybiBcIjQtQnl0ZSBVbnNpZ25lZCBJbnRlZ2VyXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVFlQRV9JTlQ2NCkge1xuICAgICAgICByZXR1cm4gXCI4LUJ5dGUgU2lnbmVkIEludGVnZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5UWVBFX1VJTlQ2NCkge1xuICAgICAgICByZXR1cm4gXCI4LUJ5dGUgVW5zaWduZWQgSW50ZWdlclwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlVua25vd25cIjtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiB0cmFuc2Zvcm0gdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuWEZPUk1fU0NBTk5FUl9BTkFUKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uZXJcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5YRk9STV9BTElHTkVEX0FOQVQpIHtcbiAgICAgICAgcmV0dXJuIFwiQWxpZ25lZFwiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlhGT1JNX1RBTEFJUkFDSCkge1xuICAgICAgICByZXR1cm4gXCJUYWxhaXJhY2hcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5YRk9STV9NTklfMTUyKSB7XG4gICAgICAgIHJldHVybiBcIk1OSVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlVua25vd25cIjtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiBzcGF0aWFsIGFuZCB0ZW1wb3JhbCB1bml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFVuaXRzQ29kZVN0cmluZyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19NRVRFUikge1xuICAgICAgICByZXR1cm4gXCJNZXRlcnNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19NTSkge1xuICAgICAgICByZXR1cm4gXCJNaWxsaW1ldGVyc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX01JQ1JPTikge1xuICAgICAgICByZXR1cm4gXCJNaWNyb25zXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfU0VDKSB7XG4gICAgICAgIHJldHVybiBcIlNlY29uZHNcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19NU0VDKSB7XG4gICAgICAgIHJldHVybiBcIk1pbGxpc2Vjb25kc1wiO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gbmlmdGkuTklGVEkxLlVOSVRTX1VTRUMpIHtcbiAgICAgICAgcmV0dXJuIFwiTWljcm9zZWNvbmRzXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfSFopIHtcbiAgICAgICAgcmV0dXJuIFwiSHpcIjtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IG5pZnRpLk5JRlRJMS5VTklUU19QUE0pIHtcbiAgICAgICAgcmV0dXJuIFwiUFBNXCI7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBuaWZ0aS5OSUZUSTEuVU5JVFNfUkFEUykge1xuICAgICAgICByZXR1cm4gXCJSYWRzXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBxZm9ybSBtYXRyaXguXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRRZm9ybU1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0TmlmdGlRRm9ybVRvTmlmdGlTRm9ybSh0aGlzLnF1YXRlcm5fYiwgdGhpcy5xdWF0ZXJuX2MsIHRoaXMucXVhdGVybl9kLCB0aGlzLnFvZmZzZXRfeCxcbiAgICAgICAgdGhpcy5xb2Zmc2V0X3ksIHRoaXMucW9mZnNldF96LCB0aGlzLnBpeERpbXNbMV0sIHRoaXMucGl4RGltc1syXSwgdGhpcy5waXhEaW1zWzNdLCB0aGlzLnBpeERpbXNbMF0pO1xufTtcblxuXG5cbi8qKlxuICogQ29udmVydHMgcWZvcm0gdG8gYW4gYWZmaW5lLiAgKFNlZSBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uYylcbiAqIEBwYXJhbSB7bnVtYmVyfSBxYlxuICogQHBhcmFtIHtudW1iZXJ9IHFjXG4gKiBAcGFyYW0ge251bWJlcn0gcWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBxeFxuICogQHBhcmFtIHtudW1iZXJ9IHF5XG4gKiBAcGFyYW0ge251bWJlcn0gcXpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gKiBAcGFyYW0ge251bWJlcn0gZHpcbiAqIEBwYXJhbSB7bnVtYmVyfSBxZmFjXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlRRm9ybVRvTmlmdGlTRm9ybSA9IGZ1bmN0aW9uIChxYiwgcWMsIHFkLCBxeCwgcXksIHF6LCBkeCwgZHksIGR6LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcWZhYykge1xuICAgIHZhciBSID0gW1swLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwXV0sXG4gICAgICAgIGEsXG4gICAgICAgIGIgPSBxYixcbiAgICAgICAgYyA9IHFjLFxuICAgICAgICBkID0gcWQsXG4gICAgICAgIHhkLFxuICAgICAgICB5ZCxcbiAgICAgICAgemQ7XG5cbiAgICAvLyBsYXN0IHJvdyBpcyBhbHdheXMgWyAwIDAgMCAxIF1cbiAgICBSWzNdWzBdID0gUlszXVsxXSA9IFJbM11bMl0gPSAwLjA7XG4gICAgUlszXVszXSA9IDEuMDtcblxuICAgIC8vIGNvbXB1dGUgYSBwYXJhbWV0ZXIgZnJvbSBiLGMsZFxuICAgIGEgPSAxLjAgLSAoYiAqIGIgKyBjICogYyArIGQgKiBkKTtcbiAgICBpZiAoYSA8IDAuMDAwMDAwMSkgeyAgICAgICAgICAgICAgICAgICAvKiBzcGVjaWFsIGNhc2UgKi9cblxuICAgICAgICBhID0gMS4wIC8gTWF0aC5zcXJ0KGIgKiBiICsgYyAqIGMgKyBkICogZCk7XG4gICAgICAgIGIgKj0gYTtcbiAgICAgICAgYyAqPSBhO1xuICAgICAgICBkICo9IGE7ICAgICAgICAvKiBub3JtYWxpemUgKGIsYyxkKSB2ZWN0b3IgKi9cbiAgICAgICAgYSA9IDAuMDsgICAgICAgICAgICAgICAgICAgICAgICAvKiBhID0gMCA9PT4gMTgwIGRlZ3JlZSByb3RhdGlvbiAqL1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYSA9IE1hdGguc3FydChhKTsgICAgICAgICAgICAgICAgICAgICAvKiBhbmdsZSA9IDIqYXJjY29zKGEpICovXG4gICAgfVxuXG4gICAgLy8gbG9hZCByb3RhdGlvbiBtYXRyaXgsIGluY2x1ZGluZyBzY2FsaW5nIGZhY3RvcnMgZm9yIHZveGVsIHNpemVzXG4gICAgeGQgPSAoZHggPiAwLjApID8gZHggOiAxLjA7ICAgICAgIC8qIG1ha2Ugc3VyZSBhcmUgcG9zaXRpdmUgKi9cbiAgICB5ZCA9IChkeSA+IDAuMCkgPyBkeSA6IDEuMDtcbiAgICB6ZCA9IChkeiA+IDAuMCkgPyBkeiA6IDEuMDtcblxuICAgIGlmIChxZmFjIDwgMC4wKSB7XG4gICAgICAgIHpkID0gLXpkOyAgICAgICAgIC8qIGxlZnQgaGFuZGVkbmVzcz8gKi9cbiAgICB9XG5cbiAgICBSWzBdWzBdID0gICAgICAgKGEgKiBhICsgYiAqIGIgLSBjICogYyAtIGQgKiBkKSAqIHhkO1xuICAgIFJbMF1bMV0gPSAyLjAgKiAoYiAqIGMgLSBhICogZCkgKiB5ZDtcbiAgICBSWzBdWzJdID0gMi4wICogKGIgKiBkICsgYSAqIGMpICogemQ7XG4gICAgUlsxXVswXSA9IDIuMCAqIChiICogYyArIGEgKiBkKSAqIHhkO1xuICAgIFJbMV1bMV0gPSAgICAgICAoYSAqIGEgKyBjICogYyAtIGIgKiBiIC0gZCAqIGQpICogeWQ7XG4gICAgUlsxXVsyXSA9IDIuMCAqIChjICogZCAtIGEgKiBiKSAqIHpkO1xuICAgIFJbMl1bMF0gPSAyLjAgKiAoYiAqIGQgLSBhICogYykgKiB4ZDtcbiAgICBSWzJdWzFdID0gMi4wICogKGMgKiBkICsgYSAqIGIpICogeWQ7XG4gICAgUlsyXVsyXSA9ICAgICAgIChhICogYSArIGQgKiBkIC0gYyAqIGMgLSBiICogYikgKiB6ZDtcblxuICAgIC8vIGxvYWQgb2Zmc2V0c1xuICAgIFJbMF1bM10gPSBxeDtcbiAgICBSWzFdWzNdID0gcXk7XG4gICAgUlsyXVszXSA9IHF6O1xuXG4gICAgcmV0dXJuIFI7XG59O1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBzZm9ybSB0byBhbiBvcmllbnRhdGlvbiBzdHJpbmcgKGUuZy4sIFhZWistLSkuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBSXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLmNvbnZlcnROaWZ0aVNGb3JtVG9ORU1BID0gZnVuY3Rpb24gKFIpIHtcbiAgICB2YXIgeGksIHhqLCB4aywgeWksIHlqLCB5aywgemksIHpqLCB6aywgdmFsLCBkZXRRLCBkZXRQLCBpLCBqLCBrLCBwLCBxLCByLCBpYmVzdCwgamJlc3QsIGtiZXN0LCBwYmVzdCwgcWJlc3QsIHJiZXN0LFxuICAgICAgICBNLCB2YmVzdCwgUSwgUCwgaUNoYXIsIGpDaGFyLCBrQ2hhciwgaVNlbnNlLCBqU2Vuc2UsIGtTZW5zZTtcbiAgICBrID0gMDtcblxuICAgIFEgPSBbWzAsIDAsIDBdLCBbMCwgMCwgMF0sIFswLCAwLCAwXV07XG4gICAgUCA9IFtbMCwgMCwgMF0sIFswLCAwLCAwXSwgWzAsIDAsIDBdXTtcblxuICAgIC8vaWYoIGljb2QgPT0gTlVMTCB8fCBqY29kID09IE5VTEwgfHwga2NvZCA9PSBOVUxMICkgcmV0dXJuIDsgLyogYmFkICovXG5cbiAgICAvLyppY29kID0gKmpjb2QgPSAqa2NvZCA9IDAgOyAvKiB0aGlzLmVycm9yTWVzc2FnZSByZXR1cm5zLCBpZiBzaCp0IGhhcHBlbnMgKi9cblxuICAgIC8qIGxvYWQgY29sdW1uIHZlY3RvcnMgZm9yIGVhY2ggKGksaixrKSBkaXJlY3Rpb24gZnJvbSBtYXRyaXggKi9cblxuICAgIC8qLS0gaSBheGlzIC0tKi8gLyotLSBqIGF4aXMgLS0qLyAvKi0tIGsgYXhpcyAtLSovXG5cbiAgICB4aSA9IFJbMF1bMF07XG4gICAgeGogPSBSWzBdWzFdO1xuICAgIHhrID0gUlswXVsyXTtcblxuICAgIHlpID0gUlsxXVswXTtcbiAgICB5aiA9IFJbMV1bMV07XG4gICAgeWsgPSBSWzFdWzJdO1xuXG4gICAgemkgPSBSWzJdWzBdO1xuICAgIHpqID0gUlsyXVsxXTtcbiAgICB6ayA9IFJbMl1bMl07XG5cbiAgICAvKiBub3JtYWxpemUgY29sdW1uIHZlY3RvcnMgdG8gZ2V0IHVuaXQgdmVjdG9ycyBhbG9uZyBlYWNoIGlqay1heGlzICovXG5cbiAgICAvKiBub3JtYWxpemUgaSBheGlzICovXG4gICAgdmFsID0gTWF0aC5zcXJ0KHhpICogeGkgKyB5aSAqIHlpICsgemkgKiB6aSk7XG4gICAgaWYgKHZhbCA9PT0gMC4wKSB7ICAvKiBzdHVwaWQgaW5wdXQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgeGkgLz0gdmFsO1xuICAgIHlpIC89IHZhbDtcbiAgICB6aSAvPSB2YWw7XG5cbiAgICAvKiBub3JtYWxpemUgaiBheGlzICovXG4gICAgdmFsID0gTWF0aC5zcXJ0KHhqICogeGogKyB5aiAqIHlqICsgemogKiB6aik7XG4gICAgaWYgKHZhbCA9PT0gMC4wKSB7ICAvKiBzdHVwaWQgaW5wdXQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgeGogLz0gdmFsO1xuICAgIHlqIC89IHZhbDtcbiAgICB6aiAvPSB2YWw7XG5cbiAgICAvKiBvcnRob2dvbmFsaXplIGogYXhpcyB0byBpIGF4aXMsIGlmIG5lZWRlZCAqL1xuICAgIHZhbCA9IHhpICogeGogKyB5aSAqIHlqICsgemkgKiB6ajsgICAgLyogZG90IHByb2R1Y3QgYmV0d2VlbiBpIGFuZCBqICovXG4gICAgaWYgKE1hdGguYWJzKHZhbCkgPiAxLkUtNCkge1xuICAgICAgICB4aiAtPSB2YWwgKiB4aTtcbiAgICAgICAgeWogLT0gdmFsICogeWk7XG4gICAgICAgIHpqIC09IHZhbCAqIHppO1xuICAgICAgICB2YWwgPSBNYXRoLnNxcnQoeGogKiB4aiArIHlqICogeWogKyB6aiAqIHpqKTsgIC8qIG11c3QgcmVub3JtYWxpemUgKi9cbiAgICAgICAgaWYgKHZhbCA9PT0gMC4wKSB7ICAgICAgICAgICAgICAvKiBqIHdhcyBwYXJhbGxlbCB0byBpPyAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgeGogLz0gdmFsO1xuICAgICAgICB5aiAvPSB2YWw7XG4gICAgICAgIHpqIC89IHZhbDtcbiAgICB9XG5cbiAgICAvKiBub3JtYWxpemUgayBheGlzOyBpZiBpdCBpcyB6ZXJvLCBtYWtlIGl0IHRoZSBjcm9zcyBwcm9kdWN0IGkgeCBqICovXG4gICAgdmFsID0gTWF0aC5zcXJ0KHhrICogeGsgKyB5ayAqIHlrICsgemsgKiB6ayk7XG4gICAgaWYgKHZhbCA9PT0gMC4wKSB7XG4gICAgICAgIHhrID0geWkgKiB6aiAtIHppICogeWo7XG4gICAgICAgIHlrID0gemkgKiB4aiAtIHpqICogeGk7XG4gICAgICAgIHprID0geGkgKiB5aiAtIHlpICogeGo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeGsgLz0gdmFsO1xuICAgICAgICB5ayAvPSB2YWw7XG4gICAgICAgIHprIC89IHZhbDtcbiAgICB9XG5cbiAgICAvKiBvcnRob2dvbmFsaXplIGsgdG8gaSAqL1xuICAgIHZhbCA9IHhpICogeGsgKyB5aSAqIHlrICsgemkgKiB6azsgICAgLyogZG90IHByb2R1Y3QgYmV0d2VlbiBpIGFuZCBrICovXG4gICAgaWYgKE1hdGguYWJzKHZhbCkgPiAxLkUtNCkge1xuICAgICAgICB4ayAtPSB2YWwgKiB4aTtcbiAgICAgICAgeWsgLT0gdmFsICogeWk7XG4gICAgICAgIHprIC09IHZhbCAqIHppO1xuICAgICAgICB2YWwgPSBNYXRoLnNxcnQoeGsgKiB4ayArIHlrICogeWsgKyB6ayAqIHprKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gMC4wKSB7ICAgIC8qIGJhZCAqL1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgeGsgLz0gdmFsO1xuICAgICAgICB5ayAvPSB2YWw7XG4gICAgICAgIHprIC89IHZhbDtcbiAgICB9XG5cbiAgICAvKiBvcnRob2dvbmFsaXplIGsgdG8gaiAqL1xuICAgIHZhbCA9IHhqICogeGsgKyB5aiAqIHlrICsgemogKiB6azsgICAgLyogZG90IHByb2R1Y3QgYmV0d2VlbiBqIGFuZCBrICovXG4gICAgaWYgKE1hdGguYWJzKHZhbCkgPiAxLmUtNCkge1xuICAgICAgICB4ayAtPSB2YWwgKiB4ajtcbiAgICAgICAgeWsgLT0gdmFsICogeWo7XG4gICAgICAgIHprIC09IHZhbCAqIHpqO1xuICAgICAgICB2YWwgPSBNYXRoLnNxcnQoeGsgKiB4ayArIHlrICogeWsgKyB6ayAqIHprKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gMC4wKSB7ICAgICAvKiBiYWQgKi9cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHhrIC89IHZhbDtcbiAgICAgICAgeWsgLz0gdmFsO1xuICAgICAgICB6ayAvPSB2YWw7XG4gICAgfVxuXG4gICAgUVswXVswXSA9IHhpO1xuICAgIFFbMF1bMV0gPSB4ajtcbiAgICBRWzBdWzJdID0geGs7XG4gICAgUVsxXVswXSA9IHlpO1xuICAgIFFbMV1bMV0gPSB5ajtcbiAgICBRWzFdWzJdID0geWs7XG4gICAgUVsyXVswXSA9IHppO1xuICAgIFFbMl1bMV0gPSB6ajtcbiAgICBRWzJdWzJdID0gems7XG5cbiAgICAvKiBhdCB0aGlzIHBvaW50LCBRIGlzIHRoZSByb3RhdGlvbiBtYXRyaXggZnJvbSB0aGUgKGksaixrKSB0byAoeCx5LHopIGF4ZXMgKi9cblxuICAgIGRldFEgPSB0aGlzLm5pZnRpX21hdDMzX2RldGVybShRKTtcbiAgICBpZiAoZGV0USA9PT0gMC4wKSB7IC8qIHNob3VsZG4ndCBoYXBwZW4gdW5sZXNzIHVzZXIgaXMgYSBEVUZJUyAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKiBCdWlsZCBhbmQgdGVzdCBhbGwgcG9zc2libGUgKzEvLTEgY29vcmRpbmF0ZSBwZXJtdXRhdGlvbiBtYXRyaWNlcyBQO1xuICAgICB0aGVuIGZpbmQgdGhlIFAgc3VjaCB0aGF0IHRoZSByb3RhdGlvbiBtYXRyaXggTT1QUSBpcyBjbG9zZXN0IHRvIHRoZVxuICAgICBpZGVudGl0eSwgaW4gdGhlIHNlbnNlIG9mIE0gaGF2aW5nIHRoZSBzbWFsbGVzdCB0b3RhbCByb3RhdGlvbiBhbmdsZS4gKi9cblxuICAgIC8qIERlc3BpdGUgdGhlIGZvcm1pZGFibGUgbG9va2luZyA2IG5lc3RlZCBsb29wcywgdGhlcmUgYXJlXG4gICAgIG9ubHkgMyozKjMqMioyKjIgPSAyMTYgcGFzc2VzLCB3aGljaCB3aWxsIHJ1biB2ZXJ5IHF1aWNrbHkuICovXG5cbiAgICB2YmVzdCA9IC02NjYuMDtcbiAgICBpYmVzdCA9IHBiZXN0ID0gcWJlc3QgPSByYmVzdCA9IDE7XG4gICAgamJlc3QgPSAyO1xuICAgIGtiZXN0ID0gMztcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gMzsgaSArPSAxKSB7ICAgICAvKiBpID0gY29sdW1uIG51bWJlciB0byB1c2UgZm9yIHJvdyAjMSAqL1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IDM7IGogKz0gMSkgeyAgICAvKiBqID0gY29sdW1uIG51bWJlciB0byB1c2UgZm9yIHJvdyAjMiAqL1xuICAgICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBrIDw9IDM7IGsgKz0gMSkgeyAgLyogayA9IGNvbHVtbiBudW1iZXIgdG8gdXNlIGZvciByb3cgIzMgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA9PT0gayB8fCBqID09PSBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUFswXVswXSA9IFBbMF1bMV0gPSBQWzBdWzJdID0gUFsxXVswXSA9IFBbMV1bMV0gPSBQWzFdWzJdID0gUFsyXVswXSA9IFBbMl1bMV0gPSBQWzJdWzJdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gLTE7IHAgPD0gMTsgcCArPSAyKSB7ICAgIC8qIHAscSxyIGFyZSAtMSBvciArMSAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gLTE7IHEgPD0gMTsgcSArPSAyKSB7ICAgLyogYW5kIGdvIGludG8gcm93cyAjMSwyLDMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyID0gLTE7IHIgPD0gMTsgciArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQWzBdW2kgLSAxXSA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQWzFdW2ogLSAxXSA9IHE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQWzJdW2sgLSAxXSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRQID0gdGhpcy5uaWZ0aV9tYXQzM19kZXRlcm0oUCk7ICAgICAgICAgICAvKiBzaWduIG9mIHBlcm11dGF0aW9uICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRldFAgKiBkZXRRKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0gPSB0aGlzLm5pZnRpX21hdDMzX211bChQLCBRKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGFuZ2xlIG9mIE0gcm90YXRpb24gPSAyLjAqYWNvcygwLjUqc3FydCgxLjArdHJhY2UoTSkpKSAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHdlIHdhbnQgbGFyZ2VzdCB0cmFjZShNKSA9PSBzbWFsbGVzdCBhbmdsZSA9PSBNIG5lYXJlc3QgdG8gSSAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gTVswXVswXSArIE1bMV1bMV0gKyBNWzJdWzJdOyAvKiB0cmFjZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiB2YmVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YmVzdCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWJlc3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYmVzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtiZXN0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJlc3QgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxYmVzdCA9IHE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJiZXN0ID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAvKiBkb2Vzbid0IG1hdGNoIHNpZ24gb2YgUSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogQXQgdGhpcyBwb2ludCBpYmVzdCBpcyAxIG9yIDIgb3IgMzsgcGJlc3QgaXMgLTEgb3IgKzE7IGV0Yy5cblxuICAgICBUaGUgbWF0cml4IFAgdGhhdCBjb3JyZXNwb25kcyBpcyB0aGUgYmVzdCBwZXJtdXRhdGlvbiBhcHByb3hpbWF0aW9uXG4gICAgIHRvIFEtaW52ZXJzZTsgdGhhdCBpcywgUCAoYXBwcm94aW1hdGVseSkgdGFrZXMgKHgseSx6KSBjb29yZGluYXRlc1xuICAgICB0byB0aGUgKGksaixrKSBheGVzLlxuXG4gICAgIEZvciBleGFtcGxlLCB0aGUgZmlyc3Qgcm93IG9mIFAgKHdoaWNoIGNvbnRhaW5zIHBiZXN0IGluIGNvbHVtbiBpYmVzdClcbiAgICAgZGV0ZXJtaW5lcyB0aGUgd2F5IHRoZSBpIGF4aXMgcG9pbnRzIHJlbGF0aXZlIHRvIHRoZSBhbmF0b21pY2FsXG4gICAgICh4LHkseikgYXhlcy4gIElmIGliZXN0IGlzIDIsIHRoZW4gdGhlIGkgYXhpcyBpcyBhbG9uZyB0aGUgeSBheGlzLFxuICAgICB3aGljaCBpcyBkaXJlY3Rpb24gUDJBIChpZiBwYmVzdCA+IDApIG9yIEEyUCAoaWYgcGJlc3QgPCAwKS5cblxuICAgICBTbywgdXNpbmcgaWJlc3QgYW5kIHBiZXN0LCB3ZSBjYW4gYXNzaWduIHRoZSBvdXRwdXQgY29kZSBmb3JcbiAgICAgdGhlIGkgYXhpcy4gIE11dGF0aXMgbXV0YW5kaXMgZm9yIHRoZSBqIGFuZCBrIGF4ZXMsIG9mIGNvdXJzZS4gKi9cblxuICAgIGlDaGFyID0gakNoYXIgPSBrQ2hhciA9IGlTZW5zZSA9IGpTZW5zZSA9IGtTZW5zZSA9IDA7XG5cbiAgICBzd2l0Y2ggKGliZXN0ICogcGJlc3QpIHtcbiAgICAgICAgY2FzZSAxOiAvKmkgPSBOSUZUSV9MMlIqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWCc7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMTogLyppID0gTklGVElfUjJMKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1gnO1xuICAgICAgICAgICAgaVNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogLyppID0gTklGVElfUDJBKi9cbiAgICAgICAgICAgIGlDaGFyID0gJ1knO1xuICAgICAgICAgICAgaVNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTI6IC8qaSA9IE5JRlRJX0EyUCovXG4gICAgICAgICAgICBpQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8qaSA9IE5JRlRJX0kyUyovXG4gICAgICAgICAgICBpQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGlTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0zOiAvKmkgPSBOSUZUSV9TMkkqL1xuICAgICAgICAgICAgaUNoYXIgPSAnWic7XG4gICAgICAgICAgICBpU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGpiZXN0ICogcWJlc3QpIHtcbiAgICAgICAgY2FzZSAxOiAvKmogPSBOSUZUSV9MMlIqL1xuICAgICAgICAgICAgakNoYXIgPSAnWCc7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMTogLypqID0gTklGVElfUjJMKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1gnO1xuICAgICAgICAgICAgalNlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogLypqID0gTklGVElfUDJBKi9cbiAgICAgICAgICAgIGpDaGFyID0gJ1knO1xuICAgICAgICAgICAgalNlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTI6IC8qaiA9IE5JRlRJX0EyUCovXG4gICAgICAgICAgICBqQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8qaiA9IE5JRlRJX0kyUyovXG4gICAgICAgICAgICBqQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGpTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0zOiAvKmogPSBOSUZUSV9TMkkqL1xuICAgICAgICAgICAgakNoYXIgPSAnWic7XG4gICAgICAgICAgICBqU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtiZXN0ICogcmJlc3QpIHtcbiAgICAgICAgY2FzZSAxOiAvKmsgPSBOSUZUSV9MMlIqL1xuICAgICAgICAgICAga0NoYXIgPSAnWCc7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnKyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAtMTogLyprID0gTklGVElfUjJMKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1gnO1xuICAgICAgICAgICAga1NlbnNlID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogLyprID0gTklGVElfUDJBKi9cbiAgICAgICAgICAgIGtDaGFyID0gJ1knO1xuICAgICAgICAgICAga1NlbnNlID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgLTI6IC8qayA9IE5JRlRJX0EyUCovXG4gICAgICAgICAgICBrQ2hhciA9ICdZJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICctJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8qayA9IE5JRlRJX0kyUyovXG4gICAgICAgICAgICBrQ2hhciA9ICdaJztcbiAgICAgICAgICAgIGtTZW5zZSA9ICcrJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0zOiAvKmsgPSBOSUZUSV9TMkkqL1xuICAgICAgICAgICAga0NoYXIgPSAnWic7XG4gICAgICAgICAgICBrU2Vuc2UgPSAnLSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gKGlDaGFyICsgakNoYXIgKyBrQ2hhciArIGlTZW5zZSArIGpTZW5zZSArIGtTZW5zZSk7XG59O1xuXG5cblxubmlmdGkuTklGVEkxLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19tdWwgPSBmdW5jdGlvbiAoQSwgQikge1xuICAgIHZhciBDID0gW1swLCAwLCAwXSwgWzAsIDAsIDBdLCBbMCwgMCwgMF1dLFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaiArPSAxKSB7XG4gICAgICAgICAgICBDW2ldW2pdID0gIEFbaV1bMF0gKiBCWzBdW2pdICArIEFbaV1bMV0gKiBCWzFdW2pdICsgQVtpXVsyXSAqIEJbMl1bal07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQztcbn07XG5cblxuXG5uaWZ0aS5OSUZUSTEucHJvdG90eXBlLm5pZnRpX21hdDMzX2RldGVybSA9IGZ1bmN0aW9uIChSKSB7XG4gICAgdmFyIHIxMSwgcjEyLCByMTMsIHIyMSwgcjIyLCByMjMsIHIzMSwgcjMyLCByMzM7XG4gICAgLyogIElOUFVUIE1BVFJJWDogICovXG4gICAgcjExID0gUlswXVswXTtcbiAgICByMTIgPSBSWzBdWzFdO1xuICAgIHIxMyA9IFJbMF1bMl07XG4gICAgcjIxID0gUlsxXVswXTtcbiAgICByMjIgPSBSWzFdWzFdO1xuICAgIHIyMyA9IFJbMV1bMl07XG4gICAgcjMxID0gUlsyXVswXTtcbiAgICByMzIgPSBSWzJdWzFdO1xuICAgIHIzMyA9IFJbMl1bMl07XG5cbiAgICByZXR1cm4gKHIxMSAqIHIyMiAqIHIzMyAtIHIxMSAqIHIzMiAqIHIyMyAtIHIyMSAqIHIxMiAqIHIzMyArIHIyMSAqIHIzMiAqIHIxMyArIHIzMSAqIHIxMiAqIHIyMyAtIHIzMSAqIHIyMiAqIHIxMyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYnl0ZSBpbmRleCBvZiB0aGUgZXh0ZW5zaW9uLlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xubmlmdGkuTklGVEkxLnByb3RvdHlwZS5nZXRFeHRlbnNpb25Mb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuaWZ0aS5OSUZUSTEuTUFHSUNfQ09PS0lFICsgNDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gc2l6ZS5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uU2l6ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gbmlmdGkuVXRpbHMuZ2V0SW50QXQoZGF0YSwgdGhpcy5nZXRFeHRlbnNpb25Mb2NhdGlvbigpLCB0aGlzLmxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gY29kZS5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uQ29kZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gbmlmdGkuVXRpbHMuZ2V0SW50QXQoZGF0YSwgdGhpcy5nZXRFeHRlbnNpb25Mb2NhdGlvbigpICsgNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xufTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuaWZ0aS5OSUZUSTE7XG59XG4iLCJcbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKioqIEltcG9ydHMgKioqL1xuXG52YXIgbmlmdGkgPSBuaWZ0aSB8fCB7fTtcbm5pZnRpLlV0aWxzID0gbmlmdGkuVXRpbHMgfHwgKCh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgnLi91dGlsaXRpZXMuanMnKSA6IG51bGwpO1xubmlmdGkuTklGVEkxID0gbmlmdGkuTklGVEkxIHx8ICgodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVpcmUoJy4vbmlmdGkxLmpzJykgOiBudWxsKTtcblxuXG4vKioqIENvbnN0cnVjdG9yICoqKi9cblxuLyoqXG4gKiBUaGUgTklGVEkyIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGxpdHRsZUVuZGlhblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpbV9pbmZvXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBkaW1zIC0gaW1hZ2UgZGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wMVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9wM1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVudF9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YXR5cGVDb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbnVtQml0c1BlclZveGVsXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2xpY2Vfc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9lbmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBwaXhEaW1zIC0gdm94ZWwgZGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHZveF9vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY2xfc2xvcGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY2xfaW50ZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4eXp0X3VuaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FsX21heFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhbF9taW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbGljZV9kdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvZmZzZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF1eF9maWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW50ZW50X25hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBxZm9ybV9jb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2Zvcm1fY29kZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fYlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5fZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5feFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5feVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHF1YXRlcm5felxuICogQHByb3BlcnR5IHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBhZmZpbmVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYWdpY1xuICogQHByb3BlcnR5IHtudW1iZXJbXX0gZXh0ZW5zaW9uRmxhZ1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5uaWZ0aS5OSUZUSTIgPSBuaWZ0aS5OSUZUSTIgfHwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgdGhpcy5kaW1faW5mbyA9IDA7XG4gICAgdGhpcy5kaW1zID0gW107XG4gICAgdGhpcy5pbnRlbnRfcDEgPSAwO1xuICAgIHRoaXMuaW50ZW50X3AyID0gMDtcbiAgICB0aGlzLmludGVudF9wMyA9IDA7XG4gICAgdGhpcy5pbnRlbnRfY29kZSA9IDA7XG4gICAgdGhpcy5kYXRhdHlwZUNvZGUgPSAwO1xuICAgIHRoaXMubnVtQml0c1BlclZveGVsID0gMDtcbiAgICB0aGlzLnNsaWNlX3N0YXJ0ID0gMDtcbiAgICB0aGlzLnNsaWNlX2VuZCA9IDA7XG4gICAgdGhpcy5zbGljZV9jb2RlID0gMDtcbiAgICB0aGlzLnBpeERpbXMgPSBbXTtcbiAgICB0aGlzLnZveF9vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2NsX3Nsb3BlID0gMTtcbiAgICB0aGlzLnNjbF9pbnRlciA9IDA7XG4gICAgdGhpcy54eXp0X3VuaXRzID0gMDtcbiAgICB0aGlzLmNhbF9tYXggPSAwO1xuICAgIHRoaXMuY2FsX21pbiA9IDA7XG4gICAgdGhpcy5zbGljZV9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b2Zmc2V0ID0gMDtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICB0aGlzLmF1eF9maWxlID0gXCJcIjtcbiAgICB0aGlzLmludGVudF9uYW1lID0gXCJcIjtcbiAgICB0aGlzLnFmb3JtX2NvZGUgPSAwO1xuICAgIHRoaXMuc2Zvcm1fY29kZSA9IDA7XG4gICAgdGhpcy5xdWF0ZXJuX2IgPSAwO1xuICAgIHRoaXMucXVhdGVybl9jID0gMDtcbiAgICB0aGlzLnF1YXRlcm5fZCA9IDA7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSAwO1xuICAgIHRoaXMucW9mZnNldF95ID0gMDtcbiAgICB0aGlzLnFvZmZzZXRfeiA9IDA7XG4gICAgdGhpcy5hZmZpbmUgPSBbWzEsIDAsIDAsIDBdLCBbMCwgMSwgMCwgMF0sIFswLCAwLCAxLCAwXSwgWzAsIDAsIDAsIDFdXTtcbiAgICB0aGlzLm1hZ2ljID0gMDtcbiAgICB0aGlzLmV4dGVuc2lvbkZsYWcgPSBbMCwgMCwgMCwgMF07XG59O1xuXG5cblxuLyoqKiBTdGF0aWMgUHNldWRvLWNvbnN0YW50cyAqKiovXG5cbm5pZnRpLk5JRlRJMi5NQUdJQ19DT09LSUUgPSA1NDA7XG5uaWZ0aS5OSUZUSTIuTUFHSUNfTlVNQkVSX0xPQ0FUSU9OID0gNDtcbm5pZnRpLk5JRlRJMi5NQUdJQ19OVU1CRVIgPSBbMHg2RSwgMHgyQiwgMHgzMiwgMCwgMHgwRCwgMHgwQSwgMHgxQSwgMHgwQV07ICAvLyBuKzJcXDBcblxuXG5cbi8qKiogUHJvdG90eXBlIE1ldGhvZHMgKioqL1xuXG4vKipcbiAqIFJlYWRzIHRoZSBoZWFkZXIgZGF0YS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5yZWFkSGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcmF3RGF0YSA9IG5ldyBEYXRhVmlldyhkYXRhKSxcbiAgICAgICAgbWFnaWNDb29raWVWYWwgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCAwLCB0aGlzLmxpdHRsZUVuZGlhbiksXG4gICAgICAgIGN0cixcbiAgICAgICAgY3RyT3V0LFxuICAgICAgICBjdHJJbixcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGFycmF5O1xuXG4gICAgaWYgKG1hZ2ljQ29va2llVmFsICE9PSBuaWZ0aS5OSUZUSTIuTUFHSUNfQ09PS0lFKSB7ICAvLyB0cnkgYXMgbGl0dGxlIGVuZGlhblxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgICAgIG1hZ2ljQ29va2llVmFsID0gbmlmdGkuVXRpbHMuZ2V0SW50QXQocmF3RGF0YSwgMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChtYWdpY0Nvb2tpZVZhbCAhPT0gbmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIE5JRlRJIGZpbGUhXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YXR5cGVDb2RlID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAxMiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMubnVtQml0c1BlclZveGVsID0gbmlmdGkuVXRpbHMuZ2V0U2hvcnRBdChyYXdEYXRhLCAxNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBpbmRleCA9IDE2ICsgKGN0ciAqIDgpO1xuICAgICAgICB0aGlzLmRpbXNbY3RyXSA9IG5pZnRpLlV0aWxzLmdldExvbmdBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZW50X3AxID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgODAsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9wMiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDg4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5pbnRlbnRfcDMgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCA5NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgZm9yIChjdHIgPSAwOyBjdHIgPCA4OyBjdHIgKz0gMSkge1xuICAgICAgICBpbmRleCA9IDEwNCArIChjdHIgKiA4KTtcbiAgICAgICAgdGhpcy5waXhEaW1zW2N0cl0gPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCBpbmRleCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIH1cblxuICAgIHRoaXMudm94X29mZnNldCA9IG5pZnRpLlV0aWxzLmdldExvbmdBdChyYXdEYXRhLCAxNjgsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuc2NsX3Nsb3BlID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMTc2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5zY2xfaW50ZXIgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAxODQsIHRoaXMubGl0dGxlRW5kaWFuKTtcblxuICAgIHRoaXMuY2FsX21heCA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDE5MiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuY2FsX21pbiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDIwMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5zbGljZV9kdXJhdGlvbiA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDIwOCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy50b2Zmc2V0ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMjE2LCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICB0aGlzLnNsaWNlX3N0YXJ0ID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIDIyNCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2xpY2VfZW5kID0gbmlmdGkuVXRpbHMuZ2V0TG9uZ0F0KHJhd0RhdGEsIDIzMiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5pZnRpLlV0aWxzLmdldFN0cmluZ0F0KHJhd0RhdGEsIDI0MCwgMjQwICsgODApO1xuICAgIHRoaXMuYXV4X2ZpbGUgPSBuaWZ0aS5VdGlscy5nZXRTdHJpbmdBdChyYXdEYXRhLCAzMjAsIDMyMCArIDI0KTtcblxuICAgIHRoaXMucWZvcm1fY29kZSA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDM0NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuc2Zvcm1fY29kZSA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDM0OCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuXG4gICAgdGhpcy5xdWF0ZXJuX2IgPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzNTIsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnF1YXRlcm5fYyA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM2MCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucXVhdGVybl9kID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzY4LCB0aGlzLmxpdHRsZUVuZGlhbik7XG4gICAgdGhpcy5xb2Zmc2V0X3ggPSBuaWZ0aS5VdGlscy5nZXREb3VibGVBdChyYXdEYXRhLCAzNzYsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLnFvZmZzZXRfeSA9IG5pZnRpLlV0aWxzLmdldERvdWJsZUF0KHJhd0RhdGEsIDM4NCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMucW9mZnNldF96ID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgMzkyLCB0aGlzLmxpdHRsZUVuZGlhbik7XG5cbiAgICBmb3IgKGN0ck91dCA9IDA7IGN0ck91dCA8IDM7IGN0ck91dCArPSAxKSB7XG4gICAgICAgIGZvciAoY3RySW4gPSAwOyBjdHJJbiA8IDQ7IGN0ckluICs9IDEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gNDAwICsgKCgoY3RyT3V0ICogNCkgKyBjdHJJbikgKiA4KTtcbiAgICAgICAgICAgIHRoaXMuYWZmaW5lW2N0ck91dF1bY3RySW5dID0gbmlmdGkuVXRpbHMuZ2V0RG91YmxlQXQocmF3RGF0YSwgaW5kZXgsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWZmaW5lWzNdWzBdID0gMDtcbiAgICB0aGlzLmFmZmluZVszXVsxXSA9IDA7XG4gICAgdGhpcy5hZmZpbmVbM11bMl0gPSAwO1xuICAgIHRoaXMuYWZmaW5lWzNdWzNdID0gMTtcblxuICAgIHRoaXMuc2xpY2VfY29kZSA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDQ5NiwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMueHl6dF91bml0cyA9IG5pZnRpLlV0aWxzLmdldEludEF0KHJhd0RhdGEsIDUwMCwgdGhpcy5saXR0bGVFbmRpYW4pO1xuICAgIHRoaXMuaW50ZW50X2NvZGUgPSBuaWZ0aS5VdGlscy5nZXRJbnRBdChyYXdEYXRhLCA1MDQsIHRoaXMubGl0dGxlRW5kaWFuKTtcbiAgICB0aGlzLmludGVudF9uYW1lID0gbmlmdGkuVXRpbHMuZ2V0U3RyaW5nQXQocmF3RGF0YSwgNTA4LCA1MDggKyAxNik7XG5cbiAgICB0aGlzLmRpbV9pbmZvID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDUyNCk7XG5cbiAgICBpZiAocmF3RGF0YS5ieXRlTGVuZ3RoID4gbmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSkge1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMF0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTQwKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25GbGFnWzFdID0gbmlmdGkuVXRpbHMuZ2V0Qnl0ZUF0KHJhd0RhdGEsIDU0MCArIDEpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbkZsYWdbMl0gPSBuaWZ0aS5VdGlscy5nZXRCeXRlQXQocmF3RGF0YSwgNTQwICsgMik7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmxhZ1szXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChyYXdEYXRhLCA1NDAgKyAzKTtcblxuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25GbGFnWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvblNpemUgPSB0aGlzLmdldEV4dGVuc2lvblNpemUocmF3RGF0YSk7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbkNvZGUgPSB0aGlzLmdldEV4dGVuc2lvbkNvZGUocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyBvZiBoZWFkZXIgZmllbGRzLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS50b0Zvcm1hdHRlZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm10ID0gbmlmdGkuVXRpbHMuZm9ybWF0TnVtYmVyLFxuICAgICAgICBzdHJpbmcgPSBcIlwiO1xuXG4gICAgc3RyaW5nICs9IChcIkRhdGF0eXBlID0gXCIgKyAgKyB0aGlzLmRhdGF0eXBlQ29kZSArIFwiIChcIiArIHRoaXMuZ2V0RGF0YXR5cGVDb2RlU3RyaW5nKHRoaXMuZGF0YXR5cGVDb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiQml0cyBQZXIgVm94ZWwgPSBcIiArIFwiID0gXCIgKyB0aGlzLm51bUJpdHNQZXJWb3hlbCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJJbWFnZSBEaW1lbnNpb25zXCIgKyBcIiAoMS04KTogXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMF0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMV0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbMl0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbM10gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNF0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNV0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbNl0gKyBcIiwgXCIgK1xuICAgICAgICB0aGlzLmRpbXNbN10gKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgUGFyYW1ldGVycyAoMS0zKTogXCIgK1xuICAgICAgICB0aGlzLmludGVudF9wMSArIFwiLCBcIiArXG4gICAgICAgIHRoaXMuaW50ZW50X3AyICsgXCIsIFwiICtcbiAgICAgICAgdGhpcy5pbnRlbnRfcDMpICsgXCJcXG5cIjtcblxuICAgIHN0cmluZyArPSAoXCJWb3hlbCBEaW1lbnNpb25zICgxLTgpOiBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbMF0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1sxXSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzJdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbM10pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s0XSkgKyBcIiwgXCIgK1xuICAgICAgICBmbXQodGhpcy5waXhEaW1zWzVdKSArIFwiLCBcIiArXG4gICAgICAgIGZtdCh0aGlzLnBpeERpbXNbNl0pICsgXCIsIFwiICtcbiAgICAgICAgZm10KHRoaXMucGl4RGltc1s3XSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJJbWFnZSBPZmZzZXQgPSBcIiArIHRoaXMudm94X29mZnNldCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEYXRhIFNjYWxlOiAgU2xvcGUgPSBcIiArIGZtdCh0aGlzLnNjbF9zbG9wZSkgKyBcIiAgSW50ZXJjZXB0ID0gXCIgKyBmbXQodGhpcy5zY2xfaW50ZXIpICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIkRpc3BsYXkgUmFuZ2U6ICBNYXggPSBcIiArIGZtdCh0aGlzLmNhbF9tYXgpICsgXCIgIE1pbiA9IFwiICsgZm10KHRoaXMuY2FsX21pbikgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRHVyYXRpb24gPSBcIiArIHRoaXMuc2xpY2VfZHVyYXRpb24gKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiVGltZSBBeGlzIFNoaWZ0ID0gXCIgKyB0aGlzLnRvZmZzZXQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgU3RhcnQgPSBcIiArIHRoaXMuc2xpY2Vfc3RhcnQgKyBcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgRW5kID0gXCIgKyB0aGlzLnNsaWNlX2VuZCArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJEZXNjcmlwdGlvbjogXFxcIlwiICsgdGhpcy5kZXNjcmlwdGlvbiArIFwiXFxcIlxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiQXV4aWxpYXJ5IEZpbGU6IFxcXCJcIiArIHRoaXMuYXV4X2ZpbGUgKyBcIlxcXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlEtRm9ybSBDb2RlID0gXCIgKyB0aGlzLnFmb3JtX2NvZGUgKyBcIiAoXCIgKyB0aGlzLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcodGhpcy5xZm9ybV9jb2RlKSArIFwiKVxcblwiKTtcbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIENvZGUgPSBcIiArIHRoaXMuc2Zvcm1fY29kZSArIFwiIChcIiArIHRoaXMuZ2V0VHJhbnNmb3JtQ29kZVN0cmluZyh0aGlzLnNmb3JtX2NvZGUpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJRdWF0ZXJuaW9uIFBhcmFtZXRlcnM6ICBcIiArXG4gICAgXCJiID0gXCIgKyBmbXQodGhpcy5xdWF0ZXJuX2IpICsgXCIgIFwiICtcbiAgICBcImMgPSBcIiArIGZtdCh0aGlzLnF1YXRlcm5fYykgKyBcIiAgXCIgK1xuICAgIFwiZCA9IFwiICsgZm10KHRoaXMucXVhdGVybl9kKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlF1YXRlcm5pb24gT2Zmc2V0czogIFwiICtcbiAgICBcInggPSBcIiArIHRoaXMucW9mZnNldF94ICsgXCIgIFwiICtcbiAgICBcInkgPSBcIiArIHRoaXMucW9mZnNldF95ICsgXCIgIFwiICtcbiAgICBcInogPSBcIiArIHRoaXMucW9mZnNldF96ICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiUy1Gb3JtIFBhcmFtZXRlcnMgWDogXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVswXVswXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVswXVsxXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVswXVsyXSkgKyBcIiwgXCIgK1xuICAgIGZtdCh0aGlzLmFmZmluZVswXVszXSkgKyBcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJTLUZvcm0gUGFyYW1ldGVycyBZOiBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzFdWzBdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzFdWzFdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzFdWzJdKSArIFwiLCBcIiArXG4gICAgZm10KHRoaXMuYWZmaW5lWzFdWzNdKSArIFwiXFxuXCIpO1xuXG4gICAgc3RyaW5nICs9IChcIlMtRm9ybSBQYXJhbWV0ZXJzIFo6IFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMl1bMF0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMl1bMV0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMl1bMl0pICsgXCIsIFwiICtcbiAgICBmbXQodGhpcy5hZmZpbmVbMl1bM10pICsgXCJcXG5cIik7XG5cbiAgICBzdHJpbmcgKz0gKFwiU2xpY2UgQ29kZSA9IFwiICsgdGhpcy5zbGljZV9jb2RlICsgXCJcXG5cIik7XG4gICAgc3RyaW5nICs9IChcIlVuaXRzIENvZGUgPSBcIiArIHRoaXMueHl6dF91bml0cyArIFwiIChcIiArIHRoaXMuZ2V0VW5pdHNDb2RlU3RyaW5nKG5pZnRpLk5JRlRJMS5TUEFUSUFMX1VOSVRTX01BU0sgJiB0aGlzLnh5enRfdW5pdHMpICsgXCIsIFwiICsgdGhpcy5nZXRVbml0c0NvZGVTdHJpbmcobmlmdGkuTklGVEkxLlRFTVBPUkFMX1VOSVRTX01BU0sgJiB0aGlzLnh5enRfdW5pdHMpICsgXCIpXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgQ29kZSA9IFwiICsgdGhpcy5pbnRlbnRfY29kZSArIFwiXFxuXCIpO1xuICAgIHN0cmluZyArPSAoXCJJbnRlbnQgTmFtZTogXFxcIlwiICsgdGhpcy5pbnRlbnRfbmFtZSArIFwiXFxcIlxcblwiKTtcblxuICAgIHN0cmluZyArPSAoXCJEaW0gSW5mbyA9IFwiICsgdGhpcy5kaW1faW5mbyArIFwiXFxuXCIpO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJ5dGUgaW5kZXggb2YgdGhlIGV4dGVuc2lvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uTG9jYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmlmdGkuTklGVEkyLk1BR0lDX0NPT0tJRSArIDQ7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gc2l6ZS5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uU2l6ZSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuZ2V0RXh0ZW5zaW9uU2l6ZTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIGNvZGUuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldEV4dGVuc2lvbkNvZGUgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldEV4dGVuc2lvbkNvZGU7XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2YgZGF0YXR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXREYXRhdHlwZUNvZGVTdHJpbmcgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldERhdGF0eXBlQ29kZVN0cmluZztcblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBvZiB0cmFuc2Zvcm0gdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmdldFRyYW5zZm9ybUNvZGVTdHJpbmcgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFRyYW5zZm9ybUNvZGVTdHJpbmc7XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgb2Ygc3BhdGlhbCBhbmQgdGVtcG9yYWwgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5nZXRVbml0c0NvZGVTdHJpbmcgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFVuaXRzQ29kZVN0cmluZztcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcWZvcm0gbWF0cml4LlxuICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59XG4gKi9cbm5pZnRpLk5JRlRJMi5wcm90b3R5cGUuZ2V0UWZvcm1NYXQgPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLmdldFFmb3JtTWF0O1xuXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBxZm9ybSB0byBhbiBhZmZpbmUuICAoU2VlIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jKVxuICogQHBhcmFtIHtudW1iZXJ9IHFiXG4gKiBAcGFyYW0ge251bWJlcn0gcWNcbiAqIEBwYXJhbSB7bnVtYmVyfSBxZFxuICogQHBhcmFtIHtudW1iZXJ9IHF4XG4gKiBAcGFyYW0ge251bWJlcn0gcXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBxelxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkelxuICogQHBhcmFtIHtudW1iZXJ9IHFmYWNcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICovXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLmNvbnZlcnROaWZ0aVFGb3JtVG9OaWZ0aVNGb3JtID0gbmlmdGkuTklGVEkxLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlRRm9ybVRvTmlmdGlTRm9ybTtcblxuXG5cbi8qKlxuICogQ29udmVydHMgc2Zvcm0gdG8gYW4gb3JpZW50YXRpb24gc3RyaW5nIChlLmcuLCBYWVorLS0pLiAgKFNlZSBodHRwOi8vbmlmdGkubmltaC5uaWguZ292L3B1Yi9kaXN0L3NyYy9uaWZ0aWxpYi9uaWZ0aTFfaW8uYylcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gUlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubmlmdGkuTklGVEkyLnByb3RvdHlwZS5jb252ZXJ0TmlmdGlTRm9ybVRvTkVNQSA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUuY29udmVydE5pZnRpU0Zvcm1Ub05FTUE7XG5cblxuXG5uaWZ0aS5OSUZUSTIucHJvdG90eXBlLm5pZnRpX21hdDMzX211bCA9IG5pZnRpLk5JRlRJMS5wcm90b3R5cGUubmlmdGlfbWF0MzNfbXVsO1xuXG5cblxubmlmdGkuTklGVEkyLnByb3RvdHlwZS5uaWZ0aV9tYXQzM19kZXRlcm0gPSBuaWZ0aS5OSUZUSTEucHJvdG90eXBlLm5pZnRpX21hdDMzX2RldGVybTtcblxuXG5cbi8qKiogRXhwb3J0cyAqKiovXG5cbnZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcbmlmICgobW9kdWxlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuaWZ0aS5OSUZUSTI7XG59XG4iLCJcbi8qanNsaW50IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqKiBJbXBvcnRzICoqKi9cblxudmFyIG5pZnRpID0gbmlmdGkgfHwge307XG5uaWZ0aS5VdGlscyA9IG5pZnRpLlV0aWxzIHx8IHt9O1xuXG5cblxuLyoqKiBTdGF0aWMgUHNldWRvLWNvbnN0YW50cyAqKiovXG5cbm5pZnRpLlV0aWxzLmNyY1RhYmxlID0gbnVsbDtcbm5pZnRpLlV0aWxzLkdVTlpJUF9NQUdJQ19DT09LSUUxID0gMzE7XG5uaWZ0aS5VdGlscy5HVU5aSVBfTUFHSUNfQ09PS0lFMiA9IDEzOTtcblxuXG5cbi8qKiogU3RhdGljIG1ldGhvZHMgKioqL1xuXG5uaWZ0aS5VdGlscy5nZXRTdHJpbmdBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0ciA9IFwiXCIsIGN0ciwgY2g7XG5cbiAgICBmb3IgKGN0ciA9IHN0YXJ0OyBjdHIgPCBlbmQ7IGN0ciArPSAxKSB7XG4gICAgICAgIGNoID0gZGF0YS5nZXRVaW50OChjdHIpO1xuXG4gICAgICAgIGlmIChjaCAhPT0gMCkge1xuICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRCeXRlQXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQpIHtcbiAgICByZXR1cm4gZGF0YS5nZXRJbnQ4KHN0YXJ0KTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRTaG9ydEF0ID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZGF0YS5nZXRJbnQxNihzdGFydCwgbGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRJbnRBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0SW50MzIoc3RhcnQsIGxpdHRsZUVuZGlhbik7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuZ2V0RmxvYXRBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0RmxvYXQzMihzdGFydCwgbGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXREb3VibGVBdCA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGRhdGEuZ2V0RmxvYXQ2NChzdGFydCwgbGl0dGxlRW5kaWFuKTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy5nZXRMb25nQXQgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgIHZhciBjdHIsIGFycmF5ID0gW10sIHZhbHVlID0gMDtcblxuICAgIGZvciAoY3RyID0gMDsgY3RyIDwgODsgY3RyICs9IDEpIHtcbiAgICAgICAgYXJyYXlbY3RyXSA9IG5pZnRpLlV0aWxzLmdldEJ5dGVBdChkYXRhLCBzdGFydCArIGN0ciwgbGl0dGxlRW5kaWFuKTtcbiAgICB9XG5cbiAgICBmb3IgKGN0ciA9IGFycmF5Lmxlbmd0aCAtIDE7IGN0ciA+PSAwOyBjdHItLSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBhcnJheVtjdHJdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cblxuXG5uaWZ0aS5VdGlscy50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciBhYiwgdmlldywgaTtcblxuICAgIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWI7XG59O1xuXG5cblxubmlmdGkuVXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZyk7XG59O1xuXG5cbm5pZnRpLlV0aWxzLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uIChudW0sIHNob3J0Rm9ybWF0KSB7XG4gICAgdmFyIHZhbCA9IDA7XG5cbiAgICBpZiAobmlmdGkuVXRpbHMuaXNTdHJpbmcobnVtKSkge1xuICAgICAgICB2YWwgPSBOdW1iZXIobnVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBudW07XG4gICAgfVxuXG4gICAgaWYgKHNob3J0Rm9ybWF0KSB7XG4gICAgICAgIHZhbCA9IHZhbC50b1ByZWNpc2lvbig1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB2YWwudG9QcmVjaXNpb24oNyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbn07XG5cblxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NjM4OTAwL2phdmFzY3JpcHQtY3JjMzJcbm5pZnRpLlV0aWxzLm1ha2VDUkNUYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGM7XG4gICAgdmFyIGNyY1RhYmxlID0gW107XG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGNyY1RhYmxlW25dID0gYztcbiAgICB9XG4gICAgcmV0dXJuIGNyY1RhYmxlO1xufTtcblxuXG5cbm5pZnRpLlV0aWxzLmNyYzMyID0gZnVuY3Rpb24oZGF0YVZpZXcpIHtcbiAgICB2YXIgY3JjVGFibGUgPSBuaWZ0aS5VdGlscy5jcmNUYWJsZSB8fCAobmlmdGkuVXRpbHMuY3JjVGFibGUgPSBuaWZ0aS5VdGlscy5tYWtlQ1JDVGFibGUoKSk7XG4gICAgdmFyIGNyYyA9IDAgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVmlldy5ieXRlTGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gY3JjVGFibGVbKGNyYyBeIGRhdGFWaWV3LmdldFVpbnQ4KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSkgPj4+IDA7XG59O1xuXG5cblxuLyoqKiBFeHBvcnRzICoqKi9cblxudmFyIG1vZHVsZVR5cGUgPSB0eXBlb2YgbW9kdWxlO1xuaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5pZnRpLlV0aWxzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBsaW5lU2VwYXJhdG9yUkUgPSAvWyBcXGZcXHRcXHZdKlxccj9cXG4vO1xudmFyIE5SUkRNYWdpY1JFID0gL15OUlJEXFxkezR9JC87XG52YXIgbGluZVJFID0gL14oW146XSopKDpbID1dKSguKikkLztcbnZhciBkYXRhRmlsZUxpc3RSRSA9IC9eTElTVCg/OiAoXFxkKykpPyQvO1xuXG4vLyBUaGUgbWluaW1hbCBvYmplY3QgdGhpcyBhY2NlcHRzIGlzIGZvcm1lZCBsaWtlIHRoaXM6XG4vLyAgIHtkYXRhOiBTb21lVHlwZWRBcnJheSwgc2l6ZXM6IFsuLi5dfVxuLy8gT24gdGhlIG90aGVyIGhhbmQsIGlmIGRhdGEgaXMgbm90IGdpdmVuIGl0IG11c3QgaGF2ZSBhIGZvcm0gbGlrZSB0aGlzOlxuLy8gICB7YnVmZmVyOiBTb21lQXJyYXlCdWZmZXIsIHR5cGU6IC4uLiwgZW5kaWFuOiAuLi4sIHNpemVzOiBbLi4uXX1cbi8vIE9mIGNvdXJzZSwgaWYgJ3R5cGUnIGlzIGFuIDgtYml0IHR5cGUsIGVuZGlhbiBpcyBub3QgbmVlZGVkLCBhbmQgaWYgJ3R5cGUnIGVxdWFscyAnYmxvY2snLCAnYmxvY2tTaXplJyBzaG91bGQgYmUgc2V0IGluc3RlYWQgb2YgJ2VuZGlhbicuIEluIHRoaXMgY2FzZSwgbm8gaW50ZXJwcmV0YXRpb24gb2YgYnVmZmVyIGlzIGRvbmUgKGF0IGFsbCwgaXQgaXMgd3JpdHRlbiBzZXJpYWxpemVkIGRpcmVjdGx5IHRvIHRoZSBidWZmZXIpLlxuLy8gVE9ETzogRm9yIG5vdyB0aGlzIG9ubHkgc3VwcG9ydHMgc2VyaWFsaXppbmcgXCJpbmxpbmVcIiBmaWxlcywgb3IgZmlsZXMgZm9yIHdoaWNoIHlvdSBoYXZlIGFscmVhZHkgcHJlcGFyZWQgdGhlIGRhdGEuXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemUgPSBmdW5jdGlvbiAobnJyZE9yZykge1xuICAgIHZhciBpLCBidWZmZXIsIGFyciwgdG90YWxMZW4gPSAxLCBucnJkID0ge30sIHByb3AsIG5hdGl2ZVR5cGUsIG5hdGl2ZVNpemUsIGJ1ZmZlckRhdGEsIGFyckRhdGEsIGxpbmUsIGxpbmVzID0gW10sIGhlYWRlcjtcbiAgICBcbiAgICAvLyBDb3B5IG5ycmRPcmcgdG8gbnJyZCB0byBhbGxvdyBtb2RpZmljYXRpb25zIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIG9yaWdpbmFsXG4gICAgZm9yKHByb3AgaW4gbnJyZE9yZykge1xuICAgICAgICBucnJkW3Byb3BdID0gbnJyZE9yZ1twcm9wXTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIHNhdmluZyBmaWxlcyB3ZSBhbGxvdyBpbmZlcnJpbmcgY2VydGFpbiBpbmZvcm1hdGlvbiBpZiBpdCBpcyBub3QgZXhwbGljaXRseSBnaXZlbi5cbiAgICAvLyBBbHNvIHdlIG5vcm1hbGl6ZSBzb21lIGZpZWxkcyB0byBtYWtlIG91ciBvd24gbGl2ZXMgZWFzaWVyLlxuICAgIGlmIChucnJkLnNpemVzPT09dW5kZWZpbmVkKSB7IC8vICdzaXplcycgc2hvdWxkIEFMV0FZUyBiZSBnaXZlblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGltZW5zaW9uPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIG5ycmQuZGltZW5zaW9uID0gbnJyZC5zaXplcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiaW50OFwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJ1aW50OFwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJpbnQxNlwiO1xuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwidWludDE2XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgIG5hdGl2ZVR5cGUgPSBcImludDMyXCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJ1aW50MzJcIjtcbiAgICAvL30gZWxzZSBpZiAobnJyZC5kYXRhIGluc3RhbmNlb2YgSW50NjRBcnJheSkge1xuICAgIC8vICAgIG5hdGl2ZVR5cGUgPSBcImludDY0XCI7XG4gICAgLy99IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ2NEFycmF5KSB7XG4gICAgLy8gICAgbmF0aXZlVHlwZSA9IFwidWludDY0XCI7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgbmF0aXZlVHlwZSA9IFwiZmxvYXRcIjtcbiAgICB9IGVsc2UgaWYgKG5ycmQuZGF0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuICAgICAgICBuYXRpdmVUeXBlID0gXCJkb3VibGVcIjtcbiAgICB9XG4gICAgaWYgKG5ycmQudHlwZT09PXVuZGVmaW5lZCAmJiBuYXRpdmVUeXBlIT09dW5kZWZpbmVkKSB7XG4gICAgICAgIG5ycmQudHlwZSA9IG5hdGl2ZVR5cGU7XG4gICAgfSBlbHNlIGlmIChucnJkLnR5cGU9PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBvZiBkYXRhIGlzIG5vdCBnaXZlbiBhbmQgY2Fubm90IGJlIGluZmVycmVkIVwiKTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbnJyZC50eXBlKSA9PSBcInN0cmluZ1wiIHx8IG5ycmQudHlwZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICBucnJkLnR5cGUgPSBwYXJzZU5SUkRUeXBlKG5ycmQudHlwZSk7XG4gICAgfVxuICAgIGlmIChucnJkLmVuY29kaW5nPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIG5ycmQuZW5jb2RpbmcgPSBcInJhd1wiO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBucnJkLmVuY29kaW5nKSA9PSBcInN0cmluZ1wiIHx8IG5ycmQuZW5jb2RpbmcgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgbnJyZC5lbmNvZGluZyA9IHBhcnNlTlJSREVuY29kaW5nKG5ycmQuZW5jb2RpbmcpO1xuICAgIH1cbiAgICBpZiAobnJyZC5kYXRhICYmIG5ycmQudHlwZSAhPSAnYmxvY2snICYmIG5ycmQudHlwZSAhPSAnaW50OCcgJiYgbnJyZC50eXBlICE9ICd1aW50OCcgJiYgbnJyZC5lbmNvZGluZyAhPSAnYXNjaWknKSB7XG4gICAgICAgIG5ycmQuZW5kaWFuID0gc3lzdGVtRW5kaWFubmVzcztcbiAgICB9IGVsc2UgaWYgKG5ycmQudHlwZSA9PSAnYmxvY2snIHx8IG5ycmQudHlwZSA9PSAnaW50OCcgfHwgbnJyZC50eXBlID09ICd1aW50OCcgfHwgbnJyZC5lbmNvZGluZyA9PSAnYXNjaWknKSB7XG4gICAgICAgIG5ycmQuZW5kaWFuID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBucnJkLmVuZGlhbikgPT0gXCJzdHJpbmdcIiB8fCBucnJkLmVuZGlhbiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICBucnJkLmVuZGlhbiA9IHBhcnNlTlJSREVuZGlhbihucnJkLmVuZGlhbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBpbmZlciBzcGF0aWFsIGRpbWVuc2lvblxuICAgIHZhciBzcGFjZURpbWVuc2lvbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAobnJyZC5zcGFjZURpbWVuc2lvbiE9PXVuZGVmaW5lZCkge1xuICAgICAgICBzcGFjZURpbWVuc2lvbiA9IG5ycmQuc3BhY2VEaW1lbnNpb247XG4gICAgfSBlbHNlIGlmIChucnJkLnNwYWNlIT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaChucnJkLnNwYWNlKSB7XG4gICAgICAgIGNhc2UgXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvclwiOlxuICAgICAgICBjYXNlIFwiUkFTXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3JcIjpcbiAgICAgICAgY2FzZSBcIkxBU1wiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvclwiOlxuICAgICAgICBjYXNlIFwiTFBTXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgXHQgIGNhc2UgXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgIFx0ICBjYXNlIFwiUkFTVFwiOlxuICAgICBcdCAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgXHQgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgICAgICBjYXNlIFwiTEFTVFwiOlxuICAgICAgICAgICAgc3BhY2VEaW1lbnNpb24gPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvci10aW1lXCI6XG4gICAgICAgIGNhc2UgXCJMUFNUXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYW5uZXIteHl6XCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYW5uZXIteHl6LXRpbWVcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM0QtcmlnaHQtaGFuZGVkXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjNELWxlZnQtaGFuZGVkXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjNELXJpZ2h0LWhhbmRlZC10aW1lXCI6XG4gICAgICAgICAgICBzcGFjZURpbWVuc2lvbiA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjNELWxlZnQtaGFuZGVkLXRpbWVcIjpcbiAgICAgICAgICAgIHNwYWNlRGltZW5zaW9uID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIHNwYWNlOiBcIiArIG5ycmQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyBjaGVjayB0aGF0IHdlIGhhdmUgYSB2YWxpZCBucnJkIHN0cnVjdHVyZS5cbiAgICBjaGVja05SUkQobnJyZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIGVsZW1lbnRzIGFuZCBjaGVjayB0aGF0IHdlIGhhdmUgZW5vdWdoIGRhdGEgKGlmIHBvc3NpYmxlKVxuICAgIGZvcihpPTA7IGk8bnJyZC5zaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobnJyZC5zaXplc1tpXTw9MCkgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZXMgc2hvdWxkIGJlIGEgbGlzdCBvZiBwb3NpdGl2ZSAoPjApIGludGVnZXJzIVwiKTtcbiAgICAgICAgdG90YWxMZW4gKj0gbnJyZC5zaXplc1tpXTtcbiAgICB9XG4gICAgaWYgKG5ycmQuZGF0YSkge1xuICAgICAgICBpZiAobnJyZC5kYXRhLmxlbmd0aCA8IHRvdGFsTGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGRhdGEgdG8gc2VyaWFsaXplIVwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnJyZC5idWZmZXIpIHtcbiAgICAgICAgaWYgKG5ycmQuZW5jb2RpbmcgPT0gXCJyYXdcIikge1xuICAgICAgICAgICAgaWYgKG5ycmQudHlwZT09XCJibG9ja1wiICYmIG5ycmQuYmxvY2tTaXplIT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlU2l6ZSA9IG5ycmQuYmxvY2tTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVTaXplID0gZ2V0TlJSRFR5cGVTaXplKG5ycmQudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnJyZC5idWZmZXIuYnl0ZUxlbmd0aCA8IHRvdGFsTGVuKm5hdGl2ZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGRhdGEgdG8gc2VyaWFsaXplIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnJyZC5kYXRhRmlsZSkge1xuICAgICAgICAvLyBPa2F5LCBpZiB5b3UgaGF2ZSB5b3VyIGRhdGEgcmVhZHksIHdlJ2xsIGp1c3Qgd3JpdGUgYSBoZWFkZXIuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lsbCBub3Qgc2VyaWFsaXplIGFuIGVtcHR5IE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IGJ1ZmZlciBpbiBidWZmZXJEYXRhLlxuICAgIGlmIChucnJkLmRhdGEpIHtcbiAgICAgICAgc3dpdGNoKG5ycmQuZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgIGlmIChucnJkLnR5cGUgPT0gbmF0aXZlVHlwZSAmJiBucnJkLmVuZGlhbiA9PSBzeXN0ZW1FbmRpYW5uZXNzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IG5ycmQuZGF0YS5idWZmZXIuc2xpY2UobnJyZC5kYXRhLmJ5dGVPZmZzZXQsIG5ycmQuZGF0YS5ieXRlT2Zmc2V0K25ycmQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnJyZC5lbmRpYW4gPT0gc3lzdGVtRW5kaWFubmVzcykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBjYXN0VHlwZWRBcnJheShucnJkLmRhdGEsIG5ycmQudHlwZSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IGJ1ZmZlckRhdGEuYnVmZmVyLnNsaWNlKGJ1ZmZlckRhdGEuYnl0ZU9mZnNldCwgYnVmZmVyRGF0YS5ieXRlT2Zmc2V0K2J1ZmZlckRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBzZXJpYWxpemVUb0J1ZmZlcihucnJkLmRhdGEsIG5ycmQudHlwZSwgbnJyZC5lbmRpYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICAgIGlmIChucnJkLnR5cGUgPT0gbmF0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBzZXJpYWxpemVUb1RleHRCdWZmZXIobnJyZC5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRGF0YSA9IHNlcmlhbGl6ZVRvVGV4dEJ1ZmZlcihjYXN0VHlwZWRBcnJheShucnJkLmRhdGEsIG5ycmQudHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBOUlJEIGVuY29kaW5nOiBcIiArIG5ycmQuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChucnJkLmJ1ZmZlcikge1xuICAgICAgICBidWZmZXJEYXRhID0gbnJyZC5idWZmZXI7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IGhlYWRlclxuICAgIGxpbmVzLnB1c2goXCJOUlJEMDAwNVwiKTsgLy8gVE9ETzogQWRqdXN0IHZlcnNpb24gYmFzZWQgb24gZmVhdHVyZXMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZCBhbmQvb3IgdGhlIHZlcnNpb24gc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIChpZiBhbnkpLlxuICAgIGxpbmVzLnB1c2goXCIjIEdlbmVyYXRlZCBieSBucnJkLWpzXCIpO1xuICAgIFxuICAgIC8vIFB1dCBpbiBkaW1lbnNpb24gYW5kIHNwYWNlIGRpbWVuc2lvbiAodGhlIE5SUkQgc3BlYyByZXF1aXJlcyB0aGF0IHRoZXNlIGFyZSBwcmVzZW50IGJlZm9yZSBhbnkgbGlzdHMgd2hvc2UgbGVuZ3RoIGRlcGVuZHMgb24gdGhlbSlcbiAgICB2YXIgZmlyc3RQcm9wcyA9IFsnZGltZW5zaW9uJywgJ3NwYWNlRGltZW5zaW9uJywgJ3NwYWNlJ107XG4gICAgZm9yKGk9MDsgaTxmaXJzdFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBmaXJzdFByb3BzW2ldO1xuICAgICAgICBpZiAobnJyZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTsgLy8gU2tpcCB0aGluZ3Mgd2UgZXhwbGljaXRseSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICBsaW5lID0gc2VyaWFsaXplRmllbGQocHJvcCwgbnJyZFtwcm9wXSwgbnJyZC5kaW1lbnNpb24sIHNwYWNlRGltZW5zaW9uKTtcbiAgICAgICAgaWYgKGxpbmUhPT11bmRlZmluZWQpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBmaWVsZCBzcGVjaWZpY2F0aW9uc1xuICAgIGZvcihwcm9wIGluIG5ycmQpIHtcbiAgICAgICAgaWYgKG5ycmRbcHJvcF0gPT09IHVuZGVmaW5lZCkgY29udGludWU7IC8vIFNraXAgdGhpbmdzIHdlIGV4cGxpY2l0bHkgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKGZpcnN0UHJvcHMuaW5kZXhPZihwcm9wKT49MCkgY29udGludWU7IC8vIFNraXAgdGhlIGZpZWxkcyB3ZSBhbHJlYWR5IG91dHB1dC5cbiAgICAgICAgbGluZSA9IHNlcmlhbGl6ZUZpZWxkKHByb3AsIG5ycmRbcHJvcF0sIG5ycmQuZGltZW5zaW9uLCBzcGFjZURpbWVuc2lvbik7XG4gICAgICAgIGlmIChsaW5lIT09dW5kZWZpbmVkKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQdXQgaW4ga2V5cyAoaWYgYW55KVxuICAgIGlmIChucnJkLmtleXMpIGZvcihwcm9wIGluIG5ycmQua2V5cykge1xuICAgICAgICBpZiAocHJvcC5pbmRleE9mKFwiOj1cIik+PTApIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb21iaW5hdGlvbiAnOj0nIGlzIG5vdCBhbGxvd2VkIGluIGFuIE5SUkQga2V5IVwiKTtcbiAgICAgICAgbGluZXMucHVzaChwcm9wICsgXCI6PVwiICsgZXNjYXBlVmFsdWUobnJyZFtwcm9wXSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQdXQgaW4gZGF0YSBmaWxlIGxpc3QgKGlmIGFueSlcbiAgICBpZiAobnJyZC5kYXRhRmlsZSAmJiBucnJkLmRhdGFGaWxlLmxlbmd0aCkge1xuICAgICAgICBsaW5lcy5wdXNoKFwiZGF0YSBmaWxlOiBMSVNUXCIpO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaW5lcywgbnJyZC5kYXRhRmlsZSk7XG4gICAgfSBlbHNlIGlmIChucnJkLmRhdGFGaWxlICYmIG5ycmQuZGF0YUZpbGUuZmlsZXMgJiYgJ3N1YmRpbScgaW4gbnJyZC5kYXRhRmlsZSkge1xuICAgICAgICBsaW5lcy5wdXNoKFwiZGF0YSBmaWxlOiBMSVNUIFwiICsgbnJyZC5kYXRhRmlsZS5zdWJkaW0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaW5lcywgbnJyZC5kYXRhRmlsZS5maWxlcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFB1dCBpbiBlbXB0eSBsaW5lIGFuZCBpbmxpbmUgZGF0YSAoaWYgd2UgaGF2ZSBpbmxpbmUgZGF0YSkgYW5kIGNvbnZlcnQgbGluZXMgdG8gYnVmZmVyXG4gICAgaWYgKGJ1ZmZlckRhdGEgJiYgISgnZGF0YUZpbGUnIGluIG5ycmQpKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIGxpbmVzLnB1c2goXCJcIik7IC8vIFdlIGFjdHVhbGx5IG5lZWQgYW4gZXh0cmEgYmxhbmsgbGluZSB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIGlzIHRlcm1pbmF0ZWQuXG4gICAgICAgIGhlYWRlciA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihoZWFkZXIubGVuZ3RoICsgYnVmZmVyRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZm9yKGk9MDsgaTxoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFyckRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXJEYXRhKTtcbiAgICAgICAgYXJyLnNldChhcnJEYXRhLCBoZWFkZXIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKFwiXCIpOyAvLyBCbGFuayBsaW5lIHRvIGF0IGxlYXN0IHRlcm1pbmF0ZSB0aGUgbGFzdCBsaW5lLlxuICAgICAgICBoZWFkZXIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGZvcihpPTA7IGk8aGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gVGhpcyBleHBlY3RzIGFuIEFycmF5QnVmZmVyLlxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIGksIGhlYWRlciwgZGF0YVN0YXJ0LCByZXQgPSB7ZGF0YTogdW5kZWZpbmVkLyogcGFyc2VkIGRhdGEgKi8sIGJ1ZmZlcjogdW5kZWZpbmVkLyogcmF3IGJ1ZmZlciBob2xkaW5nIGRhdGEgKi8sIGtleXM6IHt9LCB2ZXJzaW9uOiB1bmRlZmluZWR9LFxuICAgICAgICBsaW5lcywgbWF0Y2gsIG1hdGNoMixcbiAgICAgICAgYnVmOCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICAvLyBBIHdvcmstYXJvdW5kIGZvciBpbmNvbXBhdGliaWxpdGllcyBiZXR3ZWVuIE5vZGUncyBCdWZmZXIgYW5kIEFycmF5QnVmZmVyLlxuICAgIGlmIChidWY4LmJ1ZmZlciAhPT0gYnVmZmVyKSBidWZmZXIgPSBidWY4LmJ1ZmZlcjtcblxuICAgIC8vIEZpcnN0IGZpbmQgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiB0aGUgaGVhZGVyIGFuZCB0aGUgZGF0YSAoaWYgdGhlcmUgaXMgb25lKVxuICAgIC8vIE5vdGUgdGhhdCB3ZSBuZWVkIHRvIGRlYWwgd2l0aCB3aXRoIExGIGFuZCBDUkxGIGFzIHBvc3NpYmxlIGxpbmUgZW5kaW5ncy5cbiAgICAvLyBMdWNraWx5IHRoaXMgbWVhbnMgdGhlIGxpbmUgYWx3YXlzIGVuZHMgd2l0aCBMRiwgc28gd2Ugb25seSBuZWVkIHRvIGNvbnNpZGVyXG4gICAgLy8gTEZMRiBhbmQgTEZDUkxGIGFzIHBhdHRlcm5zIGZvciB0aGUgc2VwYXJhdGluZyBlbXB0eSBsaW5lLlxuICAgIGk9MjsgLy8gSXQgaXMgc2FmZSB0byBzdGFydCBhdCBwb3NpdGlvbiAyIChpbiBmYWN0LCB3ZSBjb3VsZCBzdGFydCBldmVuIGxhdGVyKSwgYXMgdGhlIGZpbGUgSEFTIHRvIHN0YXJ0IHdpdGggYSBtYWdpYyB3b3JkLlxuICAgIHdoaWxlKGk8YnVmOC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGJ1ZjhbaV0gPT0gMTApIHsgLy8gV2UgaGl0IGFuIExGXG4gICAgICAgICAgICBpZiAoYnVmOFtpLTFdID09IDEwIHx8IChidWY4W2ktMV0gPT0gMTMgJiYgYnVmOFtpLTJdID09IDEwKSkgeyAvLyBTYWZlIGJlY2F1c2Ugd2Ugc3RhcnQgYXQgcG9zaXRpb24gMiBhbmQgbmV2ZXIgbW92ZSBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICBkYXRhU3RhcnQgPSBpKzE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKzsgLy8gTW92ZSBmb3J3YXJkIGp1c3Qgb25jZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJ1ZjhbaV0gPT0gMTMpIHsgLy8gV2UgaGl0IGEgQ1JcbiAgICAgICAgICAgIGkrKzsgLy8gTW92ZSBmb3J3YXJkIGp1c3Qgb25jZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSArPSAyOyAvLyBNb3ZlIGZvcndhcmQgdHdvIHBsYWNlcywgXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTm93IHNwbGl0IHVwIHRoZSBoZWFkZXIgYW5kIGRhdGFcbiAgICBpZiAoZGF0YVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVhZGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWY4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1Zjguc3ViYXJyYXkoMCxkYXRhU3RhcnQpKTtcbiAgICAgICAgcmV0LmJ1ZmZlciA9IGJ1ZmZlci5zbGljZShkYXRhU3RhcnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTcGxpdCBoZWFkZXIgaW50byBsaW5lcywgcmVtb3ZlIGNvbW1lbnRzIChhbmQgYmxhbmsgbGluZXMpIGFuZCBjaGVjayBtYWdpYy5cbiAgICAvLyBBbGwgcmVtYWluaW5nIGxpbmVzIGV4Y2VwdCB0aGUgZmlyc3Qgc2hvdWxkIGJlIGZpZWxkIHNwZWNpZmljYXRpb25zIG9yIGtleS92YWx1ZSBwYWlycy5cbiAgICAvLyBUT0RPOiBUaGlzIGV4cGxpY2l0bHkgcmVtb3ZlcyBhbnkgd2hpdGVzcGFjZSBhdCB0aGUgZW5kIG9mIGxpbmVzLCBob3dldmVyLCBJIGFtIG5vdCBzdXJlIHRoYXQgdGhpcyBpcyBhY3R1YWxseSBkZXNpcmVkIGJlaGF2aW91ciBmb3IgYWxsIGtpbmRzIG9mIGxpbmVzLlxuICAgIGxpbmVzID0gaGVhZGVyLnNwbGl0KGxpbmVTZXBhcmF0b3JSRSk7XG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwubGVuZ3RoPjAgJiYgbFswXSAhPSAnIyc7IH0pOyAvLyBSZW1vdmUgY29tbWVudCBsaW5lc1xuICAgIGlmICghTlJSRE1hZ2ljUkUudGVzdChsaW5lc1swXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBpcyBub3QgYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9XG4gICAgcmV0LnZlcnNpb24gPSBwYXJzZUludChsaW5lc1swXS5zdWJzdHJpbmcoNCwgOCksIDEwKTtcbiAgICBpZiAocmV0LnZlcnNpb24+NSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJSZWFkaW5nIGFuIHVuc3VwcG9ydGVkIHZlcnNpb24gb2YgdGhlIE5SUkQgZm9ybWF0OyB0aGluZ3MgbWF5IGdvIGhheXdpcmUuXCIpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGxpbmVzXG4gICAgZm9yKGk9MTsgaTxsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIGxpbmUgaW4gTlJSRCBoZWFkZXI6IFwiICsgbGluZXNbaV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzJdID09ICc6ICcpIHsgLy8gRmllbGQgc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXBOUlJEVG9KYXZhc2NyaXB0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmICggbWF0Y2hbMV0gPT0gJ2RhdGFGaWxlJyAmJlxuICAgICAgICAgICAgICAgICAobWF0Y2gyID0gZGF0YUZpbGVMaXN0UkUuZXhlYyhtYXRjaFszXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIGxhc3QgZmllbGQgc3BlY2lmaWNhdGlvbixcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIHJlc3Qgb2YgdGhlIGxpbmVzIHNob3VsZCBjb250YWluIGZpbGUgbmFtZXMuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoMi5sZW5ndGggPT0gMiAmJiBtYXRjaDJbMV0pIHsgLy8gc3ViZGltIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0W21hdGNoWzFdXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzOiBsaW5lcy5zbGljZShpKzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZGltOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoMlsxXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRbbWF0Y2hbMV1dID0gbGluZXMuc2xpY2UoaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZXMubGVuZ3RoID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0W21hdGNoWzFdXSA9IHBhcnNlRmllbGQobWF0Y2hbMV0sIG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSA9PSAnOj0nKSB7IC8vIEtleS92YWx1ZSBwYWlyXG4gICAgICAgICAgICByZXQua2V5c1ttYXRjaFsxXV0gPSB1bmVzY2FwZVZhbHVlKG1hdGNoWzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2ljIGVycm9yIGluIE5SUkQgcGFyc2VyLlwiKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuICh1bmxlc3MgdGhlIE5SUkQgc3ludGF4IGlzIGV4dGVuZGVkIGFuZCB0aGUgcmVnZXhwIGlzIHVwZGF0ZWQsIGJ1dCB0aGlzIHNlY3Rpb24gaXMgbm90LCBvciBzb21lIG90aGVyIHByb2dyYW1tZXIgZXJyb3IpLlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBmaWxlIHNhdGlzZmllcyB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZSBOUlJEIGZvcm1hdFxuICAgIGNoZWNrTlJSRChyZXQpO1xuICAgIFxuICAgIC8vIFwiUGFyc2VcIiBkYXRhXG4gICAgaWYgKCdkYXRhRmlsZScgaW4gcmV0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHN1cHBvcnQgZm9yIGV4dGVybmFsIGRhdGEgeWV0IVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2gocmV0LmVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICByZXQuZGF0YSA9IHBhcnNlTlJSRFJhd0RhdGEocmV0LmJ1ZmZlciwgcmV0LnR5cGUsIHJldC5zaXplcywge1xuICAgICAgICAgICAgICAgIGVuZGlhbjogcmV0LmVuZGlhbiwgYmxvY2tTaXplOiByZXQuYmxvY2tTaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgICByZXQuZGF0YSA9IHBhcnNlTlJSRFRleHREYXRhKHJldC5idWZmZXIsIHJldC50eXBlLCByZXQuc2l6ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBOUlJEIGVuY29kaW5nOiBcIiArIHJldC5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZVZhbHVlKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZVZhbHVlKHZhbCkge1xuICAgIHJldHVybiB2YWwuc3BsaXQoJ1xcXFxcXFxcJykubWFwKFxuICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoJ1xcXFxuJywgJ1xcbicpOyB9XG4gICAgICAgICkuam9pbignXFxcXCcpO1xufVxuXG4vLyBTZXJpYWxpemVzIE5SUkQgZmllbGRzXG5mdW5jdGlvbiBzZXJpYWxpemVGaWVsZChwcm9wLCB2YWx1ZSwgZGltZW5zaW9uLCBzcGFjZURpbWVuc2lvbikge1xuICAgIHZhciBsaW5lO1xuICAgIHZhciBwcm9wTlJSRCA9IG1hcEphdmFzY3JpcHRUb05SUkQocHJvcCk7XG4gICAgc3dpdGNoKHByb3ApIHtcbiAgICAvLyBucnJkLWpzIHN0dWZmOiBza2lwXG4gICAgY2FzZSAnZGF0YSc6XG4gICAgY2FzZSAnYnVmZmVyJzpcbiAgICBjYXNlICdrZXlzJzpcbiAgICBjYXNlICd2ZXJzaW9uJzpcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGl0ZXJhbCAodW5pbnRlcnByZXRlZCkgZmllbGRzXG4gICAgY2FzZSAnY29udGVudCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzYW1wbGVVbml0cyc6XG4gICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gSW50ZWdlcnMgKG5vIGluZmluaXR5IG9yIHdoYXRldmVyLCBqdXN0IGEgcGxhaW4gaW50ZWdlciwgc28gdGhlIGRlZmF1bHQgc2VyaWFsaXphdGlvbiBpcyBnb29kIGVub3VnaClcbiAgICBjYXNlICdibG9ja1NpemUnOlxuICAgIGNhc2UgJ2xpbmVTa2lwJzpcbiAgICBjYXNlICdieXRlU2tpcCc6XG4gICAgY2FzZSAnZGltZW5zaW9uJzpcbiAgICBjYXNlICdzcGFjZURpbWVuc2lvbic6XG4gICAgICAgIGFzc2VydCgodHlwZW9mIHZhbHVlKSA9PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBhdCBsZWFzdCBjb250YWluIGEgbnVtYmVyIVwiKTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIEZsb2F0cyAoZGVmYXVsdCBzZXJpYWxpemF0aW9uIGlzIGdvb2QgZW5vdWdoLCBhcyBOYU4gY29udGFpbnMgbmFuLCBpZ25vcmluZyBjYXNlLCBhbmQgc2ltaWxhcmx5IGZvciBJbmZpbml0eSBpbmYpXG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtYXgnOlxuICAgIGNhc2UgJ29sZE1pbic6XG4gICAgY2FzZSAnb2xkTWF4JzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGNvbnRhaW4gYSBudW1iZXIhXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gVmVjdG9yc1xuICAgIGNhc2UgJ3NwYWNlT3JpZ2luJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCA9PT0gc3BhY2VEaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgc3BhY2UgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJudW1iZXJcIiB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiAoXCIgKyB2YWx1ZS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiBzdHJpbmdzXG4gICAgY2FzZSAnbGFiZWxzJzpcbiAgICBjYXNlICd1bml0cyc6XG4gICAgY2FzZSAnc3BhY2VVbml0cyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkgeyBhc3NlcnQoKHR5cGVvZiB2YWwpID09IFwic3RyaW5nXCIgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgb2YgbnVtYmVycyFcIik7IH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5tYXAoc2VyaWFsaXplTlJSRFF1b3RlZFN0cmluZykuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIGludGVnZXJzXG4gICAgY2FzZSAnc2l6ZXMnOlxuICAgICAgICBhc3NlcnQodmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID09IGRpbWVuc2lvbiwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgYmUgYSBsaXN0IG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgbGluZSA9IHByb3BOUlJEICsgXCI6IFwiICsgdmFsdWUuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIGZsb2F0c1xuICAgIGNhc2UgJ3NwYWNpbmdzJzpcbiAgICBjYXNlICd0aGlja25lc3Nlcyc6XG4gICAgY2FzZSAnYXhpc01pbnMnOlxuICAgIGNhc2UgJ2F4aXNNYXhzJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PSBkaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJudW1iZXJcIiB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBMaXN0cyBvZiB2ZWN0b3JzIChkaW1lbnNpb24gc2l6ZWQpXG4gICAgY2FzZSAnc3BhY2VEaXJlY3Rpb25zJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZlYykge1xuICAgICAgICAgIGFzc2VydCh2ZWMgPT09IG51bGwgfHwgKHZlYy5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2ZWMubGVuZ3RoID09PSBzcGFjZURpbWVuc2lvbiksIFwiVGhlIGVsZW1lbnRzIG9mIGZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBsaXN0cyB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgc3BhY2UgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgICBpZiAodmVjICE9PSBudWxsKSB2ZWMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7IGFzc2VydCgodHlwZW9mIHZhbCkgPT0gXCJudW1iZXJcIiB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIsIFwiVGhlIGVsZW1lbnRzIG9mIGZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBsaXN0cyBvZiBudW1iZXJzIVwiKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZS5tYXAoZnVuY3Rpb24odmVjKSB7IHJldHVybiB2ZWMgPT09IG51bGwgPyBcIm5vbmVcIiA6IChcIihcIiArIHZlYy5qb2luKFwiLFwiKSArIFwiKVwiKTsgfSkuam9pbihcIiBcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHZlY3RvcnMgKHNwYWNlIGRpbWVuc2lvbiBzaXplZClcbiAgICBjYXNlICdtZWFzdXJlbWVudEZyYW1lJzpcbiAgICAgICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA9PT0gc3BhY2VEaW1lbnNpb24sIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGEgbGlzdCB3aXRoIGxlbmd0aCBlcXVhbCB0byB0aGUgc3BhY2UgZGltZW5zaW9uIVwiKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmVjKSB7XG4gICAgICAgICAgYXNzZXJ0KHZlYyA9PT0gbnVsbCB8fCAodmVjLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHZlYy5sZW5ndGggPT09IHNwYWNlRGltZW5zaW9uKSwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIHdpdGggbGVuZ3RoIGVxdWFsIHRvIHRoZSBzcGFjZSBkaW1lbnNpb24hXCIpO1xuICAgICAgICAgIGlmICh2ZWMgIT09IG51bGwpIHZlYy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHsgYXNzZXJ0KCh0eXBlb2YgdmFsKSA9PSBcIm51bWJlclwiIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlciwgXCJUaGUgZWxlbWVudHMgb2YgZmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGJlIGxpc3RzIG9mIG51bWJlcnMhXCIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChmdW5jdGlvbih2ZWMpIHsgcmV0dXJuIHZlYyA9PT0gbnVsbCA/IFwibm9uZVwiIDogKFwiKFwiICsgdmVjLmpvaW4oXCIsXCIpICsgXCIpXCIpOyB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gT25lLW9mLWEta2luZCBmaWVsZHNcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUpID09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcsIFwiRmllbGQgXCIgKyBwcm9wICsgXCIgc2hvdWxkIGNvbnRhaW4gYSBzdHJpbmchXCIpO1xuICAgICAgICBsaW5lID0gcHJvcE5SUkQgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5jb2RpbmcnOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZywgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIHN0cmluZyFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdlbmRpYW4nOlxuICAgICAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSkgPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZywgXCJGaWVsZCBcIiArIHByb3AgKyBcIiBzaG91bGQgY29udGFpbiBhIHN0cmluZyFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdkYXRhRmlsZSc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggfHwgKHZhbHVlLmZpbGVzICYmICdzdWJkaW0nIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gTGlzdCBvZiBkYXRhIGZpbGVzOiBza2lwIGZvciBub3dcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHNlcmlhbGl6ZU5SUkREYXRhRmlsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY2VudGVycyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChzZXJpYWxpemVOUlJET3B0aW9uYWwpLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdraW5kcyc6XG4gICAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPT0gZGltZW5zaW9uLCBcIkZpZWxkIFwiICsgcHJvcCArIFwiIHNob3VsZCBiZSBhIGxpc3Qgd2l0aCBsZW5ndGggZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiFcIik7XG4gICAgICAgIGxpbmUgPSBwcm9wTlJSRCArIFwiOiBcIiArIHZhbHVlLm1hcChzZXJpYWxpemVOUlJET3B0aW9uYWwpLmpvaW4oXCIgXCIpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBTb21ldGhpbmcgdW5rbm93blxuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGZpZWxkOiBcIiArIHByb3AgKyBcIiwgc2tpcHBpbmcuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuLy8gUGFyc2VzIGFuZCBub3JtYWxpemVzIE5SUkQgZmllbGRzLCBhc3N1bWVzIHRoZSBmaWVsZCBuYW1lcyBhcmUgYWxyZWFkeSBsb3dlciBjYXNlLlxuZnVuY3Rpb24gcGFyc2VGaWVsZChpZGVudGlmaWVyLCBkZXNjcmlwdG9yKSB7XG4gICAgc3dpdGNoKGlkZW50aWZpZXIpIHtcbiAgICAvLyBMaXRlcmFsICh1bmludGVycHJldGVkKSBmaWVsZHNcbiAgICBjYXNlICdjb250ZW50JzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3NhbXBsZVVuaXRzJzpcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gSW50ZWdlcnNcbiAgICBjYXNlICdkaW1lbnNpb24nOlxuICAgIGNhc2UgJ2Jsb2NrU2l6ZSc6XG4gICAgY2FzZSAnbGluZVNraXAnOlxuICAgIGNhc2UgJ2J5dGVTa2lwJzpcbiAgICBjYXNlICdzcGFjZURpbWVuc2lvbic6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRJbnRlZ2VyKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBGbG9hdHNcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ21heCc6XG4gICAgY2FzZSAnb2xkTWluJzpcbiAgICBjYXNlICdvbGRNYXgnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJERmxvYXQoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIFZlY3RvcnNcbiAgICBjYXNlICdzcGFjZU9yaWdpbic6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRWZWN0b3IoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIHN0cmluZ3NcbiAgICBjYXNlICdsYWJlbHMnOlxuICAgIGNhc2UgJ3VuaXRzJzpcbiAgICBjYXNlICdzcGFjZVVuaXRzJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSRFF1b3RlZFN0cmluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIGludGVnZXJzXG4gICAgY2FzZSAnc2l6ZXMnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEV2hpdGVzcGFjZVNlcGFyYXRlZExpc3QoZGVzY3JpcHRvciwgcGFyc2VOUlJESW50ZWdlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIC8vIExpc3RzIG9mIGZsb2F0c1xuICAgIGNhc2UgJ3NwYWNpbmdzJzpcbiAgICBjYXNlICd0aGlja25lc3Nlcyc6XG4gICAgY2FzZSAnYXhpc01pbnMnOlxuICAgIGNhc2UgJ2F4aXNNYXhzJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSREZsb2F0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gTGlzdHMgb2YgdmVjdG9yc1xuICAgIGNhc2UgJ3NwYWNlRGlyZWN0aW9ucyc6XG4gICAgY2FzZSAnbWVhc3VyZW1lbnRGcmFtZSc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChkZXNjcmlwdG9yLCBwYXJzZU5SUkRWZWN0b3IpO1xuICAgICAgICBicmVhaztcbiAgICAvLyBPbmUtb2YtYS1raW5kIGZpZWxkc1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJEVHlwZShkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5jb2RpbmcnOlxuICAgICAgICBkZXNjcmlwdG9yID0gcGFyc2VOUlJERW5jb2RpbmcoZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZGlhbic6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRFbmRpYW4oZGVzY3JpcHRvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RhdGFGaWxlJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRERhdGFGaWxlKGRlc2NyaXB0b3IpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdjZW50ZXJzJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSRENlbnRlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2tpbmRzJzpcbiAgICAgICAgZGVzY3JpcHRvciA9IHBhcnNlTlJSRFdoaXRlc3BhY2VTZXBhcmF0ZWRMaXN0KGRlc2NyaXB0b3IsIHBhcnNlTlJSREtpbmQpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSBwYXJzZU5SUkRTcGFjZShkZXNjcmlwdG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gU29tZXRoaW5nIHVua25vd25cbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnJlY29nbml6ZWQgTlJSRCBmaWVsZDogXCIgKyBpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbi8vIFRoaXMgb25seSBpbmNsdWRlcyBuYW1lcyB3aG9zZSBsb3dlciBjYXNlIGZvcm0gaXMgZGlmZmVyZW50IGZyb20gdGhlIEphdmFzY3JpcHQgZm9ybS5cbnZhciBtYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljID0ge1xuICAgICdibG9jayBzaXplJzogJ2Jsb2NrU2l6ZScsXG4gICAgJ2Jsb2Nrc2l6ZSc6ICdibG9ja1NpemUnLFxuICAgICdvbGQgbWluJzogJ29sZE1pbicsXG4gICAgJ29sZG1pbic6ICdvbGRNaW4nLFxuICAgICdvbGQgbWF4JzogJ29sZE1heCcsXG4gICAgJ29sZG1heCc6ICdvbGRNYXgnLFxuICAgICdkYXRhIGZpbGUnOiAnZGF0YUZpbGUnLFxuICAgICdkYXRhZmlsZSc6ICdkYXRhRmlsZScsXG4gICAgJ2xpbmUgc2tpcCc6ICdsaW5lU2tpcCcsXG4gICAgJ2xpbmVza2lwJzogJ2xpbmVTa2lwJyxcbiAgICAnYnl0ZSBza2lwJzogJ2J5dGVTa2lwJyxcbiAgICAnYnl0ZXNraXAnOiAnYnl0ZVNraXAnLFxuICAgICdzYW1wbGUgdW5pdHMnOiAnc2FtcGxlVW5pdHMnLFxuICAgICdzYW1wbGV1bml0cyc6ICdzYW1wbGVVbml0cycsXG4gICAgJ2F4aXMgbWlucyc6ICdheGlzTWlucycsXG4gICAgJ2F4aXMgbWF4cyc6ICdheGlzTWF4cycsXG4gICAgJ2NlbnRlcnMnOiAnY2VudGVycycsIC8vIE5vdCBkaWZmZXJlbnQsIGp1c3QgaW5jbHVkZWQgc28gaXQgaXMgY2xlYXIgd2h5IGNlbnRlcmluZ3MgbWFwcyB0byBjZW50ZXJzXG4gICAgJ2NlbnRlcmluZ3MnOiAnY2VudGVycycsXG4gICAgJ3NwYWNlIGRpbWVuc2lvbic6ICdzcGFjZURpbWVuc2lvbicsXG4gICAgJ3NwYWNlIHVuaXRzJzogJ3NwYWNlVW5pdHMnLFxuICAgICdzcGFjZSBvcmlnaW4nOiAnc3BhY2VPcmlnaW4nLFxuICAgICdzcGFjZSBkaXJlY3Rpb25zJzogJ3NwYWNlRGlyZWN0aW9ucycsXG4gICAgJ21lYXN1cmVtZW50IGZyYW1lJzogJ21lYXN1cmVtZW50RnJhbWUnXG59O1xudmFyIG1hcEphdmFzY3JpcHRUb05SUkRTdGF0aWMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkLCBtID0ge307XG4gIGZvcihpZCBpbiBtYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljKSB7XG4gICAgbVttYXBOUlJEVG9KYXZhc2NyaXB0U3RhdGljW2lkXV0gPSBpZDtcbiAgfVxuICByZXR1cm4gbTtcbn0oKTtcbmZ1bmN0aW9uIG1hcE5SUkRUb0phdmFzY3JpcHQoaWQpIHtcbiAgICAvLyBJbiBhbnkgY2FzZSwgdXNlIHRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgdGhlIGlkXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIEZpbHRlciBvdXQgYW55IGZpZWxkcyBmb3Igd2hpY2ggd2UgaGF2ZSBhbiBleHBsaWNpdCBKYXZhc2NyaXB0IG5hbWVcbiAgICBpZiAoaWQgaW4gbWFwTlJSRFRvSmF2YXNjcmlwdFN0YXRpYykgcmV0dXJuIG1hcE5SUkRUb0phdmFzY3JpcHRTdGF0aWNbaWRdO1xuICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIChsb3dlciBjYXNlKSBpZFxuICAgIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIG1hcEphdmFzY3JpcHRUb05SUkQoaWQpIHtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBmaWVsZHMgZm9yIHdoaWNoIHdlIGhhdmUgYW4gZXhwbGljaXQgTlJSRCBuYW1lXG4gICAgaWYgKGlkIGluIG1hcEphdmFzY3JpcHRUb05SUkRTdGF0aWMpIHJldHVybiBtYXBKYXZhc2NyaXB0VG9OUlJEU3RhdGljW2lkXTtcbiAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIHRoZSBpZFxuICAgIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJESW50ZWdlcihzdHIpIHtcbiAgICB2YXIgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWwpKSB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgTlJSRCBpbnRlZ2VyOiBcIiArIHN0cik7XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJERmxvYXQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHN0ci5pbmRleE9mKCduYW4nKT49MCkgcmV0dXJuIE5hTjtcbiAgICBpZiAoc3RyLmluZGV4T2YoJy1pbmYnKT49MCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ2luZicpPj0wKSByZXR1cm4gSW5maW5pdHk7XG4gICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbCkpIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBOUlJEIGZsb2F0OiBcIiArIHN0cik7XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEVmVjdG9yKHN0cikge1xuICAgIGlmIChzdHIgPT0gXCJub25lXCIpIHJldHVybiBudWxsO1xuICAgIGlmIChzdHIubGVuZ3RoPDIgfHwgc3RyWzBdIT09XCIoXCIgfHwgc3RyW3N0ci5sZW5ndGgtMV0hPT1cIilcIikgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIE5SUkQgdmVjdG9yOiBcIiArIHN0cik7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcChwYXJzZU5SUkRGbG9hdCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFF1b3RlZFN0cmluZyhzdHIpIHtcbiAgICBpZiAobGVuZ3RoPDIgfHwgc3RyWzBdIT0nXCInIHx8IHN0cltzdHIubGVuZ3RoLTFdIT0nXCInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTlJSRCBxdW90ZWQgc3RyaW5nOiBcIiArIHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMSwgLTEpLnJlcGxhY2UoJ1xcXFxcIicsICdcIicpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOUlJEUXVvdGVkU3RyaW5nKHN0cikge1xuICAgIHJldHVybiAnXCInICsgc3RyLnJlcGxhY2UoJ1wiJywgJ1xcXFxcIicpICsgJ1wiJztcbn1cblxudmFyIHdoaXRlc3BhY2VMaXN0U2VwYXJhdG9yID0gL1sgXFx0XSsvOyAvLyBOb3RlIHRoYXQgdGhpcyBleGNsdWRlcyBvdGhlciB0eXBlcyBvZiB3aGl0ZXNwYWNlIG9uIHB1cnBvc2UhXG5mdW5jdGlvbiBwYXJzZU5SUkRXaGl0ZXNwYWNlU2VwYXJhdGVkTGlzdChzdHIsIHBhcnNlRWxlbWVudCkge1xuICAgIHJldHVybiBzdHIuc3BsaXQod2hpdGVzcGFjZUxpc3RTZXBhcmF0b3IpLm1hcChwYXJzZUVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5SUkRUeXBlKGRlc2NyaXB0b3IpIHtcbiAgICBzd2l0Y2goZGVzY3JpcHRvci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInNpZ25lZCBjaGFyXCI6XG4gICAgY2FzZSBcImludDhcIjpcbiAgICBjYXNlIFwiaW50OF90XCI6XG4gICAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBcInVjaGFyXCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIGNoYXJcIjpcbiAgICBjYXNlIFwidWludDhcIjpcbiAgICBjYXNlIFwidWludDhfdFwiOlxuICAgICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICBjYXNlIFwic2hvcnQgaW50XCI6XG4gICAgY2FzZSBcInNpZ25lZCBzaG9ydFwiOlxuICAgIGNhc2UgXCJzaWduZWQgc2hvcnQgaW50XCI6XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgY2FzZSBcImludDE2X3RcIjpcbiAgICAgICAgcmV0dXJuICdpbnQxNic7XG4gICAgY2FzZSBcInVzaG9ydFwiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBzaG9ydFwiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBzaG9ydCBpbnRcIjpcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgY2FzZSBcInVpbnQxNl90XCI6XG4gICAgICAgIHJldHVybiAndWludDE2JztcbiAgICBjYXNlIFwiaW50XCI6XG4gICAgY2FzZSBcInNpZ25lZCBpbnRcIjpcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICBjYXNlIFwiaW50MzJfdFwiOlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICBjYXNlIFwidWludFwiOlxuICAgIGNhc2UgXCJ1bnNpZ25lZCBpbnRcIjpcbiAgICBjYXNlIFwidWludDMyXCI6XG4gICAgY2FzZSBcInVpbnQzMl90XCI6XG4gICAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIFwibG9uZ2xvbmdcIjpcbiAgICBjYXNlIFwibG9uZyBsb25nXCI6XG4gICAgY2FzZSBcImxvbmcgbG9uZyBpbnRcIjpcbiAgICBjYXNlIFwic2lnbmVkIGxvbmcgbG9uZ1wiOlxuICAgIGNhc2UgXCJzaWduZWQgbG9uZyBsb25nIGludFwiOlxuICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgIGNhc2UgXCJpbnQ2NF90XCI6XG4gICAgICAgIHJldHVybiAnaW50NjQnO1xuICAgIGNhc2UgXCJ1bG9uZ2xvbmdcIjpcbiAgICBjYXNlIFwidW5zaWduZWQgbG9uZyBsb25nXCI6XG4gICAgY2FzZSBcInVuc2lnbmVkIGxvbmcgbG9uZyBpbnRcIjpcbiAgICBjYXNlIFwidWludDY0XCI6XG4gICAgY2FzZSBcInVpbnQ2NF90XCI6XG4gICAgICAgIHJldHVybiAndWludDY0JztcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuICdmbG9hdCc7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICByZXR1cm4gJ2RvdWJsZSc7XG4gICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIHR5cGU6IFwiICsgZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJERW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBzd2l0Y2goZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgICAgcmV0dXJuIFwicmF3XCI7XG4gICAgY2FzZSBcInR4dFwiOlxuICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgIHJldHVybiBcImFzY2lpXCI7XG4gICAgY2FzZSBcImhleFwiOlxuICAgICAgICByZXR1cm4gXCJoZXhcIjtcbiAgICBjYXNlIFwiZ3pcIjpcbiAgICBjYXNlIFwiZ3ppcFwiOlxuICAgICAgICByZXR1cm4gXCJnemlwXCI7XG4gICAgY2FzZSBcImJ6MlwiOlxuICAgIGNhc2UgXCJiemlwMlwiOlxuICAgICAgICByZXR1cm4gXCJiemlwMlwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGVuY29kaW5nOiBcIiArIGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEU3BhY2Uoc3BhY2UpIHtcbiAgICBzd2l0Y2goc3BhY2UudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJyaWdodC1hbnRlcmlvci1zdXBlcmlvclwiOlxuICAgIGNhc2UgXCJyYXNcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3JcIjtcbiAgICBjYXNlIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvclwiOlxuICAgIGNhc2UgXCJsYXNcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1hbnRlcmlvci1zdXBlcmlvclwiO1xuICAgIGNhc2UgXCJsZWZ0LXBvc3Rlcmlvci1zdXBlcmlvclwiOlxuICAgIGNhc2UgXCJscHNcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3JcIjtcbiBcdCAgY2FzZSBcInJpZ2h0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiBcdCAgY2FzZSBcInJhc3RcIjpcbiAgICAgICAgcmV0dXJuIFwicmlnaHQtYW50ZXJpb3Itc3VwZXJpb3ItdGltZVwiO1xuICAgIGNhc2UgXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjpcbiAgICBjYXNlIFwibGFzdFwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0LWFudGVyaW9yLXN1cGVyaW9yLXRpbWVcIjtcbiAgICBjYXNlIFwibGVmdC1wb3N0ZXJpb3Itc3VwZXJpb3ItdGltZVwiOlxuICAgIGNhc2UgXCJscHN0XCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtcG9zdGVyaW9yLXN1cGVyaW9yLXRpbWVcIjtcbiAgICBjYXNlIFwic2Nhbm5lci14eXpcIjpcbiAgICAgICAgcmV0dXJuIFwic2Nhbm5lci14eXpcIjtcbiAgICBjYXNlIFwic2Nhbm5lci14eXotdGltZVwiOlxuICAgICAgICByZXR1cm4gXCJzY2FubmVyLXh5ei10aW1lXCI7XG4gICAgY2FzZSBcIjNkLXJpZ2h0LWhhbmRlZFwiOlxuICAgICAgICByZXR1cm4gXCIzRC1yaWdodC1oYW5kZWRcIjtcbiAgICBjYXNlIFwiM2QtbGVmdC1oYW5kZWRcIjpcbiAgICAgICAgcmV0dXJuIFwiM0QtbGVmdC1oYW5kZWRcIjtcbiAgICBjYXNlIFwiM2QtcmlnaHQtaGFuZGVkLXRpbWVcIjpcbiAgICAgICAgcmV0dXJuIFwiM0QtcmlnaHQtaGFuZGVkLXRpbWVcIjtcbiAgICBjYXNlIFwiM2QtbGVmdC1oYW5kZWQtdGltZVwiOlxuICAgICAgICByZXR1cm4gXCIzRC1sZWZ0LWhhbmRlZC10aW1lXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIHNwYWNlOiBcIiArIHNwYWNlKTtcbiAgICAgICAgcmV0dXJuIHNwYWNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJERW5kaWFuKGVuZGlhbikge1xuICAgIHN3aXRjaChlbmRpYW4udG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2xpdHRsZSc6XG4gICAgICAgIHJldHVybiAnbGl0dGxlJztcbiAgICBjYXNlICdiaWcnOlxuICAgICAgICByZXR1cm4gJ2JpZyc7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQgZW5kaWFubmVzczogXCIgKyBlbmRpYW4pO1xuICAgICAgICByZXR1cm4gZW5kaWFuO1xuICAgIH1cbn1cblxuLy8gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBuZXZlciBlbmNvdW50ZXIgdGhlIExJU1QgZGF0YSBmaWxlIHNwZWNpZmljYXRpb24gZm9ybWF0LCBhcyB0aGlzIGlzIGhhbmRsZWQgZWxzZXdoZXJlLlxudmFyIGRhdGFGaWxlRm9ybWF0UkUgPSAvICgtP1xcZCspICgtP1xcZCspICgtP1xcZCspKD86IChcXGQrKSk/JC87XG5mdW5jdGlvbiBwYXJzZU5SUkREYXRhRmlsZShkYXRhRmlsZSkge1xuICAgIHZhciBtYXRjaCA9IGRhdGFGaWxlRm9ybWF0UkUuZXhlYyhkYXRhRmlsZSk7XG4gICAgaWYgKG1hdGNoKSB7IC8vIFdlIGhhdmUgYSBmb3JtYXQgc3BlY2lmaWNhdGlvblxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09IDUgJiYgbWF0Y2hbNF0pIHsgLy8gc3ViZGltIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkYXRhRmlsZS5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpLFxuICAgICAgICAgICAgICAgIG1pbjogcGFyc2VOUlJESW50ZWdlcihtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgbWF4OiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBzdGVwOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzNdKSxcbiAgICAgICAgICAgICAgICBzdWJkaW06IHBhcnNlTlJSREludGVnZXIobWF0Y2hbNF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRhdGFGaWxlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCksXG4gICAgICAgICAgICAgICAgbWluOiBwYXJzZU5SUkRJbnRlZ2VyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHBhcnNlTlJSREludGVnZXIobWF0Y2hbM10pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHsgLy8gSnVzdCBhIGZpbGVcbiAgICAgICAgcmV0dXJuIGRhdGFGaWxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTlJSRERhdGFGaWxlKGRhdGFGaWxlKSB7XG4gICAgaWYgKCh0eXBlb2YgZGF0YUZpbGUpID09IFwic3RyaW5nXCIgfHwgZGF0YUZpbGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFGaWxlO1xuICAgIH0gZWxzZSBpZiAoJ2Zvcm1hdCcgaW4gZGF0YUZpbGUgJiYgJ21pbicgaW4gZGF0YUZpbGUgJiYgJ21heCcgaW4gZGF0YUZpbGUgJiYgJ3N0ZXAnIGluIGRhdGFGaWxlKSB7XG4gICAgICAgIGlmICgnc3ViZGltJyBpbiBkYXRhRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFGaWxlLmZvcm1hdCArIFwiIFwiICsgZGF0YUZpbGUubWluICsgXCIgXCIgKyBkYXRhRmlsZS5tYXggKyBcIiBcIiArIGRhdGFGaWxlLnN0ZXAgKyBcIiBcIiArIGRhdGFGaWxlLnN1YmRpbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhRmlsZS5mb3JtYXQgKyBcIiBcIiArIGRhdGFGaWxlLm1pbiArIFwiIFwiICsgZGF0YUZpbGUubWF4ICsgXCIgXCIgKyBkYXRhRmlsZS5zdGVwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGRhdGEgZmlsZSBmb3JtYXQhXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VOUlJEQ2VudGVyKGNlbnRlcikge1xuICAgIHN3aXRjaChjZW50ZXIudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJjZWxsXCI6XG4gICAgICAgIHJldHVybiBcImNlbGxcIjtcbiAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgICByZXR1cm4gXCJub2RlXCI7XG4gICAgY2FzZSBcIj8/P1wiOlxuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBOUlJEIGNlbnRlcjogXCIgKyBjZW50ZXIpO1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgIH1cbn1cblxudmFyIE5SUkRLaW5kcyA9IHtcbiAgICBcImRvbWFpblwiOiBcImRvbWFpblwiLFxuICAgIFwic3BhY2VcIjogXCJzcGFjZVwiLFxuICAgIFwidGltZVwiOiBcInRpbWVcIixcbiAgICBcImxpc3RcIjogXCJsaXN0XCIsXG4gICAgXCJwb2ludFwiOiBcInBvaW50XCIsXG4gICAgXCJ2ZWN0b3JcIjogXCJ2ZWN0b3JcIixcbiAgICBcImNvdmFyaWFudC12ZWN0b3JcIjogXCJjb3ZhcmlhbnQtdmVjdG9yXCIsXG4gICAgXCJub3JtYWxcIjogXCJub3JtYWxcIixcbiAgICBcInN0dWJcIjogXCJzdHViXCIsXG4gICAgXCJzY2FsYXJcIjogXCJzY2FsYXJcIixcbiAgICBcImNvbXBsZXhcIjogXCJjb21wbGV4XCIsXG4gICAgXCIyLXZlY3RvclwiOiBcIjItdmVjdG9yXCIsXG4gICAgXCIzLWNvbG9yXCI6IFwiMy1jb2xvclwiLFxuICAgIFwicmdiLWNvbG9yXCI6IFwiUkdCLWNvbG9yXCIsXG4gICAgXCJoc3YtY29sb3JcIjogXCJIU1YtY29sb3JcIixcbiAgICBcInh5ei1jb2xvclwiOiBcIlhZWi1jb2xvclwiLFxuICAgIFwiNC1jb2xvclwiOiBcIjQtY29sb3JcIixcbiAgICBcInJnYmEtY29sb3JcIjogXCJSR0JBLWNvbG9yXCIsXG4gICAgXCIzLXZlY3RvclwiOiBcIjMtdmVjdG9yXCIsXG4gICAgXCIzLWdyYWRpZW50XCI6IFwiMy1ncmFkaWVudFwiLFxuICAgIFwiMy1ub3JtYWxcIjogXCIzLW5vcm1hbFwiLFxuICAgIFwiNC12ZWN0b3JcIjogXCI0LXZlY3RvclwiLFxuICAgIFwicXVhdGVybmlvblwiOiBcInF1YXRlcm5pb25cIixcbiAgICBcIjJkLXN5bW1ldHJpYy1tYXRyaXhcIjogXCIyRC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIyZC1tYXNrZWQtc3ltbWV0cmljLW1hdHJpeFwiOiBcIjJELW1hc2tlZC1zeW1tZXRyaWMtbWF0cml4XCIsXG4gICAgXCIyZC1tYXRyaXhcIjogXCIyRC1tYXRyaXhcIixcbiAgICBcIjJkLW1hc2tlZC1tYXRyaXhcIjogXCIyRC1tYXNrZWQtbWF0cml4XCIsXG4gICAgXCIzZC1zeW1tZXRyaWMtbWF0cml4XCI6IFwiM0Qtc3ltbWV0cmljLW1hdHJpeFwiLFxuICAgIFwiM2QtbWFza2VkLXN5bW1ldHJpYy1tYXRyaXhcIjogXCIzRC1tYXNrZWQtc3ltbWV0cmljLW1hdHJpeFwiLFxuICAgIFwiM2QtbWF0cml4XCI6IFwiM0QtbWF0cml4XCIsXG4gICAgXCIzZC1tYXNrZWQtbWF0cml4XCI6IFwiM0QtbWFza2VkLW1hdHJpeFwiLFxuICAgIFwiPz8/XCI6IG51bGwsXG4gICAgXCJub25lXCI6IG51bGxcbn07XG5mdW5jdGlvbiBwYXJzZU5SUkRLaW5kKGtpbmQpIHtcbiAgICB2YXIga2luZExDID0ga2luZC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChraW5kTEMgaW4gTlJSREtpbmRzKSByZXR1cm4gTlJSREtpbmRzW2tpbmRMQ107XG4gICAgY29uc29sZS53YXJuKFwiVW5yZWNvZ25pemVkIE5SUkQga2luZDogXCIgKyBraW5kKTtcbiAgICByZXR1cm4ga2luZDtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTlJSRE9wdGlvbmFsKGEpIHtcbiAgICByZXR1cm4gYT09PW51bGwgPyBcIj8/P1wiIDogYTtcbn1cblxudmFyIHN5c3RlbUVuZGlhbm5lc3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0KSxcbiAgICAgICAgaW50QXJyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZiksXG4gICAgICAgIGJ5dGVBcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGludEFyclswXSA9IDB4MDEwMjAzMDQ7XG4gICAgaWYgKGJ5dGVBcnJbMF09PTEgJiYgYnl0ZUFyclsxXT09MiAmJiBieXRlQXJyWzJdPT0zICYmIGJ5dGVBcnJbM109PTQpIHtcbiAgICAgICAgcmV0dXJuICdiaWcnO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUFyclswXT09NCAmJiBieXRlQXJyWzFdPT0zICYmIGJ5dGVBcnJbMl09PTIgJiYgYnl0ZUFyclszXT09MSkge1xuICAgICAgICByZXR1cm4gJ2xpdHRsZSc7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIlVucmVjb2duaXplZCBzeXN0ZW0gZW5kaWFubmVzcyFcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn0pKCk7XG5cbmZ1bmN0aW9uIHBhcnNlTlJSRFJhd0RhdGEoYnVmZmVyLCB0eXBlLCBzaXplcywgb3B0aW9ucykge1xuICAgIHZhciBpLCBhcnIsIHZpZXcsIHRvdGFsTGVuID0gMSwgZW5kaWFuRmxhZztcbiAgICBmb3IoaT0wOyBpPHNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzaXplc1tpXTw9MCkgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZXMgc2hvdWxkIGJlIGEgbGlzdCBvZiBwb3NpdGl2ZSAoPjApIGludGVnZXJzIVwiKTtcbiAgICAgICAgdG90YWxMZW4gKj0gc2l6ZXNbaV07XG4gICAgfVxuICAgIGlmICh0eXBlID09ICdibG9jaycpIHtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgc3BlY2lhbCwganVzdCByZXR1cm4gdGhlIHNsaWNlIGNvbnRhaW5pbmcgYWxsIGJsb2Nrcy5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKm9wdGlvbnMuYmxvY2tTaXplKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2ludDgnIHx8IHR5cGUgPT0gJ3VpbnQ4JyB8fCBvcHRpb25zLmVuZGlhbiA9PSBzeXN0ZW1FbmRpYW5uZXNzKSB7XG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgICAgICBjaGVja1NpemUoMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbikpO1xuICAgICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbikpO1xuICAgICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSgyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbioyKSk7XG4gICAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSgyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qMikpO1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSg0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio0KSk7XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSg0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qNCkpO1xuICAgICAgICAvL2Nhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAvLyAgICBjaGVja1NpemUoOCk7XG4gICAgICAgIC8vICAgIHJldHVybiBuZXcgSW50NjRBcnJheShidWZmZXIuc2xpY2UoMCx0b3RhbExlbio4KSk7XG4gICAgICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAvLyAgICBjaGVja1NpemUoOCk7XG4gICAgICAgIC8vICAgIHJldHVybiBuZXcgVWludDY0QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qOCkpO1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGNoZWNrU2l6ZSg0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5zbGljZSgwLHRvdGFsTGVuKjQpKTtcbiAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2hlY2tTaXplKDgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLnNsaWNlKDAsdG90YWxMZW4qOCkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgTlJSRCB0eXBlOiBcIiArIHR5cGUgKyBcIiwgcmV0dXJuaW5nIHJhdyBidWZmZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChvcHRpb25zLmVuZGlhbikge1xuICAgICAgICBjYXNlICdiaWcnOlxuICAgICAgICAgICAgZW5kaWFuRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpdHRsZSc6XG4gICAgICAgICAgICBlbmRpYW5GbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgZW5kaWFubmVzcyBpbiBOUlJEIGZpbGU6IFwiICsgb3B0aW9ucy5lbmRpYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnQ4XCI6IC8vIE5vdGUgdGhhdCBoZXJlIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIHRoZSBzaXplIG9mIHRoZSBidWZmZXIsIGFzIHRoZSBEYXRhVmlldy5nZXQgbWV0aG9kcyBzaG91bGQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlIHJlYWQgYmV5b25kIHRoZSBidWZmZXIuXG4gICAgICAgICAgICBhcnIgPSBuZXcgSW50OEFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0SW50OChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRVaW50OChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDE2QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRJbnQxNihpKjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQxNkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0VWludDE2KGkqMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQzMkFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8dG90YWxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IHZpZXcuZ2V0SW50MzIoaSo0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBVaW50MzJBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldFVpbnQzMihpKjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAgICAgLy8gICAgYXJyID0gbmV3IEludDY0QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAvLyAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgIGFycltpXSA9IHZpZXcuZ2V0SW50NjQoaSo4KTtcbiAgICAgICAgLy8gICAgfVxuICAgICAgICAvLyAgICByZXR1cm4gYXJyO1xuICAgICAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgLy8gICAgYXJyID0gbmV3IFVpbnQ2NEFycmF5KHRvdGFsTGVuKTtcbiAgICAgICAgLy8gICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgIC8vICAgICAgICBhcnJbaV0gPSB2aWV3LmdldFVpbnQ2NChpKjgpO1xuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgYXJyID0gbmV3IEZsb2F0MzJBcnJheSh0b3RhbExlbik7XG4gICAgICAgICAgICBmb3IoaT0wOyBpPHRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSB2aWV3LmdldEZsb2F0MzIoaSo0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGFyciA9IG5ldyBGbG9hdDY0QXJyYXkodG90YWxMZW4pO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTx0b3RhbExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gdmlldy5nZXRGbG9hdDY0KGkqOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgTlJSRCB0eXBlOiBcIiArIHR5cGUgKyBcIiwgcmV0dXJuaW5nIHJhdyBidWZmZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1NpemUoc2l6ZU9mVHlwZSkge1xuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGg8dG90YWxMZW4qc2l6ZU9mVHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiTlJSRCBmaWxlIGRvZXMgbm90IGNvbnRhaW4gZW5vdWdoIGRhdGEhXCIpO1xuICAgIH1cbn1cblxudmFyIHdoaXRlc3BhY2VEYXRhVmFsdWVMaXN0U2VwYXJhdG9yUkUgPSAvWyBcXHRcXG5cXHJcXHZcXGZdKy87XG5mdW5jdGlvbiBwYXJzZU5SUkRUZXh0RGF0YShidWZmZXIsIHR5cGUsIHNpemVzKSB7XG4gICAgdmFyIGksIGJ1ZjgsIHN0ciwgc3RyTGlzdCwgdG90YWxMZW4gPSAxO1xuICAgIGZvcihpPTA7IGk8c2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNpemVzW2ldPD0wKSB0aHJvdyBuZXcgRXJyb3IoXCJTaXplcyBzaG91bGQgYmUgYSBsaXN0IG9mIHBvc2l0aXZlICg+MCkgaW50ZWdlcnMhXCIpO1xuICAgICAgICB0b3RhbExlbiAqPSBzaXplc1tpXTtcbiAgICB9XG4gICAgYnVmOCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWY4KTtcbiAgICBzdHJMaXN0ID0gc3RyLnNwbGl0KHdoaXRlc3BhY2VEYXRhVmFsdWVMaXN0U2VwYXJhdG9yUkUpO1xuICAgIGlmIChzdHJMaXN0Lmxlbmd0aDx0b3RhbExlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIGRhdGEgaW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHN0ckxpc3QubGVuZ3RoPnRvdGFsTGVuKSB7XG4gICAgICAgIGlmIChzdHJMaXN0WzBdID09PSAnJykgc3RyTGlzdCA9IHN0ckxpc3Quc2xpY2UoMSk7IC8vIFN0cmljdGx5IHNwZWFraW5nIHRoZSBzcGVjIGRvZXNuJ3QgKGV4cGxpY2l0bHkpIGFsbG93IHdoaXRlc3BhY2UgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IG51bWJlciwgYnV0IGxldCdzIGJlIGxlbmllbnQuXG4gICAgICAgIHN0ckxpc3QgPSBzdHJMaXN0LnNsaWNlKDAsIHRvdGFsTGVuKTtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiaW50OFwiOlxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShzdHJMaXN0Lm1hcChwYXJzZU5SUkRJbnRlZ2VyKSk7XG4gICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJESW50ZWdlcikpO1xuICAgIC8vY2FzZSBcImludDY0XCI6XG4gICAgLy8gICAgcmV0dXJuIG5ldyBJbnQ2NEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICAvL2Nhc2UgXCJ1aW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IFVpbnQ2NEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREludGVnZXIpKTtcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc3RyTGlzdC5tYXAocGFyc2VOUlJERmxvYXQpKTtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KHN0ckxpc3QubWFwKHBhcnNlTlJSREZsb2F0KSk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgTlJSRCB0eXBlOiBcIiArIHR5cGUgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vLyBUaGlzIEFMV0FZUyByZXR1cm5zIGFuIGludGVnZXIsIG9yIHRocm93cyBhbiBleGNlcHRpb24uXG5mdW5jdGlvbiBnZXROUlJEVHlwZVNpemUodHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICByZXR1cm4gODtcbiAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgIHJldHVybiA4O1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCBrbm93IHRoZSBzaXplIG9mIE5SUkQgdHlwZTogXCIgKyB0eXBlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTlJSRChyZXQpIHtcbiAgICAvLyBBbHdheXMgbmVjZXNzYXJ5IGZpZWxkc1xuICAgIGlmIChyZXQuZGltZW5zaW9uPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC50eXBlPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuZW5jb2Rpbmc9PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2RpbmcgbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuc2l6ZXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZXMgbWlzc2luZyBmcm9tIE5SUkQgZmlsZSFcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIFNvbWV0aW1lcyBuZWNlc3NhcnkgZmllbGRzXG4gICAgaWYgKHJldC50eXBlICE9ICdibG9jaycgJiYgcmV0LnR5cGUgIT0gJ2ludDgnICYmIHJldC50eXBlICE9ICd1aW50OCcgJiZcbiAgICAgICAgICByZXQuZW5jb2RpbmcgIT0gJ2FzY2lpJyAmJiByZXQuZW5kaWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kaWFubmVzcyBtaXNzaW5nIGZyb20gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC50eXBlID09ICdibG9jaycgJiYgcmV0LmJsb2NrU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYmxvY2sgc2l6ZSBpbiBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBkaW1lbnNpb24gYW5kIHBlci1heGlzIGZpZWxkIGxlbmd0aHNcbiAgICBpZiAocmV0LmRpbWVuc2lvbiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJaZXJvLWRpbWVuc2lvbmFsIE5SUkQgZmlsZT9cIik7XG4gICAgfSBlbHNlIGlmIChyZXQuZGltZW5zaW9uICE9IHJldC5zaXplcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdzaXplcycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5zcGFjaW5ncyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5zcGFjaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdzcGFjaW5ncycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC50aGlja25lc3NlcyAmJiByZXQuZGltZW5zaW9uICE9IHJldC50aGlja25lc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICd0aGlja25lc3NlcycgaXMgZGlmZmVyZW50IGZyb20gJ2RpbWVuc2lvbicgaW4gYW4gTlJSRCBmaWxlIVwiKTtcbiAgICB9IGVsc2UgaWYgKHJldC5heGlzTWlucyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5heGlzTWlucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdheGlzIG1pbnMnIGlzIGRpZmZlcmVudCBmcm9tICdkaW1lbnNpb24nIGluIGFuIE5SUkQgZmlsZSFcIik7XG4gICAgfSBlbHNlIGlmIChyZXQuYXhpc01heHMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQuYXhpc01heHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnYXhpcyBtYXhzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmNlbnRlcnMgJiYgcmV0LmRpbWVuc2lvbiAhPSByZXQuY2VudGVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mICdjZW50ZXJzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmxhYmVscyAmJiByZXQuZGltZW5zaW9uICE9IHJldC5sYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiAnbGFiZWxzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LnVuaXRzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LnVuaXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ3VuaXRzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH0gZWxzZSBpZiAocmV0LmtpbmRzICYmIHJldC5kaW1lbnNpb24gIT0gcmV0LmtpbmRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgJ2tpbmRzJyBpcyBkaWZmZXJlbnQgZnJvbSAnZGltZW5zaW9uJyBpbiBhbiBOUlJEIGZpbGUhXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUT0RPOiBDaGVjayBzcGFjZS9vcmllbnRhdGlvbiBmaWVsZHMuXG4gICAgXG4gICAgLy8gV2Ugc2hvdWxkIGVpdGhlciBoYXZlIGlubGluZSBkYXRhIG9yIGV4dGVybmFsIGRhdGFcbiAgICBpZiAoKHJldC5kYXRhID09PSB1bmRlZmluZWQgfHwgcmV0LmRhdGEubGVuZ3RoID09PSAwKSAmJiAocmV0LmJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8IHJldC5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkgJiYgcmV0LmRhdGFGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTlJSRCBmaWxlIGhhcyBuZWl0aGVyIGlubGluZSBvciBleHRlcm5hbCBkYXRhIVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhc3RUeXBlZEFycmF5KGRhdGEsIHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGRhdGEpO1xuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShkYXRhKTtcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShkYXRhKTtcbiAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoZGF0YSk7XG4gICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAvLyAgICByZXR1cm4gbmV3IEludDY0QXJyYXkoZGF0YSk7XG4gICAgLy9jYXNlIFwidWludDY0XCI6XG4gICAgLy8gICAgcmV0dXJuIG5ldyBVaW50NjRBcnJheShkYXRhKTtcbiAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShkYXRhKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FzdCB0byBOUlJEIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVUb0J1ZmZlcihkYXRhLCB0eXBlLCBlbmRpYW4pIHtcbiAgICB2YXIgaSwgZW5kaWFuRmxhZywgdmlldywgbmF0aXZlU2l6ZSA9IGdldE5SUkRUeXBlU2l6ZSh0eXBlKSwgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoKm5hdGl2ZVNpemUpO1xuICAgIHN3aXRjaChlbmRpYW4pIHtcbiAgICBjYXNlICdiaWcnOlxuICAgICAgICBlbmRpYW5GbGFnID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpdHRsZSc6XG4gICAgICAgIGVuZGlhbkZsYWcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBlbmRpYW5uZXNzIGluIE5SUkQgZmlsZTogXCIgKyBlbmRpYW4pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiaW50OFwiOiAvLyBOb3RlIHRoYXQgaGVyZSB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLCBhcyB0aGUgRGF0YVZpZXcuZ2V0IG1ldGhvZHMgc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB3ZSByZWFkIGJleW9uZCB0aGUgYnVmZmVyLlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50OChpLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgoaSwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldEludDE2KGkqMiwgZGF0YVtpXSwgZW5kaWFuRmxhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYoaSoyLCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50MzIoaSo0LCBkYXRhW2ldLCBlbmRpYW5GbGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgZm9yKGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihpKjQsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgLy9jYXNlIFwiaW50NjRcIjpcbiAgICAvLyAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgdmlldy5zZXRJbnQ2NChpKjgsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgIC8vICAgIH1cbiAgICAvLyAgICByZXR1cm4gYnVmZmVyO1xuICAgIC8vY2FzZSBcInVpbnQ2NFwiOlxuICAgIC8vICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIC8vICAgICAgICB2aWV3LnNldFVpbnQ2NChpKjgsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgIC8vICAgIH1cbiAgICAvLyAgICByZXR1cm4gYnVmZmVyO1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQzMihpKjQsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICBmb3IoaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NChpKjgsIGRhdGFbaV0sIGVuZGlhbkZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IHNlcmlhbGl6ZSBOUlJEIHR5cGU6IFwiICsgdHlwZSArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvVGV4dEJ1ZmZlcihkYXRhKSB7XG4gICAgdmFyIGksIHN0cnMgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpLCBzdHIsIGJ1ZmZlciwgYXJyO1xuICAgIGZvcihpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJzW2ldID0gJycgKyBkYXRhW2ldO1xuICAgIH1cbiAgICBzdHIgPSBzdHJzLmpvaW4oXCIgXCIpO1xuICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzdHIubGVuZ3RoKTtcbiAgICBhcnIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvcihpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuIiwiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zaCBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zaCBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2c7IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJ5XG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgcy5kX2J1ZiA9IHMubGl0X2J1ZnNpemUgPj4gMTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSBCdWZmZXIuaXNCdWZmZXIoY2h1bmspO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gYnVmZmVyU2hpbS5hbGxvYygwKTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gIHZhciByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAocCkge1xuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1zdHJpbmctcHJpbWl0aXZlJyApO1xudmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXInICk7XG52YXIgY2VpbCA9IHJlcXVpcmUoICdtYXRoLWNlaWwnICk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSggJ3V0aWxzLXJlcGVhdC1zdHJpbmcnICk7XG5cblxuLy8gQ09OU1RBTlRTIC8vXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTsgLy8gMioqNTMgLSAxXG5cblxuLy8gTEVGVCBQQUQgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBscGFkKCBzdHIsIGxlblssIHBhZF0gKVxuKlx0TGVmdCBwYWRzIGEgc3RyaW5nIHN1Y2ggdGhhdCB0aGUgcGFkZGVkIHN0cmluZyBoYXMgYSBsZW5ndGggb2YgYXQgbGVhc3QgYGxlbmAuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gcGFkXG4qIEBwYXJhbSB7TnVtYmVyfSBsZW4gLSBtaW5pbXVtIHN0cmluZyBsZW5ndGhcbiogQHBhcmFtIHtTdHJpbmd9IFtwYWQ9JyAnXSAtIHN0cmluZyB1c2VkIHRvIHBhZFxuKiBAcmV0dXJucyB7U3RyaW5nfSBwYWRkZWQgc3RyaW5nXG4qL1xuZnVuY3Rpb24gbHBhZCggc3RyLCBsZW4sIHBhZCApIHtcblx0dmFyIG47XG5cdHZhciBwO1xuXHRpZiAoICFpc1N0cmluZyggc3RyICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHN0ciArICdgLicgKTtcblx0fVxuXHRpZiAoICFpc05vbk5lZ2F0aXZlSW50ZWdlciggbGVuICkgKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlci4gVmFsdWU6IGAnICsgbGVuICsgJ2AuJyApO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgKSB7XG5cdFx0cCA9IHBhZDtcblx0XHRpZiAoICFpc1N0cmluZyggcCApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcuIFZhbHVlOiBgJyArIHAgKyAnYC4nICk7XG5cdFx0fVxuXHRcdGlmICggcC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIFBhZCBzdHJpbmcgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLicgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cCA9ICcgJztcblx0fVxuXHRpZiAoIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIgKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPdXRwdXQgc3RyaW5nIGxlbmd0aCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgbGVuZ3RoLicgKTtcblx0fVxuXHRuID0gKCBsZW4gLSBzdHIubGVuZ3RoICkgLyBwLmxlbmd0aDtcblx0aWYgKCBuIDw9IDAgKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHRuID0gY2VpbCggbiApO1xuXHRyZXR1cm4gcmVwZWF0KCBwLCBuICkgKyBzdHI7XG59IC8vIGVuZCBGVU5DVElPTiBscGFkKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gbHBhZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8tc3RyaW5nLXByaW1pdGl2ZScgKTtcbnZhciBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1ub25uZWdhdGl2ZS1pbnRlZ2VyJyApO1xuXG5cbi8vIE5PVEVTIC8vXG5cbi8qKlxuKiBUaGUgYWxnb3JpdGhtaWMgdHJpY2sgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gaXMgdG8gdHJlYXQgc3RyaW5nIGNvbmNhdGVuYXRpb24gdGhlIHNhbWUgYXMgYmluYXJ5IGFkZGl0aW9uIChpLmUuLCBhbnkgbmF0dXJhbCBudW1iZXIgKG5vbm5lZ2F0aXZlIGludGVnZXIpIGNhbiBiZSBleHByZXNzZWQgYXMgYSBzdW0gb2YgcG93ZXJzIG9mIHR3bykuXG4qXG4qIEZvciBleGFtcGxlLFxuKlxuKiAgbiA9IDEwID0+IDEwMTAgPT4gMl4zICsgMl4wICsgMl4xICsgMl4wXG4qXG4qIFdlIGNhbiBwcm9kdWNlIGEgMTAtcmVwZWF0IHN0cmluZyBieSBcImFkZGluZ1wiIHRoZSByZXN1bHRzIG9mIGEgOC1yZXBlYXQgc3RyaW5nIGFuZCBhIDItcmVwZWF0IHN0cmluZy5cbipcbiogVGhlIGltcGxlbWVudGF0aW9uIGlzIHRoZW4gYXMgZm9sbG93czpcbiogIDogTGV0IGBzYCBiZSB0aGUgc3RyaW5nIHRvIGJlIHJlcGVhdGVkIGFuZCBgb2AgYmUgYW4gb3V0cHV0IHN0cmluZy5cbiogIDApIEluaXRpYWxpemUgYW4gb3V0cHV0IHN0cmluZyBgb2AuXG4qICAxKSBDaGVjayB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IHRvIGRldGVybWluZSBpZiB0aGUgY3VycmVudCBgc2Agc3RyaW5nIHNob3VsZCBiZSBcImFkZGVkXCIgdG8gdGhlIG91dHB1dCBcInRvdGFsXCIuXG4qICAgICAtIGlmIHRoZSBiaXQgaXMgYSBvbmUsIGFkZFxuKiAgICAgLSBvdGhlcndpc2UsIG1vdmUgb25cbiogIDIpIERvdWJsZSB0aGUgc3RyaW5nIGBzYCBieSBhZGRpbmcgYHNgIHRvIGBzYC5cbiogIDMpIFJpZ2h0LXNoaWZ0IHRoZSBiaXRzIG9mIGBuYC5cbiogIDQpIENoZWNrIGlmIHdlIGhhdmUgc2hpZnRlZCBvZmYgYWxsIGJpdHMuXG4qICAgICAtIGlmIHllcywgZG9uZS5cbiogICAgIC0gb3RoZXJ3aXNlLCBtb3ZlIG9uXG4qICA1KSBSZXBlYXQgMS00LlxuKlxuKiBUaGUgcmVzdWx0IGlzIHRoYXQsIGFzIHRoZSBzdHJpbmcgaXMgcmVwZWF0ZWQsIHdlIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG91YmxlZCBzdHJpbmcgaXMgb25lIHdoaWNoIHdlIHdhbnQgdG8gYWRkIHRvIG91ciBcInRvdGFsXCIuXG4qXG4qIFRoZSBhbGdvcml0aG0gcnVucyBpbiBPKGxvZ18yKG4pKSBjb21wYXJlZCB0byBPKG4pLlxuKi9cblxuXG4vLyBDT05TVEFOVFMgLy9cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyAyKio1MyAtIDFcblxuXG4vLyBSRVBFQVQgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiByZXBlYXQoIHN0ciwgbiApXG4qXHRSZXBlYXRzIGEgc3RyaW5nIGEgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcyBhbmQgcmV0dXJucyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdC5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byByZXBlYXRcbiogQHBhcmFtIHtOdW1iZXJ9IG4gLSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmdcbiogQHJldHVybnMge1N0cmluZ31cbiovXG5mdW5jdGlvbiByZXBlYXQoIHN0ciwgbiApIHtcblx0dmFyIHJwdDtcblx0dmFyIGNudDtcblx0aWYgKCAhaXNTdHJpbmcoIHN0ciApICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLiBWYWx1ZTogYCcgKyBzdHIgKyAnYC4nICk7XG5cdH1cblx0aWYgKCAhaXNOb25OZWdhdGl2ZUludGVnZXIoIG4gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLiBWYWx1ZTogYCcgKyBuICsgJ2AuJyApO1xuXHR9XG5cdGlmICggc3RyLmxlbmd0aCA9PT0gMCB8fCBuID09PSAwICkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHQvLyBDaGVjayB0aGF0IG91dHB1dCBzdHJpbmcgd2lsbCBub3QgZXhjZWVkIHRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGg6XG5cdGlmICggc3RyLmxlbmd0aCAqIG4gPiBNQVhfU0FGRV9JTlRFR0VSICkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gT3V0cHV0IHN0cmluZyBsZW5ndGggZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc3RyaW5nIGxlbmd0aC4nICk7XG5cdH1cblx0cnB0ID0gJyc7XG5cdGNudCA9IG47XG5cdGZvciggOyA7ICkge1xuXHRcdC8vIElmIHRoZSBjb3VudCBpcyBvZGQsIGFwcGVuZCB0aGUgY3VycmVudCBjb25jYXRlbmF0ZWQgc3RyaW5nOlxuXHRcdGlmICggKGNudCYxKSA9PT0gMSApIHtcblx0XHRcdHJwdCArPSBzdHI7XG5cdFx0fVxuXHRcdC8vIFJpZ2h0LXNoaWZ0IHRoZSBiaXRzOlxuXHRcdGNudCA+Pj49IDE7XG5cdFx0aWYgKCBjbnQgPT09IDAgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Ly8gRG91YmxlIHRoZSBzdHJpbmc6XG5cdFx0c3RyICs9IHN0cjtcblx0fVxuXHRyZXR1cm4gcnB0O1xufSAvLyBlbmQgRlVOQ1RJT04gcmVwZWF0KClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1zdHJpbmctcHJpbWl0aXZlJyApO1xudmFyIGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW5vbm5lZ2F0aXZlLWludGVnZXInICk7XG52YXIgY2VpbCA9IHJlcXVpcmUoICdtYXRoLWNlaWwnICk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSggJ3V0aWxzLXJlcGVhdC1zdHJpbmcnICk7XG5cblxuLy8gQ09OU1RBTlRTIC8vXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTsgLy8gMioqNTMgLSAxXG5cblxuLy8gUklHSFQgUEFEIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcnBhZCggc3RyLCBsZW5bLCBwYWRdIClcbipcdFJpZ2h0IHBhZHMgYSBzdHJpbmcgc3VjaCB0aGF0IHRoZSBwYWRkZWQgc3RyaW5nIGhhcyBhIGxlbmd0aCBvZiBhdCBsZWFzdCBgbGVuYC5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBwYWRcbiogQHBhcmFtIHtOdW1iZXJ9IGxlbiAtIG1pbmltdW0gc3RyaW5nIGxlbmd0aFxuKiBAcGFyYW0ge1N0cmluZ30gW3BhZD0nICddIC0gc3RyaW5nIHVzZWQgdG8gcGFkXG4qIEByZXR1cm5zIHtTdHJpbmd9IHBhZGRlZCBzdHJpbmdcbiovXG5mdW5jdGlvbiBycGFkKCBzdHIsIGxlbiwgcGFkICkge1xuXHR2YXIgbjtcblx0dmFyIHA7XG5cdGlmICggIWlzU3RyaW5nKCBzdHIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgc3RyICsgJ2AuJyApO1xuXHR9XG5cdGlmICggIWlzTm9uTmVnYXRpdmVJbnRlZ2VyKCBsZW4gKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLiBWYWx1ZTogYCcgKyBsZW4gKyAnYC4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRwID0gcGFkO1xuXHRcdGlmICggIWlzU3RyaW5nKCBwICkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZy4gVmFsdWU6IGAnICsgcCArICdgLicgKTtcblx0XHR9XG5cdFx0aWYgKCBwLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCAnaW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUGFkIHN0cmluZyBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwID0gJyAnO1xuXHR9XG5cdGlmICggbGVuID4gTUFYX1NBRkVfSU5URUdFUiApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvciggJ2ludmFsaWQgaW5wdXQgYXJndW1lbnQuIE91dHB1dCBzdHJpbmcgbGVuZ3RoIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHN0cmluZyBsZW5ndGguJyApO1xuXHR9XG5cdG4gPSAoIGxlbiAtIHN0ci5sZW5ndGggKSAvIHAubGVuZ3RoO1xuXHRpZiAoIG4gPD0gMCApIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cdG4gPSBjZWlsKCBuICk7XG5cdHJldHVybiBzdHIgKyByZXBlYXQoIHAsIG4gKTtcbn0gLy8gZW5kIEZVTkNUSU9OIHJwYWQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBycGFkO1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogaW50ZWdlclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gVmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc051bWJlciA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1udW1iZXInICk7XG5cblxuLy8gSVNJTlRFR0VSIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXNJbnRlZ2VyKCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuKlxuKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGludGVnZXJcbiovXG5mdW5jdGlvbiBpc0ludGVnZXIoIHZhbHVlICkge1xuXHRyZXR1cm4gaXNOdW1iZXIoIHZhbHVlICkgJiYgdmFsdWUlMSA9PT0gMDtcbn0gLy8gZW5kIEZVTkNUSU9OIGlzSW50ZWdlcigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW50ZWdlcjtcbiIsIi8qKlxuKlxuKlx0VkFMSURBVEU6IG5vbm5lZ2F0aXZlLWludGVnZXJcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbm9ubmVnYXRpdmUgaW50ZWdlci5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTUuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE1LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCAndmFsaWRhdGUuaW8taW50ZWdlcicgKTtcblxuXG4vLyBJUyBOT05ORUdBVElWRSBJTlRFR0VSIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXNOb25OZWdhdGl2ZUludGVnZXIoIHZhbHVlIClcbipcdFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGEgbm9ubmVnYXRpdmUgaW50ZWdlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyXG4qL1xuZnVuY3Rpb24gaXNOb25OZWdhdGl2ZUludGVnZXIoIHZhbHVlICkge1xuXHRyZXR1cm4gaXNJbnRlZ2VyKCB2YWx1ZSApICYmIHZhbHVlID49IDA7XG59IC8vIGVuZCBGVU5DVElPTiBpc05vbk5lZ2F0aXZlSW50ZWdlcigpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9uTmVnYXRpdmVJbnRlZ2VyO1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogbnVtYmVyXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGlzTnVtYmVyKCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG51bWJlci5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHZhbGlkYXRlZFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBudW1iZXJcbiovXG5mdW5jdGlvbiBpc051bWJlciggdmFsdWUgKSB7XG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCB2YWx1ZSApID09PSAnW29iamVjdCBOdW1iZXJdJyApICYmIHZhbHVlLnZhbHVlT2YoKSA9PT0gdmFsdWUudmFsdWVPZigpO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNOdW1iZXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgcHJpbWl0aXZlLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gdGVzdFxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgcHJpbWl0aXZlXG4qL1xuZnVuY3Rpb24gaXNTdHJpbmcoIHZhbHVlICkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn0gLy8gZW5kIEZVTkNUSU9OIGlzU3RyaW5nKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJtb2R1bGUuZXhwb3J0cz17XHJcbiAgXCJuYW1lXCI6IFwiYW1pLmpzXCIsXHJcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4wLjE3LWRldlwiLFxyXG4gIFwibWFpblwiOiBcImxpYi9hbWkuanNcIixcclxuICBcImtleXdvcmRzXCI6IFtcclxuICAgIFwiYW1pXCIsXHJcbiAgICBcImFtaS5qc1wiLFxyXG4gICAgXCJ0aHJlZS5qc1wiLFxyXG4gICAgXCJ3ZWJnbFwiLFxyXG4gICAgXCJkaWNvbVwiLFxyXG4gICAgXCJuaWZ0aVwiLFxyXG4gICAgXCJhd2Vzb21lXCIsXHJcbiAgICBcIm1lZGljYWxcIixcclxuICAgIFwiaW1hZ2luZ1wiLFxyXG4gICAgXCJ4dGtcIixcclxuICAgIFwibnJyZFwiLFxyXG4gICAgXCJ2dGtcIixcclxuICAgIFwic3RsXCIsXHJcbiAgICBcInRya1wiXHJcbiAgXSxcclxuICBcImF1dGhvclwiOiB7XHJcbiAgICBcIm5hbWVcIjogXCJOaWNvbGFzIFJhbm5vdVwiLFxyXG4gICAgXCJlbWFpbFwiOiBcIm5pY29sYXNAZXVuYXRlLmNoXCIsXHJcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZXVuYXRlLmNoXCJcclxuICB9LFxyXG4gIFwibGljZW5zZVwiOiBcIkFwYWNoZS0yLjBcIixcclxuICBcInJlcG9zaXRvcnlcIjoge1xyXG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXHJcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby9hbWlcIlxyXG4gIH0sXHJcbiAgXCJjb25maWdcIjoge1xyXG4gICAgXCJ0aHJlZVZlcnNpb25cIjogXCI4NlwiLFxyXG4gICAgXCJhbWlDRE5cIjogXCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9hbWkuanMvXCIsXHJcbiAgICBcImdhS2V5XCI6IFwiVUEtMzkzMDMwMjItM1wiLFxyXG4gICAgXCJ0cmFuc2Zvcm1zXCI6IFwiLXQgW2JhYmVsaWZ5IC0tcHJlc2V0cyBbIGVzMjAxNSBdIF1cIlxyXG4gIH0sXHJcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xyXG4gICAgXCJkaWNvbS1wYXJzZXJcIjogXCIxLjcuM1wiLFxyXG4gICAgXCJpbWFnZS1KUEVHMjAwMFwiOiBcIk9ISUYvaW1hZ2UtSlBFRzIwMDAjbWFzdGVyXCIsXHJcbiAgICBcImpwZWctbG9zc2xlc3MtZGVjb2Rlci1qc1wiOiBcIjEuMi4zXCIsXHJcbiAgICBcIm1hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nXCI6IFwiXjEuMC4wXCIsXHJcbiAgICBcIm5pZnRpLXJlYWRlci1qc1wiOiBcInYwLjUuM1wiLFxyXG4gICAgXCJucnJkLWpzXCI6IFwiXjAuMi4xXCIsXHJcbiAgICBcInBha29cIjogXCIxLjAuMVwiXHJcbiAgfSxcclxuICBcInNjcmlwdHNcIjoge1xyXG4gICAgXCJkaXN0OnByZXBhcmVcIjogXCJub2RlIC4vc2NyaXB0cy8kbnBtX3BhY2thZ2VfY29uZmlnX21vZGUuanMgLS1kaXN0XCIsXHJcbiAgICBcImRpc3Q6d2F0Y2hBbWlcIjogXCJ3YXRjaGlmeSAtZCBzcmMvYW1pICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyAtLXN0YW5kYWxvbmUgQU1JIC1vIGRpc3QvYnVpbGQvYW1pLmpzIC12XCIsXHJcbiAgICBcImRpc3Q6d2F0Y2hcIjogXCJ3YXRjaGlmeSAkbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtZCAkbnBtX3BhY2thZ2VfY29uZmlnX3RyYW5zZm9ybXMgLW8gZGlzdC8kbnBtX3BhY2thZ2VfY29uZmlnX3RhcmdldCAtdlwiLFxyXG4gICAgXCJkaXN0XCI6IFwibnBtIHJ1biBkaXN0OnByZXBhcmUgLS1hbWkuanM6bW9kZT0kbnBtX3BhY2thZ2VfY29uZmlnX21vZGUgJiYgKGxpdmUtc2VydmVyIGRpc3QgLS1vcGVuPSRucG1fcGFja2FnZV9jb25maWdfb3BlbiAmIG5wbSBydW4gZGlzdDp3YXRjaCAtLWFtaS5qczp0YXJnZXQ9JG5wbV9wYWNrYWdlX2NvbmZpZ190YXJnZXQpXCIsXHJcbiAgICBcImV4YW1wbGVcIjogXCJucG0gcnVuIGNsZWFuICYmIG5vZGUgLi9zY3JpcHRzL3JvdXRlci5qcyBleGFtcGxlcyBcIixcclxuICAgIFwibGVzc29uXCI6IFwibnBtIHJ1biBjbGVhbiAmJiBta2RpciBkaXN0L2J1aWxkICYmIHRvdWNoIGRpc3QvYnVpbGQvYW1pLmpzICYmIG5vZGUgLi9zY3JpcHRzL3JvdXRlci5qcyBsZXNzb25zIFwiLFxyXG4gICAgXCJkZW1vXCI6IFwibm9kZSAuL3NjcmlwdHMvbGVzc29ucy5qcyAtLWRlbW9cIixcclxuICAgIFwibGludFwiOiBcImVzbGludCAqKi8qLmpzIC0tcXVpZXRcIixcclxuICAgIFwiYnVpbGQ6ZXhhbXBsZXNcIjogXCJucG0gcnVuIGRpc3Q6cHJlcGFyZSAtLWFtaS5qczptb2RlPWV4YW1wbGVzICYmIGZpbmQgZXhhbXBsZXMgLW5hbWUgJyouanMnIC1wcmludDAgfCB4YXJncyAtMCAtbjEgLUl7fSBiYXNoIC1jIFxcXCJlY2hvIEJ1aWxkaW5nIHt9OyBicm93c2VyaWZ5IHt9IC1kIC12ICRucG1fcGFja2FnZV9jb25maWdfdHJhbnNmb3JtcyA+IGRpc3Qve30gXFxcIlwiLFxyXG4gICAgXCJidWlsZDphbWlcIjogXCJicm93c2VyaWZ5IHNyYy9hbWkuanMgLWQgLXYgJG5wbV9wYWNrYWdlX2NvbmZpZ190cmFuc2Zvcm1zIC0tc3RhbmRhbG9uZSBBTUkgPiBidWlsZC9hbWkuanMgJiYgdWdsaWZ5anMgYnVpbGQvYW1pLmpzIC1vIGJ1aWxkL2FtaS5taW4uanNcIixcclxuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGNsZWFuICYmIGNwIGluZGV4Lmh0bWwgZGlzdC9pbmRleC5odG1sICYmIG5wbSBydW4gYnVpbGQ6ZXhhbXBsZXMgJiYgbnBtIHJ1biBkb2NcIixcclxuICAgIFwiYnVpbGQtY2pzXCI6IFwicmltcmFmIGxpYiAmJiBjcm9zcy1lbnYgQkFCRUxfRU5WPWNqcyBiYWJlbCAuL3NyYyAtZCBsaWJcIixcclxuICAgIFwiY2xlYW5cIjogXCJyaW1yYWYgLXJmIGRpc3QvKlwiLFxyXG4gICAgXCJ0ZXN0XCI6IFwia2FybWEgc3RhcnRcIixcclxuICAgIFwiZG9jXCI6IFwianNkb2MgLXAgLXIgLVIgUkVBRE1FLm1kIC1jIGpzZG9jLmNvbmYgLWQgZGlzdC9kb2Mgc3JjXCIsXHJcbiAgICBcImFtaVwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIGRlbW8gJiYgbnBtIHJ1biBidWlsZDphbWkgJiYgbnBtIHJ1biB0ZXN0XCIsXHJcbiAgICBcImRlcGxveVwiOiBcIm5wbSBydW4gYnVpbGQgJiYgZ2gtcGFnZXMgLWQgZGlzdFwiXHJcbiAgfSxcclxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XHJcbiAgICBcImJhYmVsLWNsaVwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJiYWJlbC1wbHVnaW4tYWRkLW1vZHVsZS1leHBvcnRzXCI6IFwiXjAuMi4xXCIsXHJcbiAgICBcImJhYmVsLXBvbHlmaWxsXCI6IFwiXjYuMTMuMFwiLFxyXG4gICAgXCJiYWJlbC1wcmVzZXQtZXMyMDE1XCI6IFwiXjYuMTMuMlwiLFxyXG4gICAgXCJiYWJlbGlmeVwiOiBcIjcuMy4wXCIsXHJcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMS4wXCIsXHJcbiAgICBcImNyb3NzLWVudlwiOiBcIl4zLjIuM1wiLFxyXG4gICAgXCJlc2xpbnRcIjogXCJsYXRlc3RcIixcclxuICAgIFwiZXNsaW50LWNvbmZpZy1nb29nbGVcIjogXCJsYXRlc3RcIixcclxuICAgIFwiZ2gtcGFnZXNcIjogXCJsYXRlc3RcIixcclxuICAgIFwiZ2xzbGlmeVwiOiBcIjUuMS4wXCIsXHJcbiAgICBcImphc21pbmUtY29yZVwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJqc2RvY1wiOiBcImpzZG9jMy9qc2RvYyNtYXN0ZXJcIixcclxuICAgIFwia2FybWFcIjogXCJsYXRlc3RcIixcclxuICAgIFwia2FybWEtYnJvd3NlcmlmeVwiOiBcImxhdGVzdFwiLFxyXG4gICAgXCJrYXJtYS1qYXNtaW5lXCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcImthcm1hLXBoYW50b21qcy1sYXVuY2hlclwiOiBcIjEuMC40XCIsXHJcbiAgICBcImthcm1hLXNpbm9uXCI6IFwiXjEuMC41XCIsXHJcbiAgICBcImthcm1hLXNwZWMtcmVwb3J0ZXJcIjogXCJsYXRlc3RcIixcclxuICAgIFwibGl2ZS1zZXJ2ZXJcIjogXCJeMS4xLjBcIixcclxuICAgIFwicGhhbnRvbWpzLXByZWJ1aWx0XCI6IFwiMi4xLjE0XCIsXHJcbiAgICBcInJpbXJhZlwiOiBcIl4yLjYuMVwiLFxyXG4gICAgXCJzaGVsbGpzXCI6IFwibGF0ZXN0XCIsXHJcbiAgICBcInNpbm9uXCI6IFwiXjIuMC4wXCIsXHJcbiAgICBcInVnbGlmeS1qc1wiOiBcIl4yLjcuM1wiLFxyXG4gICAgXCJ3YXRjaGlmeVwiOiBcIjMuNy4wXCJcclxuICB9LFxyXG4gIFwiZW5naW5lc1wiOiB7XHJcbiAgICBcIm5vZGVcIjogXCI+PTYuOS4wXCJcclxuICB9LFxyXG4gIFwiYnJvd3NlcmlmeVwiOiB7XHJcbiAgICBcInRyYW5zZm9ybVwiOiBbXHJcbiAgICAgIFwiYmFiZWxpZnlcIlxyXG4gICAgXVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQ2FtZXJhcyBmcm9tICcuL2NhbWVyYXMvY2FtZXJhcyc7XHJcbmltcG9ydCBDb250cm9scyBmcm9tICcuL2NvbnRyb2xzL2NvbnRyb2xzJztcclxuaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlL2NvcmUnO1xyXG5pbXBvcnQgR2VvbWV0cmllcyBmcm9tICcuL2dlb21ldHJpZXMvZ2VvbWV0cmllcyc7XHJcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4vaGVscGVycy9oZWxwZXJzJztcclxuaW1wb3J0IExvYWRlcnMgZnJvbSAnLi9sb2FkZXJzL2xvYWRlcnMnO1xyXG5pbXBvcnQgTW9kZWxzIGZyb20gJy4vbW9kZWxzL21vZGVscyc7XHJcbmltcG9ydCBQYXJzZXJzIGZyb20gJy4vcGFyc2Vycy9wYXJzZXJzJztcclxuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi9zaGFkZXJzL3NoYWRlcnMnO1xyXG5pbXBvcnQgV2lkZ2V0cyBmcm9tICcuL3dpZGdldHMvd2lkZ2V0cyc7XHJcblxyXG5jb25zdCBwY2tnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XHJcblxyXG5leHBvcnQgZGVmYXVsdHtcclxuICBDYW1lcmFzLFxyXG4gIENvbnRyb2xzLFxyXG4gIENvcmUsXHJcbiAgR2VvbWV0cmllcyxcclxuICBIZWxwZXJzLFxyXG4gIExvYWRlcnMsXHJcbiAgTW9kZWxzLFxyXG4gIFBhcnNlcnMsXHJcbiAgU2hhZGVycyxcclxuICBXaWRnZXRzLFxyXG59O1xyXG5cclxud2luZG93LmNvbnNvbGUubG9nKGBBTUkgJHtwY2tnLnZlcnNpb259ICggVGhyZWVKUyAke3Bja2cuY29uZmlnLnRocmVlVmVyc2lvbn0pYCk7XHJcbiIsImltcG9ydCBPcnRob2dyYXBoaWMgZnJvbSAnLi9jYW1lcmFzLm9ydGhvZ3JhcGhpYyc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBjYW1lcmFzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgT3J0aG9ncmFwaGljLFxyXG59O1xyXG4iLCJpbXBvcnQgSW50ZXJzZWN0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuaW50ZXJzZWN0aW9ucyc7XHJcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4uL2NvcmUvY29yZS52YWxpZGF0b3JzJztcclxuXHJcbi8qKlxyXG4gKiBPcnRob2dyYXBoaWMgY2FtZXJhIGZyb20gVEhSRUUuSlMgd2l0aCBzb21lIGV4dHJhIGNvbnZlbmllbmNlXHJcbiAqIGZ1bmN0aW9uYWxpdGllcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy9cclxuICogLy9cclxuICpcclxuICogQG1vZHVsZSBjYW1lcmFzL29ydGhvZ3JhcGhpY1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FtZXJhc09ydGhvZ3JhcGhpYyBleHRlbmRzIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSB7XHJcbiAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpIHtcclxuICAgIHN1cGVyKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKTtcclxuXHJcbiAgICB0aGlzLl9mcm9udCA9IG51bGw7XHJcbiAgICB0aGlzLl9iYWNrID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9kaXJlY3Rpb25zID0gW1xyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpLFxyXG4gICAgICBdO1xyXG5cclxuICAgIHRoaXMuX2RpcmVjdGlvbnNMYWJlbCA9IFtcclxuICAgICAgJ0EnLCAnUCcsIC8vIFRPUC9CT1RUT01cclxuICAgICAgJ0wnLCAnUicsIC8vIExFRlQvUklHSFRcclxuICAgICAgJ0knLCAnUycsIC8vIEZST00vVE9cclxuICAgIF07XHJcblxyXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZGVmYXVsdCc7XHJcbiAgICB0aGlzLl9jb252ZW50aW9uID0gJ3JhZGlvJztcclxuICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAwO1xyXG5cclxuICAgIHRoaXMuX3JpZ2h0ID0gbnVsbDtcclxuICAgIHRoaXMuX3VwID0gbnVsbDtcclxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fY29udHJvbHMgPSBudWxsO1xyXG4gICAgdGhpcy5fYm94ID0gbnVsbDtcclxuICAgIHRoaXMuX2NhbnZhcyA9IHtcclxuICAgICAgd2lkdGg6IG51bGwsXHJcbiAgICAgIGhlaWdodDogbnVsbCxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fZnJvbUZyb250ID0gdHJ1ZTtcclxuICAgIHRoaXMuX2FuZ2xlID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgb3J0aG9ncmFwaGljIGNhbWVyYSB2YXJpYWJsZXNcclxuICAgKi9cclxuICBpbml0KHhDb3NpbmUsIHlDb3NpbmUsIHpDb3NpbmUsIGNvbnRyb2xzLCBib3gsIGNhbnZhcykge1xyXG4gICAgLy8gREVQUkVDQVRFRFxyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICBgY2FtZXJhcy5vcnRob2dyYXBoaWMuaW5pdCguLi4pIGlzIGRlcHJlY2F0ZWQuXHJcbiAgICAgIFVzZSAuY29zaW5lcywgLmNvbnRyb2xzLCAuYm94IGFuZCAuY2FudmFzIGluc3RlYWQuYCk7XHJcblxyXG4gICAgLy9cclxuICAgIGlmICghKFZhbGlkYXRvcnMudmVjdG9yMyh4Q29zaW5lKSAmJlxyXG4gICAgICBWYWxpZGF0b3JzLnZlY3RvcjMoeUNvc2luZSkgJiZcclxuICAgICAgVmFsaWRhdG9ycy52ZWN0b3IzKHpDb3NpbmUpICYmXHJcbiAgICAgIFZhbGlkYXRvcnMuYm94KGJveCkgJiZcclxuICAgICAgY29udHJvbHMpKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBpbnB1dCBwcm92aWRlZC4nKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yaWdodCA9IHhDb3NpbmU7XHJcbiAgICB0aGlzLl91cCA9IHRoaXMuX2FkanVzdFRvcERpcmVjdGlvbih4Q29zaW5lLCB5Q29zaW5lKTtcclxuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRoaXMuX3JpZ2h0LCB0aGlzLl91cCk7XHJcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgdGhpcy5fYm94ID0gYm94O1xyXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG5cclxuICAgIGxldCByYXkgPSB7XHJcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9ib3guY2VudGVyLFxyXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpcmVjdGlvbixcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPVxyXG4gICAgICB0aGlzLl9vcmRlckludGVyc2VjdGlvbnMoXHJcbiAgICAgICAgSW50ZXJzZWN0aW9ucy5yYXlCb3gocmF5LCB0aGlzLl9ib3gpLFxyXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbik7XHJcbiAgICB0aGlzLl9mcm9udCA9IGludGVyc2VjdGlvbnNbMF07XHJcbiAgICB0aGlzLl9iYWNrID0gaW50ZXJzZWN0aW9uc1sxXTtcclxuXHJcbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXNcclxuICAgIHRoaXMudXAuc2V0KHRoaXMuX3VwLngsIHRoaXMuX3VwLnksIHRoaXMuX3VwLnopO1xyXG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XHJcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XHJcbiAgICB0aGlzLl91cGRhdGVNYXRyaWNlcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgLy8gaHR0cDovL3d3dy5ncmFoYW13aWRlbWFuLmNvbS9ndy9icmFpbi9vcmllbnRhdGlvbi9vcmllbnR0ZXJtcy5odG1cclxuICAgIC8vIGRvIG1hZ2ljcyBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24gYW5kIGNvbnZlbnRpb25cclxuICAgIC8vIGFsc28gbmVlZHMgYSBkZWZhdWx0IG1vZGVcclxuXHJcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuX2dldE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnNbMl0pKSB7XHJcblxyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ3NhZ2l0dGFsJztcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdjb3JvbmFsJztcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdheGlhbCc7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2ZyZWUnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09ICdmcmVlJykge1xyXG4gICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2RpcmVjdGlvbnNbMF07XHJcbiAgICAgIHRoaXMuX3VwID0gdGhpcy5fZGlyZWN0aW9uc1sxXTtcclxuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uc1syXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBsZWZ0SW5kZXggPSB0aGlzLmxlZnREaXJlY3Rpb24oKTtcclxuICAgICAgbGV0IGxlZnREaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb25zW2xlZnRJbmRleF07XHJcbiAgICAgIGxldCBwb3N0ZXJpb3JJbmRleCA9IHRoaXMucG9zdGVyaW9yRGlyZWN0aW9uKCk7XHJcbiAgICAgIGxldCBwb3N0ZXJpb3JEaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb25zW3Bvc3RlcmlvckluZGV4XTtcclxuICAgICAgbGV0IHN1cGVyaW9ySW5kZXggPSB0aGlzLnN1cGVyaW9yRGlyZWN0aW9uKCk7XHJcbiAgICAgIGxldCBzdXBlcmlvckRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbnNbc3VwZXJpb3JJbmRleF07XHJcblxyXG4gICAgICBpZiAodGhpcy5fY29udmVudGlvbiA9PT0gJ3JhZGlvJykge1xyXG4gICAgICAgICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnYXhpYWwnOlxyXG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnYW50ZXJpb3InXHJcbiAgICAgICAgICAgICAgaWYgKHBvc3RlcmlvckRpcmVjdGlvbi55ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zdGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHN1cGVyaW9yXHJcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IHN1cGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnY29yb25hbCc6XHJcbiAgICAgICAgICAgICAgLy8gdXAgdmVjdG9yIGlzICdzdXBlcmlvcidcclxuICAgICAgICAgICAgICBpZiAoc3VwZXJpb3JEaXJlY3Rpb24ueiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyaW9yRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gbG9va2luZyB0b3dhcmRzIHBvc3RlcmlvclxyXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnc2FnaXR0YWwnOlxyXG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXHJcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyByaWdodFxyXG4gICAgICAgICAgICAgIGlmIChsZWZ0RGlyZWN0aW9uLnggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHBvc3RlcmlvckRpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcclxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGxlZnREaXJlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgICBgXCIke3RoaXMuX29yaWVudGF0aW9ufVwiIG9yaWVudGF0aW9uIGlzIG5vdCB2YWxpZC5cclxuICAgICAgICAgICAgICAgIChjaG9pY2VzOiBheGlhbCwgY29yb25hbCwgc2FnaXR0YWwpYCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbnZlbnRpb24gPT09ICduZXVybycpIHtcclxuICAgICAgICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2F4aWFsJzpcclxuICAgICAgICAgICAgICAvLyB1cCB2ZWN0b3IgaXMgJ2FudGVyaW9yJ1xyXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBpbmZlcmlvclxyXG4gICAgICAgICAgICAgIGlmIChzdXBlcmlvckRpcmVjdGlvbi56ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3VwZXJpb3JEaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gbGVmdERpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcclxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHBvc3RlcmlvckRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBzdXBlcmlvckRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2Nvcm9uYWwnOlxyXG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXHJcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyBhbnRlcmlvclxyXG4gICAgICAgICAgICAgIGlmIChwb3N0ZXJpb3JEaXJlY3Rpb24ueSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBvc3RlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSBsZWZ0RGlyZWN0aW9uOyAvLyBkb2VzIG5vdCBtYXR0ZXIgcmlnaHQvbGVmdFxyXG4gICAgICAgICAgICAgIHRoaXMuX3VwID0gc3VwZXJpb3JEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gcG9zdGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnc2FnaXR0YWwnOlxyXG4gICAgICAgICAgICAgIC8vIHVwIHZlY3RvciBpcyAnc3VwZXJpb3InXHJcbiAgICAgICAgICAgICAgaWYgKHN1cGVyaW9yRGlyZWN0aW9uLnogPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlcmlvckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIGxvb2tpbmcgdG93YXJkcyByaWdodFxyXG4gICAgICAgICAgICAgIGlmIChsZWZ0RGlyZWN0aW9uLnggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHBvc3RlcmlvckRpcmVjdGlvbjsgLy8gZG9lcyBub3QgbWF0dGVyIHJpZ2h0L2xlZnRcclxuICAgICAgICAgICAgICB0aGlzLl91cCA9IHN1cGVyaW9yRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGxlZnREaXJlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgICBgXCIke3RoaXMuX29yaWVudGF0aW9ufVwiIG9yaWVudGF0aW9uIGlzIG5vdCB2YWxpZC5cclxuICAgICAgICAgICAgICAgIChjaG9pY2VzOiBheGlhbCwgY29yb25hbCwgc2FnaXR0YWwpYCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYCR7dGhpcy5fY29udmVudGlvbn0gaXMgbm90IHZhbGlkIChjaG9pY2VzOiByYWRpbywgbmV1cm8pYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGF0IGlzIHdoYXQgZGV0ZXJtaW5lcyBsZWZ0L3JpZ2h0XHJcbiAgICBsZXQgcmF5ID0ge1xyXG4gICAgICBwb3NpdGlvbjogdGhpcy5fYm94LmNlbnRlcixcclxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXJlY3Rpb24sXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBpbnRlcnNlY3Rpb25zID1cclxuICAgICAgdGhpcy5fb3JkZXJJbnRlcnNlY3Rpb25zKFxyXG4gICAgICAgIEludGVyc2VjdGlvbnMucmF5Qm94KHJheSwgdGhpcy5fYm94KSxcclxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5fZnJvbnQgPSBpbnRlcnNlY3Rpb25zWzBdO1xyXG4gICAgdGhpcy5fYmFjayA9IGludGVyc2VjdGlvbnNbMV07XHJcblxyXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzXHJcbiAgICB0aGlzLnVwLnNldCh0aGlzLl91cC54LCB0aGlzLl91cC55LCB0aGlzLl91cC56KTtcclxuICAgIHRoaXMuX3VwZGF0ZUNhbnZhcygpO1xyXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb25BbmRUYXJnZXQodGhpcy5fZnJvbnQsIHRoaXMuX2JhY2spO1xyXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcclxuICB9XHJcblxyXG4gIGxlZnREaXJlY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZE1heEluZGV4KHRoaXMuX2RpcmVjdGlvbnMsIDApO1xyXG4gIH1cclxuXHJcbiAgcG9zdGVyaW9yRGlyZWN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zLCAxKTtcclxuICB9XHJcblxyXG4gIHN1cGVyaW9yRGlyZWN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zLCAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludmVydCByb3dzIGluIHRoZSBjdXJyZW50IHNsaWNlLlxyXG4gICAqIEludmVydGluZyByb3dzIGluIDIgc3RlcHM6XHJcbiAgICogICAqIEZsaXAgdGhlIFwidXBcIiB2ZWN0b3JcclxuICAgKiAgICogTG9vayBhdCB0aGUgc2xpY2UgZnJvbSB0aGUgb3RoZXIgc2lkZVxyXG4gICAqL1xyXG4gIGludmVydFJvd3MoKSB7XHJcbiAgICAvLyBmbGlwIFwidXBcIiB2ZWN0b3JcclxuICAgIC8vIHdlIGZsaXAgdXAgZmlyc3QgYmVjYXVzZSBpbnZlcnRDb2x1bW5zIHVwZGF0ZSBwcm9qZWN0aW8gbWF0cmljZXNcclxuICAgIHRoaXMudXAubXVsdGlwbHlTY2FsYXIoLTEpO1xyXG4gICAgdGhpcy5pbnZlcnRDb2x1bW5zKCk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9ucygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52ZXJ0IHJvd3MgaW4gdGhlIGN1cnJlbnQgc2xpY2UuXHJcbiAgICogSW52ZXJ0aW5nIHJvd3MgaW4gMSBzdGVwOlxyXG4gICAqICAgKiBMb29rIGF0IHRoZSBzbGljZSBmcm9tIHRoZSBvdGhlciBzaWRlXHJcbiAgICovXHJcbiAgaW52ZXJ0Q29sdW1ucygpIHtcclxuICAgIHRoaXMuY2VudGVyKCk7XHJcbiAgICAvLyByb3RhdGUgMTgwIGRlZ3JlZXMgYXJvdW5kIHRoZSB1cCB2ZWN0b3IuLi5cclxuICAgIGxldCBvcHBvc2l0ZVBvc2l0aW9uID0gdGhpcy5fb3Bwb3NpdGVQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgcG9zaXN0aW9uIGFuZCB0YXJnZXRcclxuICAgIC8vIGNsb25lIGlzIG5lZWRlZCBiZWNhdXNlIHRoaXMucG9zaXRpb24gaXMgb3ZlcndyaXR0ZW4gaW4gbWV0aG9kXHJcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldChvcHBvc2l0ZVBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLmNsb25lKCkpO1xyXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcclxuICAgIHRoaXMuX2Zyb21Gcm9udCA9ICF0aGlzLl9mcm9tRnJvbnQ7XHJcblxyXG4gICAgdGhpcy5fYW5nbGUgJT0gMzYwO1xyXG4gICAgdGhpcy5fYW5nbGUgPSAzNjAgLSB0aGlzLl9hbmdsZTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb25zKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDZW50ZXIgc2xpY2UgaW4gdGhlIGNhbWVyYSBGT1YuXHJcbiAgICogSXQgYWxzbyB1cGRhdGVzIHRoZSBjb250cm9sbGVycyBwcm9wZXJseS5cclxuICAgKiBXZSBjYW4gY2VudGVyIGEgY2FtZXJhIGZyb20gdGhlIGZyb250IG9yIGZyb20gdGhlIGJhY2suXHJcbiAgICovXHJcbiAgY2VudGVyKCkge1xyXG4gICAgaWYgKHRoaXMuX2Zyb21Gcm9udCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9mcm9udCwgdGhpcy5fYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbkFuZFRhcmdldCh0aGlzLl9iYWNrLCB0aGlzLl9mcm9udCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBpLzIgcm90YXRpb24gYXJvdW5kIHRoZSB6Q29zaW5lIGF4aXMuXHJcbiAgICogQ2xvY2std2lzZSByb3RhdGlvbiBmcm9tIHRoZSB1c2VyIHBvaW50IG9mIHZpZXcuXHJcbiAgICovXHJcbiAgcm90YXRlKGFuZ2xlPW51bGwpIHtcclxuICAgIHRoaXMuY2VudGVyKCk7XHJcblxyXG4gICAgbGV0IGNvbXB1dGVkQW5nbGUgPSA5MDtcclxuXHJcbiAgICBsZXQgY2xvY2t3aXNlID0gMTtcclxuICAgIGlmICghdGhpcy5fZnJvbUZyb250KSB7XHJcbiAgICAgIGNsb2Nrd2lzZSA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmdsZSA9PT0gbnVsbCkge1xyXG4gICAgICBjb21wdXRlZEFuZ2xlICo9IC1jbG9ja3dpc2U7XHJcbiAgICAgIHRoaXMuX2FuZ2xlICs9IDkwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29tcHV0ZWRBbmdsZSA9IDM2MCAtIGNsb2Nrd2lzZSAqIChhbmdsZSAtIHRoaXMuX2FuZ2xlKTtcclxuICAgICAgdGhpcy5fYW5nbGUgPSBhbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9hbmdsZSAlPSAzNjA7XHJcblxyXG4gICAgLy8gUm90YXRlIHRoZSB1cCB2ZWN0b3IgYXJvdW5kIHRoZSBcInpDb3NpbmVcIlxyXG4gICAgbGV0IHJvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25BeGlzKFxyXG4gICAgICB0aGlzLl9kaXJlY3Rpb24sXHJcbiAgICAgIGNvbXB1dGVkQW5nbGUgKiBNYXRoLlBJLzE4MCk7XHJcbiAgICB0aGlzLnVwLmFwcGx5TWF0cml4NChyb3RhdGlvbik7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcclxuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbnMoKTtcclxuICB9XHJcblxyXG4gIC8vIGRpbWVuc2lvbnNbMF0gLy8gd2lkdGhcclxuICAvLyBkaW1lbnNpb25zWzFdIC8vIGhlaWdodFxyXG4gIC8vIGRpcmVjdGlvbj0gMCB3aWR0aCwgMSBoZWlnaHQsIDIgYmVzdFxyXG4gIC8vIGZhY3RvclxyXG4gIGZpdEJveChkaXJlY3Rpb24gPSAwLCBmYWN0b3I9MS41KSB7XHJcbiAgICAvL1xyXG4gICAgLy8gaWYgKCEoZGltZW5zaW9ucyAmJiBkaW1lbnNpb25zLmxlbmd0aCA+PSAyKSkge1xyXG4gICAgLy8gICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgZGltZW5zaW9ucyBjb250YWluZXIuJyk7XHJcbiAgICAvLyAgIHdpbmRvdy5jb25zb2xlLmxvZyhkaW1lbnNpb25zKTtcclxuXHJcbiAgICAvLyAgIHJldHVybiBmYWxzZTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvL1xyXG4gICAgbGV0IHpvb20gPSAxO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB6b29tXHJcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fcmlnaHQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgem9vbSA9IGZhY3RvciAqIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy5oZWlnaHQsIHRoaXMuX3VwKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHpvb20gPSBmYWN0b3IgKiAoTWF0aC5taW4oXHJcbiAgICAgICAgICB0aGlzLl9jb21wdXRlWm9vbSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX3JpZ2h0KSxcclxuICAgICAgICAgIHRoaXMuX2NvbXB1dGVab29tKHRoaXMuX2NhbnZhcy5oZWlnaHQsIHRoaXMuX3VwKVxyXG4gICAgICAgICkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghem9vbSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy56b29tID0gem9vbTtcclxuXHJcbiAgICB0aGlzLmNlbnRlcigpO1xyXG4gIH1cclxuXHJcbiAgX2FkanVzdFRvcERpcmVjdGlvbihob3Jpem9udGFsRGlyZWN0aW9uLCB2ZXJ0aWNhbERpcmVjdGlvbikge1xyXG4gICAgY29uc3Qgdk1heEluZGV4ID0gdGhpcy5fZ2V0TWF4SW5kZXgodmVydGljYWxEaXJlY3Rpb24pO1xyXG5cclxuICAgIC8vIHNob3VsZCBoYW5kbGUgdk1heCBpbmRleCA9PT0gMFxyXG4gICAgaWYgKCh2TWF4SW5kZXggPT09IDIgJiYgdmVydGljYWxEaXJlY3Rpb24uZ2V0Q29tcG9uZW50KHZNYXhJbmRleCkgPCAwKSB8fFxyXG4gICAgICAgICh2TWF4SW5kZXggPT09IDEgJiYgdmVydGljYWxEaXJlY3Rpb24uZ2V0Q29tcG9uZW50KHZNYXhJbmRleCkgPiAwKSB8fFxyXG4gICAgICAgICh2TWF4SW5kZXggPT09IDAgJiYgdmVydGljYWxEaXJlY3Rpb24uZ2V0Q29tcG9uZW50KHZNYXhJbmRleCkgPiAwKSkge1xyXG4gICAgICB2ZXJ0aWNhbERpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgIHJldHVybiB2ZXJ0aWNhbERpcmVjdGlvbjtcclxuICB9XHJcblxyXG4gIF9nZXRNYXhJbmRleCh2ZWN0b3IpIHtcclxuICAgIC8vIGluaXQgd2l0aCBYIHZhbHVlXHJcbiAgICBsZXQgbWF4VmFsdWUgPSBNYXRoLmFicyh2ZWN0b3IueCk7XHJcbiAgICBsZXQgaW5kZXggPSAwO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyh2ZWN0b3IueSkgPiBtYXhWYWx1ZSkge1xyXG4gICAgICBtYXhWYWx1ZSA9IE1hdGguYWJzKHZlY3Rvci55KTtcclxuICAgICAgaW5kZXggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNYXRoLmFicyh2ZWN0b3IueikgPiBtYXhWYWx1ZSkge1xyXG4gICAgICBpbmRleCA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRNYXhJbmRleChkaXJlY3Rpb25zLCB0YXJnZXQpIHtcclxuICAgIC8vIGdldCBpbmRleCBvZiB0aGUgbW9zdCBzdXBlcmlvciBkaXJlY3Rpb25cclxuICAgIGxldCBtYXhJbmRpY2VzID0gdGhpcy5fZ2V0TWF4SW5kaWNlcyhkaXJlY3Rpb25zKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEluZGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKG1heEluZGljZXNbaV0gPT09IHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZ2V0TWF4SW5kaWNlcyhkaXJlY3Rpb25zKSB7XHJcbiAgICBsZXQgaW5kaWNlcyA9IFtdO1xyXG4gICAgaW5kaWNlcy5wdXNoKHRoaXMuX2dldE1heEluZGV4KGRpcmVjdGlvbnNbMF0pKTtcclxuICAgIGluZGljZXMucHVzaCh0aGlzLl9nZXRNYXhJbmRleChkaXJlY3Rpb25zWzFdKSk7XHJcbiAgICBpbmRpY2VzLnB1c2godGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uc1syXSkpO1xyXG5cclxuICAgIHJldHVybiBpbmRpY2VzO1xyXG4gIH1cclxuXHJcbiAgX29yZGVySW50ZXJzZWN0aW9ucyhpbnRlcnNlY3Rpb25zLCBkaXJlY3Rpb24pIHtcclxuICAgIGNvbnN0IG9yZGVyZWQgPVxyXG4gICAgICBpbnRlcnNlY3Rpb25zWzBdLmRvdChkaXJlY3Rpb24pIDwgaW50ZXJzZWN0aW9uc1sxXS5kb3QoZGlyZWN0aW9uKTtcclxuXHJcbiAgICBpZiAoIW9yZGVyZWQpIHtcclxuICAgICAgICByZXR1cm4gW2ludGVyc2VjdGlvbnNbMV0sIGludGVyc2VjdGlvbnNbMF1dO1xyXG4gICAgfVxyXG5cclxuICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlQ2FudmFzKCkge1xyXG4gICAgbGV0IGNhbUZhY3RvciA9IDI7XHJcbiAgICB0aGlzLmxlZnQgPSAtdGhpcy5fY2FudmFzLndpZHRoIC8gY2FtRmFjdG9yO1xyXG4gICAgdGhpcy5yaWdodCA9IHRoaXMuX2NhbnZhcy53aWR0aCAvIGNhbUZhY3RvcjtcclxuICAgIHRoaXMudG9wID0gdGhpcy5fY2FudmFzLmhlaWdodCAvIGNhbUZhY3RvcjtcclxuICAgIHRoaXMuYm90dG9tID0gLXRoaXMuX2NhbnZhcy5oZWlnaHQgLyBjYW1GYWN0b3I7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlTWF0cmljZXMoKTtcclxuICAgIHRoaXMuY29udHJvbHMuaGFuZGxlUmVzaXplKCk7XHJcbiAgfVxyXG5cclxuICBfb3Bwb3NpdGVQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgbGV0IG9wcG9zaXRlUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgLy8gY2VudGVyIHdvcmxkIHBvc3Rpb24gYXJvdW5kIGJveCBjZW50ZXJcclxuICAgIG9wcG9zaXRlUG9zaXRpb24uc3ViKHRoaXMuX2JveC5jZW50ZXIpO1xyXG4gICAgLy8gcm90YXRlXHJcbiAgICBsZXQgcm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvbkF4aXMoXHJcbiAgICAgIHRoaXMudXAsXHJcbiAgICAgIE1hdGguUEkpO1xyXG5cclxuICAgIG9wcG9zaXRlUG9zaXRpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uKTtcclxuICAgIC8vIHRyYW5zbGF0ZSBiYWNrIHRvIHdvcmxkIHBvc2l0aW9uXHJcbiAgICBvcHBvc2l0ZVBvc2l0aW9uLmFkZCh0aGlzLl9ib3guY2VudGVyKTtcclxuICAgIHJldHVybiBvcHBvc2l0ZVBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgX2NvbXB1dGVab29tKGRpbWVuc2lvbiwgZGlyZWN0aW9uKSB7XHJcbiAgICBpZiAoIShkaW1lbnNpb24gJiYgZGltZW5zaW9uID4gMCkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGRpbWVuc2lvbiBwcm92aWRlZC4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGRpbWVuc2lvbik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByYXlcclxuICAgIGxldCByYXkgPSB7XHJcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9ib3guY2VudGVyLmNsb25lKCksXHJcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IEludGVyc2VjdGlvbnMucmF5Qm94KHJheSwgdGhpcy5fYm94KTtcclxuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA8IDIpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdDYW4gbm90IGFkanVzdCB0aGUgY2FtZXJhICggPCAyIGludGVyc2VjdGlvbnMpLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cocmF5KTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2JveCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGltZW5zaW9uIC8gaW50ZXJzZWN0aW9uc1swXS5kaXN0YW5jZVRvKGludGVyc2VjdGlvbnNbMV0pO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZVBvc2l0aW9uQW5kVGFyZ2V0KHBvc2l0aW9uLCB0YXJnZXQpIHtcclxuICAgICAgLy8gcG9zaXRpb25cclxuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XHJcblxyXG4gICAgICAvLyB0YXJnZXRzXHJcbiAgICAgIHRoaXMubG9va0F0KHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnopO1xyXG4gICAgICB0aGlzLl9jb250cm9scy50YXJnZXQuc2V0KHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnopO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZU1hdHJpY2VzKCkge1xyXG4gICAgdGhpcy5fY29udHJvbHMudXBkYXRlKCk7XHJcbiAgICAvLyBUSEVOIGNhbWVyYVxyXG4gICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcbiAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlTGFiZWxzKCkge1xyXG4gICAgdGhpcy5fZGlyZWN0aW9uc0xhYmVsID0gW1xyXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fdXApLFxyXG4gICAgICB0aGlzLl92ZWN0b3IyTGFiZWwodGhpcy5fdXAuY2xvbmUoKS5uZWdhdGUoKSksXHJcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl9yaWdodCksXHJcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl9yaWdodC5jbG9uZSgpLm5lZ2F0ZSgpKSxcclxuICAgICAgdGhpcy5fdmVjdG9yMkxhYmVsKHRoaXMuX2RpcmVjdGlvbiksXHJcbiAgICAgIHRoaXMuX3ZlY3RvcjJMYWJlbCh0aGlzLl9kaXJlY3Rpb24uY2xvbmUoKS5uZWdhdGUoKSksXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgX3ZlY3RvcjJMYWJlbChkaXJlY3Rpb24pIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0TWF4SW5kZXgoZGlyZWN0aW9uKTtcclxuICAgIC8vIHNldCB2ZWN0b3IgbWF4IHZhbHVlIHRvIDFcclxuICAgIGNvbnN0IHNjYWxlZERpcmVjdGlvbiA9XHJcbiAgICAgIGRpcmVjdGlvbi5jbG9uZSgpLmRpdmlkZVNjYWxhcihNYXRoLmFicyhkaXJlY3Rpb24uZ2V0Q29tcG9uZW50KGluZGV4KSkpO1xyXG4gICAgY29uc3QgZGVsdGEgPSAwLjI7XHJcbiAgICBsZXQgbGFiZWwgPSAnJztcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaTwzOyBpKyspIHtcclxuICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSArIGRlbHRhID49IDEpIHtcclxuICAgICAgICAgIGxhYmVsICs9ICdMJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgLSBkZWx0YSA8PSAtMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ1InO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSArIGRlbHRhID49IDEpIHtcclxuICAgICAgICAgIGxhYmVsICs9ICdQJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgLSBkZWx0YSA8PSAtMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ0EnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkgPT09IDIpIHtcclxuICAgICAgICBpZiAoc2NhbGVkRGlyZWN0aW9uLmdldENvbXBvbmVudChpKSArIGRlbHRhID49IDEpIHtcclxuICAgICAgICAgIGxhYmVsICs9ICdTJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlZERpcmVjdGlvbi5nZXRDb21wb25lbnQoaSkgLSBkZWx0YSA8PSAtMSkge1xyXG4gICAgICAgICAgbGFiZWwgKz0gJ0knO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYWJlbDtcclxuICB9XHJcblxyXG4gIF91cGRhdGVEaXJlY3Rpb25zKCkge1xyXG4gICAgLy8gdXAgaXMgY29ycmVjdFxyXG4gICAgdGhpcy5fdXAgPSB0aGlzLnVwLmNsb25lKCk7XHJcblxyXG4gICAgLy8gZGlyZWN0aW9uXHJcbiAgICBsZXQgcExvY2FsID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLTEpO1xyXG4gICAgbGV0IHBXb3JsZCA9IHBMb2NhbC5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7XHJcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBwV29ybGQuc3ViKHRoaXMucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgIC8vIHJpZ2h0XHJcbiAgICB0aGlzLl9yaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKHRoaXMuX2RpcmVjdGlvbiwgdGhpcy51cCk7XHJcblxyXG4gICAgLy8gdXBkYXRlIGxhYmVscyBhY2NvcmRpbmdseVxyXG4gICAgdGhpcy5fdXBkYXRlTGFiZWxzKCk7XHJcbiAgfVxyXG5cclxuICBzZXQgY29udHJvbHMoY29udHJvbHMpIHtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udHJvbHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbHM7XHJcbiAgfVxyXG5cclxuICBzZXQgYm94KGJveCkge1xyXG4gICAgdGhpcy5fYm94ID0gYm94O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJveCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ib3g7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzKGNhbnZhcykge1xyXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FudmFzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcclxuICB9XHJcblxyXG4gIHNldCBhbmdsZShhbmdsZSkge1xyXG4gICAgdGhpcy5yb3RhdGUoYW5nbGUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGFuZ2xlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FuZ2xlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpcmVjdGlvbnMoZGlyZWN0aW9ucykge1xyXG4gICAgdGhpcy5fZGlyZWN0aW9ucyA9IGRpcmVjdGlvbnM7XHJcbiAgfVxyXG5cclxuICBnZXQgZGlyZWN0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25zO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbnZlbnRpb24oY29udmVudGlvbikge1xyXG4gICAgdGhpcy5fY29udmVudGlvbiA9IGNvbnZlbnRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgY29udmVudGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb252ZW50aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpcmVjdGlvbnNMYWJlbChkaXJlY3Rpb25zTGFiZWwpIHtcclxuICAgIHRoaXMuX2RpcmVjdGlvbnNMYWJlbCA9IGRpcmVjdGlvbnNMYWJlbDtcclxuICB9XHJcblxyXG4gIGdldCBkaXJlY3Rpb25zTGFiZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uc0xhYmVsO1xyXG4gIH1cclxuXHJcbiAgc2V0IHN0YWNrT3JpZW50YXRpb24oc3RhY2tPcmllbnRhdGlvbikge1xyXG4gICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IHN0YWNrT3JpZW50YXRpb247XHJcblxyXG4gICAgaWYgKHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPT09IDApIHtcclxuICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSAnZGVmYXVsdCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBtYXhJbmRleCA9XHJcbiAgICAgICAgdGhpcy5fZ2V0TWF4SW5kZXgoXHJcbiAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25zWyh0aGlzLl9zdGFja09yaWVudGF0aW9uICsgMikgJSAzXSk7XHJcblxyXG4gICAgICBpZiAobWF4SW5kZXggPT09IDApIHtcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdzYWdpdHRhbCc7XHJcbiAgICAgIH0gZWxzZSBpZiAobWF4SW5kZXggPT09IDEpIHtcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdjb3JvbmFsJztcclxuICAgICAgfSBlbHNlIGlmIChtYXhJbmRleCA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ2F4aWFsJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YWNrT3JpZW50YXRpb24oKSB7XHJcbiAgICAvL1xyXG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgdGhpcy5fc3RhY2tPcmllbnRhdGlvbiA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgbWF4SW5kZXggPSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb24pO1xyXG5cclxuICAgICAgaWYgKG1heEluZGV4ID09PSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zWzJdKSkge1xyXG4gICAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAwO1xyXG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zWzBdKSkge1xyXG4gICAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAxO1xyXG4gICAgICB9IGVsc2UgaWYgKG1heEluZGV4ID09PSB0aGlzLl9nZXRNYXhJbmRleCh0aGlzLl9kaXJlY3Rpb25zWzFdKSkge1xyXG4gICAgICAgIHRoaXMuX3N0YWNrT3JpZW50YXRpb24gPSAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrT3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgVHJhY2tiYWxsIGZyb20gJy4vY29udHJvbHMudHJhY2tiYWxsJztcclxuaW1wb3J0IFRyYWNrYmFsbE9ydGhvIGZyb20gJy4vY29udHJvbHMudHJhY2tiYWxsb3J0aG8nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIFRyYWNrYmFsbCxcclxuICBUcmFja2JhbGxPcnRobyxcclxufTtcclxuIiwiLyoqXHJcbiAqIE9yaWdpbmFsIGF1dGhvcnMgZnJvbSBUSFJFRUpTIHJlcG9cclxuICogQGF1dGhvciBFYmVyaGFyZCBHcmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIE1hcmsgTHVuZGluICAvIGh0dHA6Ly9tYXJrLWx1bmRpbi5jb21cclxuICogQGF1dGhvciBTaW1vbmUgTWFuaW5pIC8gaHR0cDovL2Rhcm9uMTMzNy5naXRodWIuaW9cclxuICogQGF1dGhvciBMdWNhIEFudGlnYSAgLyBodHRwOi8vbGFudGlnYS5naXRodWIuaW9cclxuICovXHJcblxyXG4gZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2tiYWxsIGV4dGVuZHMgVEhSRUUuRXZlbnREaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihvYmplY3QsIGRvbUVsZW1lbnQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgbGV0IF90aGlzID0gdGhpcztcclxuICAgIGxldCBTVEFURSA9IHtOT05FOiAtMSwgUk9UQVRFOiAwLCBaT09NOiAxLCBQQU46IDIsIFRPVUNIX1JPVEFURTogMywgVE9VQ0hfWk9PTTogNCwgVE9VQ0hfUEFOOiA1LCBDVVNUT006IDk5fTtcclxuXHJcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgIHRoaXMuZG9tRWxlbWVudCA9IChkb21FbGVtZW50ICE9PSB1bmRlZmluZWQpID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xyXG5cclxuICAgIC8vIEFQSVxyXG5cclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5zY3JlZW4gPSB7bGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwfTtcclxuXHJcbiAgICB0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xyXG4gICAgdGhpcy56b29tU3BlZWQgPSAxLjI7XHJcbiAgICB0aGlzLnBhblNwZWVkID0gMC4zO1xyXG5cclxuICAgIHRoaXMubm9Sb3RhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMubm9ab29tID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vUGFuID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vQ3VzdG9tID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5mb3JjZVN0YXRlID0gLTE7XHJcblxyXG4gICAgdGhpcy5zdGF0aWNNb3ZpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3IgPSAwLjI7XHJcblxyXG4gICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XHJcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XHJcblxyXG4gICAgdGhpcy5rZXlzID0gWzY1IC8qIEEqLywgODMgLyogUyovLCA2OF07XHJcblxyXG4gICAgLy8gaW50ZXJuYWxzXHJcblxyXG4gICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgIGxldCBFUFMgPSAwLjAwMDAwMTtcclxuXHJcbiAgICBsZXQgbGFzdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICBsZXQgX3N0YXRlID0gU1RBVEUuTk9ORSxcclxuICAgIF9wcmV2U3RhdGUgPSBTVEFURS5OT05FLFxyXG5cclxuICAgIF9leWUgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgIF9tb3ZlUHJldiA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICBfbW92ZUN1cnIgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG5cclxuICAgIF9sYXN0QXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICBfbGFzdEFuZ2xlID0gMCxcclxuXHJcbiAgICBfem9vbVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICAgIF96b29tRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuXHJcbiAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IDAsXHJcbiAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSAwLFxyXG5cclxuICAgIF9wYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAgICBfcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuXHJcbiAgICBfY3VzdG9tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgX2N1c3RvbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgLy8gZm9yIHJlc2V0XHJcblxyXG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcclxuICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcclxuICAgIHRoaXMudXAwID0gdGhpcy5vYmplY3QudXAuY2xvbmUoKTtcclxuXHJcbiAgICAvLyBldmVudHNcclxuXHJcbiAgICBsZXQgY2hhbmdlRXZlbnQgPSB7dHlwZTogJ2NoYW5nZSd9O1xyXG4gICAgbGV0IHN0YXJ0RXZlbnQgPSB7dHlwZTogJ3N0YXJ0J307XHJcbiAgICBsZXQgZW5kRXZlbnQgPSB7dHlwZTogJ2VuZCd9O1xyXG5cclxuICAgIC8vIG1ldGhvZHNcclxuXHJcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCkge1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmxlZnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGJveCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAvLyBhZGp1c3RtZW50cyBjb21lIGZyb20gc2ltaWxhciBjb2RlIGluIHRoZSBqcXVlcnkgb2Zmc2V0KCkgZnVuY3Rpb25cclxuICAgICAgICBsZXQgZCA9IHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkLmNsaWVudExlZnQ7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4udG9wID0gYm94LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCAtIGQuY2xpZW50VG9wO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gYm94LndpZHRoO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IGJveC5oZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tldmVudC50eXBlXSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhpc1tldmVudC50eXBlXShldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGV0IGdldE1vdXNlT25TY3JlZW4gPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGxldCB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgIHZlY3Rvci5zZXQoXHJcbiAgICAgICAgICAgIChwYWdlWCAtIF90aGlzLnNjcmVlbi5sZWZ0KSAvIF90aGlzLnNjcmVlbi53aWR0aCxcclxuICAgICAgICAgICAgKHBhZ2VZIC0gX3RoaXMuc2NyZWVuLnRvcCkgLyBfdGhpcy5zY3JlZW4uaGVpZ2h0XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgbGV0IGdldE1vdXNlT25DaXJjbGUgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGxldCB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgIHZlY3Rvci5zZXQoXHJcbiAgICAgICAgICAgICgocGFnZVggLSBfdGhpcy5zY3JlZW4ud2lkdGggKiAwLjUgLSBfdGhpcy5zY3JlZW4ubGVmdCkgLyAoX3RoaXMuc2NyZWVuLndpZHRoICogMC41KSksXHJcbiAgICAgICAgICAgICgoX3RoaXMuc2NyZWVuLmhlaWdodCArIDIgKiAoX3RoaXMuc2NyZWVuLnRvcCAtIHBhZ2VZKSkgLyBfdGhpcy5zY3JlZW4ud2lkdGgpIC8vIHNjcmVlbi53aWR0aCBpbnRlbnRpb25hbFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHRoaXMucm90YXRlQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKSxcclxuICAgICAgICAgIGV5ZURpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICBvYmplY3RVcERpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICBvYmplY3RTaWRld2F5c0RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICAgIGFuZ2xlO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIG1vdmVEaXJlY3Rpb24uc2V0KF9tb3ZlQ3Vyci54IC0gX21vdmVQcmV2LngsIF9tb3ZlQ3Vyci55IC0gX21vdmVQcmV2LnksIDApO1xyXG4gICAgICAgIGFuZ2xlID0gbW92ZURpcmVjdGlvbi5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgaWYgKGFuZ2xlKSB7XHJcbiAgICAgICAgICBfZXllLmNvcHkoX3RoaXMub2JqZWN0LnBvc2l0aW9uKS5zdWIoX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICBleWVEaXJlY3Rpb24uY29weShfZXllKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgIG9iamVjdFVwRGlyZWN0aW9uLmNvcHkoX3RoaXMub2JqZWN0LnVwKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgIG9iamVjdFNpZGV3YXlzRGlyZWN0aW9uLmNyb3NzVmVjdG9ycyhvYmplY3RVcERpcmVjdGlvbiwgZXllRGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICBvYmplY3RVcERpcmVjdGlvbi5zZXRMZW5ndGgoX21vdmVDdXJyLnkgLSBfbW92ZVByZXYueSk7XHJcbiAgICAgICAgICBvYmplY3RTaWRld2F5c0RpcmVjdGlvbi5zZXRMZW5ndGgoX21vdmVDdXJyLnggLSBfbW92ZVByZXYueCk7XHJcblxyXG4gICAgICAgICAgbW92ZURpcmVjdGlvbi5jb3B5KG9iamVjdFVwRGlyZWN0aW9uLmFkZChvYmplY3RTaWRld2F5c0RpcmVjdGlvbikpO1xyXG5cclxuICAgICAgICAgIGF4aXMuY3Jvc3NWZWN0b3JzKG1vdmVEaXJlY3Rpb24sIF9leWUpLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgIGFuZ2xlICo9IF90aGlzLnJvdGF0ZVNwZWVkO1xyXG4gICAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICBfZXllLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuICAgICAgICAgIF90aGlzLm9iamVjdC51cC5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XHJcblxyXG4gICAgICAgICAgX2xhc3RBeGlzLmNvcHkoYXhpcyk7XHJcbiAgICAgICAgICBfbGFzdEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgfSBlbHNlIGlmICghX3RoaXMuc3RhdGljTW92aW5nICYmIF9sYXN0QW5nbGUpIHtcclxuICAgICAgICAgIF9sYXN0QW5nbGUgKj0gTWF0aC5zcXJ0KDEuMCAtIF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKTtcclxuICAgICAgICAgIF9leWUuY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pLnN1YihfdGhpcy50YXJnZXQpO1xyXG4gICAgICAgICAgcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKF9sYXN0QXhpcywgX2xhc3RBbmdsZSk7XHJcbiAgICAgICAgICBfZXllLmFwcGx5UXVhdGVybmlvbihxdWF0ZXJuaW9uKTtcclxuICAgICAgICAgIF90aGlzLm9iamVjdC51cC5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xyXG4gICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB0aGlzLnpvb21DYW1lcmEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IGZhY3RvcjtcclxuXHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlRPVUNIX1pPT00pIHtcclxuICAgICAgICBmYWN0b3IgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCAvIF90b3VjaFpvb21EaXN0YW5jZUVuZDtcclxuICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZDtcclxuICAgICAgICBfZXllLm11bHRpcGx5U2NhbGFyKGZhY3Rvcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yID0gMS4wICsgKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogX3RoaXMuem9vbVNwZWVkO1xyXG5cclxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxLjAgJiYgZmFjdG9yID4gMC4wKSB7XHJcbiAgICAgICAgICBfZXllLm11bHRpcGx5U2NhbGFyKGZhY3Rvcik7XHJcblxyXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xyXG4gICAgICAgICAgICBfem9vbVN0YXJ0LmNvcHkoX3pvb21FbmQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3pvb21TdGFydC55ICs9IChfem9vbUVuZC55IC0gX3pvb21TdGFydC55KSAqIHRoaXMuZHluYW1pY0RhbXBpbmdGYWN0b3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucGFuQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgbW91c2VDaGFuZ2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgICAgICAgb2JqZWN0VXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgICAgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICBtb3VzZUNoYW5nZS5jb3B5KF9wYW5FbmQpLnN1YihfcGFuU3RhcnQpO1xyXG5cclxuICAgICAgICBpZiAobW91c2VDaGFuZ2UubGVuZ3RoU3EoKSkge1xyXG4gICAgICAgICAgbW91c2VDaGFuZ2UubXVsdGlwbHlTY2FsYXIoX2V5ZS5sZW5ndGgoKSAqIF90aGlzLnBhblNwZWVkKTtcclxuXHJcbiAgICAgICAgICBwYW4uY29weShfZXllKS5jcm9zcyhfdGhpcy5vYmplY3QudXApLnNldExlbmd0aChtb3VzZUNoYW5nZS54KTtcclxuICAgICAgICAgIHBhbi5hZGQob2JqZWN0VXAuY29weShfdGhpcy5vYmplY3QudXApLnNldExlbmd0aChtb3VzZUNoYW5nZS55KSk7XHJcblxyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZChwYW4pO1xyXG4gICAgICAgICAgX3RoaXMudGFyZ2V0LmFkZChwYW4pO1xyXG5cclxuICAgICAgICAgIGlmIChfdGhpcy5zdGF0aWNNb3ZpbmcpIHtcclxuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfcGFuU3RhcnQuYWRkKG1vdXNlQ2hhbmdlLnN1YlZlY3RvcnMoX3BhbkVuZCwgX3BhblN0YXJ0KS5tdWx0aXBseVNjYWxhcihfdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdGhpcy5jaGVja0Rpc3RhbmNlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIV90aGlzLm5vWm9vbSB8fCAhX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBpZiAoX2V5ZS5sZW5ndGhTcSgpID4gX3RoaXMubWF4RGlzdGFuY2UgKiBfdGhpcy5tYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmFkZFZlY3RvcnMoX3RoaXMudGFyZ2V0LCBfZXllLnNldExlbmd0aChfdGhpcy5tYXhEaXN0YW5jZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9leWUubGVuZ3RoU3EoKSA8IF90aGlzLm1pbkRpc3RhbmNlICogX3RoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZS5zZXRMZW5ndGgoX3RoaXMubWluRGlzdGFuY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmICghX3RoaXMubm9Sb3RhdGUpIHtcclxuICAgICAgICBfdGhpcy5yb3RhdGVDYW1lcmEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfdGhpcy56b29tQ2FtZXJhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBfdGhpcy5wYW5DYW1lcmEoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfdGhpcy5ub0N1c3RvbSkge1xyXG4gICAgICAgIF90aGlzLmN1c3RvbShfY3VzdG9tU3RhcnQsIF9jdXN0b21FbmQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkVmVjdG9ycyhfdGhpcy50YXJnZXQsIF9leWUpO1xyXG5cclxuICAgICAgX3RoaXMuY2hlY2tEaXN0YW5jZXMoKTtcclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5sb29rQXQoX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoX3RoaXMub2JqZWN0LnBvc2l0aW9uKSA+IEVQUykge1xyXG4gICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xyXG5cclxuICAgICAgICBsYXN0UG9zaXRpb24uY29weShfdGhpcy5vYmplY3QucG9zaXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuICAgICAgX3ByZXZTdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICBfdGhpcy50YXJnZXQuY29weShfdGhpcy50YXJnZXQwKTtcclxuICAgICAgX3RoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkoX3RoaXMucG9zaXRpb24wKTtcclxuICAgICAgX3RoaXMub2JqZWN0LnVwLmNvcHkoX3RoaXMudXAwKTtcclxuXHJcbiAgICAgIF9leWUuc3ViVmVjdG9ycyhfdGhpcy5vYmplY3QucG9zaXRpb24sIF90aGlzLnRhcmdldCk7XHJcblxyXG4gICAgICBfdGhpcy5vYmplY3QubG9va0F0KF90aGlzLnRhcmdldCk7XHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcclxuXHJcbiAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KF90aGlzLm9iamVjdC5wb3NpdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbih0YXJnZXRTdGF0ZSkge1xyXG4gICAgICBfdGhpcy5mb3JjZVN0YXRlID0gdGFyZ2V0U3RhdGU7XHJcbiAgICAgIF9wcmV2U3RhdGUgPSB0YXJnZXRTdGF0ZTtcclxuICAgICAgX3N0YXRlID0gdGFyZ2V0U3RhdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY3VzdG9tID0gZnVuY3Rpb24oY3VzdG9tU3RhcnQsIGN1c3RvbUVuZCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy8gbGlzdGVuZXJzXHJcblxyXG4gICAgZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93bik7XHJcblxyXG4gICAgICBfcHJldlN0YXRlID0gX3N0YXRlO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlJPVEFURV0gJiYgIV90aGlzLm5vUm90YXRlKSB7XHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuUk9UQVRFO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuWk9PTV0gJiYgIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5QQU5dICYmICFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlBBTjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgX3N0YXRlID0gX3ByZXZTdGF0ZTtcclxuXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IGV2ZW50LmJ1dHRvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICYmICFfdGhpcy5ub1JvdGF0ZSkge1xyXG4gICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLlpPT00gJiYgIV90aGlzLm5vWm9vbSkge1xyXG4gICAgICAgIF96b29tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICAgIF96b29tRW5kLmNvcHkoX3pvb21TdGFydCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLkNVU1RPTSAmJiAhX3RoaXMubm9DdXN0b20pIHtcclxuICAgICAgICBfY3VzdG9tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICAgIF9jdXN0b21FbmQuY29weShfcGFuU3RhcnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUsIGZhbHNlKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXAsIGZhbHNlKTtcclxuXHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXRlID09PSBTVEFURS5ST1RBVEUgJiYgIV90aGlzLm5vUm90YXRlKSB7XHJcbiAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICBfbW92ZUN1cnIuY29weShnZXRNb3VzZU9uQ2lyY2xlKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuWk9PTSAmJiAhX3RoaXMubm9ab29tKSB7XHJcbiAgICAgICAgX3pvb21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUEFOICYmICFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuQ1VTVE9NICYmICFfdGhpcy5ub0N1c3RvbSkge1xyXG4gICAgICAgIF9jdXN0b21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW91c2V1cChldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgaWYgKF90aGlzLmZvcmNlU3RhdGUgPT09IC0xKSB7XHJcbiAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXApO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBsZXQgZGVsdGEgPSAwO1xyXG5cclxuICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcclxuIC8vIFdlYktpdCAvIE9wZXJhIC8gRXhwbG9yZXIgOVxyXG5cclxuICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyA0MDtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcclxuIC8vIEZpcmVmb3hcclxuXHJcbiAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gMztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9zdGF0ZSAhPT0gU1RBVEUuQ1VTVE9NKSB7XHJcbiAgICAgICAgX3pvb21TdGFydC55ICs9IGRlbHRhICogMC4wMTtcclxuICAgICAgfSBlbHNlIGlmIChfc3RhdGUgPT09IFNUQVRFLkNVU1RPTSkge1xyXG4gICAgICAgIF9jdXN0b21TdGFydC55ICs9IGRlbHRhICogMC4wMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydChldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfWk9PTTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xyXG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB7IE5PTkU6IC0xLCBST1RBVEU6IDAsIFpPT006IDEsIFBBTjogMiwgVE9VQ0hfUk9UQVRFOiAzLCBUT1VDSF9aT09NX1BBTjogNCwgQ1VTVE9NOiA5OSB9O1xyXG4gICAgICAgIHN3aXRjaCAoX3N0YXRlKSB7XHJcblxyXG4gICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAvLyAxIG9yIDIgZmluZ2Vycywgc21hZSBiZWhhdmlvclxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XHJcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xyXG4gICAgICAgICAgICBfbW92ZVByZXYuY29weShfbW92ZUN1cnIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfWk9PTTtcclxuICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWDtcclxuICAgICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuWk9PTTtcclxuICAgICAgICAgICAgICBfem9vbVN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgICAgX3pvb21FbmQuY29weShfem9vbVN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xyXG4gICAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgICBfcGFuRW5kLmNvcHkoX3BhblN0YXJ0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XHJcbiAgICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA5OTpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuQ1VTVE9NO1xyXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICBfY3VzdG9tU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgX2N1c3RvbUVuZC5jb3B5KF9jdXN0b21TdGFydCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b3VjaG1vdmUoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuTk9ORTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8geyBOT05FOiAtMSwgUk9UQVRFOiAwLCBaT09NOiAxLCBQQU46IDIsIFRPVUNIX1JPVEFURTogMywgVE9VQ0hfWk9PTV9QQU46IDQsIENVU1RPTTogOTkgfTtcclxuICAgICAgICBzd2l0Y2ggKF9zdGF0ZSkge1xyXG5cclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgX21vdmVQcmV2LmNvcHkoX21vdmVDdXJyKTtcclxuICAgICAgICAgICAgX21vdmVDdXJyLmNvcHkoZ2V0TW91c2VPbkNpcmNsZShldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX3pvb21FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgLy8gMiBmaW5nZXJzIVxyXG4gICAgICAgICAgICAvLyBUT1VDSCBaT09NXHJcbiAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAvLyAyIGZpbmdlcnNcclxuICAgICAgICAgICAgLy8gVE9VQ0hfUEFOXHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSA5OTpcclxuICAgICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgX2N1c3RvbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b3VjaGVuZChldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfdGhpcy5mb3JjZVN0YXRlID09PSAtMSkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoIChfc3RhdGUpIHtcclxuXHJcbiAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIF9tb3ZlUHJldi5jb3B5KF9tb3ZlQ3Vycik7XHJcbiAgICAgICAgICAgIF9tb3ZlQ3Vyci5jb3B5KGdldE1vdXNlT25DaXJjbGUoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgLy8gVE9VQ0ggWk9PTVxyXG4gICAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDA7XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IFNUQVRFLlpPT007XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgLy8gVE9VQ0ggWk9PTVxyXG4gICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgICAgICBfcGFuRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgX3BhblN0YXJ0LmNvcHkoX3BhbkVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3N0YXRlID0gU1RBVEUuUEFOO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDk5OlxyXG4gICAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgICBfY3VzdG9tRW5kLmNvcHkoZ2V0TW91c2VPblNjcmVlbih4LCB5KSk7XHJcbiAgICAgICAgICAgIF9jdXN0b21TdGFydC5jb3B5KF9jdXN0b21FbmQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59LCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgbW91c2V3aGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UpO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXAsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xyXG5cclxuICAgIC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEBhdXRob3IgRWJlcmhhcmQgR3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBNYXJrIEx1bmRpbiAgLyBodHRwOi8vbWFyay1sdW5kaW4uY29tXHJcbiAqIEBhdXRob3IgUGF0cmljayBGdWxsZXIgLyBodHRwOi8vcGF0cmljay1mdWxsZXIuY29tXHJcbiAqIEBhdXRob3IgTWF4IFNtb2xlbnMgLyBodHRwczovL2dpdGh1Yi5jb20vbXNtb2xlbnNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFja2JhbGxvcnRobyBleHRlbmRzIFRIUkVFLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50LCBzdGF0ZSA9IHtOT05FOiAtMSwgUk9UQVRFOiAxLCBaT09NOiAyLCBQQU46IDAsIFNDUk9MTDogNCwgVE9VQ0hfUk9UQVRFOiA0LCBUT1VDSF9aT09NX1BBTjogNX0pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgbGV0IF90aGlzID0gdGhpcztcclxuICAgIGxldCBTVEFURSA9IHN0YXRlO1xyXG5cclxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgdGhpcy5kb21FbGVtZW50ID0gKGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XHJcblxyXG4gICAgLy8gQVBJXHJcblxyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnNjcmVlbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xyXG5cclxuICAgIHRoaXMucmFkaXVzID0gMDtcclxuXHJcbiAgICB0aGlzLnpvb21TcGVlZCA9IDEuMjtcclxuXHJcbiAgICB0aGlzLm5vWm9vbSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub1BhbiA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuc3RhdGljTW92aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yID0gMC4yO1xyXG5cclxuICAgIHRoaXMua2V5cyA9IFs2NSAvKiBBKi8sIDgzIC8qIFMqLywgNjhdO1xyXG5cclxuICAgIC8vIGludGVybmFsc1xyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICBsZXQgRVBTID0gMC4wMDAwMDE7XHJcblxyXG4gICAgbGV0IF9jaGFuZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICBsZXQgX3N0YXRlID0gU1RBVEUuTk9ORSxcclxuICAgIF9wcmV2U3RhdGUgPSBTVEFURS5OT05FLFxyXG5cclxuICAgIF9leWUgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuICAgIF96b29tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgX3pvb21FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG5cclxuICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gMCxcclxuICAgIF90b3VjaFpvb21EaXN0YW5jZUVuZCA9IDAsXHJcblxyXG4gICAgX3BhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICAgIF9wYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuICAgIC8vIHdpbmRvdyBsZXZlbCBmaXJlIGFmdGVyLi4uXHJcblxyXG4gICAgLy8gZm9yIHJlc2V0XHJcblxyXG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcclxuICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcclxuICAgIHRoaXMudXAwID0gdGhpcy5vYmplY3QudXAuY2xvbmUoKTtcclxuXHJcbiAgICB0aGlzLmxlZnQwID0gdGhpcy5vYmplY3QubGVmdDtcclxuICAgIHRoaXMucmlnaHQwID0gdGhpcy5vYmplY3QucmlnaHQ7XHJcbiAgICB0aGlzLnRvcDAgPSB0aGlzLm9iamVjdC50b3A7XHJcbiAgICB0aGlzLmJvdHRvbTAgPSB0aGlzLm9iamVjdC5ib3R0b207XHJcblxyXG4gICAgLy8gZXZlbnRzXHJcblxyXG4gICAgbGV0IGNoYW5nZUV2ZW50ID0ge3R5cGU6ICdjaGFuZ2UnfTtcclxuICAgIGxldCBzdGFydEV2ZW50ID0ge3R5cGU6ICdzdGFydCd9O1xyXG4gICAgbGV0IGVuZEV2ZW50ID0ge3R5cGU6ICdlbmQnfTtcclxuXHJcbiAgICAvLyBtZXRob2RzXHJcblxyXG4gICAgdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLnNjcmVlbi5sZWZ0ID0gMDtcclxuICAgICAgICB0aGlzLnNjcmVlbi50b3AgPSAwO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBib3ggPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgLy8gYWRqdXN0bWVudHMgY29tZSBmcm9tIHNpbWlsYXIgY29kZSBpbiB0aGUganF1ZXJ5IG9mZnNldCgpIGZ1bmN0aW9uXHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ubGVmdCA9IGJveC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0IC0gZC5jbGllbnRMZWZ0O1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLnRvcCA9IGJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSBkLmNsaWVudFRvcDtcclxuICAgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IGJveC53aWR0aDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBib3guaGVpZ2h0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIE1hdGgubWluKHRoaXMuc2NyZWVuLndpZHRoLCB0aGlzLnNjcmVlbi5oZWlnaHQpO1xyXG5cclxuICAgICAgdGhpcy5sZWZ0MCA9IHRoaXMub2JqZWN0LmxlZnQ7XHJcbiAgICAgIHRoaXMucmlnaHQwID0gdGhpcy5vYmplY3QucmlnaHQ7XHJcbiAgICAgIHRoaXMudG9wMCA9IHRoaXMub2JqZWN0LnRvcDtcclxuICAgICAgdGhpcy5ib3R0b20wID0gdGhpcy5vYmplY3QuYm90dG9tO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzW2V2ZW50LnR5cGVdID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZ2V0TW91c2VPblNjcmVlbiA9IChmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0TW91c2VPblNjcmVlbihwYWdlWCwgcGFnZVkpIHtcclxuICAgICAgICB2ZWN0b3Iuc2V0KFxyXG4gICAgICAgICAgKHBhZ2VYIC0gX3RoaXMuc2NyZWVuLmxlZnQpIC8gX3RoaXMuc2NyZWVuLndpZHRoLFxyXG4gICAgICAgICAgKHBhZ2VZIC0gX3RoaXMuc2NyZWVuLnRvcCkgLyBfdGhpcy5zY3JlZW4uaGVpZ2h0XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdGhpcy56b29tQ2FtZXJhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlRPVUNIX1pPT01fUEFOKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvciA9IF90b3VjaFpvb21EaXN0YW5jZUVuZCAvIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0O1xyXG4gICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kO1xyXG5cclxuICAgICAgICBfdGhpcy5vYmplY3Quem9vbSAqPSBmYWN0b3I7XHJcblxyXG4gICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZmFjdG9yID0gMS4wICsgKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogX3RoaXMuem9vbVNwZWVkO1xyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMoZmFjdG9yIC0gMS4wKSA+IEVQUyAmJiBmYWN0b3IgPiAwLjApIHtcclxuICAgICAgICAgIF90aGlzLm9iamVjdC56b29tIC89IGZhY3RvcjtcclxuXHJcbiAgICAgICAgICBpZiAoX3RoaXMuc3RhdGljTW92aW5nKSB7XHJcbiAgICAgICAgICAgIF96b29tU3RhcnQuY29weShfem9vbUVuZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfem9vbVN0YXJ0LnkgKz0gKF96b29tRW5kLnkgLSBfem9vbVN0YXJ0LnkpICogdGhpcy5keW5hbWljRGFtcGluZ0ZhY3RvcjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBfY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucGFuQ2FtZXJhID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgbW91c2VDaGFuZ2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgICAgIG9iamVjdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgICAgICBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbkNhbWVyYSgpIHtcclxuICAgICAgICBtb3VzZUNoYW5nZS5jb3B5KF9wYW5FbmQpLnN1YihfcGFuU3RhcnQpO1xyXG5cclxuICAgICAgICBpZiAobW91c2VDaGFuZ2UubGVuZ3RoU3EoKSkge1xyXG4gICAgICAgICAgLy8gU2NhbGUgbW92ZW1lbnQgdG8ga2VlcCBjbGlja2VkL2RyYWdnZWQgcG9zaXRpb24gdW5kZXIgY3Vyc29yXHJcbiAgICAgICAgICBsZXQgc2NhbGVfeCA9IChfdGhpcy5vYmplY3QucmlnaHQgLSBfdGhpcy5vYmplY3QubGVmdCkgLyBfdGhpcy5vYmplY3Quem9vbTtcclxuICAgICAgICAgIGxldCBzY2FsZV95ID0gKF90aGlzLm9iamVjdC50b3AgLSBfdGhpcy5vYmplY3QuYm90dG9tKSAvIF90aGlzLm9iamVjdC56b29tO1xyXG4gICAgICAgICAgbW91c2VDaGFuZ2UueCAqPSBzY2FsZV94O1xyXG4gICAgICAgICAgbW91c2VDaGFuZ2UueSAqPSBzY2FsZV95O1xyXG5cclxuICAgICAgICAgIHBhbi5jb3B5KF9leWUpLmNyb3NzKF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLngpO1xyXG4gICAgICAgICAgcGFuLmFkZChvYmplY3RVcC5jb3B5KF90aGlzLm9iamVjdC51cCkuc2V0TGVuZ3RoKG1vdXNlQ2hhbmdlLnkpKTtcclxuXHJcbiAgICAgICAgICBfdGhpcy5vYmplY3QucG9zaXRpb24uYWRkKHBhbik7XHJcbiAgICAgICAgICBfdGhpcy50YXJnZXQuYWRkKHBhbik7XHJcblxyXG4gICAgICAgICAgaWYgKF90aGlzLnN0YXRpY01vdmluZykge1xyXG4gICAgICAgICAgICBfcGFuU3RhcnQuY29weShfcGFuRW5kKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9wYW5TdGFydC5hZGQobW91c2VDaGFuZ2Uuc3ViVmVjdG9ycyhfcGFuRW5kLCBfcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKF90aGlzLmR5bmFtaWNEYW1waW5nRmFjdG9yKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX2V5ZS5zdWJWZWN0b3JzKF90aGlzLm9iamVjdC5wb3NpdGlvbiwgX3RoaXMudGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmICghX3RoaXMubm9ab29tKSB7XHJcbiAgICAgICAgX3RoaXMuem9vbUNhbWVyYSgpO1xyXG5cclxuICAgICAgICBpZiAoX2NoYW5nZWQpIHtcclxuICAgICAgICAgIF90aGlzLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3RoaXMucGFuQ2FtZXJhKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5hZGRWZWN0b3JzKF90aGlzLnRhcmdldCwgX2V5ZSk7XHJcblxyXG4gICAgICBfdGhpcy5vYmplY3QubG9va0F0KF90aGlzLnRhcmdldCk7XHJcblxyXG4gICAgICBpZiAoX2NoYW5nZWQpIHtcclxuICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcclxuXHJcbiAgICAgICAgX2NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9zdGF0ZSA9IFNUQVRFLk5PTkU7XHJcbiAgICAgIF9wcmV2U3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgX3RoaXMudGFyZ2V0LmNvcHkoX3RoaXMudGFyZ2V0MCk7XHJcbiAgICAgIF90aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KF90aGlzLnBvc2l0aW9uMCk7XHJcbiAgICAgIF90aGlzLm9iamVjdC51cC5jb3B5KF90aGlzLnVwMCk7XHJcblxyXG4gICAgICBfZXllLnN1YlZlY3RvcnMoX3RoaXMub2JqZWN0LnBvc2l0aW9uLCBfdGhpcy50YXJnZXQpO1xyXG5cclxuICAgICAgX3RoaXMub2JqZWN0LmxlZnQgPSBfdGhpcy5sZWZ0MDtcclxuICAgICAgX3RoaXMub2JqZWN0LnJpZ2h0ID0gX3RoaXMucmlnaHQwO1xyXG4gICAgICBfdGhpcy5vYmplY3QudG9wID0gX3RoaXMudG9wMDtcclxuICAgICAgX3RoaXMub2JqZWN0LmJvdHRvbSA9IF90aGlzLmJvdHRvbTA7XHJcblxyXG4gICAgICBfdGhpcy5vYmplY3QubG9va0F0KF90aGlzLnRhcmdldCk7XHJcblxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcclxuXHJcbiAgICAgIF9jaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGxpc3RlbmVyc1xyXG5cclxuICAgIGZ1bmN0aW9uIGtleWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24pO1xyXG5cclxuICAgICAgX3ByZXZTdGF0ZSA9IF9zdGF0ZTtcclxuXHJcbiAgICAgIGlmIChfc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gX3RoaXMua2V5c1tTVEFURS5ST1RBVEVdICYmICFfdGhpcy5ub1JvdGF0ZSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IFNUQVRFLlJPVEFURTtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBfdGhpcy5rZXlzW1NUQVRFLlpPT01dICYmICFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfc3RhdGUgPSBTVEFURS5aT09NO1xyXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IF90aGlzLmtleXNbU1RBVEUuUEFOXSAmJiAhX3RoaXMubm9QYW4pIHtcclxuICAgICAgICBfc3RhdGUgPSBTVEFURS5QQU47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXl1cChldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIF9zdGF0ZSA9IF9wcmV2U3RhdGU7XHJcblxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLk5PTkUpIHtcclxuICAgICAgICBfc3RhdGUgPSBldmVudC5idXR0b247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlJPVEFURSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfem9vbVN0YXJ0LmNvcHkoZ2V0TW91c2VPblNjcmVlbihldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpKTtcclxuICAgICAgICBfem9vbUVuZC5jb3B5KF96b29tU3RhcnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKF9zdGF0ZSA9PT0gU1RBVEUuUEFOICYmICFfdGhpcy5ub1Bhbikge1xyXG4gICAgICAgIF9wYW5TdGFydC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgICAgX3BhbkVuZC5jb3B5KF9wYW5TdGFydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZXZlbnQpIHtcclxuICAgICAgaWYgKF90aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIGlmIChfc3RhdGUgPT09IFNUQVRFLlJPVEFURSAmJiAhX3RoaXMubm9Sb3RhdGUpIHtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5aT09NICYmICFfdGhpcy5ub1pvb20pIHtcclxuICAgICAgICBfem9vbUVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoX3N0YXRlID09PSBTVEFURS5QQU4gJiYgIV90aGlzLm5vUGFuKSB7XHJcbiAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZXVwKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXApO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICBsZXQgZGVsdGEgPSAwO1xyXG5cclxuICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcclxuICAgICAgICAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcclxuXHJcbiAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gNDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveFxyXG5cclxuICAgICAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGSVJFIFNDUk9MTCBFVkVOVFxyXG5cclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudCh7XHJcbiAgICAgICAgdHlwZTogJ09uU2Nyb2xsJyxcclxuICAgICAgICBkZWx0YTogZGVsdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gX3pvb21TdGFydC55ICs9IGRlbHRhICogMC4wMTtcclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcclxuICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG91Y2hzdGFydChldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIHN3aXRjaCAoZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgX3N0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5UT1VDSF9aT09NX1BBTjtcclxuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xyXG4gICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XHJcbiAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBfdG91Y2hab29tRGlzdGFuY2VTdGFydCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gICAgICAgICAgdmFyIHggPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcclxuICAgICAgICAgIHZhciB5ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgKyBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSAvIDI7XHJcbiAgICAgICAgICBfcGFuU3RhcnQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgIF9wYW5FbmQuY29weShfcGFuU3RhcnQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgfVxyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvdWNobW92ZShldmVudCkge1xyXG4gICAgICBpZiAoX3RoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICBjYXNlIDE6XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xyXG4gICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVk7XHJcbiAgICAgICAgICBfdG91Y2hab29tRGlzdGFuY2VFbmQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggKyBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XHJcbiAgICAgICAgICB2YXIgeSA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xyXG4gICAgICAgICAgX3BhbkVuZC5jb3B5KGdldE1vdXNlT25TY3JlZW4oeCwgeSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvdWNoZW5kKGV2ZW50KSB7XHJcbiAgICAgIGlmIChfdGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgc3dpdGNoIChldmVudC50b3VjaGVzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICBjYXNlIDE6XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIF90b3VjaFpvb21EaXN0YW5jZVN0YXJ0ID0gX3RvdWNoWm9vbURpc3RhbmNlRW5kID0gMDtcclxuXHJcbiAgICAgICAgICB2YXIgeCA9IChldmVudC50b3VjaGVzWzBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sxXS5wYWdlWCkgLyAyO1xyXG4gICAgICAgICAgdmFyIHkgPSAoZXZlbnQudG91Y2hlc1swXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcclxuICAgICAgICAgIF9wYW5FbmQuY29weShnZXRNb3VzZU9uU2NyZWVuKHgsIHkpKTtcclxuICAgICAgICAgIF9wYW5TdGFydC5jb3B5KF9wYW5FbmQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBfc3RhdGUgPSBTVEFURS5OT05FO1xyXG4gICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250ZXh0bWVudShldmVudCkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBjb250ZXh0bWVudSwgZmFsc2UpO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIG1vdXNld2hlZWwsIGZhbHNlKTsgLy8gZmlyZWZveFxyXG5cclxuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmUsIGZhbHNlKTtcclxuXHJcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSwgZmFsc2UpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCwgZmFsc2UpO1xyXG5cclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duLCBmYWxzZSk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGtleXVwLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGNvbnRleHRtZW51LCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duLCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIG1vdXNld2hlZWwsIGZhbHNlKTtcclxuICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgbW91c2V3aGVlbCwgZmFsc2UpOyAvLyBmaXJlZm94XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UpO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXAsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xyXG5cclxuICAgIC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcbn1cclxuXHJcbiIsIi8qKlxyXG4gKiBDb2xvcnMgdXRpbGl0eSBmdW5jdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ycyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgTEFCIHRvIFhZWlxyXG4gICAqIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA4I3RleHQ4XHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGxcclxuICAgKiBAcGFyYW0geyp9IGFcclxuICAgKiBAcGFyYW0geyp9IGJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIGNpZWxhYjJYWVoobCwgYSwgYikge1xyXG4gICAgY29uc3QgcmVmWCA9IDk1LjA0NztcclxuICAgIGNvbnN0IHJlZlkgPSAxMDAuMDA7XHJcbiAgICBjb25zdCByZWZaID0gMTA4Ljg4MztcclxuXHJcbiAgICBsZXQgeSA9IChsICsgMTYpIC8gMTE2O1xyXG4gICAgbGV0IHggPSBhIC8gNTAwICsgeTtcclxuICAgIGxldCB6ID0geSAtIGIgLyAyMDA7XHJcblxyXG4gICAgaWYgKE1hdGgucG93KHksIDMpID4gMC4wMDg4NTYpIHtcclxuICAgICAgeSA9IE1hdGgucG93KHksIDMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeSA9ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGgucG93KHgsIDMpID4gMC4wMDg4NTYpIHtcclxuICAgICAgeCA9IE1hdGgucG93KHgsIDMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeCA9ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGgucG93KHosIDMpID4gMC4wMDg4NTYpIHtcclxuICAgICAgeiA9IE1hdGgucG93KHosIDMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeiA9ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtyZWZYICogeCwgcmVmWSAqIHksIHJlZlogKiB6XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgWFlaIHRvIFJHQiBzcGFjZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB4XHJcbiAgICogQHBhcmFtIHsqfSB5XHJcbiAgICogQHBhcmFtIHsqfSB6XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyB4eXoyUkdCKHgsIHksIHopIHtcclxuICAgIHggLz0gMTAwO1xyXG4gICAgeSAvPSAxMDA7XHJcbiAgICB6IC89IDEwMDtcclxuICAgIGxldCByID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODY7XHJcbiAgICBsZXQgZyA9IHggKiAtMC45Njg5ICsgeSAqIDEuODc1OCArIHogKiAwLjA0MTU7XHJcbiAgICBsZXQgYiA9IHggKiAwLjA1NTcgKyB5ICogLTAuMjA0MCArIHogKiAxLjA1NzA7XHJcblxyXG4gICAgaWYgKHIgPiAwLjAwMzEzMDgpIHtcclxuICAgICAgciA9IDEuMDU1ICogKE1hdGgucG93KHIsIDEgLyAyLjQpKSAtIDAuMDU1O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IDEyLjkyICogcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZyA+IDAuMDAzMTMwOCkge1xyXG4gICAgICBnID0gMS4wNTUgKiAoTWF0aC5wb3coZywgMSAvIDIuNCkpIC0gMC4wNTU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnID0gMTIuOTIgKiBnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiID4gMC4wMDMxMzA4KSB7XHJcbiAgICAgIGIgPSAxLjA1NSAqIChNYXRoLnBvdyhiLCAxIC8gMi40KSkgLSAwLjA1NTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGIgPSAxMi45MiAqIGI7XHJcbiAgICB9XHJcblxyXG4gICAgciA9IHIgKiAyNTU7XHJcbiAgICBnID0gZyAqIDI1NTtcclxuICAgIGIgPSBiICogMjU1O1xyXG5cclxuICAgIHJldHVybiBbciwgZywgYl07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IExBQiB0byBSR0JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gbFxyXG4gICAqIEBwYXJhbSB7Kn0gYVxyXG4gICAqIEBwYXJhbSB7Kn0gYlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgY2llbGFiMlJHQihsID0gNTAsIGEgPSAwLCBiID0gMCkge1xyXG4gICAgaWYgKCEobCA+PSAwICYmIGwgPD0gMTAwKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgeHl6ID0gdGhpcy5jaWVsYWIyWFlaKGwsIGEsIGIpO1xyXG4gICAgcmV0dXJuIHRoaXMueHl6MlJHQiguLi54eXopO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IENvcmVVdGlscyBmcm9tICcuL2NvcmUudXRpbHMnO1xyXG5pbXBvcnQgVmFsaWRhdG9ycyBmcm9tICcuL2NvcmUudmFsaWRhdG9ycyc7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZS90ZXN0IGludGVyc2VjdGlvbiBiZXR3ZWVuIGRpZmZlcmVudCBvYmplY3RzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGNvcmUvaW50ZXJzZWN0aW9uc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVyc2VjdGlvbnMge1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gb3JpZW50ZWQgYm91bmRpbmcgYm94IGFuZCBhIHBsYW5lLlxyXG4gKlxyXG4gKiBSZXR1cm5zIGludGVyc2VjdGlvbiBpbiBwbGFuZSdzIHNwYWNlLlxyXG4gKlxyXG4gKiBTaG91bGQgcmV0dXJuIGF0IGxlYXN0IDMgaW50ZXJzZWN0aW9ucy4gSWYgbm90LCB0aGUgcGxhbmUgYW5kIHRoZSBib3ggZG8gbm90XHJcbiAqIGludGVyc2VjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGFhYmIgLSBBeGUgQWxpZ25lZCBCb3VuZGluZyBCb3ggcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gYWFiYi5oYWxmRGltZW5zaW9ucyAtIEhhbGYgZGltZW5zaW9ucyBvZiB0aGUgYm94LlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IGFhYmIuY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3guXHJcbiAqIEBwYXJhbSB7VEhSRUUuTWF0cml4NH0gYWFiYi50b0FBQkIgLSBUcmFuc2Zvcm0gdG8gZ28gZnJvbSBwbGFuZSBzcGFjZSB0byBib3ggc3BhY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGFuZSAtIFBsYW5lIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGxhbmUucG9zaXRpb24gLSBwb3NpdGlvbiBvZiBub3JtYWwgd2hpY2ggZGVzY3JpYmVzIHRoZSBwbGFuZS5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwbGFuZS5kaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheTxUSFJFRS5WZWN0b3IzPn0gTGlzdCBvZiBhbGwgaW50ZXJzZWN0aW9ucyBpbiBwbGFuZSdzIHNwYWNlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaXMgaW52YWxpZCBpbnB1dCBwcm92aWRlZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy9SZXR1cm5zIGFycmF5IHdpdGggaW50ZXJzZWN0aW9uIE4gaW50ZXJzZWN0aW9uc1xyXG4gKiBsZXQgYWFiYiA9IHtcclxuICogICBjZW50ZXI6IG5ldyBUSFJFRS5WZWN0b3IzKDE1MCwgMTUwLCAxNTApLFxyXG4gKiAgIGhhbGZEaW1lbnNpb25zOiBuZXcgVEhSRUUuVmVjdG9yMyg1MCwgNjAsIDcwKSxcclxuICogICB0b0FBQkI6IG5ldyBUSFJFRS5NYXRyaXg0KClcclxuICogfVxyXG4gKiBsZXQgcGxhbmUgPSB7XHJcbiAqICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDExMCwgMTIwLCAxMzApLFxyXG4gKiAgIGRpcmVjdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMClcclxuICogfVxyXG4gKlxyXG4gKiBsZXQgaW50ZXJzZWN0aW9ucyA9IENvcmVJbnRlcnNlY3Rpb25zLmFhYmJQbGFuZShhYWJiLCBwbGFuZSk7XHJcbiAqIC8vIGludGVyc2VjdGlvbnMgPT1cclxuICogLy9bIHsgeCA6IDExMCwgeSA6IDkwLCAgeiA6IDgwIH0sXHJcbiAqIC8vICB7IHggOiAxMTAsIHkgOiAyMTAsIHogOiAyMjAgfSxcclxuICogLy8gIHsgeCA6IDExMCwgeSA6IDIxMCwgeiA6IDgwIH0sXHJcbiAqIC8vICB7IHggOiAxMTAsIHkgOiA5MCwgIHogOiAyMjAgfSBdXHJcbiAqXHJcbiAqIC8vUmV0dXJucyBlbXB0eSBhcnJheSB3aXRoIDAgaW50ZXJzZWN0aW9uc1xyXG4gKiBsZXQgYWFiYiA9IHtcclxuICpcclxuICogfVxyXG4gKiBsZXQgcGxhbmUgPSB7XHJcbiAqXHJcbiAqIH1cclxuICpcclxuICogbGV0IGludGVyc2VjdGlvbnMgPSBWSlMuQ29yZS5WYWxpZGF0b3JzLm1hdHJpeDQobmV3IFRIUkVFLlZlY3RvcjMoKSk7XHJcbiAqXHJcbiAqIC8vUmV0dXJucyBmYWxzZSBpZiBpbnZhbGlkIGlucHV0P1xyXG4gKlxyXG4gKi9cclxuICBzdGF0aWMgYWFiYlBsYW5lKGFhYmIsIHBsYW5lKSB7XHJcbiAgICAvL1xyXG4gICAgLy8gb2JiID0geyBoYWxmRGltZW5zaW9ucywgb3JpZW50YXRpb24sIGNlbnRlciwgdG9BQUJCIH1cclxuICAgIC8vIHBsYW5lID0geyBwb3NpdGlvbiwgZGlyZWN0aW9uIH1cclxuICAgIC8vXHJcbiAgICAvL1xyXG4gICAgLy8gTE9HSUM6XHJcbiAgICAvL1xyXG4gICAgLy8gVGVzdCBpbnRlcnNlY3Rpb24gb2YgZWFjaCBlZGdlIG9mIHRoZSBPcmllbnRlZCBCb3VuZGluZyBCb3ggd2l0aCB0aGUgUGxhbmVcclxuICAgIC8vXHJcbiAgICAvLyBBTEwgRURHRVNcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIC4rLS0tLS0tLStcclxuICAgIC8vICAgIC4nIHwgICAgIC4nfFxyXG4gICAgLy8gICArLS0tKy0tLSsnICB8XHJcbiAgICAvLyAgIHwgICB8ICAgfCAgIHxcclxuICAgIC8vICAgfCAgLCstLS0rLS0tK1xyXG4gICAgLy8gICB8LicgICAgIHwgLidcclxuICAgIC8vICAgKy0tLS0tLS0rJ1xyXG4gICAgLy9cclxuICAgIC8vIFNQQUNFIE9SSUVOVEFUSU9OXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgK1xyXG4gICAgLy8gICAgIGogfFxyXG4gICAgLy8gICAgICAgfFxyXG4gICAgLy8gICAgICAgfCAgIGlcclxuICAgIC8vICAgayAgLCstLS0tLS0tK1xyXG4gICAgLy8gICAgLidcclxuICAgIC8vICAgK1xyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyAxLSBNb3ZlIFBsYW5lIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBpbiBJSksgc3BhY2VcclxuICAgIC8vIDItIFRlc3QgRWRnZXMvIElKSyBQbGFuZSBpbnRlcnNlY3Rpb25zXHJcbiAgICAvLyAzLSBSZXR1cm4gaW50ZXJzZWN0aW9uIEVkZ2UvIElKSyBQbGFuZSBpZiBpdCB0b3VjaGVzIHRoZSBPcmllbnRlZCBCQm94XHJcblxyXG4gICAgbGV0IGludGVyc2VjdGlvbnMgPSBbXTtcclxuXHJcbiAgICBpZiAoISh0aGlzLnZhbGlkYXRlQWFiYihhYWJiKSAmJlxyXG4gICAgICAgdGhpcy52YWxpZGF0ZVBsYW5lKHBsYW5lKSkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIgb3IgcGxhbmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnZlcnQgc3BhY2UgbWF0cml4XHJcbiAgICBsZXQgZnJvbUFBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgZnJvbUFBQkIuZ2V0SW52ZXJzZShhYWJiLnRvQUFCQik7XHJcblxyXG4gICAgbGV0IHQxID0gcGxhbmUuZGlyZWN0aW9uLmNsb25lKCkuYXBwbHlNYXRyaXg0KGFhYmIudG9BQUJCKTtcclxuICAgIGxldCB0MCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLmFwcGx5TWF0cml4NChhYWJiLnRvQUFCQik7XHJcblxyXG4gICAgbGV0IHBsYW5lQUFCQiA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBwbGFuZS5wb3NpdGlvbi5jbG9uZSgpLmFwcGx5TWF0cml4NChhYWJiLnRvQUFCQiksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKHQxLnggLSB0MC54LCB0MS55IC0gdDAueSwgdDEueiAtIHQwLnopLm5vcm1hbGl6ZSgpXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBiYm94ID0gQ29yZVV0aWxzLmJib3goYWFiYi5jZW50ZXIsIGFhYmIuaGFsZkRpbWVuc2lvbnMpO1xyXG5cclxuICAgIGxldCBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKTtcclxuXHJcbiAgICAvLyAxMiBlZGdlcyAoaS5lLiByYXkpL3BsYW5lIGludGVyc2VjdGlvbiB0ZXN0c1xyXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBGSVJTVCBDT1JORVIgKDAsIDAsIDApXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgK1xyXG4gICAgLy8gICAgICAgfFxyXG4gICAgLy8gICAgICAgfFxyXG4gICAgLy8gICAgICAgfFxyXG4gICAgLy8gICAgICAsKy0tLSstLS0rXHJcbiAgICAvLyAgICAuJ1xyXG4gICAgLy8gICArXHJcblxyXG4gICAgbGV0IHJheSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBhYWJiLmNlbnRlci54IC0gYWFiYi5oYWxmRGltZW5zaW9ucy54LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueiAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueiksXHJcbiAgICAgIG9yaWVudGF0aW9uLnhcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICByYXkuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheS5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi56O1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBMQVNUIENPUk5FUlxyXG4gICAgLy9cclxuICAgIC8vICAgICAgICAgICAgICAgK1xyXG4gICAgLy8gICAgICAgICAgICAgLidcclxuICAgIC8vICAgKy0tLS0tLS0rJ1xyXG4gICAgLy8gICAgICAgICAgIHxcclxuICAgIC8vICAgICAgICAgICB8XHJcbiAgICAvLyAgICAgICAgICAgfFxyXG4gICAgLy8gICAgICAgICAgICtcclxuICAgIC8vXHJcblxyXG4gICAgbGV0IHJheTIgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueCArIGFhYmIuaGFsZkRpbWVuc2lvbnMueCxcclxuICAgICAgICBhYWJiLmNlbnRlci55ICsgYWFiYi5oYWxmRGltZW5zaW9ucy55LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnogKyBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxyXG4gICAgICBvcmllbnRhdGlvbi54XHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkyLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheTIuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5MiwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICByYXkyLmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLno7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTIsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBTRUNPTkQgQ09STkVSXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAgICAgICAgICArXHJcbiAgICAvLyAgICAgICAgICAgICAgIHxcclxuICAgIC8vICAgICAgICAgICAgICAgfFxyXG4gICAgLy8gICAgICAgICAgICAgICB8XHJcbiAgICAvLyAgICAgICAgICAgICAgICtcclxuICAgIC8vICAgICAgICAgICAgIC4nXHJcbiAgICAvLyAgICAgICAgICAgKydcclxuXHJcbiAgICBsZXQgcmF5MyA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBhYWJiLmNlbnRlci54ICsgYWFiYi5oYWxmRGltZW5zaW9ucy54LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnkgLSBhYWJiLmhhbGZEaW1lbnNpb25zLnksXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueiAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueiksXHJcbiAgICAgIG9yaWVudGF0aW9uLnlcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTMsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgcmF5My5kaXJlY3Rpb24gPSBvcmllbnRhdGlvbi56O1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXkzLCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIFJBWVMgU1RBUlRJTkcgRlJPTSBUSEUgVEhJUkQgQ09STkVSXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICAuKy0tLS0tLS0rXHJcbiAgICAvLyAgICAuJ1xyXG4gICAgLy8gICArXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvL1xyXG5cclxuICAgIGxldCByYXk0ID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnggLSBhYWJiLmhhbGZEaW1lbnNpb25zLngsXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueSArIGFhYmIuaGFsZkRpbWVuc2lvbnMueSxcclxuICAgICAgICBhYWJiLmNlbnRlci56IC0gYWFiYi5oYWxmRGltZW5zaW9ucy56KSxcclxuICAgICAgb3JpZW50YXRpb24ueFxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NCwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICByYXk0LmRpcmVjdGlvbiA9IG9yaWVudGF0aW9uLno7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheTQsIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gUkFZUyBTVEFSVElORyBGUk9NIFRIRSBGT1VSVEggQ09STkVSXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyAgICtcclxuICAgIC8vICAgfFxyXG4gICAgLy8gICB8XHJcbiAgICAvLyAgIHxcclxuICAgIC8vICAgKy0tLS0tLS0rXHJcblxyXG4gICAgbGV0IHJheTUgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYWFiYi5jZW50ZXIueCAtIGFhYmIuaGFsZkRpbWVuc2lvbnMueCxcclxuICAgICAgICBhYWJiLmNlbnRlci55IC0gYWFiYi5oYWxmRGltZW5zaW9ucy55LFxyXG4gICAgICAgIGFhYmIuY2VudGVyLnogKyBhYWJiLmhhbGZEaW1lbnNpb25zLnopLFxyXG4gICAgICBvcmllbnRhdGlvbi54XHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXk1LCBwbGFuZUFBQkIsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIHJheTUuZGlyZWN0aW9uID0gb3JpZW50YXRpb24ueTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5NSwgcGxhbmVBQUJCLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBAdG9kbyBtYWtlIHN1cmUgb2JqZWN0cyBhcmUgdW5pcXVlLi4uXHJcblxyXG4gICAgLy8gYmFjayB0byBvcmlnaW5hbCBzcGFjZVxyXG4gICAgaW50ZXJzZWN0aW9ucy5tYXAoXHJcbiAgICAgIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudC5hcHBseU1hdHJpeDQoZnJvbUFBQkIpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xyXG4gIH1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCBhIHBsYW5lLlxyXG4gKlxyXG4gKiBAbWVtYmVyT2YgdGhpc1xyXG4gKiBAcHVibGljXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByYXkgLSBSYXkgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcmF5LnBvc2l0aW9uIC0gcG9zaXRpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcmF5LlxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHJheS5kaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcmF5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhbmUgLSBQbGFuZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBsYW5lLnBvc2l0aW9uIC0gcG9zaXRpb24gb2Ygbm9ybWFsIHdoaWNoIGRlc2NyaWJlcyB0aGUgcGxhbmUuXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGxhbmUuZGlyZWN0aW9uIC0gRGlyZWN0aW9uIG9mIG5vcm1hbCB3aGljaCBkZXNjcmliZXMgdGhlIHBsYW5lLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yM3xudWxsfSBJbnRlcnNlY3Rpb24gYmV0d2VlbiByYXkgYW5kIHBsYW5lIG9yIG51bGwuXHJcbiAqL1xyXG4gIHN0YXRpYyByYXlQbGFuZShyYXksIHBsYW5lKSB7XHJcbiAgLy8gcmF5OiB7cG9zaXRpb24sIGRpcmVjdGlvbn1cclxuICAvLyBwbGFuZToge3Bvc2l0aW9uLCBkaXJlY3Rpb259XHJcblxyXG4gIGlmIChyYXkuZGlyZWN0aW9uLmRvdChwbGFuZS5kaXJlY3Rpb24pICE9PSAwKSB7XHJcbiAgICAvL1xyXG4gICAgLy8gbm90IHBhcmFsbGVsLCBtb3ZlIGZvcndhcmRcclxuICAgIC8vXHJcbiAgICAvLyBMT0dJQzpcclxuICAgIC8vXHJcbiAgICAvLyBSYXkgZXF1YXRpb246IFAgPSBQMCArIHRWXHJcbiAgICAvLyBQID0gPFB4LCBQeSwgUHo+XHJcbiAgICAvLyBQMCA9IDxyYXkucG9zaXRpb24ueCwgcmF5LnBvc2l0aW9uLnksIHJheS5wb3NpdGlvbi56PlxyXG4gICAgLy8gViA9IDxyYXkuZGlyZWN0aW9uLngsIHJheS5kaXJlY3Rpb24ueSwgcmF5LmRpcmVjdGlvbi56PlxyXG4gICAgLy9cclxuICAgIC8vIFRoZXJlZm9yZTpcclxuICAgIC8vIFB4ID0gcmF5LnBvc2l0aW9uLnggKyB0KnJheS5kaXJlY3Rpb24ueFxyXG4gICAgLy8gUHkgPSByYXkucG9zaXRpb24ueSArIHQqcmF5LmRpcmVjdGlvbi55XHJcbiAgICAvLyBQeiA9IHJheS5wb3NpdGlvbi56ICsgdCpyYXkuZGlyZWN0aW9uLnpcclxuICAgIC8vXHJcbiAgICAvL1xyXG4gICAgLy9cclxuICAgIC8vIFBsYW5lIGVxdWF0aW9uOiBheCArIGJ5ICsgY3ogKyBkID0gMFxyXG4gICAgLy8gYSA9IHBsYW5lLmRpcmVjdGlvbi54XHJcbiAgICAvLyBiID0gcGxhbmUuZGlyZWN0aW9uLnlcclxuICAgIC8vIGMgPSBwbGFuZS5kaXJlY3Rpb24uelxyXG4gICAgLy8gZCA9IC0oIHBsYW5lLmRpcmVjdGlvbi54KnBsYW5lLnBvc2l0aW9uLnggK1xyXG4gICAgLy8gICAgICAgIHBsYW5lLmRpcmVjdGlvbi55KnBsYW5lLnBvc2l0aW9uLnkgK1xyXG4gICAgLy8gICAgICAgIHBsYW5lLmRpcmVjdGlvbi56KnBsYW5lLnBvc2l0aW9uLnogKVxyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyAxLSBpbiB0aGUgcGxhbmUgZXF1YXRpb24sIHdlIHJlcGxhY2UgeCwgeSBhbmQgeiBieSBQeCwgUHkgYW5kIFB6XHJcbiAgICAvLyAyLSBmaW5kIHRcclxuICAgIC8vIDMtIHJlcGxhY2UgdCBpbiBQeCwgUHkgYW5kIFB6IHRvIGdldCB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICAvL1xyXG4gICAgbGV0IHQgPSAocGxhbmUuZGlyZWN0aW9uLnggKiAocGxhbmUucG9zaXRpb24ueCAtIHJheS5wb3NpdGlvbi54KSArIHBsYW5lLmRpcmVjdGlvbi55ICogKHBsYW5lLnBvc2l0aW9uLnkgLSByYXkucG9zaXRpb24ueSkgKyBwbGFuZS5kaXJlY3Rpb24ueiAqIChwbGFuZS5wb3NpdGlvbi56IC0gcmF5LnBvc2l0aW9uLnopKSAvXHJcbiAgICAgICAgKHBsYW5lLmRpcmVjdGlvbi54ICogcmF5LmRpcmVjdGlvbi54ICsgcGxhbmUuZGlyZWN0aW9uLnkgKiByYXkuZGlyZWN0aW9uLnkgKyBwbGFuZS5kaXJlY3Rpb24ueiAqIHJheS5kaXJlY3Rpb24ueik7XHJcblxyXG4gICAgbGV0IGludGVyc2VjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIHJheS5wb3NpdGlvbi54ICsgdCAqIHJheS5kaXJlY3Rpb24ueCxcclxuICAgICAgICByYXkucG9zaXRpb24ueSArIHQgKiByYXkuZGlyZWN0aW9uLnksXHJcbiAgICAgICAgcmF5LnBvc2l0aW9uLnogKyB0ICogcmF5LmRpcmVjdGlvbi56KTtcclxuXHJcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIHJheSBhbmQgYSBib3hcclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmF5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGJveFxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqL1xyXG4gIHN0YXRpYyByYXlCb3gocmF5LCBib3gpIHtcclxuICAgIC8vIHNob3VsZCBhbHNvIGRvIHRoZSBzcGFjZSB0cmFuc2Zvcm1zIGhlcmVcclxuICAgIC8vIHJheToge3Bvc2l0aW9uLCBkaXJlY3Rpb259XHJcbiAgICAvLyBib3g6IHtoYWxmRGltZW5zaW9ucywgY2VudGVyfVxyXG5cclxuICAgIGxldCBpbnRlcnNlY3Rpb25zID0gW107XHJcblxyXG4gICAgbGV0IGJib3ggPSBDb3JlVXRpbHMuYmJveChib3guY2VudGVyLCBib3guaGFsZkRpbWVuc2lvbnMpO1xyXG5cclxuICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhiYm94KTtcclxuXHJcbiAgICAvLyBYIG1pblxyXG4gICAgbGV0IHBsYW5lID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGJib3gubWluLngsXHJcbiAgICAgICAgYm94LmNlbnRlci55LFxyXG4gICAgICAgIGJveC5jZW50ZXIueiksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKC0xLCAwLCAwKVxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgLy8gWCBtYXhcclxuICAgIHBsYW5lID0gdGhpcy5wb3NkaXIoXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIGJib3gubWF4LngsXHJcbiAgICAgICAgYm94LmNlbnRlci55LFxyXG4gICAgICAgIGJveC5jZW50ZXIueiksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApXHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBZIG1pblxyXG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYm94LmNlbnRlci54LFxyXG4gICAgICAgIGJib3gubWluLnksXHJcbiAgICAgICAgYm94LmNlbnRlci56KSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgLTEsIDApXHJcbiAgICApO1xyXG4gICAgdGhpcy5yYXlQbGFuZUluQkJveChyYXksIHBsYW5lLCBiYm94LCBpbnRlcnNlY3Rpb25zKTtcclxuXHJcbiAgICAvLyBZIG1heFxyXG4gICAgcGxhbmUgPSB0aGlzLnBvc2RpcihcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgYm94LmNlbnRlci54LFxyXG4gICAgICAgIGJib3gubWF4LnksXHJcbiAgICAgICAgYm94LmNlbnRlci56KSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMClcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIFogbWluXHJcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBib3guY2VudGVyLngsXHJcbiAgICAgICAgYm94LmNlbnRlci55LFxyXG4gICAgICAgIGJib3gubWluLnopLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSlcclxuICAgICk7XHJcbiAgICB0aGlzLnJheVBsYW5lSW5CQm94KHJheSwgcGxhbmUsIGJib3gsIGludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgIC8vIFogbWF4XHJcbiAgICBwbGFuZSA9IHRoaXMucG9zZGlyKFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICBib3guY2VudGVyLngsXHJcbiAgICAgICAgYm94LmNlbnRlci55LFxyXG4gICAgICAgIGJib3gubWF4LnopLFxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKVxyXG4gICAgKTtcclxuICAgIHRoaXMucmF5UGxhbmVJbkJCb3gocmF5LCBwbGFuZSwgYmJveCwgaW50ZXJzZWN0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRlcnNlY3Rpb24gYmV0d2VlbiByYXkgYW5kIGEgcGxhbmUgdGhhdCBhcmUgaW4gYSBib3guXHJcbiAgICogQHBhcmFtIHsqfSByYXlcclxuICAgKiBAcGFyYW0geyp9IHBsYW5lQUFCQlxyXG4gICAqIEBwYXJhbSB7Kn0gYmJveFxyXG4gICAqIEBwYXJhbSB7Kn0gaW50ZXJzZWN0aW9uc1xyXG4gICAqL1xyXG4gIHN0YXRpYyByYXlQbGFuZUluQkJveChyYXksIHBsYW5lQUFCQiwgYmJveCwgaW50ZXJzZWN0aW9ucykge1xyXG4gICAgbGV0IGludGVyc2VjdGlvbiA9IHRoaXMucmF5UGxhbmUocmF5LCBwbGFuZUFBQkIpO1xyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKGludGVyc2VjdGlvbik7XHJcbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIHRoaXMuaW5CQm94KGludGVyc2VjdGlvbiwgYmJveCkpIHtcclxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmZpbmQodGhpcy5maW5kSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbikpKSB7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgaW50ZXJzZWN0aW9uIGluIGFycmF5XHJcbiAgICogQHBhcmFtIHsqfSBteWludGVyc2VjdGlvblxyXG4gICAqL1xyXG4gIHN0YXRpYyBmaW5kSW50ZXJzZWN0aW9uKG15aW50ZXJzZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZm91bmQoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XHJcbiAgICAgIGlmIChteWludGVyc2VjdGlvbi54ID09PSBlbGVtZW50LnggJiZcclxuICAgICAgICBteWludGVyc2VjdGlvbi55ID09PSBlbGVtZW50LnkgJiZcclxuICAgICAgICBteWludGVyc2VjdGlvbi56ID09PSBlbGVtZW50LnopIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElzIHBvaW50IGluIGJveC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gYmJveFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGluQkJveChwb2ludCwgYmJveCkge1xyXG4gICAgLy9cclxuICAgIGxldCBlcHNpbG9uID0gMC4wMDAxO1xyXG4gICAgaWYgKHBvaW50ICYmXHJcbiAgICAgICAgcG9pbnQueCA+PSBiYm94Lm1pbi54IC0gZXBzaWxvbiAmJlxyXG4gICAgICAgIHBvaW50LnkgPj0gYmJveC5taW4ueSAtIGVwc2lsb24gJiZcclxuICAgICAgICBwb2ludC56ID49IGJib3gubWluLnogLSBlcHNpbG9uICYmXHJcbiAgICAgICAgcG9pbnQueCA8PSBiYm94Lm1heC54ICsgZXBzaWxvbiAmJlxyXG4gICAgICAgIHBvaW50LnkgPD0gYmJveC5tYXgueSArIGVwc2lsb24gJiZcclxuICAgICAgICBwb2ludC56IDw9IGJib3gubWF4LnogKyBlcHNpbG9uKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHBvc2Rpcihwb3NpdGlvbiwgZGlyZWN0aW9uKSB7XHJcbiAgICByZXR1cm4ge3Bvc2l0aW9uLCBkaXJlY3Rpb259O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHZhbGlkYXRlUGxhbmUocGxhbmUpIHtcclxuICAgIC8vXHJcbiAgICBpZiAocGxhbmUgPT09IG51bGwpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIHBsYW5lLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghVmFsaWRhdG9ycy52ZWN0b3IzKHBsYW5lLnBvc2l0aW9uKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgcGxhbmUucG9zaXRpb24uJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhwbGFuZS5wb3NpdGlvbik7XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFWYWxpZGF0b3JzLnZlY3RvcjMocGxhbmUuZGlyZWN0aW9uKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgcGxhbmUuZGlyZWN0aW9uLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUuZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyB2YWxpZGF0ZUFhYmIoYWFiYikge1xyXG4gICAgLy9cclxuICAgIGlmIChhYWJiID09PSBudWxsKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBhYWJiLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coYWFiYik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIVZhbGlkYXRvcnMubWF0cml4NChhYWJiLnRvQUFCQikpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIudG9BQUJCOiAnKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIudG9BQUJCKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIVZhbGlkYXRvcnMudmVjdG9yMyhhYWJiLmNlbnRlcikpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIuY2VudGVyLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coYWFiYi5jZW50ZXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKFZhbGlkYXRvcnMudmVjdG9yMyhhYWJiLmhhbGZEaW1lbnNpb25zKSAmJlxyXG4gICAgICAgYWFiYi5oYWxmRGltZW5zaW9ucy54ID49IDAgJiZcclxuICAgICAgIGFhYmIuaGFsZkRpbWVuc2lvbnMueSA+PSAwICYmXHJcbiAgICAgICBhYWJiLmhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdJbnZhbGlkIGFhYmIuaGFsZkRpbWVuc2lvbnMuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhYWJiLmhhbGZEaW1lbnNpb25zKTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBDb2xvcnMgZnJvbSAnLi9jb3JlLmNvbG9ycyc7XHJcbmltcG9ydCBJbnRlcnNlY3Rpb25zIGZyb20gJy4vY29yZS5pbnRlcnNlY3Rpb25zJztcclxuaW1wb3J0IFBhY2sgZnJvbSAnLi9jb3JlLnBhY2snO1xyXG5pbXBvcnQgVmFsaWRhdG9ycyBmcm9tICcuL2NvcmUudmFsaWRhdG9ycyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL2NvcmUudXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIENvbG9ycyxcclxuICBJbnRlcnNlY3Rpb25zLFxyXG4gIFV0aWxzLFxyXG4gIFZhbGlkYXRvcnMsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBQYWNraW5nIGZ1bmN0aW9ucy5cclxuICpcclxuICogQG1vZHVsZSBjb3JlL3BhY2sgKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhY2sge1xyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqL1xyXG4gIC8vIHN0YXRpYyBwYWNrVG84Qml0c1RleHR1cmUoYml0cywgY2hhbm5lbHMsIGZyYW1lLCB0ZXh0dXJlU2l6ZSwgc3RhcnRWb3hlbCwgc3RvcFZveGVsKSB7XHJcbiAgLy8gICBsZXQgcGFja2VkID0ge1xyXG4gIC8vICAgICB0ZXh0dXJlVHlwZTogbnVsbCxcclxuICAvLyAgICAgZGF0YTogbnVsbFxyXG4gIC8vICAgfTtcclxuXHJcbiAgLy8gICBsZXQgcGFja0luZGV4ID0gMDtcclxuICAvLyAgIGxldCBmcmFtZUluZGV4ID0gMDtcclxuICAvLyAgIGxldCBpbkZyYW1lSW5kZXggPSAwO1xyXG4gIC8vICAgbGV0IGZyYW1lRGltZW5zaW9uID0gZnJhbWVbMF0ucm93cyAqIGZyYW1lWzBdLmNvbHVtbnM7XHJcbiAgLy8gICBsZXQgZGF0YSA9IG51bGw7XHJcblxyXG4gIC8vICAgaWYgKGJpdHMgPT09IDggJiYgY2hhbm5lbHMgPT09IDEpIHtcclxuICAvLyAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMSk7XHJcbiAgLy8gICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXHJcbiAgLy8gICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XHJcbiAgLy8gICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXHJcblxyXG4gIC8vICAgICAgIGRhdGFbcGFja0luZGV4XSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdO1xyXG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xyXG5cclxuICAvLyAgICAgfVxyXG4gIC8vICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JGb3JtYXQ7XHJcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAvLyAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMTYgJiYgY2hhbm5lbHMgPT09IDEpIHtcclxuICAvLyAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMik7XHJcbiAgLy8gICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXHJcbiAgLy8gICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XHJcbiAgLy8gICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXHJcblxyXG4gIC8vICAgICAgIC8vIHNsb3chXHJcbiAgLy8gICAgICAgLy9sZXQgYXNiID0gVkpTLmNvcmUucGFjay51aW50MTZUb0FscGhhTHVtaW5hbmNlKGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVtpbkZyYW1lSW5kZXhdKTtcclxuICAvLyAgICAgICBsZXQgcmF3ID0gZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XHJcblxyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cclxuICAvLyAgICAgICBsZXQgbHNiID0gcmF3ICYgMHgwMEZGO1xyXG4gIC8vICAgICAgIGxldCBtc2IgPSAocmF3ID4+PiA4KSAmIDB4MDBGRjtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuICAvLyAgICAgICBkYXRhWzIgKiBwYWNrSW5kZXhdID0gbHNiO1xyXG4gIC8vICAgICAgIGRhdGFbMiAqIHBhY2tJbmRleCArIDFdID0gbXNiO1xyXG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xyXG4gIC8vICAgICB9XHJcbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0O1xyXG4gIC8vICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgLy8gICB9IGVsc2UgaWYgKGJpdHMgPT09IDMyICYmIGNoYW5uZWxzID09PSAxKSB7XHJcblxyXG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcclxuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cclxuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuXHJcbiAgLy8gICAgICAgLy8gc2xvdyFcclxuICAvLyAgICAgICAvL2xldCBhc2IgPSBWSlMuY29yZS5wYWNrLnVpbnQxNlRvQWxwaGFMdW1pbmFuY2UoZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF0pO1xyXG4gIC8vICAgICAgIGxldCByYXcgPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuXHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xyXG4gIC8vICAgICAgIGxldCBiMCA9IHJhdyAmIDB4MDAwMDAwRkY7XHJcbiAgLy8gICAgICAgbGV0IGIxID0gKHJhdyA+Pj4gOCkgJiAweDAwMDAwMEZGO1xyXG4gIC8vICAgICAgIGxldCBiMiA9IChyYXcgPj4+IDgpICYgMHgwMDAwMDBGRjtcclxuICAvLyAgICAgICBsZXQgYjMgPSAocmF3ID4+PiA4KSAmIDB4MDAwMDAwRkY7XHJcbiAgLy8gICAgICAgLy8gbGV0IGxzYjEgPSByYXcgJiAweEZGO1xyXG4gIC8vICAgICAgIC8vIGxldCBtc2IxID0gKHJhdyA+PiA4KSAmIDB4RkY7XHJcbiAgLy8gICAgICAgLypqc2hpbnQgYml0d2lzZTogdHJ1ZSovXHJcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IGIwO1xyXG4gIC8vICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDFdID0gYjE7XHJcbiAgLy8gICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMl0gPSBiMjtcclxuICAvLyAgICAgICBkYXRhWzQgKiBwYWNrSW5kZXggKyAzXSA9IGIzO1xyXG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xyXG4gIC8vICAgICB9XHJcbiAgLy8gICAgIHBhY2tlZC50ZXh0dXJlVHlwZSA9IFRIUkVFLlJHQkFGb3JtYXQ7XHJcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAvLyAgIH0gZWxzZSBpZiAoYml0cyA9PT0gOCAmJiBjaGFubmVscyA9PT0gMykge1xyXG4gIC8vICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiAzKTtcclxuICAvLyAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gIC8vICAgICAgIC8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cclxuICAvLyAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuICAvLyAgICAgICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuXHJcbiAgLy8gICAgICAgZGF0YVszICogcGFja0luZGV4XSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVszICogaW5GcmFtZUluZGV4XTtcclxuICAvLyAgICAgICBkYXRhWzMgKiBwYWNrSW5kZXggKyAxXSA9IGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVszICogaW5GcmFtZUluZGV4ICsgMV07XHJcbiAgLy8gICAgICAgZGF0YVszICogcGFja0luZGV4ICsgMl0gPSBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbMyAqIGluRnJhbWVJbmRleCArIDJdO1xyXG4gIC8vICAgICAgIHBhY2tJbmRleCsrO1xyXG5cclxuICAvLyAgICAgfVxyXG4gIC8vICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQ7XHJcbiAgLy8gICAgIHBhY2tlZC5kYXRhID0gZGF0YTtcclxuICAvLyAgIH1cclxuXHJcbiAgLy8gICByZXR1cm4gcGFja2VkO1xyXG5cclxuICAvLyB9XHJcbn1cclxuXHJcbi8vICd1c2Ugc3RyaWN0JztcclxuXHJcbi8vIHZhciBWSlMgPSBWSlMgfHwge307XHJcbi8vIFZKUy5jb3JlID0gVkpTLmNvcmUgfHwge307XHJcblxyXG4vLyAvKipcclxuLy8gICogQGNvbnN0cnVjdG9yXHJcbi8vICAqIEBjbGFzc1xyXG4vLyAgKiBAbWVtYmVyT2YgVkpTLmNvcmVcclxuLy8gICogQHB1YmxpY1xyXG4vLyAqL1xyXG4vLyBWSlMuY29yZS5wYWNrID0gVkpTLmNvcmUucGFjayB8fCB7fTtcclxuXHJcbi8vIC8vIERlYWwgd2l0aCBlbmRpYW5lc3NcclxuLy8gLy8gZG8gbm90IGFkZCBhIGlmIHRoZXJlIGFmIGlzIGlzIHNsb3cgaW4gYm9nIGxvb3BzXHJcbi8vIC8vIGFkZCBtb3JlIGZ1bmN0aW9uc1xyXG4vLyBWSlMuY29yZS5wYWNrLnVpbnQxNlRvQWxwaGFMdW1pbmFuY2UgPSBmdW5jdGlvbih1aW50MTYsIGFiKSB7XHJcbi8vICAgLypqc2hpbnQgYml0d2lzZTogZmFsc2UqL1xyXG4vLyAgIHZhciBsc2IgPSB1aW50MTYgJiAweEZGO1xyXG4vLyAgIHZhciBtc2IgPSAodWludDE2ID4+IDgpICYgMHhGRjtcclxuLy8gICAvKmpzaGludCBiaXR3aXNlOiB0cnVlKi9cclxuLy8gICBhYiA9IFtsc2IsIG1zYl07XHJcbi8vIH07XHJcblxyXG4vLyBWSlMuY29yZS5wYWNrLnVpbnQ4VG9MdW1pbmFuY2UgPSBmdW5jdGlvbih1aW50OCkge1xyXG4vLyAgIHJldHVybiB1aW50ODtcclxuLy8gfTtcclxuXHJcbi8vIFZKUy5jb3JlLnBhY2sudWludDhWM1RvUkdCID0gZnVuY3Rpb24odWludDhWMykge1xyXG4vLyAgIHJldHVybiB1aW50OFYzO1xyXG4vLyB9O1xyXG5cclxuLy8gLyoqKiBFeHBvcnRzICoqKi9cclxuXHJcbi8vIHZhciBtb2R1bGVUeXBlID0gdHlwZW9mIG1vZHVsZTtcclxuLy8gaWYgKChtb2R1bGVUeXBlICE9PSAndW5kZWZpbmVkJykgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuLy8gICBtb2R1bGUuZXhwb3J0cyA9IFZKUy5jb3JlLnBhY2s7XHJcbi8vIH1cclxuIiwiY29uc3QgVVJMID0gcmVxdWlyZSgndXJsJyk7XHJcbmltcG9ydCBWYWxpZGF0b3JzIGZyb20gJy4vY29yZS52YWxpZGF0b3JzJztcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmFsIHB1cnBvc2UgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGNvcmUvdXRpbHNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVVdGlscyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgYm91ZGluZyBib3ggb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gY2VudGVyIC0gQ2VudGVyIG9mIHRoZSBib3guXHJcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBoYWxmRGltZW5zaW9ucyAtIEhhbGYgRGltZW5zaW9ucyBvZiB0aGUgYm94LlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGJvdW5kaW5nIGJveCBvYmplY3QuIHtPYmplY3QubWlufSBpcyBhIHtUSFJFRS5WZWN0b3IzfVxyXG4gICAqIGNvbnRhaW5pbmcgdGhlIG1pbiBib3VuZHMuIHtPYmplY3QubWF4fSBpcyBhIHtUSFJFRS5WZWN0b3IzfSBjb250YWluaW5nIHRoZVxyXG4gICAqIG1heCBib3VuZHMuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaW5wdXQgTk9UIHZhbGlkLlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogLy8gUmV0dXJuc1xyXG4gICAqIC8veyBtaW46IHsgeCA6IDAsIHkgOiAwLCAgeiA6IDAgfSxcclxuICAgKiAvLyAgbWF4OiB7IHggOiAyLCB5IDogNCwgIHogOiA2IH1cclxuICAgKiAvL31cclxuICAgKiBWSlMuQ29yZS5VdGlscy5iYm94KFxyXG4gICAqICAgbmV3IFRIUkVFLlZlY3RvcjMoMSwgMiwgMyksIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDIsIDMpKTtcclxuICAgKlxyXG4gICAqIC8vUmV0dXJucyBmYWxzZVxyXG4gICAqIFZKUy5Db3JlLlV0aWxzLmJib3gobmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLk1hdHJpeDQoKSk7XHJcbiAgICpcclxuICAgKi9cclxuICBzdGF0aWMgYmJveChjZW50ZXIsIGhhbGZEaW1lbnNpb25zKSB7XHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSB2YWxpZCBpbnB1dHNcclxuICAgIGlmICghKFZhbGlkYXRvcnMudmVjdG9yMyhjZW50ZXIpICYmXHJcbiAgICAgIFZhbGlkYXRvcnMudmVjdG9yMyhoYWxmRGltZW5zaW9ucykpKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnSW52YWxpZCBjZW50ZXIgb3IgcGxhbmUgaGFsZkRpbWVuc2lvbnMuJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgaGFsZiBkaW1lbnNpb25zIGFyZSA+PSAwXHJcbiAgICBpZiAoIShoYWxmRGltZW5zaW9ucy54ID49IDAgJiZcclxuICAgICAgaGFsZkRpbWVuc2lvbnMueSA+PSAwICYmXHJcbiAgICAgIGhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdoYWxmRGltZW5zaW9ucyBtdXN0IGJlID49IDAuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhoYWxmRGltZW5zaW9ucyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtaW4vbWF4IGJvdW5kXHJcbiAgICBsZXQgbWluID0gY2VudGVyLmNsb25lKCkuc3ViKGhhbGZEaW1lbnNpb25zKTtcclxuICAgIGxldCBtYXggPSBjZW50ZXIuY2xvbmUoKS5hZGQoaGFsZkRpbWVuc2lvbnMpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1pbixcclxuICAgICAgbWF4LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgbWluL21heCB2YWx1ZXMgaW4gYW4gYXJyYXlcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICovXHJcbiAgc3RhdGljIG1pbk1heChkYXRhID0gW10pIHtcclxuICAgIGxldCBtaW5NYXggPSBbNjU1MzUsIC0zMjc2OF07XHJcbiAgICBsZXQgbnVtUGl4ZWxzID0gZGF0YS5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xyXG4gICAgICBsZXQgc3B2ID0gZGF0YVtpbmRleF07XHJcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcclxuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBzcHYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW5NYXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBIVE1MRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9ialxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGlzRWxlbWVudChvYmopIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzaW5nIFczIERPTTIgKHdvcmtzIGZvciBGRiwgT3BlcmEgYW5kIENocm9tKVxyXG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIC8vIEJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIFczIERPTTIgZG9uJ3QgaGF2ZSBIVE1MRWxlbWVudCBhbmRcclxuICAgICAgLy8gYW4gZXhjZXB0aW9uIGlzIHRocm93biBhbmQgd2UgZW5kIHVwIGhlcmUuIFRlc3Rpbmcgc29tZVxyXG4gICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgYWxsIGVsZW1lbnRzIGhhdmUuICh3b3JrcyBvbiBJRTcpXHJcbiAgICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpICYmXHJcbiAgICAgICAgKG9iai5ub2RlVHlwZSA9PT0gMSkgJiYgKHR5cGVvZiBvYmouc3R5bGUgPT09ICdvYmplY3QnKSAmJlxyXG4gICAgICAgICh0eXBlb2Ygb2JqLm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1N0cmluZyhzdHIpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXJzZSB1cmxcclxuICAgKiBAcGFyYW0geyp9IHVybFxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBzdGF0aWMgcGFyc2VVcmwodXJsKSB7XHJcbiAgICAvL1xyXG4gICAgY29uc3QgZGF0YSA9IHt9O1xyXG4gICAgZGF0YS5maWxlbmFtZSA9ICcnO1xyXG4gICAgZGF0YS5leHRlbnNpb24gPSAnJztcclxuICAgIGRhdGEucGF0aG5hbWUgPSAnJztcclxuICAgIGRhdGEucXVlcnkgPSAnJztcclxuXHJcbiAgICBsZXQgcGFyc2VkVXJsID0gVVJMLnBhcnNlKHVybCk7XHJcbiAgICBkYXRhLnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xyXG4gICAgZGF0YS5xdWVyeSA9IHBhcnNlZFVybC5xdWVyeTtcclxuXHJcbiAgICAvLyBnZXQgZmlsZSBuYW1lXHJcbiAgICBkYXRhLmZpbGVuYW1lID0gZGF0YS5wYXRobmFtZS5zcGxpdCgnLycpLnBvcCgpO1xyXG5cclxuICAgIC8vIGZpbmQgZXh0ZW5zaW9uXHJcbiAgICBsZXQgc3BsaXR0ZWROYW1lID0gZGF0YS5maWxlbmFtZS5zcGxpdCgnLicpO1xyXG4gICAgaWYgKHNwbGl0dGVkTmFtZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICBkYXRhLmV4dGVuc2lvbiA9ICdkaWNvbSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhLmV4dGVuc2lvbiA9IGRhdGEuZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKGRhdGEuZXh0ZW5zaW9uKSkge1xyXG4gICAgICBkYXRhLmV4dGVuc2lvbiA9ICdkaWNvbSc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRhdGEucXVlcnkgJiZcclxuICAgICAgZGF0YS5xdWVyeS5pbmNsdWRlcygnY29udGVudFR5cGU9YXBwbGljYXRpb24lMkZkaWNvbScpKSB7XHJcbiAgICAgIGRhdGEuZXh0ZW5zaW9uID0gJ2RpY29tJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgSUpLIHRvIExQUyB0cmFuZm9ybS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0geENvc1xyXG4gICAqIEBwYXJhbSB7Kn0geUNvc1xyXG4gICAqIEBwYXJhbSB7Kn0gekNvc1xyXG4gICAqIEBwYXJhbSB7Kn0gc3BhY2luZ1xyXG4gICAqIEBwYXJhbSB7Kn0gb3JpZ2luXHJcbiAgICogQHBhcmFtIHsqfSByZWdpc3RyYXRpb25NYXRyaXhcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIGlqazJMUFMoXHJcbiAgICB4Q29zLCB5Q29zLCB6Q29zLFxyXG4gICAgc3BhY2luZywgb3JpZ2luLFxyXG4gICAgcmVnaXN0cmF0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSkge1xyXG4gICAgY29uc3QgaWprMkxQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICBpamsyTFBTLnNldChcclxuICAgICAgeENvcy54ICogc3BhY2luZy54LCB5Q29zLnggKiBzcGFjaW5nLnksIHpDb3MueCAqIHNwYWNpbmcueiwgb3JpZ2luLngsXHJcbiAgICAgIHhDb3MueSAqIHNwYWNpbmcueCwgeUNvcy55ICogc3BhY2luZy55LCB6Q29zLnkgKiBzcGFjaW5nLnosIG9yaWdpbi55LFxyXG4gICAgICB4Q29zLnogKiBzcGFjaW5nLngsIHlDb3MueiAqIHNwYWNpbmcueSwgekNvcy56ICogc3BhY2luZy56LCBvcmlnaW4ueixcclxuICAgICAgMCwgMCwgMCwgMSk7XHJcbiAgICBpamsyTFBTLnByZW11bHRpcGx5KHJlZ2lzdHJhdGlvbk1hdHJpeCk7XHJcblxyXG4gICAgcmV0dXJuIGlqazJMUFM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIEFBQkIgdG8gTFBTIHRyYW5zZm9ybS5cclxuICAgKiBBQUJCOiBBeGUgQWxpZ25lZCBCb3VuZGluZyBCb3guXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHhDb3NcclxuICAgKiBAcGFyYW0geyp9IHlDb3NcclxuICAgKiBAcGFyYW0geyp9IHpDb3NcclxuICAgKiBAcGFyYW0geyp9IG9yaWdpblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgYWFiYjJMUFMoXHJcbiAgICB4Q29zLCB5Q29zLCB6Q29zLFxyXG4gICAgb3JpZ2luKSB7XHJcbiAgICBjb25zdCBhYWJiMkxQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICBhYWJiMkxQUy5zZXQoXHJcbiAgICAgICAgeENvcy54LCB5Q29zLngsIHpDb3MueCwgb3JpZ2luLngsXHJcbiAgICAgICAgeENvcy55LCB5Q29zLnksIHpDb3MueSwgb3JpZ2luLnksXHJcbiAgICAgICAgeENvcy56LCB5Q29zLnosIHpDb3Mueiwgb3JpZ2luLnosXHJcbiAgICAgICAgMCwgMCwgMCwgMSk7XHJcblxyXG4gICAgcmV0dXJuIGFhYmIyTFBTO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGNvb3JkaW5hdGVzIGZyb20gd29ybGQgY29vcmRpbmF0ZSB0byBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGxwczJJSktcclxuICAgKiBAcGFyYW0geyp9IHdvcmxkQ29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgICBzdGF0aWMgd29ybGRUb0RhdGEobHBzMklKSywgd29ybGRDb29yZGluYXRlcykge1xyXG4gICAgbGV0IGRhdGFDb29yZGluYXRlID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxyXG4gICAgICAuY29weSh3b3JsZENvb3JkaW5hdGVzKVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KGxwczJJSkspO1xyXG5cclxuICAgIC8vIHNhbWUgcm91bmRpbmcgaW4gdGhlIHNoYWRlcnNcclxuICAgIGRhdGFDb29yZGluYXRlLmFkZFNjYWxhcigwLjUpLmZsb29yKCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGFDb29yZGluYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHZveGVsIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHN0YWNrXHJcbiAgICogQHBhcmFtIHsqfSBjb29yZGluYXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0YXRpYyB2YWx1ZShzdGFjaywgY29vcmRpbmF0ZSkge1xyXG4gICAgaWYgKGNvb3JkaW5hdGUueiA+PSAwICYmXHJcbiAgICAgICAgY29vcmRpbmF0ZS56IDwgc3RhY2suX2ZyYW1lLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gc3RhY2suX2ZyYW1lW2Nvb3JkaW5hdGUuel0uXHJcbiAgICAgICAgdmFsdWUoY29vcmRpbmF0ZS54LCBjb29yZGluYXRlLnkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBseSBzbG9wZS9pbnRlcmNlcHQgdG8gYSB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7Kn0gc2xvcGVcclxuICAgKiBAcGFyYW0geyp9IGludGVyY2VwdFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgcmVzY2FsZVNsb3BlSW50ZXJjZXB0KHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KSB7XHJcbiAgICByZXR1cm4gdmFsdWUgKiBzbG9wZSArIGludGVyY2VwdDtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKiBWYWxpZGF0ZSBiYXNpYyBzdHJ1Y3R1cmVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvL1JldHVybnMgdHJ1ZVxyXG4gKiBWSlMuQ29yZS5WYWxpZGF0b3JzLm1hdHJpeDQobmV3IFRIUkVFLk1hdHJpeDQoKSk7XHJcbiAqXHJcbiAqIC8vUmV0dXJucyBmYWxzZVxyXG4gKiBWSlMuQ29yZS5WYWxpZGF0b3JzLm1hdHJpeDQobmV3IFRIUkVFLlZlY3RvcjMoKSk7XHJcbiAqXHJcbiAqIEBtb2R1bGUgY29yZS92YWxpZGF0b3JzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdG9ycyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlcyBhIG1hdHJpeCBhcyBhIFRIUkVFSlMuTWF0cml4NFxyXG4gICAqIGxpbmtcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0VG9UZXN0IC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBNYXRyaXg0LCBmYWxzZSBpZiBOT1QuXHJcbiAgICovXHJcbiAgc3RhdGljIG1hdHJpeDQob2JqZWN0VG9UZXN0KSB7XHJcbiAgICBpZiAoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcclxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2VsZW1lbnRzJykgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5lbGVtZW50cy5sZW5ndGggPT09IDE2ICYmXHJcbiAgICAgICB0eXBlb2Ygb2JqZWN0VG9UZXN0LmlkZW50aXR5ID09PSAnZnVuY3Rpb24nJiZcclxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QuY29weSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdC5kZXRlcm1pbmFudCA9PT0gJ2Z1bmN0aW9uJykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBWYWxpZGF0ZXMgYSB2ZWN0b3IgYXMgYSBUSFJFRUpTLlZlY3RvcjNcclxuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RUb1Rlc3QgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cclxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgVmVjdG9yMywgZmFsc2UgaWYgTk9ULlxyXG4gICovXHJcbiAgc3RhdGljIHZlY3RvcjMob2JqZWN0VG9UZXN0KSB7XHJcbiAgICBpZiAoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcclxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3gnKSAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd5JykgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgneicpICYmXHJcbiAgICAgICAhb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCd3JykpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gLyoqXHJcbiAgKiBWYWxpZGF0ZXMgYSBib3guXHJcbiAgKlxyXG4gICogQGV4YW1wbGVcclxuICAqIC8vIGEgYm94IGlzIGRlZmluZWQgYXNcclxuICAqIGxldCBib3ggPSB7XHJcbiAgKiAgIGNlbnRlcjogVEhSRUUuVmVjdG9yMyxcclxuICAqICAgaGFsZkRpbWVuc2lvbnM6IFRIUkVFLlZlY3RvcjNcclxuICAqIH1cclxuICAqXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0VG9UZXN0IC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXHJcbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIGJveCwgZmFsc2UgaWYgTk9ULlxyXG4gICovXHJcbiAgc3RhdGljIGJveChvYmplY3RUb1Rlc3QpIHtcclxuICAgIGlmICghKG9iamVjdFRvVGVzdCAhPT0gbnVsbCAmJlxyXG4gICAgICAgdHlwZW9mIG9iamVjdFRvVGVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgIG9iamVjdFRvVGVzdC5oYXNPd25Qcm9wZXJ0eSgnY2VudGVyJykgJiZcclxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QuY2VudGVyKSAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0Lmhhc093blByb3BlcnR5KCdoYWxmRGltZW5zaW9ucycpICYmXHJcbiAgICAgICB0aGlzLnZlY3RvcjMob2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zKSAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zLnggPj0gMCAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zLnkgPj0gMCAmJlxyXG4gICAgICAgb2JqZWN0VG9UZXN0LmhhbGZEaW1lbnNpb25zLnogPj0gMCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAvKipcclxuICAqIFZhbGlkYXRlcyBhIHJheS5cclxuICAqXHJcbiAgKiBAZXhhbXBsZVxyXG4gICogLy8gYSByYXkgaXMgZGVmaW5lZCBhc1xyXG4gICogbGV0IHJheSA9IHtcclxuICAqICAgcG9zdGlvbjogVEhSRUUuVmVjdG9yMyxcclxuICAqICAgZGlyZWN0aW9uOiBUSFJFRS5WZWN0b3IzXHJcbiAgKiB9XHJcbiAgKlxyXG4gICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFRvVGVzdCAtIFRoZSBvYmplY3QgdG8gYmUgdGVzdGVkLlxyXG4gICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCByYXksIGZhbHNlIGlmIE5PVC5cclxuICAqL1xyXG4gIHN0YXRpYyByYXkob2JqZWN0VG9UZXN0KSB7XHJcbiAgICBpZiAoIShvYmplY3RUb1Rlc3QgIT09IG51bGwgJiZcclxuICAgICAgIHR5cGVvZiBvYmplY3RUb1Rlc3QgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ3Bvc2l0aW9uJykgJiZcclxuICAgICAgIHRoaXMudmVjdG9yMyhvYmplY3RUb1Rlc3QucG9zaXRpb24pICYmXHJcbiAgICAgICBvYmplY3RUb1Rlc3QuaGFzT3duUHJvcGVydHkoJ2RpcmVjdGlvbicpICYmXHJcbiAgICAgICB0aGlzLnZlY3RvcjMob2JqZWN0VG9UZXN0LmRpcmVjdGlvbikpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IFNsaWNlIGZyb20gJy4vZ2VvbWV0cmllcy5zbGljZSc7XHJcbmltcG9ydCBWb3hlbCBmcm9tICcuL2dlb21ldHJpZXMudm94ZWwnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgZ2VvbWV0cmllc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBTbGljZSxcclxuICBWb3hlbCxcclxufTtcclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBjb3JlSW50ZXJzZWN0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuaW50ZXJzZWN0aW9ucyc7XHJcblxyXG4vKipcclxuICpcclxuICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGNyZWF0aW5nIGFuIGlycmVndWxhciAzRCBwbGFuYXIgc2hhcGUgZ2l2ZW4gYSBib3ggYW5kIHRoZSBjdXQtcGxhbmUuXHJcbiAqXHJcbiAqIERlbW86IHtAbGluayBodHRwczovL2ZubmRzYy5naXRodWIuaW8vdmpzI2dlb21ldHJ5X3NsaWNlfVxyXG4gKlxyXG4gKiBAbW9kdWxlIGdlb21ldHJpZXMvc2xpY2VcclxuICpcclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBoYWxmRGltZW5zaW9ucyAtIEhhbGYtZGltZW5zaW9ucyBvZiB0aGUgYm94IHRvIGJlIHNsaWNlZC5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBjZW50ZXIgLSBDZW50ZXIgb2YgdGhlIGJveCB0byBiZSBzbGljZWQuXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yMzxUSFJFRS5WZWN0b3IzPn0gb3JpZW50YXRpb24gLSBPcmllbnRhdGlvbiBvZiB0aGUgYm94IHRvIGJlIHNsaWNlZC4gKG1pZ2h0IG5vdCBiZSBuZWNlc3NhcnkuLj8pXHJcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcG9zaXRpb24gLSBQb3NpdGlvbiBvZiB0aGUgY3V0dGluZyBwbGFuZS5cclxuICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb24gLSBDcm9zcyBkaXJlY3Rpb24gb2YgdGhlIGN1dHRpbmcgcGxhbmUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIERlZmluZSBib3ggdG8gYmUgc2xpY2VkXHJcbiAqIGxldCBoYWxmRGltZW5zaW9ucyA9IG5ldyBUSFJFRS5WZWN0b3IoMTIzLCA0NSwgNjcpO1xyXG4gKiBsZXQgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XHJcbiAqIGxldCBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLFxyXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApLFxyXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXHJcbiAqICk7XHJcbiAqXHJcbiAqIC8vIERlZmluZSBzbGljZSBwbGFuZVxyXG4gKiBsZXQgcG9zaXRpb24gPSBjZW50ZXIuY2xvbmUoKTtcclxuICogbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjIsIDAuNSwgMC4zKTtcclxuICpcclxuICogLy8gQ3JlYXRlIHRoZSBzbGljZSBnZW9tZXRyeSAmIG1hdGVyaWFsc1xyXG4gKiBsZXQgc2xpY2VHZW9tZXRyeSA9IG5ldyBWSlMuZ2VvbWV0cmllcy5zbGljZShoYWxmRGltZW5zaW9ucywgY2VudGVyLCBvcmllbnRhdGlvbiwgcG9zaXRpb24sIGRpcmVjdGlvbik7XHJcbiAqIGxldCBzbGljZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcclxuICogICAnc2lkZSc6IFRIUkVFLkRvdWJsZVNpZGUsXHJcbiAqICAgJ2NvbG9yJzogMHhGRjU3MjJcclxuICogfSk7XHJcbiAqXHJcbiAqICAvLyBDcmVhdGUgbWVzaCBhbmQgYWRkIGl0IHRvIHRoZSBzY2VuZVxyXG4gKiAgbGV0IHNsaWNlID0gbmV3IFRIUkVFLk1lc2goc2xpY2VHZW9tZXRyeSwgc2xpY2VNYXRlcmlhbCk7XHJcbiAqICBzY2VuZS5hZGQoc2xpY2UpO1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlb21ldHJpZXNTbGljZSBleHRlbmRzIFRIUkVFLlNoYXBlR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoaGFsZkRpbWVuc2lvbnMsIGNlbnRlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgdG9BQUJCID0gbmV3IFRIUkVFLk1hdHJpeDQoKSkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBwcmVwYXJlIGRhdGEgZm9yIHRoZSBzaGFwZSFcclxuICAgICAgLy9cclxuICAgICAgbGV0IGFhYmIgPSB7XHJcbiAgICAgICAgaGFsZkRpbWVuc2lvbnMsXHJcbiAgICAgICAgY2VudGVyLFxyXG4gICAgICAgIHRvQUFCQixcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGxldCBwbGFuZSA9IHtcclxuICAgICAgICBwb3NpdGlvbixcclxuICAgICAgICBkaXJlY3Rpb24sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBCT09NIVxyXG4gICAgICBsZXQgaW50ZXJzZWN0aW9ucyA9IGNvcmVJbnRlcnNlY3Rpb25zLmFhYmJQbGFuZShhYWJiLCBwbGFuZSk7XHJcblxyXG4gICAgICAvLyBjYW4gbm90IGV4aXN0IGJlZm9yZSBjYWxsaW5nIHRoZSBjb25zdHJ1Y3RvclxyXG4gICAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdXQVJOSU5HOiBMZXNzIHRoYW4gMyBpbnRlcnNlY3Rpb25zIGJldHdlZW4gQUFCQiBhbmQgUGxhbmUuJyk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdBQUJCJyk7XHJcbiAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGFhYmIpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnUGxhbmUnKTtcclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cocGxhbmUpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnZXhpdGluZy4uLicpO1xyXG4gICAgICAgIC8vIG9yIHRocm93IGVycm9yP1xyXG4gICAgICAgIHRocm93ICdnZW9tZXRyaWVzLnNsaWNlIGhhcyBsZXNzIHRoYW4gMyBpbnRlcnNlY3Rpb25zLCBjYW4gbm90IGNyZWF0ZSBhIHZhbGlkIGdlb21ldHJ5Lic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBvcmRlcmVkSW50ZXJzZWN0aW9ucyA9IEdlb21ldHJpZXNTbGljZS5vcmRlckludGVyc2VjdGlvbnMoaW50ZXJzZWN0aW9ucywgZGlyZWN0aW9uKTtcclxuICAgICAgbGV0IHNsaWNlU2hhcGUgPSBHZW9tZXRyaWVzU2xpY2Uuc2hhcGUob3JkZXJlZEludGVyc2VjdGlvbnMpO1xyXG5cclxuICAgICAgLy9cclxuICAgICAgLy8gR2VuZXJhdGUgR2VvbWV0cnkgZnJvbSBzaGFwZVxyXG4gICAgICAvLyBJdCBkb2VzIHRyaWFuZ3VsYXRpb24gZm9yIHVzIVxyXG4gICAgICAvL1xyXG4gICAgICBzdXBlcihzbGljZVNoYXBlKTtcclxuICAgICAgdGhpcy50eXBlID0gJ1NsaWNlR2VvbWV0cnknO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIHJlYWwgcG9zaXRpb24gb2YgZWFjaCB2ZXJ0ZXghIChub3QgaW4gMmQpXHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBvcmRlcmVkSW50ZXJzZWN0aW9ucztcclxuICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBzaGFwZShwb2ludHMpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gQ3JlYXRlIFNoYXBlXHJcbiAgICAgIC8vXHJcbiAgICAgIGxldCBzaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG4gICAgICAvLyBtb3ZlIHRvIGZpcnN0IHBvaW50IVxyXG4gICAgICBzaGFwZS5tb3ZlVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcclxuXHJcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgcG9pbnRzIVxyXG4gICAgICBmb3IgKGxldCBsID0gMTsgbCA8IHBvaW50cy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgIC8vIHByb2plY3QgZWFjaCBvbiBwbGFuZSFcclxuICAgICAgICBzaGFwZS5saW5lVG8ocG9pbnRzW2xdLnh5LngsIHBvaW50c1tsXS54eS55KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2xvc2UgdGhlIHNoYXBlIVxyXG4gICAgICBzaGFwZS5saW5lVG8ocG9pbnRzWzBdLnh5LngsIHBvaW50c1swXS54eS55KTtcclxuICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG5cclxuIC8qKlxyXG4gICpcclxuICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGV4dHJhY3QgY2VudGVyIG9mIG1hc3MgZnJvbSBsaXN0IG9mIHBvaW50cy5cclxuICAqXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICpcclxuICAqIEBwYXJhbSB7QXJyYXk8VEhSRUUuVmVjdG9yMz59IHBvaW50cyAtIFNldCBvZiBwb2ludHMgZnJvbSB3aGljaCB3ZSB3YW50IHRvIGV4dHJhY3QgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICpcclxuICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBDZW50ZXIgb2YgbWFzcyBmcm9tIGdpdmVuIHBvaW50cy5cclxuICAqL1xyXG4gIHN0YXRpYyBjZW50ZXJPZk1hc3MocG9pbnRzKSB7XHJcbiAgICBsZXQgY2VudGVyT2ZNYXNzID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjZW50ZXJPZk1hc3MueCArPSBwb2ludHNbaV0ueDtcclxuICAgICAgY2VudGVyT2ZNYXNzLnkgKz0gcG9pbnRzW2ldLnk7XHJcbiAgICAgIGNlbnRlck9mTWFzcy56ICs9IHBvaW50c1tpXS56O1xyXG4gICAgfVxyXG4gICAgY2VudGVyT2ZNYXNzLmRpdmlkZVNjYWxhcihwb2ludHMubGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gY2VudGVyT2ZNYXNzO1xyXG4gIH1cclxuXHJcbiAvKipcclxuICAqXHJcbiAgKiBPcmRlciAzRCBwbGFuYXIgcG9pbnRzIGFyb3VuZCBhIHJlZmVuY2UgcG9pbnQuXHJcbiAgKlxyXG4gICogQHByaXZhdGVcclxuICAqXHJcbiAgKiBAcGFyYW0ge0FycmF5PFRIUkVFLlZlY3RvcjM+fSBwb2ludHMgLSBTZXQgb2YgcGxhbmFyIDNEIHBvaW50cyB0byBiZSBvcmRlcmVkLlxyXG4gICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb24gLSBEaXJlY3Rpb24gb2YgdGhlIHBsYW5lIGluIHdoaWNoIHBvaW50cyBhbmQgcmVmZXJlbmNlIGFyZSBzaXR0aW5nLlxyXG4gICpcclxuICAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBTZXQgb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgb3JkZXJlZCBwb2ludHMuXHJcbiAgKi9cclxuICBzdGF0aWMgb3JkZXJJbnRlcnNlY3Rpb25zKHBvaW50cywgZGlyZWN0aW9uKSB7XHJcbiAgICBsZXQgcmVmZXJlbmNlID0gR2VvbWV0cmllc1NsaWNlLmNlbnRlck9mTWFzcyhwb2ludHMpO1xyXG4gICAgLy8gZGlyZWN0aW9uIGZyb20gZmlyc3QgcG9pbnQgdG8gcmVmZXJlbmNlXHJcbiAgICBsZXQgcmVmZXJlbmNlRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHBvaW50c1swXS54IC0gcmVmZXJlbmNlLngsXHJcbiAgICAgIHBvaW50c1swXS55IC0gcmVmZXJlbmNlLnksXHJcbiAgICAgIHBvaW50c1swXS56IC0gcmVmZXJlbmNlLnpcclxuICAgICAgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBsZXQgYmFzZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApXHJcbiAgICAgICAgLmNyb3NzVmVjdG9ycyhyZWZlcmVuY2VEaXJlY3Rpb24sIGRpcmVjdGlvbilcclxuICAgICAgICAubm9ybWFsaXplKCk7XHJcblxyXG4gICAgbGV0IG9yZGVyZWRwb2ludHMgPSBbXTtcclxuXHJcbiAgICAvLyBvdGhlciBsaW5lcyAvLyBpZiBpbnRlciwgcmV0dXJuIGxvY2F0aW9uICsgYW5nbGVcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGxldCBwb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgIHBvaW50c1tqXS54LFxyXG4gICAgICAgIHBvaW50c1tqXS55LFxyXG4gICAgICAgIHBvaW50c1tqXS56KTtcclxuICAgICAgcG9pbnQuZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgcG9pbnRzW2pdLnggLSByZWZlcmVuY2UueCxcclxuICAgICAgICBwb2ludHNbal0ueSAtIHJlZmVyZW5jZS55LFxyXG4gICAgICAgIHBvaW50c1tqXS56IC0gcmVmZXJlbmNlLnopLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgbGV0IHggPSByZWZlcmVuY2VEaXJlY3Rpb24uZG90KHBvaW50LmRpcmVjdGlvbik7XHJcbiAgICAgIGxldCB5ID0gYmFzZS5kb3QocG9pbnQuZGlyZWN0aW9uKTtcclxuICAgICAgcG9pbnQueHkgPSB7eCwgeX07XHJcblxyXG4gICAgICBsZXQgdGhldGEgPSBNYXRoLmF0YW4yKHksIHgpICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICBwb2ludC5hbmdsZSA9IHRoZXRhO1xyXG5cclxuICAgICAgb3JkZXJlZHBvaW50cy5wdXNoKHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICBvcmRlcmVkcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICByZXR1cm4gYS5hbmdsZSAtIGIuYW5nbGU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgbm9EdXBzID0gW29yZGVyZWRwb2ludHNbMF1dO1xyXG4gICAgbGV0IGVwc2lsb24gPSAwLjAwMDE7XHJcbiAgICBmb3IobGV0IGk9MTsgaTxvcmRlcmVkcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmKE1hdGguYWJzKG9yZGVyZWRwb2ludHNbaS0xXS5hbmdsZSAtIG9yZGVyZWRwb2ludHNbaV0uYW5nbGUpID4gZXBzaWxvbikge1xyXG4gICAgICAgIG5vRHVwcy5wdXNoKG9yZGVyZWRwb2ludHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vRHVwcztcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKlxyXG4gKiBAbW9kdWxlIGdlb21ldHJpZXMvdm94ZWxcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9tZXRyaWVzVm94ZWwgZXh0ZW5kcyBUSFJFRS5Cb3hHZW9tZXRyeSB7XHJcbiAgY29uc3RydWN0b3IoZGF0YVBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcigxLCAxLCAxKTtcclxuXHJcbiAgICB0aGlzLl9sb2NhdGlvbiA9IGRhdGFQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLmFwcGx5TWF0cml4KG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKFxyXG4gICAgICB0aGlzLl9sb2NhdGlvbi54LFxyXG4gICAgICB0aGlzLl9sb2NhdGlvbi55LFxyXG4gICAgICB0aGlzLl9sb2NhdGlvbi56KSk7XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRWZXJ0aWNlcygpIHtcclxuICAgIHRoaXMudmVydGljZXNbMF0uc2V0KDAuNSwgMC41LCAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1sxXS5zZXQoMC41LCAwLjUsIC0wLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1syXS5zZXQoMC41LCAtMC41LCAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1szXS5zZXQoMC41LCAtMC41LCAtMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbNF0uc2V0KC0wLjUsIDAuNSwgLTAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzVdLnNldCgtMC41LCAwLjUsIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzZdLnNldCgtMC41LCAtMC41LCAtMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbN10uc2V0KC0wLjUsIC0wLjUsIDAuNSk7XHJcbiAgfVxyXG5cclxuICBzZXQgbG9jYXRpb24obG9jYXRpb24pIHtcclxuICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcblxyXG4gICAgLy8gdXBkYXRlIHZlcnRpY2VzIGZyb20gbG9jYXRpb25cclxuICAgIHRoaXMudmVydGljZXNbMF0uc2V0KCsgMC41LCArIDAuNSwgKyAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1sxXS5zZXQoKyAwLjUsICsgMC41LCAtIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzJdLnNldCgrIDAuNSwgLSAwLjUsICsgMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbM10uc2V0KCsgMC41LCAtIDAuNSwgLSAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s0XS5zZXQoLSAwLjUsICsgMC41LCAtIDAuNSk7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzVdLnNldCgtIDAuNSwgKyAwLjUsICsgMC41KTtcclxuICAgIHRoaXMudmVydGljZXNbNl0uc2V0KC0gMC41LCAtIDAuNSwgLSAwLjUpO1xyXG4gICAgdGhpcy52ZXJ0aWNlc1s3XS5zZXQoLSAwLjUsIC0gMC41LCArIDAuNSk7XHJcblxyXG4gICAgdGhpcy5hcHBseU1hdHJpeChcclxuICAgICAgbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oXHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24ueCxcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbi55LFxyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLnopKTtcclxuXHJcbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9jYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9jYXRpb247XHJcbiAgfVxyXG5cclxuXHJcbn1cclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2JvcmRlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc0JvcmRlciBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcclxuICBjb25zdHJ1Y3RvcihoZWxwZXJzU2xpY2UpIHtcclxuICAgIC8vXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2hlbHBlcnNTbGljZSA9IGhlbHBlcnNTbGljZTtcclxuXHJcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NvbG9yID0gMHhmZjAwMDA7XHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIHNldCBoZWxwZXJzU2xpY2UoaGVscGVyc1NsaWNlKSB7XHJcbiAgICB0aGlzLl9oZWxwZXJzU2xpY2UgPSBoZWxwZXJzU2xpY2U7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBoZWxwZXJzU2xpY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVscGVyc1NsaWNlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xyXG4gICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICBpZiAodGhpcy5fbWVzaCkge1xyXG4gICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICB9XHJcblxyXG4gIHNldCBjb2xvcihjb2xvcikge1xyXG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcclxuICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZSgpIHtcclxuICAgIGlmICghdGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xyXG4gICAgICAgIGNvbG9yOiB0aGlzLl9jb2xvcixcclxuICAgICAgICBsaW5ld2lkdGg6IDEsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICBpZiAoIXRoaXMuX2hlbHBlcnNTbGljZS5nZW9tZXRyeS52ZXJ0aWNlcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGVscGVyc1NsaWNlLmdlb21ldHJ5LnZlcnRpY2VzWzBdKTtcclxuXHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIGlmICh0aGlzLl9oZWxwZXJzU2xpY2UuYWFiYlNwYWNlID09PSAnSUpLJykge1xyXG4gICAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX2hlbHBlcnNTbGljZS5zdGFjay5pamsyTFBTKTtcclxuICAgIH1cclxuICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XHJcblxyXG4gICAgLy8gYW5kIGFkZCBpdCFcclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZSgpIHtcclxuICAgIC8vIHVwZGF0ZSBzbGljZVxyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX21lc2gubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gIH1cclxufVxyXG4iLCJcclxuLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy9ib3VuZGluZ2JveFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNCb3VuZGluZ0JveCBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcclxuICBjb25zdHJ1Y3RvcihzdGFjaykge1xyXG4gICAgLy9cclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gcHJpdmF0ZSB2YXJzXHJcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xyXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XHJcbiAgICB0aGlzLl9jb2xvciA9IDB4RkZGRkZGO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcblxyXG4gICAgLy8gY3JlYXRlIG9iamVjdFxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXR0ZXJzL3NldHRlcnNcclxuICBzZXQgdmlzaWJsZSh2aXNpYmxlKSB7XHJcbiAgICB0aGlzLl92aXNpYmxlID0gdmlzaWJsZTtcclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yKGNvbG9yKSB7XHJcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xyXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgfVxyXG5cclxuICAvLyBwcml2YXRlIG1ldGhvZHNcclxuICBfY3JlYXRlKCkge1xyXG4gICAgLy8gQ29udmVuaWVuY2UgdmFyc1xyXG4gICAgbGV0IGRpbWVuc2lvbnMgPSB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLO1xyXG4gICAgbGV0IGhhbGZEaW1lbnNpb25zID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XHJcbiAgICBsZXQgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoLTAuNSwgLTAuNSwgLTAuNSk7XHJcblxyXG4gICAgLy8gR2VvbWV0cnlcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxyXG4gICAgICBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy56KTtcclxuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gaW1hZ2Ugc3BhY2VcclxuICAgIHRoaXMuX2dlb21ldHJ5IC5hcHBseU1hdHJpeChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihcclxuICAgICAgaGFsZkRpbWVuc2lvbnMueCArIG9mZnNldC54LFxyXG4gICAgICBoYWxmRGltZW5zaW9ucy55ICsgb2Zmc2V0LnksXHJcbiAgICAgIGhhbGZEaW1lbnNpb25zLnogKyBvZmZzZXQueikpO1xyXG5cclxuXHJcbiAgICAvLyBNZXNoXHJcbiAgICBsZXQgYm94TWVzaCA9XHJcbiAgICAgIG5ldyBUSFJFRS5NZXNoKHRoaXMuX2dlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoMHhmZjAwMDApKTtcclxuICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuQm94SGVscGVyKGJveE1lc2gsIHRoaXMuX2NvbG9yKTtcclxuXHJcbiAgICAvLyBNYXRlcmlhbFxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSB0aGlzLl9tZXNoLm1hdGVyaWFsO1xyXG5cclxuICAgIC8vIHBvc2l0aW9uIGJib3ggaW4gd29ybGQgc3BhY2VcclxuICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5fc3RhY2suaWprMkxQUyk7XHJcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xyXG5cclxuICAgIC8vIGFuZCBhZGQgaXQhXHJcbiAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICB9XHJcblxyXG4gIF91cGRhdGUoKSB7XHJcbiAgICAvLyB1cGRhdGUgc2xpY2VcclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX21lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcclxuICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMuX2dlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IEJvcmRlciBmcm9tICcuL2hlbHBlcnMuYm9yZGVyJztcclxuaW1wb3J0IEJvdW5kaW5nQm94IGZyb20gJy4vaGVscGVycy5ib3VuZGluZ2JveCc7XHJcbmltcG9ydCBMb2NhbGl6ZXIgZnJvbSAnLi9oZWxwZXJzLmxvY2FsaXplcic7XHJcbmltcG9ydCBMdXQgZnJvbSAnLi9oZWxwZXJzLmx1dCc7XHJcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICcuL2hlbHBlcnMucHJvZ3Jlc3NiYXInO1xyXG5pbXBvcnQgUHJvZ3Jlc3NCYXJFdmVudEJhc2VkIGZyb20gJy4vaGVscGVycy5wcm9ncmVzc2Jhci5ldmVudGJhc2VkJztcclxuaW1wb3J0IFNsaWNlIGZyb20gJy4vaGVscGVycy5zbGljZSc7XHJcbmltcG9ydCBTdGFjayBmcm9tICcuL2hlbHBlcnMuc3RhY2snO1xyXG5pbXBvcnQgVm9sdW1lUmVuZGVyaW5nIGZyb20gJy4vaGVscGVycy52b2x1bWVyZW5kZXJpbmcnO1xyXG5pbXBvcnQgWCBmcm9tICcuL3gvaGVscGVycy54JztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgQm9yZGVyLFxyXG4gIEJvdW5kaW5nQm94LFxyXG4gIExvY2FsaXplcixcclxuICBMdXQsXHJcbiAgUHJvZ3Jlc3NCYXIsXHJcbiAgUHJvZ3Jlc3NCYXJFdmVudEJhc2VkLFxyXG4gIFNsaWNlLFxyXG4gIFN0YWNrLFxyXG4gIFZvbHVtZVJlbmRlcmluZyxcclxuICBYLFxyXG59O1xyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFNoYWRlcnNVbmlmb3JtIGZyb21cclxuICAnLi4vc2hhZGVycy9zaGFkZXJzLmxvY2FsaXplci51bmlmb3JtJztcclxuaW1wb3J0IFNoYWRlcnNWZXJ0ZXggZnJvbVxyXG4gICcuLi9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLnZlcnRleCc7XHJcbmltcG9ydCBTaGFkZXJzRnJhZ21lbnQgZnJvbVxyXG4gICcuLi9zaGFkZXJzL3NoYWRlcnMubG9jYWxpemVyLmZyYWdtZW50JztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvbG9jYWxpemVyXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyc0xvY2FsaXplciBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcclxuICBjb25zdHJ1Y3RvcihzdGFjaywgZ2VvbWV0cnksIHJlZmVyZW5jZVBsYW5lKSB7XHJcbiAgICAvL1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xyXG4gICAgdGhpcy5fcmVmZXJlbmNlUGxhbmUgPSByZWZlcmVuY2VQbGFuZTtcclxuICAgIHRoaXMuX3BsYW5lMSA9IG51bGw7XHJcbiAgICB0aGlzLl9jb2xvcjEgPSBudWxsO1xyXG4gICAgdGhpcy5fcGxhbmUyID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbG9yMiA9IG51bGw7XHJcbiAgICB0aGlzLl9wbGFuZTMgPSBudWxsO1xyXG4gICAgdGhpcy5fY29sb3IzID0gbnVsbDtcclxuICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gMDtcclxuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XHJcbiAgICB0aGlzLl9zaGFkZXJzRnJhZ21lbnQgPSBTaGFkZXJzRnJhZ21lbnQ7XHJcbiAgICB0aGlzLl9zaGFkZXJzVmVydGV4ID0gU2hhZGVyc1ZlcnRleDtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gU2hhZGVyc1VuaWZvcm0udW5pZm9ybXMoKTtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlKCkge1xyXG4gICAgdGhpcy5fcHJlcGFyZU1hdGVyaWFsKCk7XHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5fc3RhY2suX2lqazJMUFMpO1xyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZU1hdGVyaWFsKCkge1xyXG4gICAgaWYgKCF0aGlzLm1hdGVyaWFsKSB7XHJcbiAgICAgIC8vIHJlZmVyZW5jZSBwbGFuZVxyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51U2xpY2UudmFsdWUgPSB0aGlzLl9yZWZlcmVuY2VQbGFuZTtcclxuXHJcbiAgICAgIC8vIGxvY2FsaXplciBwbGFuZXNcclxuICAgICAgaWYgKHRoaXMuX3BsYW5lMSkge1xyXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTEudmFsdWUgPSB0aGlzLl9wbGFuZTE7XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IxLnZhbHVlID0gdGhpcy5fY29sb3IxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fcGxhbmUyKSB7XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMi52YWx1ZSA9IHRoaXMuX3BsYW5lMjtcclxuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjIudmFsdWUgPSB0aGlzLl9jb2xvcjI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9wbGFuZTMpIHtcclxuICAgICAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUzLnZhbHVlID0gdGhpcy5fcGxhbmUzO1xyXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMy52YWx1ZSA9IHRoaXMuX2NvbG9yMztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9cclxuICAgICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc1dpZHRoLnZhbHVlID0gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNIZWlnaHQudmFsdWUgPSB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcblxyXG4gICAgICAvLyBnZW5lcmF0ZSBtYXRlcmlhbFxyXG4gICAgICBsZXQgZnMgPSBuZXcgU2hhZGVyc0ZyYWdtZW50KHRoaXMuX3VuaWZvcm1zKTtcclxuICAgICAgbGV0IHZzID0gbmV3IFNoYWRlcnNWZXJ0ZXgoKTtcclxuICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoXHJcbiAgICAgICAge3NpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXHJcbiAgICAgICAgIHVuaWZvcm1zOiB0aGlzLl91bmlmb3JtcyxcclxuICAgICAgICAgdmVydGV4U2hhZGVyOiB2cy5jb21wdXRlKCksXHJcbiAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcy5jb21wdXRlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGdlb21ldHJ5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5O1xyXG4gIH1cclxuXHJcbiAgc2V0IGdlb21ldHJ5KGdlb21ldHJ5KSB7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cclxuICAgIGlmICh0aGlzLl9tZXNoKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX21lc2ggPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlZmVyZW5jZVBsYW5lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZVBsYW5lO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlZmVyZW5jZVBsYW5lKHJlZmVyZW5jZVBsYW5lKSB7XHJcbiAgICB0aGlzLl9yZWZlcmVuY2VQbGFuZSA9IHJlZmVyZW5jZVBsYW5lO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVNsaWNlLnZhbHVlID0gdGhpcy5fcmVmZXJlbmNlUGxhbmU7XHJcbiAgfVxyXG5cclxuICBnZXQgcGxhbmUxKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lMTtcclxuICB9XHJcblxyXG4gIHNldCBwbGFuZTEocGxhbmUxKSB7XHJcbiAgICB0aGlzLl9wbGFuZTEgPSBwbGFuZTE7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmUxLnZhbHVlID0gdGhpcy5fcGxhbmUxO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbG9yMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xvcjE7XHJcbiAgfVxyXG5cclxuICBzZXQgY29sb3IxKGNvbG9yMSkge1xyXG4gICAgdGhpcy5fY29sb3IxID0gY29sb3IxO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lQ29sb3IxLnZhbHVlID0gdGhpcy5fY29sb3IxO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBsYW5lMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9wbGFuZTI7XHJcbiAgfVxyXG5cclxuICBzZXQgcGxhbmUyKHBsYW5lMikge1xyXG4gICAgdGhpcy5fcGxhbmUyID0gcGxhbmUyO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVBsYW5lMi52YWx1ZSA9IHRoaXMuX3BsYW5lMjtcclxuICB9XHJcblxyXG4gIGdldCBjb2xvcjIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sb3IyO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yMihjb2xvcjIpIHtcclxuICAgIHRoaXMuX2NvbG9yMiA9IGNvbG9yMjtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZUNvbG9yMi52YWx1ZSA9IHRoaXMuX2NvbG9yMjtcclxuICB9XHJcblxyXG4gIGdldCBwbGFuZTMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGxhbmUzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBsYW5lMyhwbGFuZTMpIHtcclxuICAgIHRoaXMuX3BsYW5lMyA9IHBsYW5lMztcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVQbGFuZTMudmFsdWUgPSB0aGlzLl9wbGFuZTM7XHJcbiAgfVxyXG5cclxuICBnZXQgY29sb3IzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yMztcclxuICB9XHJcblxyXG4gIHNldCBjb2xvcjMoY29sb3IzKSB7XHJcbiAgICB0aGlzLl9jb2xvcjMgPSBjb2xvcjM7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGxhbmVDb2xvcjMudmFsdWUgPSB0aGlzLl9jb2xvcjM7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FudmFzV2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzV2lkdGgoY2FudmFzV2lkdGgpIHtcclxuICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51Q2FudmFzV2lkdGgudmFsdWUgPSB0aGlzLl9jYW52YXNXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXNIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGNhbnZhc0hlaWdodChjYW52YXNIZWlnaHQpIHtcclxuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVDYW52YXNIZWlnaHQudmFsdWUgPSB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcbiAgfVxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBoZWxwZXJzL2x1dFxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNMdXQge1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcklELFxyXG4gICAgICAgICAgICAgIGx1dCA9ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICBsdXRPID0gJ2xpbmVhcicsXHJcbiAgICAgICAgICAgICAgY29sb3IgPSBbWzAsIDAsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxyXG4gICAgICAgICAgICAgIG9wYWNpdHkgPSBbWzAsIDBdLCBbMSwgMV1dLFxyXG4gICAgICAgICAgICAgIGRpc2NyZXRlID0gZmFsc2UpIHtcclxuICAgIC8vIG1pbi9tYXggKDAtMSBvciByZWFsIGludGVuc2l0aWVzKVxyXG4gICAgLy8gc2hvdy9oaWRlXHJcbiAgICAvLyBob3Jpem9udGFsL3ZlcnRpY2FsXHJcbiAgICB0aGlzLl9jb250YWluZXJJRCA9IGNvbnRhaW5lcklEO1xyXG5cclxuICAgIHRoaXMuX2Rpc2NyZXRlID0gZGlzY3JldGU7XHJcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xyXG4gICAgdGhpcy5fbHV0ID0gbHV0O1xyXG4gICAgdGhpcy5fbHV0cyA9IHtbbHV0XTogY29sb3J9O1xyXG5cclxuICAgIHRoaXMuX29wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgdGhpcy5fbHV0TyA9IGx1dE87XHJcbiAgICB0aGlzLl9sdXRzTyA9IHtbbHV0T106IG9wYWNpdHl9O1xyXG5cclxuICAgIHRoaXMuaW5pdENhbnZhcygpO1xyXG4gICAgdGhpcy5wYWludENhbnZhcygpO1xyXG4gIH1cclxuXHJcbiAgaW5pdENhbnZhcygpIHtcclxuICAgIC8vIGNvbnRhaW5lclxyXG4gICAgdGhpcy5fY2FudmFzQ29udGFpbmVyID0gdGhpcy5pbml0Q2FudmFzQ29udGFpbmVyKHRoaXMuX2NvbnRhaW5lcklEKTtcclxuICAgIC8vIGJhY2tncm91bmRcclxuICAgIHRoaXMuX2NhbnZhc0JnID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcclxuICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXNCZyk7XHJcbiAgICAvLyBmb3JlZ3JvdW5kXHJcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xyXG4gICAgdGhpcy5fY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgfVxyXG5cclxuICBpbml0Q2FudmFzQ29udGFpbmVyKGNhbnZhc0NvbnRhaW5lcklkKSB7XHJcbiAgICBsZXQgY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzQ29udGFpbmVySWQpO1xyXG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gJzI1NiBweCc7XHJcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEyOCBweCc7XHJcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjRjlGOUY5JztcclxuICAgIHJldHVybiBjYW52YXNDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVDYW52YXMoKSB7XHJcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTY7XHJcbiAgICBjYW52YXMud2lkdGggPSAyNTY7XHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG4gIH1cclxuXHJcbiAgcGFpbnRDYW52YXMoKSB7XHJcbiAgICAvLyBzZXR1cCBjb250ZXh0XHJcbiAgICBsZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuXHJcbiAgICAvLyBhcHBseSBjb2xvclxyXG4gICAgaWYgKCF0aGlzLl9kaXNjcmV0ZSkge1xyXG4gICAgICBsZXQgY29sb3IgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jb2xvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbG9yLmFkZENvbG9yU3RvcCh0aGlzLl9jb2xvcltpXVswXSwgYHJnYmEoICR7TWF0aC5yb3VuZCh0aGlzLl9jb2xvcltpXVsxXSAqIDI1NSl9LCAke01hdGgucm91bmQodGhpcy5fY29sb3JbaV1bMl0gKiAyNTUpfSwgJHtNYXRoLnJvdW5kKHRoaXMuX2NvbG9yW2ldWzNdICogMjU1KX0sIDEpYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHgubGluZVdpZHRoPTIqdGhpcy5fY2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9jb2xvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gdGhpcy5fY29sb3JbaV1bMF07XHJcbiAgICAgICAgbGV0IG5leHRQb3MgPSAxO1xyXG4gICAgICAgIGlmIChpIDwgdGhpcy5fY29sb3IubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgbmV4dFBvcyA9IHRoaXMuX2NvbG9yW2krMV1bMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwcmV2aW91c1BvcyA9IDA7XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICBwcmV2aW91c1BvcyA9IHRoaXMuX2NvbG9yW2ktMV1bMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZnJvbSA9IHByZXZpb3VzUG9zICsgKGN1cnJlbnRQb3MgLSBwcmV2aW91c1BvcykvMjtcclxuICAgICAgICBsZXQgdG8gPSBjdXJyZW50UG9zICsgKG5leHRQb3MgLSBjdXJyZW50UG9zKS8yO1xyXG4gICAgICAgIGxldCBjb2xvciA9IHRoaXMuX2NvbG9yW2ldO1xyXG4gICAgICAgIGxldCBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVtpXSA/IHRoaXMuX29wYWNpdHlbaV1bMV0gOiAxO1xyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoICR7TWF0aC5yb3VuZChjb2xvclsxXSAqIDI1NSl9LCAke01hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpfSwgJHtNYXRoLnJvdW5kKGNvbG9yWzNdICogMjU1KX0sICR7b3BhY2l0eX0pYDtcclxuICAgICAgICBjdHgubW92ZVRvKGZyb20qdGhpcy5fY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgICBjdHgubGluZVRvKHRvKnRoaXMuX2NhbnZhcy53aWR0aCwgMCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fZGlzY3JldGUpIHtcclxuICAgICAgLy8gaWYgZGlzY3JldGUsIHdlIGFscmVhZHkgdG9vayBjYXJlIG9mIHRoZSBvcGFjaXR5LlxyXG4gICAgICAvLyBzZXR1cCBjb250ZXh0XHJcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xyXG5cclxuICAgICAgLy8gYXBwbHkgb3BhY2l0eVxyXG4gICAgICBsZXQgb3BhY2l0eSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29wYWNpdHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBvcGFjaXR5LmFkZENvbG9yU3RvcCh0aGlzLl9vcGFjaXR5W2ldWzBdLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAnICsgdGhpcy5fb3BhY2l0eVtpXVsxXSArICcpJyk7XHJcbiAgICAgIH1cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wYWNpdHk7XHJcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICBsZXQgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKHRoaXMuX2NhbnZhcyk7XHJcbiAgICB0ZXh0dXJlLm1hcHBpbmcgPSBUSFJFRS5VVk1hcHBpbmc7XHJcbiAgICB0ZXh0dXJlLndyYXBTID0gdGV4dHVyZS53cmFwVCA9IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuICAgIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRydWU7XHJcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGx1dCh0YXJnZXRMVVQpIHtcclxuICAgIHRoaXMuX2NvbG9yID0gdGhpcy5fbHV0c1t0YXJnZXRMVVRdO1xyXG4gICAgdGhpcy5fbHV0ID0gdGFyZ2V0TFVUO1xyXG5cclxuICAgIHRoaXMucGFpbnRDYW52YXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBsdXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbHV0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGx1dHMobmV3THV0cykge1xyXG4gICAgdGhpcy5fbHV0cyA9IG5ld0x1dHM7XHJcbiAgfVxyXG5cclxuICBnZXQgbHV0cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9sdXRzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGx1dE8odGFyZ2V0TFVUTykge1xyXG4gICAgdGhpcy5fb3BhY2l0eSA9IHRoaXMuX2x1dHNPW3RhcmdldExVVE9dO1xyXG4gICAgdGhpcy5fbHV0TyA9IHRhcmdldExVVE87XHJcblxyXG4gICAgdGhpcy5wYWludENhbnZhcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGx1dE8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbHV0TztcclxuICB9XHJcblxyXG4gIHNldCBsdXRzTyhuZXdMdXRzTykge1xyXG4gICAgdGhpcy5fbHV0c08gPSBuZXdMdXRzTztcclxuICB9XHJcblxyXG4gIGdldCBsdXRzTygpIHtcclxuICAgIHJldHVybiB0aGlzLl9sdXRzTztcclxuICB9XHJcblxyXG4gIHNldCBkaXNjcmV0ZShkaXNjcmV0ZSkge1xyXG4gICAgdGhpcy5fZGlzY3JldGUgPSBkaXNjcmV0ZTtcclxuXHJcbiAgICB0aGlzLnBhaW50Q2FudmFzKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgZGlzY3JldGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGlzY3JldGU7XHJcbiAgfVxyXG5cclxuICBsdXRzQXZhaWxhYmxlKHR5cGUgPSAnY29sb3InKSB7XHJcbiAgICBsZXQgYXZhaWxhYmxlID0gW107XHJcbiAgICBsZXQgbHV0cyA9IHRoaXMuX2x1dHM7XHJcblxyXG4gICAgaWYgKHR5cGUgIT09ICdjb2xvcicpIHtcclxuICAgICAgbHV0cyA9IHRoaXMuX2x1dHNPO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgaW4gbHV0cykge1xyXG4gICAgICBhdmFpbGFibGUucHVzaChpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXZhaWxhYmxlO1xyXG4gIH1cclxuXHJcbiAgLy8gYWRkIGx1dHMgdG8gY2xhc3MnIGx1dCAoc28gYSB1c2VyIGNhbiBhZGQgaXRzIG93biBhcyB3ZWxsKVxyXG4gIHN0YXRpYyBwcmVzZXRMdXRzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2RlZmF1bHQnOiBbWzAsIDAsIDAsIDBdLCBbMSwgMSwgMSwgMV1dLFxyXG4gICAgICAnc3BlY3RydW0nOiBbWzAsIDAsIDAsIDBdLCBbMC4xLCAwLCAwLCAxXSwgWzAuMzMsIDAsIDEsIDFdLCBbMC41LCAwLCAxLCAwXSwgWzAuNjYsIDEsIDEsIDBdLCBbMC45LCAxLCAwLCAwXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ2hvdF9hbmRfY29sZCc6IFtbMCwgMCwgMCwgMV0sIFswLjE1LCAwLCAxLCAxXSwgWzAuMywgMCwgMSwgMF0sIFswLjQ1LCAwLCAwLCAwXSwgWzAuNSwgMCwgMCwgMF0sIFswLjU1LCAwLCAwLCAwXSwgWzAuNywgMSwgMSwgMF0sIFswLjg1LCAxLCAwLCAwXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ2dvbGQnOiBbWzAsIDAsIDAsIDBdLCBbMC4xMywgMC4xOSwgMC4wMywgMF0sIFswLjI1LCAwLjM5LCAwLjEyLCAwXSwgWzAuMzgsIDAuNTksIDAuMjYsIDBdLCBbMC41MCwgMC44MCwgMC40NiwgMC4wOF0sIFswLjYzLCAwLjk5LCAwLjcxLCAwLjIxXSwgWzAuNzUsIDAuOTksIDAuODgsIDAuMzRdLCBbMC44OCwgMC45OSwgMC45OSwgMC40OF0sIFsxLCAwLjkwLCAwLjk1LCAwLjYxXV0sXHJcbiAgICAgICdyZWQnOiBbWzAsIDAuNzUsIDAsIDBdLCBbMC41LCAxLCAwLjUsIDBdLCBbMC45NSwgMSwgMSwgMF0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICAgICdncmVlbic6IFtbMCwgMCwgMC43NSwgMF0sIFswLjUsIDAuNSwgMSwgMF0sIFswLjk1LCAxLCAxLCAwXSwgWzEsIDEsIDEsIDFdXSxcclxuICAgICAgJ2JsdWUnOiBbWzAsIDAsIDAsIDFdLCBbMC41LCAwLCAwLjUsIDFdLCBbMC45NSwgMCwgMSwgMV0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICAgICd3YWxraW5nX2RlYWQnOiBbWzAsIDAuMSwgMSwgMV0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICAgICdyYW5kb20nOiBbWzAsIDAsIDAsIDBdLCBbMC4yNywgMC4xOCwgMC4xOCwgMC4xOF0sIFswLjQxLCAxLCAxLCAxXSwgWzAuNywgMSwgMCwgMF0sIFsxLCAxLCAxLCAxXV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIHByZXNldEx1dHNPKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2xpbmVhcic6IFtbMCwgMF0sIFsxLCAxXV0sXHJcbiAgICAgICdsb3dwYXNzJzogW1swLCAwLjhdLCBbMC4yLCAwLjZdLCBbMC4zLCAwLjFdLCBbMSwgMF1dLFxyXG4gICAgICAnYmFuZHBhc3MnOiBbWzAsIDBdLCBbMC40LCAwLjhdLCBbMC42LCAwLjhdLCBbMSwgMF1dLFxyXG4gICAgICAnaGlnaHBhc3MnOiBbWzAsIDBdLCBbMC43LCAwLjFdLCBbMC44LCAwLjZdLCBbMSwgMC44XV0sXHJcbiAgICAgICdmbGF0JzogW1swLCAuN10sIFsxLCAxXV0sXHJcbiAgICAgICdyYW5kb20nOiBbWzAsIDAuXSwgWzAuMzgsIDAuXSwgWzAuNTUsIDEuXSwgWzAuNzIsIDEuXSwgWzEsIDAuMDVdXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKipcclxuICogSGVscGVycyBtYXRlcmlhbCBtaXhpbi5cclxuICpcclxuICogQG1vZHVsZSBoZWxwZXJzL21hdGVyaWFsL21peGluXHJcbiAqL1xyXG5cclxubGV0IEhlcmxwZXJzTWF0ZXJpYWxNaXhpbiA9IChzdXBlcmNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xyXG5cclxuICBfY3JlYXRlTWF0ZXJpYWwoZXh0cmFPcHRpb25zKSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBzaGFkZXJzIG9uLWRlbWFuZCFcclxuICAgIGxldCBmcyA9IG5ldyB0aGlzLl9zaGFkZXJzRnJhZ21lbnQodGhpcy5fdW5pZm9ybXMpO1xyXG4gICAgbGV0IHZzID0gbmV3IHRoaXMuX3NoYWRlcnNWZXJ0ZXgoKTtcclxuXHJcbiAgICAvLyBtYXRlcmlhbFxyXG4gICAgbGV0IGdsb2JhbE9wdGlvbnMgPSB7XHJcbiAgICAgIHVuaWZvcm1zOiB0aGlzLl91bmlmb3JtcyxcclxuICAgICAgdmVydGV4U2hhZGVyOiB2cy5jb21wdXRlKCksXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmcy5jb21wdXRlKCksXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihleHRyYU9wdGlvbnMsIGdsb2JhbE9wdGlvbnMpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwob3B0aW9ucyk7XHJcbiAgICB0aGlzLl9tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlTWF0ZXJpYWwoKSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBzaGFkZXJzIG9uLWRlbWFuZCFcclxuICAgIGxldCBmcyA9IG5ldyB0aGlzLl9zaGFkZXJzRnJhZ21lbnQodGhpcy5fdW5pZm9ybXMpO1xyXG4gICAgbGV0IHZzID0gbmV3IHRoaXMuX3NoYWRlcnNWZXJ0ZXgoKTtcclxuXHJcbiAgICB0aGlzLl9tYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB2cy5jb21wdXRlKCk7XHJcbiAgICB0aGlzLl9tYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGZzLmNvbXB1dGUoKTtcclxuXHJcbiAgICB0aGlzLl9tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZVRleHR1cmUoKSB7XHJcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgbSA9IDA7IG0gPCB0aGlzLl9zdGFjay5fcmF3RGF0YS5sZW5ndGg7IG0rKykge1xyXG4gICAgICBsZXQgdGV4ID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKFxyXG4gICAgICAgIHRoaXMuX3N0YWNrLnJhd0RhdGFbbV0sXHJcbiAgICAgICAgdGhpcy5fc3RhY2sudGV4dHVyZVNpemUsXHJcbiAgICAgICAgdGhpcy5fc3RhY2sudGV4dHVyZVNpemUsXHJcbiAgICAgICAgdGhpcy5fc3RhY2sudGV4dHVyZVR5cGUsXHJcbiAgICAgICAgVEhSRUUuVW5zaWduZWRCeXRlVHlwZSxcclxuICAgICAgICBUSFJFRS5VVk1hcHBpbmcsXHJcbiAgICAgICAgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyxcclxuICAgICAgICBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLFxyXG4gICAgICAgIFRIUkVFLk5lYXJlc3RGaWx0ZXIsXHJcbiAgICAgICAgVEhSRUUuTmVhcmVzdEZpbHRlcik7XHJcbiAgICAgIHRleC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgIHRleC5mbGlwWSA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVybHBlcnNNYXRlcmlhbE1peGluO1xyXG4iLCJpbXBvcnQgQ29yZVV0aWxzIGZyb20gJy4uL2NvcmUvY29yZS51dGlscyc7XHJcbi8qKlxyXG4gKiBFdmVudCBCYXNlZCBwcm9ncmVzc2JhclxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvcHJvZ3Jlc3NCYXJcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogbGV0IGxvYWRlciA9IG5ldyBMb2FkZXJzVm9sdW1lKCk7XHJcbiAqIGNvbnN0IGRvbUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmVzc2JhcicpO1xyXG4gKiBjb25zdCBwYiA9IG5ldyBIZWxwZXJzUHJvZ3Jlc3NCYXJFdmVudEJhc2VkKGxvYWRlciwgZG9tQ29udGFpbmVyKTtcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzUHJvZ3Jlc3NCYXJFdmVudEJhc2VkIHtcclxuICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBkb21UYXJnZXQpIHtcclxuICAgIGlmICghZW1pdHRlciB8fCAhdGhpcy5faXNGdW5jdGlvbihlbWl0dGVyLmVtaXQpKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3BsZWFzZSBnaXZlIHRoZSB0aGlzLl9lbWl0dGVyIGluc3RhbmNlJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ29yZVV0aWxzLmlzU3RyaW5nKGRvbVRhcmdldCkpIHtcclxuICAgICAgdGhpcy5fZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZG9tVGFyZ2V0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RvbSA9IGRvbVRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIUNvcmVVdGlscy5pc0VsZW1lbnQodGhpcy5fZG9tKSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdwbGVhc2UgZ2l2ZSB0aGUgaWQgb2YgY29udGFpbmVyIGRvbSBvciBkaXJlY3RseSBhIGRvbSBpbnN0YW5jZScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlcjtcclxuICAgIHRoaXMuaW5pdENvbnRhaW5lckRvbSgpO1xyXG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5uZXIoKTtcclxuICAgIHRoaXMubG9hZGVkID0gMDtcclxuICAgIHRoaXMudG90YWxGaWxlID0gMDtcclxuICB9XHJcblxyXG4gIF9pc0Z1bmN0aW9uKGZuKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcclxuICB9XHJcblxyXG4gIGluaXRFdmVudExpc3Rlbm5lcigpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2xvYWQtc3RhcnQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjb25zdCB0b3RhbEZpbGVzID0gZXZlbnQudG90YWxGaWxlcztcclxuICAgICAgc2VsZi50b3RhbEZpbGUgPSB0b3RhbEZpbGVzO1xyXG4gICAgICBzZWxmLl9kb21Ub3RhbEZpbGUuaW5uZXJIVE1MID0gdG90YWxGaWxlcztcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLXN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgY29uc3QgZmV0Y2hMaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XHJcblxyXG4gICAgICBjb25zdCBmaWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGZpbGVUYWcuaW5uZXJIVE1MID0gJ2ZpbGU6ICcgKyBldmVudC5maWxlO1xyXG4gICAgICBmaWxlVGFnLnN0eWxlLmNvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgICBmZXRjaExpLmFwcGVuZChmaWxlVGFnKTtcclxuXHJcbiAgICAgIGZldGNoTGkuY2xhc3NOYW1lID0gJ2ZldGNoLWZpbGUnO1xyXG4gICAgICBmZXRjaExpLmlkID0gJ2ZpbGUtJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIGZldGNoTGkuc3R5bGUubWFyZ2luQm90dG9tID0gJzdweCc7XHJcbiAgICAgIGZldGNoTGkuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjZmZmZmZmOyc7XHJcbiAgICAgIGZldGNoTGkuc3R5bGUud2lkdGggPSAnNjAlJztcclxuICAgICAgY29uc3QgZmV0Y2hwcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBmZXRjaHByb2dyZXNzLmlkID0gJ2ZpbGUtZmV0Y2gtJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIGZldGNocHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xyXG4gICAgICBmZXRjaExpLmFwcGVuZChmZXRjaHByb2dyZXNzKTtcclxuICAgICAgc2VsZi5fZG9tUHJvY2Vzc0xpc3QuYXBwZW5kKGZldGNoTGkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtcHJvZ3Jlc3MnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjb25zdCBpZCA9ICdmaWxlLWZldGNoLScgKyBldmVudC5maWxlO1xyXG4gICAgICBjb25zdCBmaWxlRmV0Y2hEb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgIGZpbGVGZXRjaERvbS5zdHlsZS53aWR0aCA9IChldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCkgKiAxMDAgKyAnJSc7XHJcbiAgICAgIGZpbGVGZXRjaERvbS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJlZCc7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1zdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgLy8gc2hvdyByZXN1bHRcclxuICAgICAgY29uc3QgbGlQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS0nICsgZXZlbnQuZmlsZSk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICByZXN1bHQuaWQgPSAnZmlsZS1yZXN1bHQtJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIHJlc3VsdC5pbm5lckhUTUwgPSAnZmV0Y2gtc3VjY2Vzcyc7XHJcbiAgICAgIHJlc3VsdC5zdHlsZS5jb2xvciA9ICcjZmZmZmZmJztcclxuICAgICAgbGlQYXJlbnQuYXBwZW5kKHJlc3VsdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdmZXRjaC1lcnJvcicsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ2ZldGNoLWFib3J0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbignZmV0Y2gtdGltZW91dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VtaXR0ZXIub24oJ3BhcnNlLXN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgY29uc3QgbGlQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS0nICsgZXZlbnQuZmlsZSlcclxuICAgICAgY29uc3QgcGFyc2Vwcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBwYXJzZXByb2dyZXNzLmlkID0gJ2ZpbGUtcGFyc2UtJyArIGV2ZW50LmZpbGU7XHJcbiAgICAgIHBhcnNlcHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAnMCUnO1xyXG4gICAgICBsaVBhcmVudC5hcHBlbmQocGFyc2Vwcm9ncmVzcyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9lbWl0dGVyLm9uKCdwYXJzaW5nJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgY29uc3QgaWQgPSAnZmlsZS1wYXJzZS0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgY29uc3QgZmlsZVBhcnNlRG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICBmaWxlUGFyc2VEb20uc3R5bGUud2lkdGggPSAoZXZlbnQucGFyc2VkIC8gZXZlbnQudG90YWwpICogMTAwICsgJyUnO1xyXG4gICAgICBmaWxlUGFyc2VEb20uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCB5ZWxsb3cnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fZW1pdHRlci5vbigncGFyc2Utc3VjY2VzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIHNlbGYubG9hZGVkICs9IDE7XHJcbiAgICAgIHNlbGYuX2RvbUN1cnJlbnRGaWxlLmlubmVySFRNTCA9IHNlbGYubG9hZGVkO1xyXG4gICAgICBzZWxmLl9kb21DdXJyZW50UHJvZ3Jlc3Muc3R5bGUud2lkdGggPSAoc2VsZi5sb2FkZWQgLyBzZWxmLnRvdGFsRmlsZSkgKlxyXG4gICAgICAgIDEwMCArICclJztcclxuICAgICAgLy8gc2hvdyByZXN1bHRcclxuICAgICAgY29uc3QgbGlQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZS0nICsgZXZlbnQuZmlsZSlcclxuICAgICAgY29uc3QgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHJlc3VsdC5pZCA9ICdmaWxlLXJlc3VsdC0nICsgZXZlbnQuZmlsZTtcclxuICAgICAgcmVzdWx0LmlubmVySFRNTCA9ICdwYXJzZS1zdWNjZXNzJztcclxuICAgICAgcmVzdWx0LnN0eWxlLmNvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgICBsaVBhcmVudC5hcHBlbmQocmVzdWx0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdENvbnRhaW5lckRvbSgpIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lckRvbSA9XHJcbiAgICAgIFwiPGRpdiBpZD0nYW1pLXByb2dyZXNzLWJhci1jb250YWluZXInIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzMsIDMzLCAzMyk7IGNvbG9yOiAjZmZmZmZmOyc+XCIgK1xyXG4gICAgICBcIjxkaXY+XCIgK1xyXG4gICAgICBcIjxsYWJlbCBmb3I9J3Byb2dyZXNzLWJhcicgaWQ9J3Byb2dyZXNzLWxhYmVsJyBzdHlsZT0nd2lkdGg6IDYwJTsgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjsgdGV4dC1hbGlnbjogY2VudGVyOyc+XCIgK1xyXG4gICAgICBcIjxzcGFuIGlkPSdjdXJyZW50LWZpbGUtaW5kZXgnPjA8L3NwYW4+XCIgK1xyXG4gICAgICBcIi9cIiArXHJcbiAgICAgIFwiPHNwYW4gaWQ9J3RvdGFsLWZpbGUnPjA8L3NwYW4+XCIgK1xyXG4gICAgICBcIjwvbGFiZWw+XCIgK1xyXG4gICAgICBcIjxkaXYgaWQ9J3Byb2dyZXNzLWJhcicgc3R5bGU9J3dpZHRoOiA2MCU7IGJvcmRlcjogMXB4IHNvbGlkICNmZmZmZmY7IHRleHQtYWxpZ246IGNlbnRlcjsnPlwiICtcclxuICAgICAgXCI8ZGl2IGlkPSdjdXJyZW50LXByb2dyZXNzJyBzdHlsZT0nYm9yZGVyOiAxcHggc29saWQgcmVkOyB3aWR0aDogMCU7Jz48L2Rpdj5cIiArXHJcbiAgICAgIFwiPC9kaXY+XCIgK1xyXG4gICAgICBcIjwvZGl2PlwiICtcclxuICAgICAgXCI8dWwgaWQ9J3Byb2Nlc3MtbGlzdCcgc3R5bGU9J2xpc3Qtc3R5bGUtdHlwZTogbm9uZTsgcGFkZGluZzogMDsgb3ZlcmZsb3cteTogYXV0bzsnPlwiICtcclxuICAgICAgLy8gXCI8bGkgY2xhc3M9J2ZldGNoLWZpbGUnPlwiICtcclxuICAgICAgLy8gXCI8ZGl2IGlkPSdmaWxlLWZldGNoLXh4eHh4aWQnPjwvZGl2PlwiICtcclxuICAgICAgLy8gXCI8ZGl2IGlkPSdmaWxlLXBhcnNlLXh4eHh4aWQnPjwvZGl2PlwiICtcclxuICAgICAgLy8gXCI8L2xpPlwiICtcclxuICAgICAgXCI8L3VsPlwiICtcclxuICAgICAgXCI8L2Rpdj5cIjtcclxuICAgIGNvbnN0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHdyYXAuaW5uZXJIVE1MID0gY29udGFpbmVyRG9tO1xyXG4gICAgdGhpcy5fZG9tLmFwcGVuZCh3cmFwKTtcclxuICAgIC8vIGRvbSBpbnRlcmZhY2VcclxuICAgIHRoaXMuX2RvbUN1cnJlbnRGaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnQtZmlsZS1pbmRleCcpO1xyXG4gICAgdGhpcy5fZG9tVG90YWxGaWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsLWZpbGUnKTtcclxuICAgIHRoaXMuX2RvbVByb2Nlc3NMaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2Nlc3MtbGlzdCcpO1xyXG4gICAgdGhpcy5fZG9tQ3VycmVudFByb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnQtcHJvZ3Jlc3MnKTtcclxuICB9XHJcbn1cclxuIiwiXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvcHJvZ3Jlc3NCYXJcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzUHJvZ3Jlc3NCYXIge1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5fbW9kZXMgPSB7XHJcbiAgICAgICdsb2FkJzoge1xyXG4gICAgICAgICduYW1lJzogJ2xvYWQnLFxyXG4gICAgICAgICdjb2xvcic6ICcjRkZGNTZGJyxcclxuICAgICAgfSxcclxuICAgICAgJ3BhcnNlJzoge1xyXG4gICAgICAgICduYW1lJzogJ3BhcnNlJyxcclxuICAgICAgICAnY29sb3InOiAnIzIxOTZGMycsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX21vZGUgPSBudWxsO1xyXG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xyXG4gICAgdGhpcy5fdG90YWwgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgZnJlZSgpIHtcclxuICAgIGxldCBwcm9ncmVzc0NvbnRhaW5lcnMgPSB0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncHJvZ3Jlc3MgY29udGFpbmVyJyk7XHJcbiAgICBpZiAocHJvZ3Jlc3NDb250YWluZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcHJvZ3Jlc3NDb250YWluZXJzWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJvZ3Jlc3NDb250YWluZXJzWzBdKTtcclxuICAgIH1cclxuICAgIHByb2dyZXNzQ29udGFpbmVycyA9IG51bGw7XHJcbiAgICAvLyBzdG9wIHJlbmRlcmluZyBsb29wXHJcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJRCk7XHJcbiAgfVxyXG5cclxuICBpbml0KCkge1xyXG4gICAgbGV0IHByb2dyZXNzQ29udGFpbmVyID0gdGhpcy5fZG9tQ29udGFpbmVyKCk7XHJcblxyXG4gICAgZm9yIChsZXQgbW9kZSBpbiB0aGlzLl9tb2Rlcykge1xyXG4gICAgICBpZiAodGhpcy5fbW9kZXMuaGFzT3duUHJvcGVydHkobW9kZSkpIHtcclxuICAgICAgICBsZXQgYmFyID0gdGhpcy5fZG9tQmFyKHRoaXMuX21vZGVzW21vZGVdKTtcclxuICAgICAgICBwcm9ncmVzc0NvbnRhaW5lci5hcHBlbmRDaGlsZChiYXIpO1xyXG4gICAgICAgIGJhciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NDb250YWluZXIpO1xyXG4gICAgcHJvZ3Jlc3NDb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIHN0YXJ0IHJlbmRlcmluZyBsb29wXHJcbiAgICB0aGlzLnVwZGF0ZVVJKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUodmFsdWUsIHRvdGFsLCBtb2RlKSB7XHJcbiAgICB0aGlzLl9tb2RlID0gbW9kZTtcclxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAvLyBkZXBlbmRpbmcgb24gQ0ROLCB0b3RhbCByZXR1cm4gdG8gWEhUVFBSZXF1ZXN0IGNhbiBiZSAwLlxyXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgdG8gYW5pbWF0ZSB0aGUgcHJvZ3Jlc3NiYXJcclxuICAgIGlmICh0b3RhbCA9PT0gMCkge1xyXG4gICAgICB0aGlzLl90b3RhbCA9IHZhbHVlO1xyXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucmFuZG9tKCkqdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl90b3RhbCA9IHRvdGFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlVUkoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+e1xyXG4gICAgICB0aGlzLnVwZGF0ZVVJKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoISh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9tb2RlKSAmJlxyXG4gICAgICB0aGlzLl9tb2Rlc1t0aGlzLl9tb2RlXS5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmXHJcbiAgICAgIHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmhhc093blByb3BlcnR5KCdjb2xvcicpKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVzc2FnZSA9ICcnO1xyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKCh0aGlzLl92YWx1ZSAvIHRoaXMuX3RvdGFsKSAqIDEwMCk7XHJcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuX21vZGVzW3RoaXMuX21vZGVdLmNvbG9yO1xyXG5cclxuICAgIGxldCBwcm9ncmVzc0JhciA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdwcm9ncmVzcyAnICsgdGhpcy5fbW9kZXNbdGhpcy5fbW9kZV0ubmFtZSk7XHJcbiAgICBpZiAocHJvZ3Jlc3NCYXIubGVuZ3RoID4gMCkge1xyXG4gICAgICBwcm9ncmVzc0JhclswXS5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xyXG4gICAgICBwcm9ncmVzc0JhclswXS5zdHlsZS53aWR0aCA9IHByb2dyZXNzICsgJyUnO1xyXG4gICAgfVxyXG4gICAgcHJvZ3Jlc3NCYXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgX2RvbUNvbnRhaW5lcigpIHtcclxuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgICAvLyBjbGFzcyBpdFxyXG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJyk7XHJcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY29udGFpbmVyJyk7XHJcblxyXG4gICAgLy8gc3R5bGUgaXRcclxuICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnOHB4JztcclxuICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMTU4LCAxNTgsIDE1OCwgMC41KSc7XHJcbiAgICBjb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xyXG4gICAgY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICcxJztcclxuXHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgX2RvbUJhcihtb2RlKSB7XHJcbiAgICBpZiAoIShtb2RlLmhhc093blByb3BlcnR5KCduYW1lJykgJiZcclxuICAgICAgKG1vZGUuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykpKSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0ludmFsaWQgbW9kZSBwcm92aWRlZC4nKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKG1vZGUpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgICAvLyBjbGFzcyBpdFxyXG4gICAgYmFyLmNsYXNzTGlzdC5hZGQobW9kZS5uYW1lKTtcclxuICAgIGJhci5jbGFzc0xpc3QuYWRkKCdwcm9ncmVzcycpO1xyXG5cclxuICAgIC8vIHN0eWxlIGl0XHJcbiAgICBiYXIuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCAnICsgbW9kZS5jb2xvcjtcclxuICAgIGJhci5zdHlsZS53aWR0aCA9ICcwJSc7XHJcblxyXG4gICAgcmV0dXJuIGJhcjtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgR2VvbWV0cmllc1NsaWNlIGZyb20gJy4uL2dlb21ldHJpZXMvZ2VvbWV0cmllcy5zbGljZSc7XHJcbmltcG9ydCBTaGFkZXJzVW5pZm9ybSBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMuZGF0YS51bmlmb3JtJztcclxuaW1wb3J0IFNoYWRlcnNWZXJ0ZXggZnJvbSAnLi4vc2hhZGVycy9zaGFkZXJzLmRhdGEudmVydGV4JztcclxuaW1wb3J0IFNoYWRlcnNGcmFnbWVudCBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMuZGF0YS5mcmFnbWVudCc7XHJcblxyXG5pbXBvcnQgSGVscGVyc01hdGVyaWFsTWl4aW4gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGVyaWFsLm1peGluJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMvc2xpY2VcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzU2xpY2UgZXh0ZW5kcyBIZWxwZXJzTWF0ZXJpYWxNaXhpbihUSFJFRS5PYmplY3QzRCkge1xyXG4gIGNvbnN0cnVjdG9yKHN0YWNrLFxyXG4gICAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApLFxyXG4gICAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpLFxyXG4gICAgICAgICAgICAgIGFhYmJTcGFjZSA9ICdJSksnKSB7XHJcbiAgICAvL1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvLyBwcml2YXRlIHZhcnNcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcblxyXG4gICAgLy8gaW1hZ2Ugc2V0dGluZ3NcclxuICAgIC8vIGluZGV4IG9ubHkgdXNlZCB0byBncmFiIHdpbmRvdy9sZXZlbCBhbmQgaW50ZXJjZXB0L3Nsb3BlXHJcbiAgICB0aGlzLl9pbnZlcnQgPSB0aGlzLl9zdGFjay5pbnZlcnQ7XHJcblxyXG4gICAgdGhpcy5fbHV0ID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fbHV0VGV4dHVyZSA9IG51bGw7XHJcbiAgICAvLyBpZiBhdXRvID09PSB0cnVlLCBnZXQgZnJvbSBpbmRleFxyXG4gICAgLy8gZWxzZSBmcm9tIHN0YWNrIHdoaWNoIGhvbGRzIHRoZSBkZWZhdWx0IHZhbHVlc1xyXG4gICAgdGhpcy5faW50ZW5zaXR5QXV0byA9IHRydWU7XHJcbiAgICB0aGlzLl9pbnRlcnBvbGF0aW9uID0gMTsgLy8gZGVmYXVsdCB0byB0cmlsaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgLy8gc3RhcnRzIGF0IDBcclxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IG51bGw7XHJcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gbnVsbDtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gMDtcclxuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XHJcbiAgICB0aGlzLl9ib3JkZXJDb2xvciA9IG51bGw7XHJcblxyXG4gICAgLy8gT2JqZWN0M0Qgc2V0dGluZ3NcclxuICAgIC8vIHNoYXBlXHJcbiAgICB0aGlzLl9wbGFuZVBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl9wbGFuZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIC8vIGNoYW5nZSBhYUJCU3BhY2UgY2hhbmdlcyB0aGUgYm94IGRpbWVuc2lvbnNcclxuICAgIC8vIGFsc28gY2hhbmdlcyB0aGUgdHJhbnNmb3JtXHJcbiAgICAvLyB0aGVyZSBpcyBhbHNvIGEgc3dpdGNoIHRvIG1vdmUgYmFjayBtZXNoIHRvIExQUyBzcGFjZSBhdXRvbWF0aWNhbGx5XHJcbiAgICB0aGlzLl9hYUJCc3BhY2UgPSBhYWJiU3BhY2U7IC8vIG9yIExQUyAtPiBkaWZmZXJlbnQgdHJhbnNmb3JtcywgZXNwIGZvciB0aGUgZ2VvbWV0cnkvbWVzaFxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcclxuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IFNoYWRlcnNGcmFnbWVudDtcclxuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBTaGFkZXJzVmVydGV4O1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB1cGRhdGUgZGltZW5zaW9ucywgY2VudGVyLCBldGMuXHJcbiAgICAvLyBkZXBlbmRpbmcgb24gYWFCQlNwYWNlXHJcbiAgICB0aGlzLl9pbml0KCk7XHJcblxyXG4gICAgLy8gdXBkYXRlIG9iamVjdFxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXR0ZXJzL3NldHRlcnNcclxuXHJcbiAgZ2V0IHN0YWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xyXG4gIH1cclxuXHJcbiAgc2V0IHN0YWNrKHN0YWNrKSB7XHJcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvd1dpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XHJcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IHdpbmRvd1dpZHRoO1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgd2luZG93Q2VudGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NlbnRlcjtcclxuICB9XHJcblxyXG4gIHNldCB3aW5kb3dDZW50ZXIod2luZG93Q2VudGVyKSB7XHJcbiAgICB0aGlzLl93aW5kb3dDZW50ZXIgPSB3aW5kb3dDZW50ZXI7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICB9XHJcblxyXG4gIGdldCByZXNjYWxlU2xvcGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcclxuICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSA9IHJlc2NhbGVTbG9wZTtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVJbnRlcmNlcHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcclxuICB9XHJcblxyXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSByZXNjYWxlSW50ZXJjZXB0O1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaW52ZXJ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludmVydDtcclxuICB9XHJcblxyXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XHJcbiAgICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICB9XHJcblxyXG4gIGdldCBsdXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbHV0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGx1dChsdXQpIHtcclxuICAgIHRoaXMuX2x1dCA9IGx1dDtcclxuICB9XHJcblxyXG4gIGdldCBsdXRUZXh0dXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2x1dFRleHR1cmU7XHJcbiAgfVxyXG5cclxuICBzZXQgbHV0VGV4dHVyZShsdXRUZXh0dXJlKSB7XHJcbiAgICB0aGlzLl9sdXRUZXh0dXJlID0gbHV0VGV4dHVyZTtcclxuICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZ3NVbmlmb3JtcygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGludGVuc2l0eUF1dG8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZW5zaXR5QXV0bztcclxuICB9XHJcblxyXG4gIHNldCBpbnRlbnNpdHlBdXRvKGludGVuc2l0eUF1dG8pIHtcclxuICAgIHRoaXMuX2ludGVuc2l0eUF1dG8gPSBpbnRlbnNpdHlBdXRvO1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5ncygpO1xyXG4gICAgdGhpcy51cGRhdGVJbnRlbnNpdHlTZXR0aW5nc1VuaWZvcm1zKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaW50ZXJwb2xhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xyXG4gICAgdGhpcy5faW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgfVxyXG5cclxuICBzZXQgaW5kZXgoaW5kZXgpIHtcclxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIHNldCBwbGFuZVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl9wbGFuZVBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBwbGFuZVBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgcGxhbmVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XHJcbiAgICB0aGlzLl9wbGFuZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBsYW5lRGlyZWN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYW5lRGlyZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGhhbGZEaW1lbnNpb25zKGhhbGZEaW1lbnNpb25zKSB7XHJcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyA9IGhhbGZEaW1lbnNpb25zO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhhbGZEaW1lbnNpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hhbGZEaW1lbnNpb25zO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNlbnRlcihjZW50ZXIpIHtcclxuICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcclxuICB9XHJcblxyXG4gIGdldCBjZW50ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2VudGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IGFhYmJTcGFjZShhYWJiU3BhY2UpIHtcclxuICAgIHRoaXMuX2FhQkJzcGFjZSA9IGFhYmJTcGFjZTtcclxuICAgIHRoaXMuX2luaXQoKTtcclxuICB9XHJcblxyXG4gIGdldCBhYWJiU3BhY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWFCQnNwYWNlO1xyXG4gIH1cclxuXHJcbiAgc2V0IG1lc2gobWVzaCkge1xyXG4gICAgdGhpcy5fbWVzaCA9IG1lc2g7XHJcbiAgfVxyXG5cclxuICBnZXQgbWVzaCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZXNoO1xyXG4gIH1cclxuXHJcbiAgc2V0IGdlb21ldHJ5KGdlb21ldHJ5KSB7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGdlb21ldHJ5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5O1xyXG4gIH1cclxuXHJcbiAgc2V0IGNhbnZhc1dpZHRoKGNhbnZhc1dpZHRoKSB7XHJcbiAgICB0aGlzLl9jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc1dpZHRoLnZhbHVlID0gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FudmFzV2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzSGVpZ2h0KGNhbnZhc0hlaWdodCkge1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudUNhbnZhc0hlaWdodC52YWx1ZSA9IHRoaXMuX2NhbnZhc0hlaWdodDtcclxuICB9XHJcblxyXG4gIGdldCBjYW52YXNIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgc2V0IGJvcmRlckNvbG9yKGJvcmRlckNvbG9yKSB7XHJcbiAgICB0aGlzLl9ib3JkZXJDb2xvciA9IGJvcmRlckNvbG9yO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudUJvcmRlckNvbG9yLnZhbHVlID0gbmV3IFRIUkVFLkNvbG9yKGJvcmRlckNvbG9yKTtcclxuICB9XHJcblxyXG4gIGdldCBib3JkZXJDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9ib3JkZXJDb2xvcjtcclxuICB9XHJcblxyXG4gIF9pbml0KCkge1xyXG4gICAgaWYgKCF0aGlzLl9zdGFjayB8fCAhdGhpcy5fc3RhY2suX3ByZXBhcmVkIHx8ICF0aGlzLl9zdGFjay5fcGFja2VkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fYWFCQnNwYWNlID09PSAnSUpLJykge1xyXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyA9IHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLO1xyXG4gICAgICB0aGlzLl9jZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICB0aGlzLl9zdGFjay5oYWxmRGltZW5zaW9uc0lKSy54IC0gMC41LFxyXG4gICAgICAgIHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLLnkgLSAwLjUsXHJcbiAgICAgICAgdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSksueiAtIDAuNSk7XHJcbiAgICAgIHRoaXMuX3RvQUFCQiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBMUFNcclxuICAgICAgbGV0IGFhQkJveCA9IHRoaXMuX3N0YWNrLkFBQkJveCgpO1xyXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucyA9IGFhQkJveC5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XHJcbiAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YWNrLmNlbnRlckFBQkJveCgpO1xyXG4gICAgICB0aGlzLl90b0FBQkIgPSB0aGlzLl9zdGFjay5scHMyQUFCQjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIF9jcmVhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3N0YWNrIHx8ICF0aGlzLl9zdGFjay5wcmVwYXJlZCB8fCAhdGhpcy5fc3RhY2sucGFja2VkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZW5pZW5jZSB2YXJzXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzU2xpY2UoXHJcbiAgICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMsXHJcbiAgICAgICAgdGhpcy5fY2VudGVyLFxyXG4gICAgICAgIHRoaXMuX3BsYW5lUG9zaXRpb24sXHJcbiAgICAgICAgdGhpcy5fcGxhbmVEaXJlY3Rpb24sXHJcbiAgICAgICAgdGhpcy5fdG9BQUJCKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGUpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ2ludmFsaWQgc2xpY2UgZ2VvbWV0cnkgLSBleGl0aW5nLi4uJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlU2l6ZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnRleHR1cmVTaXplO1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51RGF0YURpbWVuc2lvbnMudmFsdWUgPSBbdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSksuel07XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVXb3JsZFRvRGF0YS52YWx1ZSA9IHRoaXMuX3N0YWNrLmxwczJJSks7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVOdW1iZXJPZkNoYW5uZWxzLnZhbHVlID0gdGhpcy5fc3RhY2subnVtYmVyT2ZDaGFubmVscztcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudVBpeGVsVHlwZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnBpeGVsVHlwZTtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudUJpdHNBbGxvY2F0ZWQudmFsdWUgPSB0aGlzLl9zdGFjay5iaXRzQWxsb2NhdGVkO1xyXG4gICAgICB0aGlzLl91bmlmb3Jtcy51UGFja2VkUGVyUGl4ZWwudmFsdWUgPSB0aGlzLl9zdGFjay5wYWNrZWRQZXJQaXhlbDtcclxuICAgICAgLy8gY29tcHV0ZSB0ZXh0dXJlIGlmIG1hdGVyaWFsIGV4aXN0XHJcbiAgICAgIHRoaXMuX3ByZXBhcmVUZXh0dXJlKCk7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlQ29udGFpbmVyLnZhbHVlID0gdGhpcy5fdGV4dHVyZXM7XHJcblxyXG4gICAgICB0aGlzLl9jcmVhdGVNYXRlcmlhbCh7XHJcbiAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXBkYXRlIGludGVuc2l0eSByZWxhdGVkIHN0dWZmXHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIG1lc2ghXHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIGlmICh0aGlzLl9hYUJCc3BhY2UgPT09ICdJSksnKSB7XHJcbiAgICAgIHRoaXMuX21lc2guYXBwbHlNYXRyaXgodGhpcy5fc3RhY2suaWprMkxQUyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcclxuXHJcbiAgICAvLyBhbmQgYWRkIGl0IVxyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVJbnRlbnNpdHlTZXR0aW5ncygpIHtcclxuICAgIC8vIGlmIGF1dG8sIGdldCBmcm9tIGZyYW1lIGluZGV4XHJcbiAgICBpZiAodGhpcy5faW50ZW5zaXR5QXV0bykge1xyXG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3dpbmRvd0NlbnRlcicpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUludGVuc2l0eVNldHRpbmcoJ3dpbmRvd1dpZHRoJyk7XHJcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygncmVzY2FsZVNsb3BlJyk7XHJcbiAgICAgIHRoaXMudXBkYXRlSW50ZW5zaXR5U2V0dGluZygncmVzY2FsZUludGVyY2VwdCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMuX3dpbmRvd0NlbnRlciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IHRoaXMuX3N0YWNrLndpbmRvd0NlbnRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX193aW5kb3dXaWR0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gdGhpcy5fc3RhY2sud2luZG93V2lkdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9yZXNjYWxlU2xvcGUgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9yZXNjYWxlU2xvcGUgPSB0aGlzLl9zdGFjay5yZXNjYWxlU2xvcGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCA9IHRoaXMuX3N0YWNrLnJlc2NhbGVJbnRlcmNlcHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmdzVW5pZm9ybXMoKSB7XHJcbiAgICAvLyBjb21wZW5zYXRlIGZvciB0aGUgb2Zmc2V0IHRvIG9ubHkgcGFzcyA+IDAgdmFsdWVzIHRvIHNoYWRlcnNcclxuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBpZiAodGhpcy5fc3RhY2suX21pbk1heFswXSA8IDApIHtcclxuICAgICAgb2Zmc2V0IC09IHRoaXMuX3N0YWNrLl9taW5NYXhbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHNsaWNlIHdpbmRvdyBjZW50ZXIgYW5kIHdpZHRoXHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UmVzY2FsZVNsb3BlSW50ZXJjZXB0LnZhbHVlID1cclxuICAgICAgW3RoaXMuX3Jlc2NhbGVTbG9wZSwgdGhpcy5fcmVzY2FsZUludGVyY2VwdF07XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51V2luZG93Q2VudGVyV2lkdGgudmFsdWUgPVxyXG4gICAgICBbb2Zmc2V0ICsgdGhpcy5fd2luZG93Q2VudGVyLCB0aGlzLl93aW5kb3dXaWR0aF07XHJcblxyXG4gICAgLy8gaW52ZXJ0XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51SW52ZXJ0LnZhbHVlID0gdGhpcy5faW52ZXJ0ID09PSB0cnVlID8gMSA6IDA7XHJcblxyXG4gICAgLy8gaW50ZXJwb2xhdGlvblxyXG4gICAgdGhpcy5fdW5pZm9ybXMudUludGVycG9sYXRpb24udmFsdWUgPSB0aGlzLl9pbnRlcnBvbGF0aW9uO1xyXG5cclxuICAgIC8vIGx1dFxyXG4gICAgaWYgKHRoaXMuX2x1dCA9PT0gJ25vbmUnKSB7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVMdXQudmFsdWUgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fdW5pZm9ybXMudUx1dC52YWx1ZSA9IDE7XHJcbiAgICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlTFVULnZhbHVlID0gdGhpcy5fbHV0VGV4dHVyZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVuc2l0eVNldHRpbmcoc2V0dGluZykge1xyXG4gICAgaWYgKHRoaXMuX3N0YWNrLmZyYW1lW3RoaXMuX2luZGV4XSAmJlxyXG4gICAgICAgIHRoaXMuX3N0YWNrLmZyYW1lW3RoaXMuX2luZGV4XVtzZXR0aW5nXSkge1xyXG4gICAgICB0aGlzWydfJyArIHNldHRpbmddID0gdGhpcy5fc3RhY2suZnJhbWVbdGhpcy5faW5kZXhdW3NldHRpbmddO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpc1snXycgKyBzZXR0aW5nXSA9IHRoaXMuX3N0YWNrW3NldHRpbmddO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZSgpIHtcclxuICAgIC8vIHVwZGF0ZSBzbGljZVxyXG4gICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgdGhpcy5yZW1vdmUodGhpcy5fbWVzaCk7XHJcbiAgICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZGlzcG9zZSB0aGUgdGV4dHVyZSFcclxuICAgICAgLy8gdGhpcy5fbWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcbiAgICAgIC8vIHRoaXMuX21lc2gubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jcmVhdGUoKTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICAvLyBSZWxlYXNlIG1lbW9yeVxyXG4gICAgZm9yKHZhciBqID0wOyBqPCB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICB0aGlzLl90ZXh0dXJlc1tqXS5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX3RleHR1cmVzW2pdID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcclxuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLl9zaGFkZXJzVmVydGV4ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IG51bGw7XHJcblxyXG4gICAgLy8gbWF0ZXJpYWwsIGdlb21ldHJ5IGFuZCBtZXNoXHJcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9tZXNoKTtcclxuICAgIHRoaXMuX21lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fbWVzaC5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX21lc2gubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwudmVydGV4U2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsLnVuaWZvcm1zID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9zdGFjayA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBjYXJ0ZXNpYW5FcXVhdGlvbigpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgZ2VvbWV0cnlcclxuICAgIGlmICghdGhpcy5fZ2VvbWV0cnkgfHxcclxuICAgICAgICF0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcyB8fFxyXG4gICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIDwgMykge1xyXG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcztcclxuICAgIGxldCBkYXRhVG9Xb3JsZCA9IHRoaXMuX3N0YWNrLmlqazJMUFM7XHJcbiAgICBsZXQgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMyh2ZXJ0aWNlc1swXS54LCB2ZXJ0aWNlc1swXS55LCB2ZXJ0aWNlc1swXS56KVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KGRhdGFUb1dvcmxkKTtcclxuICAgIGxldCBwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKHZlcnRpY2VzWzFdLngsIHZlcnRpY2VzWzFdLnksIHZlcnRpY2VzWzFdLnopXHJcbiAgICAgIC5hcHBseU1hdHJpeDQoZGF0YVRvV29ybGQpO1xyXG4gICAgbGV0IHAzID0gbmV3IFRIUkVFLlZlY3RvcjModmVydGljZXNbMl0ueCwgdmVydGljZXNbMl0ueSwgdmVydGljZXNbMl0ueilcclxuICAgICAgLmFwcGx5TWF0cml4NChkYXRhVG9Xb3JsZCk7XHJcbiAgICBsZXQgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0bGV0IHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIGxldCBub3JtYWwgPSB2MVxyXG4gICAgICAuc3ViVmVjdG9ycyhwMywgcDIpXHJcbiAgICAgIC5jcm9zcyh2Mi5zdWJWZWN0b3JzKHAxLCBwMikpXHJcbiAgICAgIC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoXHJcbiAgICAgIG5vcm1hbC54LFxyXG4gICAgICBub3JtYWwueSxcclxuICAgICAgbm9ybWFsLnosXHJcbiAgICAgIC0gbm9ybWFsLmRvdChwMSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKiAqIEltcG9ydHMgKioqL1xyXG5pbXBvcnQgSGVscGVyc0JvcmRlciBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuYm9yZGVyJztcclxuaW1wb3J0IEhlbHBlcnNCb3VuZGluZ0JveCBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuYm91bmRpbmdib3gnO1xyXG5pbXBvcnQgSGVscGVyc1NsaWNlIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5zbGljZSc7XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGVhc2lseSBkaXNwbGF5IGFuZCBpbnRlcmFjdCB3aXRoIGEgc3RhY2suPGJyPlxyXG4gKjxicj5cclxuICogRGVmYXVsdHM6PGJyPlxyXG4gKiAgIC0gb3JpZW50YXRpb246IDAgKGFjcXVpc2l0aW9uIGRpcmVjdGlvbik8YnI+XHJcbiAqICAgLSBpbmRleDogbWlkZGxlIHNsaWNlIGluIGFjcXVpc2l0aW9uIGRpcmVjdGlvbjxicj5cclxuICo8YnI+XHJcbiAqIEZlYXR1cmVzOjxicj5cclxuICogICAtIHNsaWNlIGZyb20gdGhlIHN0YWNrIChpbiBhbnkgZGlyZWN0aW9uKTxicj5cclxuICogICAtIHNsaWNlIGJvcmRlcjxicj5cclxuICogICAtIHN0YWNrIGJvdW5kaW5nIGJveDxicj5cclxuICo8YnI+XHJcbiAqIExpdmUgZGVtbyBhdDoge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZ2gvZ2V0L2xpYnJhcnkvcHVyZS9mbm5kc2MvYW1pL3RyZWUvbWFzdGVyL2xlc3NvbnMvMDEjcnVufExlc3NvbiAwMX1cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbGV0IHN0YWNrID0gbmV3IFZKUy5Nb2RlbHMuU3RhY2soKTtcclxuICogLi4uIC8vIHByZXBhcmUgdGhlIHN0YWNrXHJcbiAqXHJcbiAqIGxldCBzdGFja0hlbHBlciA9IG5ldyBWSlMuSGVscGVycy5TdGFjayhzdGFjayk7XHJcbiAqIHN0YWNrSGVscGVyLmJib3guY29sb3IgPSAweEY5RjlGOTtcclxuICogc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHhGOUY5Rjk7XHJcbiAqXHJcbiAqIGxldCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xyXG4gKiBzY2VuZS5hZGQoc3RhY2tIZWxwZXIpO1xyXG4gKlxyXG4gKiBAZXh0ZW5kcyBUSFJFRS5PYmplY3QzRFxyXG4gKlxyXG4gKiBAc2VlIG1vZHVsZTpoZWxwZXJzL2JvcmRlclxyXG4gKiBAc2VlIG1vZHVsZTpoZWxwZXJzL2JvdW5kaW5nYm94XHJcbiAqIEBzZWUgbW9kdWxlOmhlbHBlcnMvc2xpY2VcclxuICpcclxuICogQG1vZHVsZSBoZWxwZXJzL3N0YWNrXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWxwZXJzU3RhY2sgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XHJcbiAgY29uc3RydWN0b3Ioc3RhY2spIHtcclxuICAgIC8vXHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgICB0aGlzLl9iQm94ID0gbnVsbDtcclxuICAgIHRoaXMuX3NsaWNlID0gbnVsbDtcclxuICAgIHRoaXMuX2JvcmRlciA9IG51bGw7XHJcbiAgICB0aGlzLl9kdW1teSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAwO1xyXG4gICAgdGhpcy5faW5kZXggPSAwO1xyXG5cclxuICAgIHRoaXMuX3VuaWZvcm1zID0gbnVsbDtcclxuICAgIHRoaXMuX2F1dG9XaW5kb3dMZXZlbCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBmYWxzZTtcclxuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xyXG5cclxuICAgIHRoaXMuX2NhbnZhc1dpZHRoID0gMDtcclxuICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IDA7XHJcbiAgICB0aGlzLl9ib3JkZXJDb2xvciA9IG51bGw7XHJcblxyXG5cclxuICAgIC8vIHRoaXMuX2Fycm93ID0ge1xyXG4gICAgLy8gICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgLy8gICBjb2xvcjogMHhGRkYzMzYsXHJcbiAgICAvLyAgIGxlbmd0aDogMjAsXHJcbiAgICAvLyAgIG1hdGVyaWFsOiBudWxsLFxyXG4gICAgLy8gICBnZW9tZXRyeTogbnVsbCxcclxuICAgIC8vICAgbWVzaDogbnVsbFxyXG4gICAgLy8gfTtcclxuICAgIHRoaXMuX2NyZWF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICAvLyBQVUJMSUMgTUVUSE9EU1xyXG4gIC8vXHJcblxyXG4gIC8vXHJcbiAgLy8gU0VUVEVSUy9HRVRURVJTXHJcbiAgLy9cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHN0YWNrLlxyXG4gICAqXHJcbiAgICogQHR5cGUge01vZGVsc1N0YWNrfVxyXG4gICAqL1xyXG4gIGdldCBzdGFjaygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFjaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBzdGFjay5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtNb2RlbHNTdGFja31cclxuICAgKi9cclxuICBzZXQgc3RhY2soc3RhY2spIHtcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYm91bmRpbmcgYm94IGhlbHBlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtIZWxwZXJzQm91bmRpbmdCb3h9XHJcbiAgICovXHJcbiAgZ2V0IGJib3goKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYkJveDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzbGljZSBoZWxwZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7SGVscGVyc1NsaWNlfVxyXG4gICAqL1xyXG4gIGdldCBzbGljZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zbGljZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBib3JkZXIgaGVscGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0hlbHBlcnNTbGljZX1cclxuICAgKi9cclxuICBnZXQgYm9yZGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JvcmRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldC9nZXQgY3VycmVudCBzbGljZSBpbmRleC48YnI+XHJcbiAgICogU2V0cyBvdXRPZkJvdW5kcyBmbGFnIHRvIGtub3cgaWYgdGFyZ2V0IGluZGV4IGlzIGluL291dCBzdGFjayBib3VuZGluZyBib3guPGJyPlxyXG4gICAqIDxicj5cclxuICAgKiBJbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNsaWNlSGVscGVyIGluZGV4IGFuZCBwb3NpdGlvbi4gQWxzbyB1cGRhdGVzIHRoZVxyXG4gICAqIGJvcmRlckhlbHBlciB3aXRoIHRoZSB1cGRhdGVkIHNsaWNlSGVscGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgfVxyXG5cclxuICBzZXQgaW5kZXgoaW5kZXgpIHtcclxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSBzbGljZVxyXG4gICAgdGhpcy5fc2xpY2UuaW5kZXggPSBpbmRleDtcclxuICAgIGxldCBoYWxmRGltZW5zaW9ucyA9IHRoaXMuX3N0YWNrLmhhbGZEaW1lbnNpb25zSUpLO1xyXG4gICAgdGhpcy5fc2xpY2UucGxhbmVQb3NpdGlvbiA9IHRoaXMuX3ByZXBhcmVTbGljZVBvc2l0aW9uKGhhbGZEaW1lbnNpb25zLCB0aGlzLl9pbmRleCk7XHJcblxyXG4gICAgLy8gYWxzbyB1cGRhdGUgdGhlIGJvcmRlclxyXG4gICAgdGhpcy5fYm9yZGVyLmhlbHBlcnNTbGljZSA9IHRoaXMuX3NsaWNlO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBvdXJPZkJvdW5kcyBmbGFnXHJcbiAgICB0aGlzLl9pc0luZGV4T3V0T2ZCb3VuZHMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldC9nZXQgY3VycmVudCBzbGljZSBvcmllbnRhdGlvbi48YnI+XHJcbiAgICogVmFsdWVzOiA8YnI+XHJcbiAgICogICAtIDA6IGFjcXVpc2l0aW9uIGRpcmVjdGlvbiAoc2xpY2Ugbm9ybWFsIGlzIHpfY29zaW5lKTxicj5cclxuICAgKiAgIC0gMTogbmV4dCBkaXJlY3Rpb24gKHNsaWNlIG5vcm1hbCBpcyB4X2Nvc2luZSk8YnI+XHJcbiAgICogICAtIDI6IG5leHQgZGlyZWN0aW9uIChzbGljZSBub3JtYWwgaXMgeV9jb3NpbmUpPGJyPlxyXG4gICAqICAgLSBuOiBzZXQgb3JpZW50YXRpb24gdG8gMDxicj5cclxuICAgKiA8YnI+XHJcbiAgICogSW50ZXJuYWxseSB1cGRhdGVzIHRoZSBzbGljZUhlbHBlciBkaXJlY3Rpb24uIEFsc28gdXBkYXRlcyB0aGVcclxuICAgKiBib3JkZXJIZWxwZXIgd2l0aCB0aGUgdXBkYXRlZCBzbGljZUhlbHBlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IG9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgdGhpcy5fY29tcHV0ZU9yaWVudGF0aW9uTWF4SW5kZXgoKTtcclxuXHJcbiAgICB0aGlzLl9zbGljZS5wbGFuZURpcmVjdGlvbiA9IHRoaXMuX3ByZXBhcmVEaXJlY3Rpb24odGhpcy5fb3JpZW50YXRpb24pO1xyXG5cclxuICAgIC8vIGFsc28gdXBkYXRlIHRoZSBib3JkZXJcclxuICAgIHRoaXMuX2JvcmRlci5oZWxwZXJzU2xpY2UgPSB0aGlzLl9zbGljZTtcclxuICB9XHJcblxyXG4gIGdldCBvcmllbnRhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldC9nZXQgdGhlIG91dE9mQm91bmQgZmxhZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHNldCBvdXRPZkJvdW5kcyhvdXRPZkJvdW5kcykge1xyXG4gICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBvdXRPZkJvdW5kcztcclxuICB9XHJcblxyXG4gIGdldCBvdXRPZkJvdW5kcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9vdXRPZkJvdW5kcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldC9nZXQgdGhlIG9yaWVudGF0aW9uTWF4SW5kZXggZmxhZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHNldCBvcmllbnRhdGlvbk1heEluZGV4KG9yaWVudGF0aW9uTWF4SW5kZXgpIHtcclxuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSBvcmllbnRhdGlvbk1heEluZGV4O1xyXG4gIH1cclxuXHJcbiAgZ2V0IG9yaWVudGF0aW9uTWF4SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleDtcclxuICB9XHJcblxyXG4gIHNldCBjYW52YXNXaWR0aChjYW52YXNXaWR0aCkge1xyXG4gICAgdGhpcy5fY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcclxuICAgIHRoaXMuX3NsaWNlLmNhbnZhc1dpZHRoID0gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgY2FudmFzV2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzV2lkdGg7XHJcbiAgfVxyXG5cclxuICBzZXQgY2FudmFzSGVpZ2h0KGNhbnZhc0hlaWdodCkge1xyXG4gICAgdGhpcy5fY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xyXG4gICAgdGhpcy5fc2xpY2UuY2FudmFzSGVpZ2h0ID0gdGhpcy5fY2FudmFzSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW52YXNIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBzZXQgYm9yZGVyQ29sb3IoYm9yZGVyQ29sb3IpIHtcclxuICAgIHRoaXMuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XHJcbiAgICB0aGlzLl9ib3JkZXIuY29sb3IgPSBib3JkZXJDb2xvcjtcclxuICAgIHRoaXMuX3NsaWNlLmJvcmRlckNvbG9yID0gdGhpcy5fYm9yZGVyQ29sb3I7XHJcbiAgfVxyXG5cclxuICBnZXQgYm9yZGVyQ29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYm9yZGVyQ29sb3I7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xyXG4gIC8vXHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWwgc2V0dXAsIGluY2x1ZGluZyBzdGFjayBwcmVwYXJlLCBiYm94IHByZXBhcmUsIHNsaWNlIHByZXBhcmUgYW5kXHJcbiAgICogYm9yZGVyIHByZXBhcmUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9jcmVhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhY2spIHtcclxuICAgICAgLy8gcHJlcGFyZSBzdGhlIHN0YWNrIGludGVybmFsc1xyXG4gICAgICB0aGlzLl9wcmVwYXJlU3RhY2soKTtcclxuXHJcbiAgICAgIC8vIHByZXBhcmUgdmlzdWFsIG9iamVjdHNcclxuICAgICAgdGhpcy5fcHJlcGFyZUJCb3goKTtcclxuICAgICAgdGhpcy5fcHJlcGFyZVNsaWNlKCk7XHJcbiAgICAgIHRoaXMuX3ByZXBhcmVCb3JkZXIoKTtcclxuICAgICAgLy8gdG9kbzogQXJyb3dcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnbm8gc3RhY2sgdG8gYmUgcHJlcGFyZWQuLi4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jb21wdXRlT3JpZW50YXRpb25NYXhJbmRleCgpIHtcclxuICAgIGxldCBkaW1lbnNpb25zSUpLID0gdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSztcclxuICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSAwO1xyXG4gICAgc3dpdGNoICh0aGlzLl9vcmllbnRhdGlvbikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCA9IGRpbWVuc2lvbnNJSksueiAtIDE7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbk1heEluZGV4ID0gZGltZW5zaW9uc0lKSy54IC0gMTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uTWF4SW5kZXggPSBkaW1lbnNpb25zSUpLLnkgLSAxO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIGRvIG5vdGhpbmchXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHaXZlbiBvcmllbnRhdGlvbiwgY2hlY2sgaWYgaW5kZXggaXMgaW4vb3V0IG9mIGJvdW5kcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2lzSW5kZXhPdXRPZkJvdW5kcygpIHtcclxuICAgIHRoaXMuX2NvbXB1dGVPcmllbnRhdGlvbk1heEluZGV4KCk7XHJcbiAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fb3JpZW50YXRpb25NYXhJbmRleCB8fCB0aGlzLl9pbmRleCA8IDApIHtcclxuICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXBhcmUgYSBzdGFjayBmb3IgdmlzdWFsaXphdGlvbi4gKGltYWdlIHRvIHdvcmxkIHRyYW5zZm9ybSwgZnJhbWVzIG9yZGVyLFxyXG4gICAqIHBhY2sgZGF0YSBpbnRvIDggYml0cyB0ZXh0dXJlcywgZXRjLilcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3ByZXBhcmVTdGFjaygpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcsIGlmIG5vdCB0aHJvdyBhbiBlcnJvclxyXG4gICAgLy8gY29tcHV0ZSBpbWFnZSB0byB3b3JrZCB0cmFuc2Zvcm0sIG9yZGVyIGZyYW1lcywgZXRjLlxyXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wcmVwYXJlZCkge1xyXG4gICAgICB0aGlzLl9zdGFjay5wcmVwYXJlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBwYWNrIGRhdGEgaW50byA4IGJpdHMgcmdiYSB0ZXh0dXJlIGZvciB0aGUgc2hhZGVyXHJcbiAgICAvLyB0aGlzIG9uZSBjYW4gYmUgc2xvdy4uLlxyXG4gICAgaWYgKCF0aGlzLl9zdGFjay5wYWNrZWQpIHtcclxuICAgICAgdGhpcy5fc3RhY2sucGFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dXAgYm91bmRpbmcgYm94IGhlbHBlciBnaXZlbiBwcmVwYXJlZCBzdGFjayBhbmQgYWRkIGJvdW5kaW5nIGJveCBoZWxwZXJcclxuICAgKiB0byBzdGFjayBoZWxwZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcmVwYXJlQkJveCgpIHtcclxuICAgIHRoaXMuX2JCb3ggPSBuZXcgSGVscGVyc0JvdW5kaW5nQm94KHRoaXMuX3N0YWNrKTtcclxuICAgIHRoaXMuYWRkKHRoaXMuX2JCb3gpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dXAgYm9yZGVyIGhlbHBlciBnaXZlbiBzbGljZSBoZWxwZXIgYW5kIGFkZCBib3JkZXIgaGVscGVyXHJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZUJvcmRlcigpIHtcclxuICAgIHRoaXMuX2JvcmRlciA9IG5ldyBIZWxwZXJzQm9yZGVyKHRoaXMuX3NsaWNlKTtcclxuICAgIHRoaXMuYWRkKHRoaXMuX2JvcmRlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR1cCBzbGljZSBoZWxwZXIgZ2l2ZW4gcHJlcGFyZWQgc3RhY2sgaGVscGVyIGFuZCBhZGQgc2xpY2UgaGVscGVyXHJcbiAgICogdG8gc3RhY2sgaGVscGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZVNsaWNlKCkge1xyXG4gICAgbGV0IGhhbGZEaW1lbnNpb25zSUpLID0gdGhpcy5fc3RhY2suaGFsZkRpbWVuc2lvbnNJSks7XHJcbiAgICAvLyBjb21wdXRlIGluaXRpYWwgaW5kZXggZ2l2ZW4gb3JpZW50YXRpb25cclxuICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fcHJlcGFyZVNsaWNlSW5kZXgoaGFsZkRpbWVuc2lvbnNJSkspO1xyXG4gICAgLy8gY29tcHV0ZSBpbml0aWFsIHBvc2l0aW9uIGdpdmVuIG9yaWVudGF0aW9uIGFuZCBpbmRleFxyXG4gICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fcHJlcGFyZVNsaWNlUG9zaXRpb24oaGFsZkRpbWVuc2lvbnNJSkssIHRoaXMuX2luZGV4KTtcclxuICAgIC8vIGNvbXB1dGUgaW5pdGlhbCBkaXJlY3Rpb24gb3JpZW50YXRpb25cclxuICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLl9wcmVwYXJlRGlyZWN0aW9uKHRoaXMuX29yaWVudGF0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9zbGljZSA9IG5ldyBIZWxwZXJzU2xpY2UodGhpcy5fc3RhY2ssIHRoaXMuX2luZGV4LCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcclxuICAgIHRoaXMuYWRkKHRoaXMuX3NsaWNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgc2xpY2UgaW5kZXggZGVwZW5kaW5nIG9uIG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBpbmRpY2VzIC0gSW5kaWNlcyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZVNsaWNlSW5kZXgoaW5kaWNlcykge1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIHN3aXRjaCAodGhpcy5fb3JpZW50YXRpb24pIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRpY2VzLnopO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGljZXMueCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kaWNlcy55KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBkbyBub3RoaW5nIVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBzbGljZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gb3JpZW50YXRpb24uXHJcbiAgICogU2V0cyBpbmRleCBpbiBwcm9wZXIgbG9jYXRpb24gb2YgcmVmZXJlbmNlIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSByUG9zaXRpb24gLSBSZWZlcmVuY2UgcG9zaXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ3VycmVudCBpbmRleC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNsaWNlIGluZGV4IGFjY29yZGluZyB0byBjdXJyZW50IG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZVNsaWNlUG9zaXRpb24oclBvc2l0aW9uLCBpbmRleCkge1xyXG4gICAgbGV0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX29yaWVudGF0aW9uKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueCksXHJcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi55KSxcclxuICAgICAgICAgIGluZGV4KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLnkpLFxyXG4gICAgICAgICAgTWF0aC5mbG9vcihyUG9zaXRpb24ueikpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgICAgIE1hdGguZmxvb3IoclBvc2l0aW9uLngpLFxyXG4gICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICBNYXRoLmZsb29yKHJQb3NpdGlvbi56KSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyFcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgc2xpY2UgZGlyZWN0aW9uIGRlcGVuZGluZyBvbiBvcmllbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmllbnRhdGlvbiAtIFNsaWNlIG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1RIUkVFLlZlY3RvcjN9IFNsaWNlIGRpcmVjdGlvblxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJlcGFyZURpcmVjdGlvbihvcmllbnRhdGlvbikge1xyXG4gICAgbGV0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xyXG4gICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIGRvIG5vdGhpbmchXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgdGhlIHN0YWNrIGhlbHBlciBtZW1vcnkgaW5jbHVkaW5nIHRoZSBzbGljZSBtZW1vcnkuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMucmVtb3ZlKHRoaXMuX3NsaWNlKTtcclxuICAgIHRoaXMuX3NsaWNlLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX3NsaWNlID0gbnVsbDtcclxuICAgIHRoaXMuX2JCb3guZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5fYkJveCA9ICBudWxsO1xyXG4gICAgdGhpcy5fYm9yZGVyLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX2JvcmRlciA9ICBudWxsO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBTaGFkZXJzVW5pZm9ybSBmcm9tICcuLi9zaGFkZXJzL3NoYWRlcnMudnIudW5pZm9ybSc7XHJcbmltcG9ydCBTaGFkZXJzVmVydGV4IGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy52ci52ZXJ0ZXgnO1xyXG5pbXBvcnQgU2hhZGVyc0ZyYWdtZW50IGZyb20gJy4uL3NoYWRlcnMvc2hhZGVycy52ci5mcmFnbWVudCc7XHJcblxyXG5pbXBvcnQgSGVscGVyc01hdGVyaWFsTWl4aW4gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGVyaWFsLm1peGluJztcclxuXHJcblxyXG4vKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3ZvbHVtZXJlbmRlcmluZ1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlbHBlcnNWb2x1bWVSZW5kZXJpbmcgZXh0ZW5kcyBIZWxwZXJzTWF0ZXJpYWxNaXhpbihUSFJFRS5PYmplY3QzRCkge1xyXG4gIGNvbnN0cnVjdG9yKHN0YWNrKSB7XHJcbiAgICAvL1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xyXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcclxuICAgIHRoaXMuX3NoYWRlcnNGcmFnbWVudCA9IFNoYWRlcnNGcmFnbWVudDtcclxuICAgIHRoaXMuX3NoYWRlcnNWZXJ0ZXggPSBTaGFkZXJzVmVydGV4O1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2ludGVycG9sYXRpb24gPSAxOyAvLyBkZWZhdWx0IHRvIHRyaWxpbmVhciBpbnRlcnBvbGF0aW9uXHJcblxyXG4gICAgdGhpcy5fY3JlYXRlKCk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlKCkge1xyXG4gICAgdGhpcy5fcHJlcGFyZVN0YWNrKCk7XHJcbiAgICB0aGlzLl9wcmVwYXJlVGV4dHVyZSgpO1xyXG4gICAgdGhpcy5fcHJlcGFyZU1hdGVyaWFsKCk7XHJcbiAgICB0aGlzLl9wcmVwYXJlR2VvbWV0cnkoKTtcclxuXHJcbiAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gIH1cclxuXHJcbiAgX3ByZXBhcmVTdGFjaygpIHtcclxuICAgIGlmICghdGhpcy5fc3RhY2sucHJlcGFyZWQpIHtcclxuICAgICAgdGhpcy5fc3RhY2sucHJlcGFyZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fc3RhY2sucGFja2VkKSB7XHJcbiAgICAgIHRoaXMuX3N0YWNrLnBhY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9wcmVwYXJlTWF0ZXJpYWwoKSB7XHJcbiAgICAvLyBjb21wZW5zYXRlIGZvciB0aGUgb2Zmc2V0IHRvIG9ubHkgcGFzcyA+IDAgdmFsdWVzIHRvIHNoYWRlcnNcclxuICAgIC8vIG1vZGVscyA+IG1vZGVscy5zdGFjay5qcyA6IF9wYWNrVG84Qml0c1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBpZiAodGhpcy5fc3RhY2suX21pbk1heFswXSA8IDApIHtcclxuICAgICAgb2Zmc2V0ID0gdGhpcy5fc3RhY2suX21pbk1heFswXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1bmlmb3Jtc1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSBTaGFkZXJzVW5pZm9ybS51bmlmb3JtcygpO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVdvcmxkQkJveC52YWx1ZSA9IHRoaXMuX3N0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVUZXh0dXJlU2l6ZS52YWx1ZSA9IHRoaXMuX3N0YWNrLnRleHR1cmVTaXplO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVRleHR1cmVDb250YWluZXIudmFsdWUgPSB0aGlzLl90ZXh0dXJlcztcclxuICAgIHRoaXMuX3VuaWZvcm1zLnVXb3JsZFRvRGF0YS52YWx1ZSA9IHRoaXMuX3N0YWNrLmxwczJJSks7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51TnVtYmVyT2ZDaGFubmVscy52YWx1ZSA9IHRoaXMuX3N0YWNrLm51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UGl4ZWxUeXBlLnZhbHVlID0gdGhpcy5fc3RhY2sucGl4ZWxUeXBlO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudUJpdHNBbGxvY2F0ZWQudmFsdWUgPSB0aGlzLl9zdGFjay5iaXRzQWxsb2NhdGVkO1xyXG4gICAgdGhpcy5fdW5pZm9ybXMudVBhY2tlZFBlclBpeGVsLnZhbHVlID0gdGhpcy5fc3RhY2sucGFja2VkUGVyUGl4ZWw7XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51V2luZG93Q2VudGVyV2lkdGgudmFsdWUgPSBbb2Zmc2V0ICsgdGhpcy5fc3RhY2sud2luZG93Q2VudGVyLCB0aGlzLl9zdGFjay53aW5kb3dXaWR0aCAqIDAuOF07XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51UmVzY2FsZVNsb3BlSW50ZXJjZXB0LnZhbHVlID0gW3RoaXMuX3N0YWNrLnJlc2NhbGVTbG9wZSwgdGhpcy5fc3RhY2sucmVzY2FsZUludGVyY2VwdF07XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51RGF0YURpbWVuc2lvbnMudmFsdWUgPSBbdGhpcy5fc3RhY2suZGltZW5zaW9uc0lKSy54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5kaW1lbnNpb25zSUpLLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLmRpbWVuc2lvbnNJSksuel07XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XHJcblxyXG4gICAgdGhpcy5fY3JlYXRlTWF0ZXJpYWwoe1xyXG4gICAgICBzaWRlOiBUSFJFRS5Gcm9udFNpZGUsXHJcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfcHJlcGFyZUdlb21ldHJ5KCkge1xyXG4gICAgbGV0IHdvcmxkQkJveCA9IHRoaXMuX3N0YWNrLndvcmxkQm91bmRpbmdCb3goKTtcclxuICAgIGxldCBjZW50ZXJMUFMgPSB0aGlzLl9zdGFjay53b3JsZENlbnRlcigpO1xyXG5cclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxyXG4gICAgICB3b3JsZEJCb3hbMV0gLSB3b3JsZEJCb3hbMF0sXHJcbiAgICAgIHdvcmxkQkJveFszXSAtIHdvcmxkQkJveFsyXSxcclxuICAgICAgd29ybGRCQm94WzVdIC0gd29ybGRCQm94WzRdKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5LmFwcGx5TWF0cml4KG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKFxyXG4gICAgICBjZW50ZXJMUFMueCwgY2VudGVyTFBTLnksIGNlbnRlckxQUy56KSk7XHJcbiAgfVxyXG5cclxuICBnZXQgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdW5pZm9ybXM7XHJcbiAgfVxyXG5cclxuICBzZXQgdW5pZm9ybXModW5pZm9ybXMpIHtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgfVxyXG5cclxuICBnZXQgc3RhY2soKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhY2s7XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhY2soc3RhY2spIHtcclxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XHJcbiAgfVxyXG5cclxuICBnZXQgaW50ZXJwb2xhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IGludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xyXG4gICAgdGhpcy5faW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XHJcbiAgICB0aGlzLl91bmlmb3Jtcy51SW50ZXJwb2xhdGlvbi52YWx1ZSA9IHRoaXMuX2ludGVycG9sYXRpb247XHJcbiAgICB0aGlzLl91cGRhdGVNYXRlcmlhbCgpO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3gvaW50ZXJhY3RvclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJhY3RvciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgfVxyXG5cclxuICAvLyBwcml2YXRlIG1ldGhvZHNcclxuICBfY3JlYXRlKCkge1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZSgpIHtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBJbnRlcmFjdG9yIGZyb20gJy4vaGVscGVycy54LmludGVyYWN0b3InO1xyXG5pbXBvcnQgTWVzaCBmcm9tICcuL2hlbHBlcnMueC5tZXNoJztcclxuaW1wb3J0IFJlbmRlcmVyM0QgZnJvbSAnLi9oZWxwZXJzLngucmVuZGVyZXIzZCc7XHJcbmltcG9ydCBSZW5kZXJlcjJEIGZyb20gJy4vaGVscGVycy54LnJlbmRlcmVyMmQnO1xyXG5pbXBvcnQgVm9sdW1lIGZyb20gJy4vaGVscGVycy54LnZvbHVtZSc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBoZWxwZXJzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIEludGVyYWN0b3IsXHJcbiAgTWVzaCxcclxuICBSZW5kZXJlcjNELFxyXG4gIFJlbmRlcmVyMkQsXHJcbiAgVm9sdW1lLFxyXG59O1xyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3gvbWVzaFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuXzNqc1ZUS19sb2FkZXIgPSBuZXcgVEhSRUUuVlRLTG9hZGVyKCk7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsQ29sb3IgPSAweEU5MUU2MztcclxuICAgIHRoaXMuX1JBU3RvTFBTID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLl9tYXRlcmlhbENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gYWNjZXNzb3IgcHJvcGVydGllc1xyXG4gIGdldCBmaWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XHJcbiAgfVxyXG5cclxuICBzZXQgZmlsZShmbmFtZSkge1xyXG4gICAgdGhpcy5fZmlsZSA9IGZuYW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1hdGVyaWFsQ29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWxDb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBtYXRlcmlhbENvbG9yKGNvbG9yKSB7XHJcbiAgICB0aGlzLl9tYXRlcmlhbENvbG9yID0gY29sb3I7XHJcbiAgfVxyXG5cclxuICAvLyBsb2FkIGZ1bmN0aW9uXHJcbiAgbG9hZCgpIHtcclxuICAgIGlmICh0aGlzLmZpbGUpIHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0aGlzLl8zanNWVEtfbG9hZGVyLmxvYWQodGhpcy5maWxlLFxyXG4gICAgICAgICAgKGdlb21ldHJ5KSA9PiB7XHJcbiAgICAgICAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuICAgICAgICAgICAgICB0aGlzLl9tZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgICAgICAgICAgICB0aGlzLl9SQVN0b0xQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fUkFTdG9MUFMuc2V0KC0xLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgLTEsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5fbWVzaC5hcHBseU1hdHJpeCh0aGlzLl9SQVN0b0xQUyk7XHJcbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSBhbmQgcmV0dXJuIHRoZSBtZXNoXHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9tZXNoKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICAoKSA9PiB7fSxcclxuICAgICAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkbid0IGxvYWQgZmlsZTogJHt0aGlzLmZpbGV9LmAsXHJcbiAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe21lc3NhZ2U6IGBGaWxlIGlzIG5vdCBkZWZpbmVkOiAke3RoaXMuZmlsZX0uYH0pO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBoZWxwZXJzL3gvcmVuZGVyZXIyZFxyXG4gKi9cclxuaW1wb3J0IENhbWVyYXNPcnRob2dyYXBoaWMgZnJvbSAnLi4vLi4vY2FtZXJhcy9jYW1lcmFzLm9ydGhvZ3JhcGhpYyc7XHJcbmltcG9ydCBDb250cm9sc09ydGhvZ3JhcGhpYyBmcm9tICcuLi8uLi9jb250cm9scy9jb250cm9scy50cmFja2JhbGxvcnRobyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVySWQ9J3IyZCcsIG9yaWVudGF0aW9uPSdkZWZhdWx0Jykge1xyXG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcclxuICAgIHRoaXMuX2NhbWVyYSA9IG51bGw7XHJcbiAgICB0aGlzLl9jb250cm9scyA9IG51bGw7XHJcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgdGhpcy5fc2NlbmUgPSBudWxsO1xyXG4gICAgdGhpcy5fb2JqZWN0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpO1xyXG4gICAgdGhpcy5faW5pdENhbWVyYSgpO1xyXG4gICAgdGhpcy5faW5pdFNjZW5lKCk7XHJcbiAgICB0aGlzLl9pbml0Q29udHJvbHMoKTtcclxuXHJcbiAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnNcclxuICAgIHRoaXMuX29uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX29uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGFkZChvYmplY3QpIHtcclxuICAgIHRoaXMuX29iamVjdCA9IG9iamVjdDtcclxuICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9vYmplY3QpO1xyXG5cclxuICAgIHRoaXMuX3NldHVwQ2FtZXJhKHRoaXMuX29iamVjdC5zdGFjayk7XHJcbiAgICB0aGlzLl9vcmllbnRDYW1lcmEodGhpcy5fb2JqZWN0LCB0aGlzLl9vcmllbnRhdGlvbik7XHJcblxyXG4gICAgdGhpcy5fb2JqZWN0LmNhbnZhc1dpZHRoID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoO1xyXG4gICAgdGhpcy5fb2JqZWN0LmNhbnZhc0hlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ09uU2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIGZhbHNlKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdPblNjcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGFuaW1hdGUoKSB7XHJcbiAgICB0aGlzLl9jb250cm9scy51cGRhdGUoKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcclxuXHJcbiAgICAvLyByZXF1ZXN0IG5ldyBmcmFtZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG5cclxuICBfaW5pdFJlbmRlcmVyKGNvbnRhaW5lcklkKSB7XHJcbiAgICAvLyByZW5kZXJlclxyXG4gICAgdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySWQpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XHJcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U2l6ZSh0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDIxMjEyMSwgMSk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5kb21FbGVtZW50KTtcclxuICB9XHJcblxyXG4gIF9pbml0Q2FtZXJhKCkge1xyXG4gICAgdGhpcy5fY2FtZXJhID0gbmV3IENhbWVyYXNPcnRob2dyYXBoaWModGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIC8gLTIsXHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIDIsIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAyLFxyXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IC8gLTIsIDEsIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgX2luaXRTY2VuZSgpIHtcclxuICAgIHRoaXMuX3NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdENvbnRyb2xzKCkge1xyXG4gICAgLy8gY29udHJvbHNcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gbmV3IENvbnRyb2xzT3J0aG9ncmFwaGljKHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnN0YXRpY01vdmluZyA9IHRydWU7XHJcbiAgICB0aGlzLl9jb250cm9scy5ub1JvdGF0ZSA9IHRydWU7XHJcbiAgICB0aGlzLl9jYW1lcmEuY29udHJvbHMgPSB0aGlzLl9jb250cm9scztcclxuICB9XHJcblxyXG4gIF9zZXR1cENhbWVyYShzdGFjaykge1xyXG4gICAgLy8gc2V0IGNhbWVyYVxyXG4gICAgbGV0IHdvcmxkYmIgPSBzdGFjay53b3JsZEJvdW5kaW5nQm94KCk7XHJcbiAgICBsZXQgbHBzRGltcyA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICB3b3JsZGJiWzFdIC0gd29ybGRiYlswXSxcclxuICAgICAgd29ybGRiYlszXSAtIHdvcmxkYmJbMl0sXHJcbiAgICAgIHdvcmxkYmJbNV0gLSB3b3JsZGJiWzRdXHJcbiAgICApO1xyXG5cclxuICAgIC8vIGJveDoge2hhbGZEaW1lbnNpb25zLCBjZW50ZXJ9XHJcbiAgICBsZXQgYm94ID0ge1xyXG4gICAgICBjZW50ZXI6IHN0YWNrLndvcmxkQ2VudGVyKCkuY2xvbmUoKSxcclxuICAgICAgaGFsZkRpbWVuc2lvbnM6IG5ldyBUSFJFRS5WZWN0b3IzKGxwc0RpbXMueCArIDEwLCBscHNEaW1zLnkgKyAxMCxcclxuICAgICAgICBscHNEaW1zLnogKyAxMCksXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGluaXQgYW5kIHpvb21cclxuICAgIGxldCBjYW52YXMgPSB7XHJcbiAgICAgICAgd2lkdGg6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQsXHJcbiAgICAgIH07XHJcblxyXG4gICAgdGhpcy5fY2FtZXJhLmRpcmVjdGlvbnMgPSBbc3RhY2sueENvc2luZSwgc3RhY2sueUNvc2luZSwgc3RhY2suekNvc2luZV07XHJcbiAgICB0aGlzLl9jYW1lcmEuYm94ID0gYm94O1xyXG4gICAgdGhpcy5fY2FtZXJhLmNhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuX2NhbWVyYS51cGRhdGUoKTtcclxuICAgIHRoaXMuX2NhbWVyYS5maXRCb3goMik7XHJcbiAgfVxyXG5cclxuICBfb3JpZW50Q2FtZXJhKHRhcmdldCwgb3JpZW50YXRpb249J2RlZmF1bHQnKSB7XHJcbiAgICAgIHRoaXMuX2NhbWVyYS5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICB0aGlzLl9jYW1lcmEudXBkYXRlKCk7XHJcbiAgICAgIHRoaXMuX2NhbWVyYS5maXRCb3goMik7XHJcbiAgICAgIHRhcmdldC5vcmllbnRhdGlvbiA9IHRoaXMuX2NhbWVyYS5zdGFja09yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgX29uV2luZG93UmVzaXplKCkge1xyXG4gICAgICB0aGlzLl9jYW1lcmEuY2FudmFzID0ge1xyXG4gICAgICAgIHdpZHRoOiB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0LFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9jYW1lcmEuZml0Qm94KDIpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgdGhpcy5fb2JqZWN0LmNhbnZhc1dpZHRoID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoO1xyXG4gICAgICB0aGlzLl9vYmplY3QuY2FudmFzSGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIF9vblNjcm9sbChldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmRlbHRhID4gMCkge1xyXG4gICAgICBpZiAodGhpcy5fb2JqZWN0LmluZGV4ID49IHRoaXMuX29iamVjdC5vcmllbnRhdGlvbk1heEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX29iamVjdC5pbmRleCArPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRoaXMuX29iamVjdC5pbmRleCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX29iamVjdC5pbmRleCAtPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIEBtb2R1bGUgaGVscGVycy94L3JlbmRlcmVyM2RcclxuICovXHJcbmltcG9ydCBDb250cm9sc1RyYWNrYmFsbCBmcm9tICcuLi8uLi9jb250cm9scy9jb250cm9scy50cmFja2JhbGwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcklkPSdyM2QnKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fY2FtZXJhID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gbnVsbDtcclxuICAgIHRoaXMuX3NjZW5lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpO1xyXG4gICAgdGhpcy5faW5pdENhbWVyYSgpO1xyXG4gICAgdGhpcy5faW5pdFNjZW5lKCk7XHJcbiAgICB0aGlzLl9pbml0Q29udHJvbHMoKTtcclxuXHJcbiAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnNcclxuICAgIHRoaXMuX29uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIHNldCBjb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIGFkZChvYmopIHtcclxuICAgIHRoaXMuX3NjZW5lLmFkZChvYmopO1xyXG4gIH1cclxuXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBjZW50ZXIod29ybGRQb3NpdGlvbikge1xyXG4gICAgLy8gdXBkYXRlIGNhbXJlYSdzIGFuZCBjb250cm9sJ3MgdGFyZ2V0XHJcbiAgICB0aGlzLl9jYW1lcmEubG9va0F0KHdvcmxkUG9zaXRpb24ueCwgd29ybGRQb3NpdGlvbi55LCB3b3JsZFBvc2l0aW9uLnopO1xyXG4gICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLnRhcmdldC5zZXQod29ybGRQb3NpdGlvbi54LCB3b3JsZFBvc2l0aW9uLnksXHJcbiAgICAgIHdvcmxkUG9zaXRpb24ueik7XHJcbiAgfVxyXG5cclxuICBhbmltYXRlKCkge1xyXG4gICAgdGhpcy5fY29udHJvbHMudXBkYXRlKCk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXIodGhpcy5fc2NlbmUsIHRoaXMuX2NhbWVyYSk7XHJcblxyXG4gICAgLy8gcmVxdWVzdCBuZXcgZnJhbWVcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvLyBwcml2YXRlIG1ldGhvZHNcclxuXHJcbiAgX29uV2luZG93UmVzaXplKCkge1xyXG4gICAgdGhpcy5fY2FtZXJhLmFzcGVjdCA9XHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQ7XHJcbiAgICB0aGlzLl9jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFNpemUodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgICB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIF9pbml0UmVuZGVyZXIoY29udGFpbmVySWQpIHtcclxuICAgIC8vIHJlbmRlcmVyXHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJZCk7XHJcbiAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcclxuICAgICAgYW50aWFsaWFzOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuICAgICAgdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4NDI0MjQyLCAxKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgX2luaXRDYW1lcmEoKSB7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsXHJcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQsIDEsIDEwMDAwMDAwKTtcclxuICAgIHRoaXMuX2NhbWVyYS5wb3NpdGlvbi54ID0gMjUwO1xyXG4gICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnkgPSAyNTA7XHJcbiAgICB0aGlzLl9jYW1lcmEucG9zaXRpb24ueiA9IDI1MDtcclxuICB9XHJcblxyXG4gIF9pbml0U2NlbmUoKSB7XHJcbiAgICAvLyBhZGQgc29tZSBsaWdodHMgdG8gdGhlIHNjZW5lIGJ5IGRlZmF1bHRcclxuICAgIHRoaXMuX3NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG4gICAgLy8gYW1iaWVudFxyXG4gICAgdGhpcy5fc2NlbmUuYWRkKG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHgzNTM1MzUpKTtcclxuXHJcbiAgICAvLyBkaXJlY3Rpb25hbCAxXHJcbiAgICBsZXQgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcclxuICAgIGRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24uc2V0KDIwMCwgMjAwLCAxMDAwKS5ub3JtYWxpemUoKTtcclxuICAgIHRoaXMuX3NjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcclxuXHJcbiAgICAvLyBkaXJlY3Rpb25hbCAyXHJcbiAgICBsZXQgZGlyZWN0aW9uYWxMaWdodDIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGZmZmZmZiwgMSk7XHJcbiAgICBkaXJlY3Rpb25hbExpZ2h0Mi5wb3NpdGlvbi5zZXQoLTIwMCwgLTIwMCwgLTEwMDApLm5vcm1hbGl6ZSgpO1xyXG4gICAgdGhpcy5fc2NlbmUuYWRkKGRpcmVjdGlvbmFsTGlnaHQyKTtcclxuICB9XHJcblxyXG4gIF9pbml0Q29udHJvbHMoKSB7XHJcbiAgICAvLyBjb250cm9sc1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHNUcmFja2JhbGwodGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fY29udHJvbHMucm90YXRlU3BlZWQgPSAxLjQ7XHJcbiAgICB0aGlzLl9jb250cm9scy56b29tU3BlZWQgPSAxLjI7XHJcbiAgICB0aGlzLl9jb250cm9scy5wYW5TcGVlZCA9IDAuODtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGhlbHBlcnMveC92b2x1bWVcclxuICovXHJcblxyXG5pbXBvcnQgSGVscGVyc1N0YWNrIGZyb20gJy4uL2hlbHBlcnMuc3RhY2snO1xyXG5pbXBvcnQgTG9hZGVyc1ZvbHVtZSBmcm9tICcuLi8uLi9sb2FkZXJzL2xvYWRlcnMudm9sdW1lJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fZmlsZSA9IG51bGw7XHJcbiAgICB0aGlzLl9wcm9ncmVzc2JhckNvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLl9zdGFjayA9IG51bGw7XHJcbiAgICB0aGlzLl9jZW50ZXJMUFMgPSBudWxsO1xyXG4gICAgdGhpcy5feFNsaWNlID0gbnVsbDtcclxuICAgIHRoaXMuX3lTbGljZSA9IG51bGw7XHJcbiAgICB0aGlzLl96U2xpY2UgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gYWNjZXNzb3IgcHJvcGVydGllc1xyXG4gIGdldCBmaWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbGU7XHJcbiAgfVxyXG5cclxuICBzZXQgZmlsZShmbmFtZSkge1xyXG4gICAgdGhpcy5fZmlsZSA9IGZuYW1lO1xyXG4gIH1cclxuXHJcbiAgc2V0IHByb2dyZXNzYmFyQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgdGhpcy5fcHJvZ3Jlc3NiYXJDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICBnZXQgY2VudGVyTFBTKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NlbnRlckxQUztcclxuICB9XHJcblxyXG4gIGdldCBzdGFjaygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFjaztcclxuICB9XHJcblxyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIF9jcmVhdGVTbGljZShvcmllbnRhdGlvbikge1xyXG4gICAgaWYgKHRoaXMuX3N0YWNrKSB7XHJcbiAgICAgIGNvbnN0IHN0YWNrSGVscGVyID0gbmV3IEhlbHBlcnNTdGFjayh0aGlzLl9zdGFjayk7XHJcbiAgICAgIHN0YWNrSGVscGVyLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcblxyXG4gICAgICBpZiAob3JpZW50YXRpb249PT0wKSB7XHJcbiAgICAgICAgc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHhGNDQzMzY7XHJcbiAgICAgICAgdGhpcy5feFNsaWNlID0gc3RhY2tIZWxwZXI7XHJcbiAgICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb249PT0xKSB7XHJcbiAgICAgICAgc3RhY2tIZWxwZXIuYmJveC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHg0Q0FGNTA7XHJcbiAgICAgICAgdGhpcy5feVNsaWNlID0gc3RhY2tIZWxwZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhY2tIZWxwZXIuYmJveC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgc3RhY2tIZWxwZXIuYm9yZGVyLmNvbG9yID0gMHgyMTk2RjM7XHJcbiAgICAgICAgdGhpcy5felNsaWNlID0gc3RhY2tIZWxwZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2NlbnRlckxQUyA9IHN0YWNrSGVscGVyLnN0YWNrLndvcmxkQ2VudGVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBwdWJsaWMgbWV0aG9kc1xyXG4gIGxvYWQoKSB7XHJcbiAgICBpZiAodGhpcy5maWxlKSB7XHJcbiAgICAgIC8vIGluc3RhbnRpYXRlIHRoZSBsb2FkZXJcclxuICAgICAgLy8gaXQgbG9hZHMgYW5kIHBhcnNlcyB0aGUgZGljb20gaW1hZ2VcclxuICAgICAgY29uc3QgbG9hZGVyID0gbmV3IExvYWRlcnNWb2x1bWUodGhpcy5fcHJvZ3Jlc3NiYXJDb250YWluZXIpO1xyXG4gICAgICByZXR1cm4gbG9hZGVyLmxvYWQodGhpcy5maWxlKS50aGVuKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGxvYWRlci5kYXRhLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWplY3Qoe21lc3NhZ2U6IGBObyBkYXRhIGxvYWRlZDogJHtsb2FkZXIuZGF0YX0uYH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdGhyZWUgc2xpY2VzIHdoZW4gYWxsIGZpbGVzIGhhdmUgYmVlbiBsb2FkZWRcclxuICAgICAgICAgIGNvbnN0IHNlcmllcyA9IGxvYWRlci5kYXRhWzBdLm1lcmdlU2VyaWVzKGxvYWRlci5kYXRhKVswXTtcclxuICAgICAgICAgIGxvYWRlci5mcmVlKCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fc3RhY2sgPSBzZXJpZXMuc3RhY2tbMF07XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTbGljZSgwKTtcclxuICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX3hTbGljZSk7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTbGljZSgxKTtcclxuICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX3lTbGljZSk7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTbGljZSgyKTtcclxuICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX3pTbGljZSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgbG9hZGVyLmZyZWUoKTtcclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1NvbWV0aGluZyB3ZW50IHdyb25nIGxvYWRpbmcgdGhlIHZvbHVtZS4uLicpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7bWVzc2FnZTogYEZpbGUgbm90IGRlZmluZWQ6ICR7dGhpcy5maWxlfS5gfSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKiBJbXBvcnRzICoqL1xyXG5pbXBvcnQgSGVscGVyc1Byb2dyZXNzQmFyIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5wcm9ncmVzc2Jhcic7XHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcclxuXHJcblxyXG4vKipcclxuICpcclxuICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgdG8gbG9hZCBhIERJQ09NIGltYWdlLiBVc2UgbG9hZGluZyBtYW5hZ2VyIGZvclxyXG4gKiBhZHZhbmNlZCB1c2FnZSwgc3VjaCBhcyBtdWx0aXBsZSBmaWxlcyBoYW5kbGluZy5cclxuICpcclxuICogRGVtbzoge0BsaW5rIGh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby92anMjbG9hZGVyX2RpY29tfVxyXG4gKlxyXG4gKiBAbW9kdWxlIGxvYWRlcnMvYmFzZVxyXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICogQGV4YW1wbGVcclxuICogdmFyIGZpbGVzID0gWycvZGF0YS9kY20vZnJ1aXQnXTtcclxuICpcclxuICogLy8gSW5zdGFudGlhdGUgYSBkaWNvbSBsb2FkZXJcclxuICogdmFyIGxEaWNvbW9hZGVyID0gbmV3IGRpY29tKCk7XHJcbiAqXHJcbiAqIC8vIGxvYWQgYSByZXNvdXJjZVxyXG4gKiBsb2FkZXIubG9hZChcclxuICogICAvLyByZXNvdXJjZSBVUkxcclxuICogICBmaWxlc1swXSxcclxuICogICAvLyBGdW5jdGlvbiB3aGVuIHJlc291cmNlIGlzIGxvYWRlZFxyXG4gKiAgIGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gKiAgICAgLy9zY2VuZS5hZGQoIG9iamVjdCApO1xyXG4gKiAgICAgd2luZG93LmNvbnNvbGUubG9nKG9iamVjdCk7XHJcbiAqICAgfVxyXG4gKiApO1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGVyc0Jhc2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIExvYWRlci5cclxuICAgKiBAcGFyYW0ge2RvbX0gY29udGFpbmVyIC0gVGhlIGRvbSBjb250YWluZXIgb2YgbG9hZGVyLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBQcm9ncmVzc0JhciAtIFRoZSBwcm9ncmVzc2JhciBvZiBsb2FkZXIuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyID0gbnVsbCwgUHJvZ3Jlc3NCYXIgPSBIZWxwZXJzUHJvZ3Jlc3NCYXIpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9sb2FkZWQgPSAtMTtcclxuICAgIHRoaXMuX3RvdGFsTG9hZGVkID0gLTE7XHJcbiAgICB0aGlzLl9wYXJzZWQgPSAtMTtcclxuICAgIHRoaXMuX3RvdGFsUGFyc2VkID0gLTE7XHJcblxyXG4gICAgdGhpcy5fZGF0YSA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuX3Byb2dyZXNzQmFyID0gbnVsbDtcclxuICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgUHJvZ3Jlc3NCYXIpIHtcclxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIgPSBuZXcgUHJvZ3Jlc3NCYXIodGhpcy5fY29udGFpbmVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGZyZWUgdGhlIHJlZmVyZW5jZS5cclxuICAgKi9cclxuICBmcmVlKCkge1xyXG4gICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcclxuICAgIC8vIHRoaXMuX2hlbHBlcnNQcm9ncmVzc0JhciA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLmZyZWUoKTtcclxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbG9hZCB0aGUgcmVzb3VyY2UgYnkgdXJsLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSByZXNvdXJjZSB1cmwuXHJcbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cclxuICAgKi9cclxuICBmZXRjaCh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwpO1xyXG4gICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdHJ1ZTtcclxuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXN0YXJ0JyBldmVudFxyXG4gICAgICAgIHRoaXMuZW1pdCgnZmV0Y2gtc3RhcnQnLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgdGhpcy5fbG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgdGhpcy5fdG90YWxMb2FkZWQgPSBldmVudC50b3RhbDtcclxuXHJcbiAgICAgICAgICAvLyB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZXZlbnRlciBzZXQgdXBcclxuICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc0Jhcikge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUodGhpcy5fbG9hZGVkLCB0aGlzLl90b3RhbExvYWRlZCxcclxuICAgICAgICAgICAgICAnbG9hZCcpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCBidWZmZXIgPSByZXF1ZXN0LnJlc3BvbnNlO1xyXG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0ge1xyXG4gICAgICAgICAgICB1cmwsXHJcbiAgICAgICAgICAgIGJ1ZmZlcixcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gZW1pdCAnZmV0Y2gtc3VjY2VzcycgZXZlbnRcclxuICAgICAgICAgIHRoaXMuZW1pdCgnZmV0Y2gtc3VjY2VzcycsIHtcclxuICAgICAgICAgICAgZmlsZTogdXJsLFxyXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICB0b3RhbExvYWRlZDogZXZlbnQudG90YWwsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLWVycm9yJyBldmVudFxyXG4gICAgICAgIHRoaXMuZW1pdCgnZmV0Y2gtZXJyb3InLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXN0YXJ0JyBldmVudFxyXG4gICAgICAgIHRoaXMuZW1pdCgnZmV0Y2gtYWJvcnQnLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXNUZXh0KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGVtaXQgJ2ZldGNoLXRpbWVvdXQnIGV2ZW50XHJcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC10aW1lb3V0Jywge1xyXG4gICAgICAgICAgZmlsZTogdXJsLFxyXG4gICAgICAgICAgdGltZTogbmV3IERhdGUoKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVqZWN0KHJlcXVlc3Quc3RhdHVzVGV4dCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLl9sb2FkZWQgPSBldmVudC5sb2FkZWQ7XHJcbiAgICAgICAgdGhpcy5fdG90YWxMb2FkZWQgPSBldmVudC50b3RhbDtcclxuICAgICAgICAvLyBlbWl0ICdmZXRjaC1wcm9ncmVzcycgZXZlbnRcclxuICAgICAgICB0aGlzLmVtaXQoJ2ZldGNoLXByb2dyZXNzJywge1xyXG4gICAgICAgICAgZmlsZTogdXJsLFxyXG4gICAgICAgICAgdG90YWw6IGV2ZW50LnRvdGFsLFxyXG4gICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxyXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc0Jhcikge1xyXG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIudXBkYXRlKHRoaXMuX2xvYWRlZCwgdGhpcy5fdG90YWxMb2FkZWQsXHJcbiAgICAgICAgICAgICdsb2FkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAvLyBlbWl0ICdmZXRjaC1lbmQnIGV2ZW50XHJcbiAgICAgICAgdGhpcy5lbWl0KCdmZXRjaC1lbmQnLCB7XHJcbiAgICAgICAgICBmaWxlOiB1cmwsXHJcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGp1c3QgdXNlIG9ubG9hZCB3aGVuIHN1Y2Nlc3MgYW5kIG9uZXJyb3Igd2hlbiBmYWlsdXJlLCBldGMgb25hYm9ydFxyXG4gICAgICAgIC8vIHJlamVjdChyZXF1ZXN0LnN0YXR1c1RleHQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHBhcnNlIHRoZSBkYXRhIGxvYWRlZFxyXG4gICAqIFNIT1VMRCBCRSBpbXBsZW1lbnRkIGJ5IGRldGFpbCBsb2FkZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIC0gbG9hZGVkIGRhdGEuXHJcbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZS5cclxuICAgKi9cclxuICBwYXJzZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlZmF1bHQgbG9hZCBzZXF1ZW5jZSBncm91cCBwcm9taXNlLlxyXG4gICAqIEBwYXJhbSB7YXJyYXl9IHVybCAtIHJlc291cmNlIHVybC5cclxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxyXG4gICAqL1xyXG4gIGxvYWRTZXF1ZW5jZUdyb3VwKHVybCkge1xyXG4gICAgY29uc3QgZmV0Y2hTZXF1ZW5jZSA9IFtdO1xyXG5cclxuICAgIHVybC5mb3JFYWNoKChmaWxlKSA9PiB7XHJcbiAgICAgIGZldGNoU2VxdWVuY2UucHVzaChcclxuICAgICAgICB0aGlzLmZldGNoKGZpbGUpXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmV0Y2hTZXF1ZW5jZSlcclxuICAgICAgLnRoZW4oKHJhd2RhdGEpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShyYXdkYXRhKTtcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnb29wcy4uLiBzb21ldGhpbmcgd2VudCB3cm9uZy4uLicpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZGVmYXVsdCBsb2FkIHNlcXVlbmNlIHByb21pc2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHJlc291cmNlIHVybC5cclxuICAgKiBAcmV0dXJuIHtwcm9taXNlfSBwcm9taXNlLlxyXG4gICAqL1xyXG4gIGxvYWRTZXF1ZW5jZSh1cmwpIHtcclxuICAgIHJldHVybiB0aGlzLmZldGNoKHVybClcclxuICAgICAgLnRoZW4oKHJhd2RhdGEpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShyYXdkYXRhKTtcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnb29wcy4uLiBzb21ldGhpbmcgd2VudCB3cm9uZy4uLicpO1xyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbG9hZCB0aGUgZGF0YSBieSB1cmwodXJscylcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdXJsIC0gcmVzb3VyY2UgdXJsLlxyXG4gICAqIEByZXR1cm4ge3Byb21pc2V9IHByb21pc2VcclxuICAgKi9cclxuICBsb2FkKHVybCkge1xyXG4gICAgLy8gaWYgd2UgbG9hZCBhIHNpbmdsZSBmaWxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodXJsKSkge1xyXG4gICAgICB1cmwgPSBbdXJsXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0ICdsb2FkLXN0YXJ0JyBldmVudFxyXG4gICAgdGhpcy5lbWl0KCdsb2FkLXN0YXJ0Jywge1xyXG4gICAgICBmaWxlczogdXJsLFxyXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbG9hZFNlcXVlbmNlcyA9IFtdO1xyXG4gICAgdXJsLmZvckVhY2goKGZpbGUpID0+IHtcclxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGUpKSB7XHJcbiAgICAgICAgbG9hZFNlcXVlbmNlcy5wdXNoKFxyXG4gICAgICAgICAgdGhpcy5sb2FkU2VxdWVuY2UoZmlsZSlcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvYWRTZXF1ZW5jZXMucHVzaChcclxuICAgICAgICAgIHRoaXMubG9hZFNlcXVlbmNlR3JvdXAoZmlsZSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkU2VxdWVuY2VzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBkYXRhXHJcbiAgICogQHBhcmFtIHthcnJheX0gZGF0YVxyXG4gICAqL1xyXG4gIHNldCBkYXRhKGRhdGEpIHtcclxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGRhdGFcclxuICAgKiBAcmV0dXJuIHthcnJheX0gZGF0YSBsb2FkZWRcclxuICAgKi9cclxuICBnZXQgZGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IFZvbHVtZSBmcm9tICcuL2xvYWRlcnMudm9sdW1lJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGxvYWRlcnNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgVm9sdW1lLFxyXG59O1xyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuY29uc3QgUEFLTyA9IHJlcXVpcmUoJ3Bha28nKTtcclxuXHJcbmltcG9ydCBMb2FkZXJzQmFzZSBmcm9tICcuL2xvYWRlcnMuYmFzZSc7XHJcbmltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi4vY29yZS9jb3JlLnV0aWxzJztcclxuaW1wb3J0IE1vZGVsc1NlcmllcyBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLnNlcmllcyc7XHJcbmltcG9ydCBNb2RlbHNTdGFjayBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLnN0YWNrJztcclxuaW1wb3J0IE1vZGVsc0ZyYW1lIGZyb20gJy4uL21vZGVscy9tb2RlbHMuZnJhbWUnO1xyXG5pbXBvcnQgUGFyc2Vyc0RpY29tIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5kaWNvbSc7XHJcbmltcG9ydCBQYXJzZXJzTWhkIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5taGQnO1xyXG5pbXBvcnQgUGFyc2Vyc05pZnRpIGZyb20gJy4uL3BhcnNlcnMvcGFyc2Vycy5uaWZ0aSc7XHJcbmltcG9ydCBQYXJzZXJzTnJyZCBmcm9tICcuLi9wYXJzZXJzL3BhcnNlcnMubnJyZCc7XHJcblxyXG4vKipcclxuICpcclxuICogSXQgaXMgdHlwaWNhbGx5IHVzZWQgdG8gbG9hZCBhIERJQ09NIGltYWdlLiBVc2UgbG9hZGluZyBtYW5hZ2VyIGZvclxyXG4gKiBhZHZhbmNlZCB1c2FnZSwgc3VjaCBhcyBtdWx0aXBsZSBmaWxlcyBoYW5kbGluZy5cclxuICpcclxuICogRGVtbzoge0BsaW5rIGh0dHBzOi8vZm5uZHNjLmdpdGh1Yi5pby92anMjbG9hZGVyX2RpY29tfVxyXG4gKlxyXG4gKiBAbW9kdWxlIGxvYWRlcnMvdm9sdW1lc1xyXG4gKiBAZXh0ZW5kcyBMb2FkZXJzQmFzZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZmlsZXMgPSBbJy9kYXRhL2RjbS9mcnVpdCddO1xyXG4gKlxyXG4gKiAvLyBJbnN0YW50aWF0ZSBhIGRpY29tIGxvYWRlclxyXG4gKiB2YXIgbERpY29tb2FkZXIgPSBuZXcgZGljb20oKTtcclxuICpcclxuICogLy8gbG9hZCBhIHJlc291cmNlXHJcbiAqIGxvYWRlci5sb2FkKFxyXG4gKiAgIC8vIHJlc291cmNlIFVSTFxyXG4gKiAgIGZpbGVzWzBdLFxyXG4gKiAgIC8vIEZ1bmN0aW9uIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkXHJcbiAqICAgZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAqICAgICAvL3NjZW5lLmFkZCggb2JqZWN0ICk7XHJcbiAqICAgICB3aW5kb3cuY29uc29sZS5sb2cob2JqZWN0KTtcclxuICogICB9XHJcbiAqICk7XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2FkZXJzVm9sdW1lcyBleHRlbmRzIExvYWRlcnNCYXNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgcmVzcG9uc2UuXHJcbiAgICogcmVzcG9uc2UgaXMgZm9ybWF0ZWQgYXM6XHJcbiAgICogICAge1xyXG4gICAqICAgICAgdXJsOiAncmVzb3VyY2UgdXJsJyxcclxuICAgKiAgICAgIGJ1ZmZlcjogeG1scmVzcG9uc2UsXHJcbiAgICogICAgfVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAtIHJlc3BvbnNlXHJcbiAgICogQHJldHVybiB7cHJvbWlzZX0gcHJvbWlzZVxyXG4gICAqL1xyXG4gIHBhcnNlKHJlc3BvbnNlKSB7XHJcbiAgICAvLyBlbWl0ICdwYXJzZS1zdGFydCcgZXZlbnRcclxuICAgIHRoaXMuZW1pdCgncGFyc2Utc3RhcnQnLCB7XHJcbiAgICAgIGZpbGU6IHJlc3BvbnNlLnVybCxcclxuICAgICAgdGltZTogbmV3IERhdGUoKSxcclxuICAgIH0pO1xyXG4gICAgLy8gZ2l2ZSBhIGNoYW5jZSB0byB0aGUgVUkgdG8gdXBkYXRlIGJlY2F1c2VcclxuICAgIC8vIGFmdGVyIHRoZSByZW5kZXJpbmcgd2lsbCBiZSBibG9ja2VkIHdpdGggaW50ZW5zaXZlIEpTXHJcbiAgICAvLyB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZXZlbnRlciBzZXQgdXBcclxuICAgIGlmICh0aGlzLl9wcm9ncmVzc0Jhcikge1xyXG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci51cGRhdGUoMCwgMTAwLCAncGFyc2UnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChcclxuICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZShuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgbGV0IGRhdGEgPSByZXNwb25zZTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwcm9jZXNzKGRhdGFzZXQpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiByYXcvbWhkIHBhaXJcclxuICAgICAgICAgICAgICAgIGxldCBtaGRGaWxlID1cclxuICAgICAgICAgICAgICAgICAgZGF0YS5maWx0ZXIodGhpcy5fZmlsdGVyQnlFeHRlbnNpb24uYmluZChudWxsLCAnTUhEJykpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhd0ZpbGUgPVxyXG4gICAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcih0aGlzLl9maWx0ZXJCeUV4dGVuc2lvbi5iaW5kKG51bGwsICdSQVcnKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDIgJiZcclxuICAgICAgICAgICAgICAgICAgICBtaGRGaWxlLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJhd0ZpbGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGEudXJsID0gbWhkRmlsZVswXS51cmw7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGEuZXh0ZW5zaW9uID0gbWhkRmlsZVswXS5leHRlbnNpb247XHJcbiAgICAgICAgICAgICAgICAgIGRhdGEubWhkQnVmZmVyID0gbWhkRmlsZVswXS5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGEucmF3QnVmZmVyID0gcmF3RmlsZVswXS5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBsZXQgUGFyc2VyID0gdGhpcy5fcGFyc2VyKGRhdGEuZXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgICBpZiAoIVBhcnNlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1pdCAncGFyc2UtZXJyb3InIGV2ZW50XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhcnNlLWVycm9yJywge1xyXG4gICAgICAgICAgICAgICAgICBmaWxlOiByZXNwb25zZS51cmwsXHJcbiAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBkYXRhLmZpbGVuYW1lICsgJ2NhbiBub3QgYmUgcGFyc2VkLicsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChkYXRhLmZpbGVuYW1lICsgJyBjYW4gbm90IGJlIHBhcnNlZC4nKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIGNoZWNrIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgIGxldCB2b2x1bWVQYXJzZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIgPSBuZXcgUGFyc2VyKGRhdGEsIDApO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgICAgIC8vIGVtaXQgJ3BhcnNlLWVycm9yJyBldmVudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJzZS1lcnJvcicsIHtcclxuICAgICAgICAgICAgICAgICAgZmlsZTogcmVzcG9uc2UudXJsLFxyXG4gICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgc2VyaWVzXHJcbiAgICAgICAgICAgICAgbGV0IHNlcmllcyA9IG5ldyBNb2RlbHNTZXJpZXMoKTtcclxuICAgICAgICAgICAgICAvLyBnbG9iYWwgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5zdGFuY2VVSUQgPSB2b2x1bWVQYXJzZXIuc2VyaWVzSW5zdGFuY2VVSUQoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMudHJhbnNmZXJTeW50YXhVSUQgPSB2b2x1bWVQYXJzZXIudHJhbnNmZXJTeW50YXhVSUQoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzRGVzY3JpcHRpb24gPSB2b2x1bWVQYXJzZXIuc2VyaWVzRGVzY3JpcHRpb24oKTtcclxuICAgICAgICAgICAgICBzZXJpZXMuc3R1ZHlEZXNjcmlwdGlvbiA9IHZvbHVtZVBhcnNlci5zdHVkeURlc2NyaXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgc2VyaWVzLm51bWJlck9mRnJhbWVzID0gdm9sdW1lUGFyc2VyLm51bWJlck9mRnJhbWVzKCk7XHJcbiAgICAgICAgICAgICAgaWYgKCFzZXJpZXMubnVtYmVyT2ZGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlcmllcy5udW1iZXJPZkZyYW1lcyA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHNlcmllcy5udW1iZXJPZkNoYW5uZWxzID0gdm9sdW1lUGFyc2VyLm51bWJlck9mQ2hhbm5lbHMoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMubW9kYWxpdHkgPSB2b2x1bWVQYXJzZXIubW9kYWxpdHkoKTtcclxuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlZ21lbnRhdGlvbiwgYXR0YWNoIGV4dHJhIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgaWYgKHNlcmllcy5tb2RhbGl0eSA9PT0gJ1NFRycpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbG9yc1xyXG4gICAgICAgICAgICAgICAgLy8gbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAvLyBldGMuXHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuc2VnbWVudGF0aW9uVHlwZSA9IHZvbHVtZVBhcnNlci5zZWdtZW50YXRpb25UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuc2VnbWVudGF0aW9uU2VnbWVudHMgPVxyXG4gICAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIuc2VnbWVudGF0aW9uU2VnbWVudHMoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgLy8gcGF0aWVudCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50SUQgPSB2b2x1bWVQYXJzZXIucGF0aWVudElEKCk7XHJcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnROYW1lID0gdm9sdW1lUGFyc2VyLnBhdGllbnROYW1lKCk7XHJcbiAgICAgICAgICAgICAgc2VyaWVzLnBhdGllbnRBZ2UgPSB2b2x1bWVQYXJzZXIucGF0aWVudEFnZSgpO1xyXG4gICAgICAgICAgICAgIHNlcmllcy5wYXRpZW50QmlydGhkYXRlID0gdm9sdW1lUGFyc2VyLnBhdGllbnRCaXJ0aGRhdGUoKTtcclxuICAgICAgICAgICAgICBzZXJpZXMucGF0aWVudFNleCA9IHZvbHVtZVBhcnNlci5wYXRpZW50U2V4KCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGp1c3QgY3JlYXRlIDEgZHVtbXkgc3RhY2sgZm9yIG5vd1xyXG4gICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ldyBNb2RlbHNTdGFjaygpO1xyXG4gICAgICAgICAgICAgIHN0YWNrLm51bWJlck9mQ2hhbm5lbHMgPSB2b2x1bWVQYXJzZXIubnVtYmVyT2ZDaGFubmVscygpO1xyXG4gICAgICAgICAgICAgIHN0YWNrLnBpeGVsUmVwcmVzZW50YXRpb24gPVxyXG4gICAgICAgICAgICAgICAgdm9sdW1lUGFyc2VyLnBpeGVsUmVwcmVzZW50YXRpb24oKTtcclxuICAgICAgICAgICAgICBzdGFjay5waXhlbFR5cGUgPSB2b2x1bWVQYXJzZXIucGl4ZWxUeXBlKCk7XHJcbiAgICAgICAgICAgICAgc3RhY2suaW52ZXJ0ID0gdm9sdW1lUGFyc2VyLmludmVydCgpO1xyXG4gICAgICAgICAgICAgIHN0YWNrLnNwYWNpbmdCZXR3ZWVuU2xpY2VzID1cclxuICAgICAgICAgICAgICAgIHZvbHVtZVBhcnNlci5zcGFjaW5nQmV0d2VlblNsaWNlcygpO1xyXG4gICAgICAgICAgICAgIHN0YWNrLm1vZGFsaXR5ID0gc2VyaWVzLm1vZGFsaXR5O1xyXG4gICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VnbWVudGF0aW9uLCBhdHRhY2ggZXh0cmEgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICBpZiAoc3RhY2subW9kYWxpdHkgPT09ICdTRUcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2xvcnNcclxuICAgICAgICAgICAgICAgIC8vIGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgLy8gZXRjLlxyXG4gICAgICAgICAgICAgICAgc3RhY2suc2VnbWVudGF0aW9uVHlwZSA9IHNlcmllcy5zZWdtZW50YXRpb25UeXBlO1xyXG4gICAgICAgICAgICAgICAgc3RhY2suc2VnbWVudGF0aW9uU2VnbWVudHMgPSBzZXJpZXMuc2VnbWVudGF0aW9uU2VnbWVudHM7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHNlcmllcy5zdGFjay5wdXNoKHN0YWNrKTtcclxuICAgICAgICAgICAgICAvLyByZWN1cnNpdmUgY2FsbCBmb3IgZWFjaCBmcmFtZVxyXG4gICAgICAgICAgICAgIC8vIGJldHRlciB0aGFuIGZvciBsb29wIHRvIGJlIGFibGVcclxuICAgICAgICAgICAgICAvLyB0byB1cGRhdGUgZG9tIHdpdGggXCJwcm9ncmVzc1wiIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dChcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGcmFtZShcclxuICAgICAgICAgICAgICAgICAgc2VyaWVzLCBzdGFjaywgcmVzcG9uc2UudXJsLCAwLFxyXG4gICAgICAgICAgICAgICAgICB2b2x1bWVQYXJzZXIsIHJlc29sdmUsIHJlamVjdCksIDApO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9LCAxMCk7XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiByZWN1cnNpdmUgcGFyc2UgZnJhbWVcclxuICAgKiBAcGFyYW0ge01vZGVsc1Nlcmllc30gc2VyaWVzIC0gZGF0YSBzZXJpZXNcclxuICAgKiBAcGFyYW0ge01vZGVsc1N0YWNrfSBzdGFjayAtIGRhdGEgc3RhY2tcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gcmVzb3VyY2UgdXJsXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgLSBmcmFtZSBpbmRleFxyXG4gICAqIEBwYXJhbSB7cGFyc2VyfSBkYXRhUGFyc2VyIC0gc2VsZWN0ZWQgcGFyc2VyXHJcbiAgICogQHBhcmFtIHtwcm9taXNlLnJlc29sdmV9IHJlc29sdmUgLSBwcm9taXNlIHJlc29sdmUgYXJnc1xyXG4gICAqIEBwYXJhbSB7cHJvbWlzZS5yZWplY3R9IHJlamVjdCAtIHByb21pc2UgcmVqZWN0IGFyZ3NcclxuICAgKi9cclxuICBwYXJzZUZyYW1lKHNlcmllcywgc3RhY2ssIHVybCwgaSwgZGF0YVBhcnNlciwgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICBsZXQgZnJhbWUgPSBuZXcgTW9kZWxzRnJhbWUoKTtcclxuICAgIGZyYW1lLnNvcEluc3RhbmNlVUlEID0gZGF0YVBhcnNlci5zb3BJbnN0YW5jZVVJRChpKTtcclxuICAgIGZyYW1lLnVybCA9IHVybDtcclxuICAgIGZyYW1lLmluZGV4ID0gaTtcclxuICAgIGZyYW1lLnJvd3MgPSBkYXRhUGFyc2VyLnJvd3MoaSk7XHJcbiAgICBmcmFtZS5jb2x1bW5zID0gZGF0YVBhcnNlci5jb2x1bW5zKGkpO1xyXG4gICAgZnJhbWUubnVtYmVyT2ZDaGFubmVscyA9IHN0YWNrLm51bWJlck9mQ2hhbm5lbHM7XHJcbiAgICBmcmFtZS5waXhlbFJlcHJlc2VudGF0aW9uID0gc3RhY2sucGl4ZWxSZXByZXNlbnRhdGlvbjtcclxuICAgIGZyYW1lLnBpeGVsVHlwZSA9IHN0YWNrLnBpeGVsVHlwZTtcclxuICAgIGZyYW1lLnBpeGVsRGF0YSA9IGRhdGFQYXJzZXIuZXh0cmFjdFBpeGVsRGF0YShpKTtcclxuICAgIGZyYW1lLnBpeGVsU3BhY2luZyA9IGRhdGFQYXJzZXIucGl4ZWxTcGFjaW5nKGkpO1xyXG4gICAgZnJhbWUuc3BhY2luZ0JldHdlZW5TbGljZXMgPSBkYXRhUGFyc2VyLnNwYWNpbmdCZXR3ZWVuU2xpY2VzKGkpO1xyXG4gICAgZnJhbWUuc2xpY2VUaGlja25lc3MgPSBkYXRhUGFyc2VyLnNsaWNlVGhpY2tuZXNzKGkpO1xyXG4gICAgZnJhbWUuaW1hZ2VPcmllbnRhdGlvbiA9IGRhdGFQYXJzZXIuaW1hZ2VPcmllbnRhdGlvbihpKTtcclxuICAgIGZyYW1lLnJpZ2h0SGFuZGVkID0gZGF0YVBhcnNlci5yaWdodEhhbmRlZCgpO1xyXG4gICAgc3RhY2sucmlnaHRIYW5kZWQgPSBmcmFtZS5yaWdodEhhbmRlZDtcclxuICAgIGlmIChmcmFtZS5pbWFnZU9yaWVudGF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgIGZyYW1lLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XHJcbiAgICB9XHJcbiAgICBmcmFtZS5pbWFnZVBvc2l0aW9uID0gZGF0YVBhcnNlci5pbWFnZVBvc2l0aW9uKGkpO1xyXG4gICAgaWYgKGZyYW1lLmltYWdlUG9zaXRpb24gPT09IG51bGwpIHtcclxuICAgICAgZnJhbWUuaW1hZ2VQb3NpdGlvbiA9IFswLCAwLCBpXTtcclxuICAgIH1cclxuICAgIGZyYW1lLmRpbWVuc2lvbkluZGV4VmFsdWVzID0gZGF0YVBhcnNlci5kaW1lbnNpb25JbmRleFZhbHVlcyhpKTtcclxuICAgIGZyYW1lLmJpdHNBbGxvY2F0ZWQgPSBkYXRhUGFyc2VyLmJpdHNBbGxvY2F0ZWQoaSk7XHJcbiAgICBmcmFtZS5pbnN0YW5jZU51bWJlciA9IGRhdGFQYXJzZXIuaW5zdGFuY2VOdW1iZXIoaSk7XHJcbiAgICBmcmFtZS53aW5kb3dDZW50ZXIgPSBkYXRhUGFyc2VyLndpbmRvd0NlbnRlcihpKTtcclxuICAgIGZyYW1lLndpbmRvd1dpZHRoID0gZGF0YVBhcnNlci53aW5kb3dXaWR0aChpKTtcclxuICAgIGZyYW1lLnJlc2NhbGVTbG9wZSA9IGRhdGFQYXJzZXIucmVzY2FsZVNsb3BlKGkpO1xyXG4gICAgZnJhbWUucmVzY2FsZUludGVyY2VwdCA9IGRhdGFQYXJzZXIucmVzY2FsZUludGVyY2VwdChpKTtcclxuICAgIC8vIHNob3VsZCBwYXNzIGZyYW1lIGluZGV4IGZvciBjb25zaXN0ZW5jeS4uLlxyXG4gICAgZnJhbWUubWluTWF4ID0gZGF0YVBhcnNlci5taW5NYXhQaXhlbERhdGEoZnJhbWUucGl4ZWxEYXRhKTtcclxuXHJcbiAgICAvLyBpZiBzZXJpZXMubW9cclxuICAgIGlmIChzZXJpZXMubW9kYWxpdHkgPT09ICdTRUcnKSB7XHJcbiAgICAgIGZyYW1lLnJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gZGF0YVBhcnNlci5yZWZlcmVuY2VkU2VnbWVudE51bWJlcihpKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGFjay5mcmFtZS5wdXNoKGZyYW1lKTtcclxuXHJcbiAgICAvLyB1cGRhdGUgc3RhdHVzXHJcbiAgICB0aGlzLl9wYXJzZWQgPSBpICsgMTtcclxuICAgIHRoaXMuX3RvdGFsUGFyc2VkID0gc2VyaWVzLm51bWJlck9mRnJhbWVzO1xyXG5cclxuICAgIC8vIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBldmVudGVyIHNldCB1cFxyXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzQmFyKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLnVwZGF0ZSh0aGlzLl9wYXJzZWQsIHRoaXMuX3RvdGFsUGFyc2VkLCAncGFyc2UnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0ICdwYXJzaW5nJyBldmVudFxyXG4gICAgdGhpcy5lbWl0KCdwYXJzaW5nJywge1xyXG4gICAgICBmaWxlOiB1cmwsXHJcbiAgICAgIHRvdGFsOiB0aGlzLl90b3RhbFBhcnNlZCxcclxuICAgICAgcGFyc2VkOiB0aGlzLl9wYXJzZWQsXHJcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fcGFyc2VkID09PSB0aGlzLl90b3RhbFBhcnNlZCkge1xyXG4gICAgICAvLyBlbWl0ICdwYXJzZS1zdWNjZXNzJyBldmVudFxyXG4gICAgICB0aGlzLmVtaXQoJ3BhcnNlLXN1Y2Nlc3MnLCB7XHJcbiAgICAgICAgZmlsZTogdXJsLFxyXG4gICAgICAgIHRvdGFsOiB0aGlzLl90b3RhbFBhcnNlZCxcclxuICAgICAgICBwYXJzZWQ6IHRoaXMuX3BhcnNlZCxcclxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJlc29sdmUoc2VyaWVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgdGhpcy5wYXJzZUZyYW1lKFxyXG4gICAgICAgICAgc2VyaWVzLCBzdGFjaywgdXJsLCB0aGlzLl9wYXJzZWQsIGRhdGFQYXJzZXIsIHJlc29sdmUsIHJlamVjdCksIDBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBwYXJzZXIgZ2l2ZW4gYW4gZXh0ZW5zaW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIGV4dGVuc2lvblxyXG4gICAqIEByZXR1cm4ge3BhcnNlcn0gc2VsZWN0ZWQgcGFyc2VyXHJcbiAgICovXHJcbiAgX3BhcnNlcihleHRlbnNpb24pIHtcclxuICAgIGxldCBQYXJzZXIgPSBudWxsO1xyXG5cclxuICAgIHN3aXRjaCAoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgY2FzZSAnTklJJzpcclxuICAgICAgY2FzZSAnTklJXyc6XHJcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc05pZnRpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdEQ00nOlxyXG4gICAgICBjYXNlICdESUNPTSc6XHJcbiAgICAgIGNhc2UgJ0lNQSc6XHJcbiAgICAgIGNhc2UgJyc6XHJcbiAgICAgICAgUGFyc2VyID0gUGFyc2Vyc0RpY29tO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdNSEQnOlxyXG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNNaGQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ05SUkQnOlxyXG4gICAgICAgIFBhcnNlciA9IFBhcnNlcnNOcnJkO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygndW5zdXBwb3J0ZWQgZXh0ZW5zaW9uOiAnICsgZXh0ZW5zaW9uKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGFyc2VyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFByZS1wcm9jZXNzIGRhdGEgdG8gYmUgcGFyc2VkIChmaW5kIGRhdGEgdHlwZSBhbmQgZGUtY29tcHJlc3MpXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhXHJcbiAgICovXHJcbiAgX3ByZXByb2Nlc3MoZGF0YSkge1xyXG4gICAgY29uc3QgcGFyc2VkVXJsID0gQ29yZVV0aWxzLnBhcnNlVXJsKGRhdGEudXJsKTtcclxuICAgIC8vIHVwZGF0ZSBkYXRhXHJcbiAgICBkYXRhLmZpbGVuYW1lID0gcGFyc2VkVXJsLmZpbGVuYW1lO1xyXG4gICAgZGF0YS5leHRlbnNpb24gPSBwYXJzZWRVcmwuZXh0ZW5zaW9uO1xyXG4gICAgZGF0YS5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcclxuICAgIGRhdGEucXVlcnkgPSBwYXJzZWRVcmwucXVlcnk7XHJcblxyXG4gICAgLy8gdW56aXAgaWYgZXh0ZW5zaW9uIGlzICcuZ3onXHJcbiAgICBpZiAoZGF0YS5leHRlbnNpb24gPT09ICdneicpIHtcclxuICAgICAgZGF0YS5nemNvbXByZXNzZWQgPSB0cnVlO1xyXG4gICAgICBkYXRhLmV4dGVuc2lvbiA9XHJcbiAgICAgICAgZGF0YS5maWxlbmFtZS5zcGxpdCgnLmd6Jykuc2hpZnQoKS5zcGxpdCgnLicpLnBvcCgpO1xyXG4gICAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IFBBS08uaW5mbGF0ZShkYXRhLmJ1ZmZlcik7XHJcbiAgICAgIGRhdGEuYnVmZmVyID0gZGVjb21wcmVzc2VkRGF0YS5idWZmZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhLmd6Y29tcHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlsdGVyIGRhdGEgYnkgZXh0ZW5zaW9uXHJcbiAgICogQHBhcmFtIHsqfSBleHRlbnNpb25cclxuICAgKiBAcGFyYW0geyp9IGl0ZW1cclxuICAgKiBAcmV0dXJucyBCb29sZWFuXHJcbiAgICovXHJcbiAgX2ZpbHRlckJ5RXh0ZW5zaW9uKGV4dGVuc2lvbiwgaXRlbSkge1xyXG4gICAgaWYgKGl0ZW0uZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkgPT09IGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogQmFzZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBtb2R1bGUgbW9kZWxzL2Jhc2VcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbHNCYXNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2lkID0gLTE7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIDIgYXJyYXlzIG9mIG1vZGVscy5cclxuICAgKiBNZXJnZSB0aGUgdGFyZ2V0IGFycmF5IGludG8gdGhlIHJlZmVyZW5jZSBhcnJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE1vZGVscz59IHJlZmVyZW5jZUFycmF5IC0gQXJyYXkgdG8gYmUgbWVyZ2UgYWdhaW5zdFxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE1vZGVscz59IHRhcmdldEFycmF5IC0gQXJyYXkgdG8gYmUgbWVyZ2VkIGFnYWluc3QgcmVmZXJlbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtZXJnZSB3YXMgc3VjZXNzZnVsLiBGYWxzZSBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cclxuICAgKi9cclxuICBtZXJnZU1vZGVscyhyZWZlcmVuY2VBcnJheSwgdGFyZ2V0QXJyYXkpIHtcclxuICAgIGlmICghKHRoaXMuX3ZhbGlkYXRlTW9kZWxBcnJheShyZWZlcmVuY2VBcnJheSkgJiZcclxuICAgICAgdGhpcy5fdmFsaWRhdGVNb2RlbEFycmF5KHRhcmdldEFycmF5KSkpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdpbnZhbGlkIGlucHV0cyBwcm92aWRlZC4nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0QXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gdGVzdCB0YXJnZXRBcnJheSBhZ2FpbnN0IGV4aXN0aW5nIHRhcmdldEFycmF5XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmZXJlbmNlQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAocmVmZXJlbmNlQXJyYXlbal0ubWVyZ2UodGFyZ2V0QXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAvLyBtZXJnZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKGogPT09IHJlZmVyZW5jZUFycmF5Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIC8vIGxhc3QgbWVyZ2Ugd2FzIG5vdCBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IHRhcmdldEFycmF5XHJcbiAgICAgICAgICByZWZlcmVuY2VBcnJheS5wdXNoKHRhcmdldEFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIG1vZGVsIGFnYWluc3QgY3VycmVudCBtb2RlbC5cclxuICAgKi9cclxuICBtZXJnZShtb2RlbCkge1xyXG4gICAgLy8gbWFrZSBzdXJlIG1vZGVsIGlzIHZhbGlkXHJcbiAgICBpZighKHRoaXMudmFsaWRhdGUobW9kZWwpKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhleSBjYW4gYmUgbWVyZ2VkIGlmIHRoZXkgbWF0Y2hcclxuICAgIGlmKHRoaXMuX2lkID09PSBtb2RlbC5faWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSBhIG1vZGVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb2RlbCBpcyB2YWxpZC4gRmFsc2UgaWYgbm90LlxyXG4gICAqL1xyXG4gIHZhbGlkYXRlKG1vZGVsKSB7XHJcbiAgICBpZiAoIShtb2RlbCAmJlxyXG4gICAgICBtb2RlbCAhPT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2YgbW9kZWwubWVyZ2UgPT09ICdmdW5jdGlvbicpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIGFycmF5IG9mIG1vZGVscy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE1vZGVscz59IG1vZGVsQXJyYXkgLSBBcnJheSBjb250YWluaW5nIG1vZGVscy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXJyYXkgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cclxuICAgKi9cclxuICBfdmFsaWRhdGVNb2RlbEFycmF5KG1vZGVsQXJyYXkpIHtcclxuICAgIGlmICghKG1vZGVsQXJyYXkgIT09IG51bGwgJiYgQXJyYXkgPT09IG1vZGVsQXJyYXkuY29uc3RydWN0b3IpKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnaW52YWxpZCBtb2RlbCBhcnJheSBwcm92aWRlZC4nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWxBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIShtb2RlbEFycmF5W2ldICYmXHJcbiAgICAgICAgbW9kZWxBcnJheVtpXSAhPT0gbnVsbCAmJlxyXG4gICAgICAgIHR5cGVvZiBtb2RlbEFycmF5W2ldLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgbW9kZWxBcnJheVtpXS52YWxpZGF0ZShtb2RlbEFycmF5W2ldKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbn1cclxuIiwiLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBNb2RlbHNCYXNlIGZyb20gJy4uL21vZGVscy9tb2RlbHMuYmFzZSc7XHJcblxyXG4vKipcclxuICogRnJhbWUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAbW9kdWxlIG1vZGVscy9mcmFtZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzRnJhbWUgZXh0ZW5kcyBNb2RlbHNCYXNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fc29wSW5zdGFuY2VVSUQgPSBudWxsO1xyXG4gICAgdGhpcy5fdXJsID0gbnVsbDtcclxuICAgIHRoaXMuX3N0YWNrSUQgPSAtMTtcclxuICAgIHRoaXMuX3Jvd3MgPSAwO1xyXG4gICAgdGhpcy5fY29sdW1ucyA9IDA7XHJcbiAgICB0aGlzLl9kaW1lbnNpb25JbmRleFZhbHVlcyA9IFtdO1xyXG4gICAgdGhpcy5faW1hZ2VQb3NpdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX3NsaWNlVGhpY2tuZXNzID0gMTtcclxuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gbnVsbDtcclxuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSAwO1xyXG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gMDtcclxuICAgIHRoaXMuX3BpeGVsU3BhY2luZyA9IG51bGw7XHJcbiAgICB0aGlzLl9waXhlbEFzcGVjdFJhdGlvID0gbnVsbDtcclxuICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5faW5zdGFuY2VOdW1iZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gbnVsbDtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gbnVsbDtcclxuICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSA9IG51bGw7XHJcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9iaXRzQWxsb2NhdGVkID0gODtcclxuXHJcbiAgICB0aGlzLl9taW5NYXggPSBudWxsO1xyXG4gICAgdGhpcy5fZGlzdCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5faW5kZXggPSAtMTtcclxuXHJcbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IC0xO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgdGhlIGZyYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBtb2RlbFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB2YWxpZGF0ZShtb2RlbCkge1xyXG4gICAgaWYgKCEoc3VwZXIudmFsaWRhdGUobW9kZWwpICYmXHJcbiAgICAgIHR5cGVvZiBtb2RlbC5jb3NpbmVzID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgIHR5cGVvZiBtb2RlbC5zcGFjaW5nWFkgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19zb3BJbnN0YW5jZVVJRCcpICYmXHJcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfZGltZW5zaW9uSW5kZXhWYWx1ZXMnKSAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX2ltYWdlT3JpZW50YXRpb24nKSAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX2ltYWdlUG9zaXRpb24nKSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2UgY3VycmVudCBmcmFtZSB3aXRoIHByb3ZpZGVkIGZyYW1lLlxyXG4gICAqXHJcbiAgICogRnJhbWVzIGNhbiBiZSBtZXJnZWQgKGkuZS4gYXJlIGlkZW50aWNhbCkgaWYgZm9sbG93aW5nIGFyZSBlcXVhbHM6XHJcbiAgICogIC0gZGltZW5zaW9uSW5kZXhWYWx1ZXNcclxuICAgKiAgLSBpbWFnZU9yaWVudGF0aW9uXHJcbiAgICogIC0gaW1hZ2VQb3NpdGlvblxyXG4gICAqICAtIGluc3RhbmNlTnVtYmVyXHJcbiAgICogIC0gc29wSW5zdGFuY2VVSURcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gZnJhbWVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZnJhbWVzIGNvdWxkIGJlIG1lcmdlLiBGYWxzZSBpZiBub3QuXHJcbiAgICovXHJcbiAgbWVyZ2UoZnJhbWUpIHtcclxuICAgIGlmICghdGhpcy52YWxpZGF0ZShmcmFtZSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jb21wYXJlQXJyYXlzKFxyXG4gICAgICAgICAgdGhpcy5fZGltZW5zaW9uSW5kZXhWYWx1ZXMsIGZyYW1lLmRpbWVuc2lvbkluZGV4VmFsdWVzKSAmJlxyXG4gICAgICAgIHRoaXMuX2NvbXBhcmVBcnJheXMoXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uLCBmcmFtZS5pbWFnZU9yaWVudGF0aW9uKSAmJlxyXG4gICAgICAgIHRoaXMuX2NvbXBhcmVBcnJheXMoXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZVBvc2l0aW9uLCBmcmFtZS5pbWFnZVBvc2l0aW9uKSAmJlxyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlTnVtYmVyID09PSBmcmFtZS5pbnN0YW5jZU51bWJlciAmJlxyXG4gICAgICAgIHRoaXMuX3NvcEluc3RhbmNlVUlEID09PSBmcmFtZS5zb3BJbnN0YW5jZVVJRCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIFgsIHkgYW5kIFogY29zaW5lcyBmcm9tIGltYWdlIG9yaWVudGF0aW9uXHJcbiAgICogUmV0dXJucyBkZWZhdWx0IG9yaWVudGF0aW9uIGlmIF9pbWFnZU9yaWVudGF0aW9uIHdhcyBpbnZhbGlkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2FycmF5fSBBcnJheVszXSBjb250YWluaW5nIGNvc2luZXNYLCBZIGFuZCBaLlxyXG4gICAqL1xyXG4gIGNvc2luZXMoKSB7XHJcbiAgICBsZXQgY29zaW5lcyA9IFtuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSxcclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksXHJcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpXTtcclxuXHJcbiAgICAgaWYgKHRoaXMuX2ltYWdlT3JpZW50YXRpb24gJiZcclxuICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvbi5sZW5ndGggPT09IDYpIHtcclxuICAgICAgbGV0IHhDb3MgPVxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvblswXSxcclxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bMV0sXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzJdKTtcclxuICAgICAgbGV0IHlDb3MgPVxyXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICAgICAgdGhpcy5faW1hZ2VPcmllbnRhdGlvblszXSxcclxuICAgICAgICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb25bNF0sXHJcbiAgICAgICAgICB0aGlzLl9pbWFnZU9yaWVudGF0aW9uWzVdKTtcclxuXHJcbiAgICAgIGlmICh4Q29zLmxlbmd0aCgpID4gMCAmJiB5Q29zLmxlbmd0aCgpID4gMCkge1xyXG4gICAgICAgIGNvc2luZXNbMF0gPSB4Q29zO1xyXG4gICAgICAgIGNvc2luZXNbMV0gPSB5Q29zO1xyXG4gICAgICAgIGNvc2luZXNbMl0gPVxyXG4gICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkuXHJcbiAgICAgICAgICBjcm9zc1ZlY3RvcnMoY29zaW5lc1swXSwgY29zaW5lc1sxXSkuXHJcbiAgICAgICAgICBub3JtYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdObyB2YWxpZCBpbWFnZSBvcmllbnRhdGlvbiBmb3IgZnJhbWUnKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1JldHVybmluZyBkZWZhdWx0IG9yaWVudGF0aW9uLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fcmlnaHRIYW5kZWQpIHtcclxuICAgICAgY29zaW5lc1syXS5uZWdhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29zaW5lcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB4L3kgc3BhY2luZyBvZiBhIGZyYW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzcGFjaW5nWFkoKSB7XHJcbiAgICBsZXQgc3BhY2luZ1hZID0gWzEuMCwgMS4wXTtcclxuXHJcbiAgICBpZiAodGhpcy5waXhlbFNwYWNpbmcpIHtcclxuICAgICAgc3BhY2luZ1hZWzBdID0gdGhpcy5waXhlbFNwYWNpbmdbMF07XHJcblxyXG4gICAgICBzcGFjaW5nWFlbMV0gPSB0aGlzLnBpeGVsU3BhY2luZ1sxXTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5waXhlbEFzcGVjdFJhdGlvKSB7XHJcbiAgICAgIHNwYWNpbmdYWVswXSA9IDEuMDtcclxuICAgICAgc3BhY2luZ1hZWzFdID0gMS4wICogdGhpcy5waXhlbEFzcGVjdFJhdGlvWzFdIC8gdGhpcy5waXhlbEFzcGVjdFJhdGlvWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzcGFjaW5nWFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZGF0YSB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBjb2x1bW5cclxuICAgKiBAcGFyYW0geyp9IHJvd1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB2YWx1ZShjb2x1bW4sIHJvdykge1xyXG4gICAgcmV0dXJuIHRoaXMucGl4ZWxEYXRhW2NvbHVtbiArIHRoaXMuX2NvbHVtbnMgKiByb3ddO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZSAyIGFycmF5cy5cclxuICAgKlxyXG4gICAqIDIgbnVsbCBhcnJheXMgcmV0dXJuIHRydWUuXHJcbiAgICogRG8gbm8gcGVyZm9ybSBzdHJpY3QgdHlwZSBjaGVja2luZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXHJcbiAgICogQHBhcmFtIHsqfSB0YXJnZXRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXJyYXlzIGFyZSBpZGVudGljYWxzLiBGYWxzZSBpZiBub3QuXHJcbiAgICovXHJcbiAgX2NvbXBhcmVBcnJheXMocmVmZXJlbmNlLCB0YXJnZXQpIHtcclxuICAgIC8vIGNvdWxkIGJvdGggYmUgbnVsbFxyXG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIG5vdCBudWxsLi4uLlxyXG4gICAgaWYgKHJlZmVyZW5jZSAmJlxyXG4gICAgICAgIHRhcmdldCAmJlxyXG4gICAgICAgIHJlZmVyZW5jZS5qb2luKCkgPT09IHRhcmdldC5qb2luKCkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJvd3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcm93cztcclxuICB9XHJcblxyXG4gIHNldCByb3dzKHJvd3MpIHtcclxuICAgIHRoaXMuX3Jvd3MgPSByb3dzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbHVtbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29sdW1ucztcclxuICB9XHJcblxyXG4gIHNldCBjb2x1bW5zKGNvbHVtbnMpIHtcclxuICAgIHRoaXMuX2NvbHVtbnMgPSBjb2x1bW5zO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNwYWNpbmdCZXR3ZWVuU2xpY2VzKHNwYWNpbmdCZXR3ZWVuU2xpY2VzKSB7XHJcbiAgICB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcyA9IHNwYWNpbmdCZXR3ZWVuU2xpY2VzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNsaWNlVGhpY2tuZXNzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlVGhpY2tuZXNzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNsaWNlVGhpY2tuZXNzKHNsaWNlVGhpY2tuZXNzKSB7XHJcbiAgICB0aGlzLl9zbGljZVRoaWNrbmVzcyA9IHNsaWNlVGhpY2tuZXNzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGltYWdlUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBpbWFnZVBvc2l0aW9uKGltYWdlUG9zaXRpb24pIHtcclxuICAgIHRoaXMuX2ltYWdlUG9zaXRpb24gPSBpbWFnZVBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGltYWdlT3JpZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VPcmllbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBpbWFnZU9yaWVudGF0aW9uKGltYWdlT3JpZW50YXRpb24pIHtcclxuICAgIHRoaXMuX2ltYWdlT3JpZW50YXRpb24gPSBpbWFnZU9yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvd1dpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdpbmRvd1dpZHRoKHdpbmRvd1dpZHRoKSB7XHJcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IHdpbmRvd1dpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvd0NlbnRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLl93aW5kb3dDZW50ZXI7XHJcbiAgfVxyXG5cclxuICBzZXQgd2luZG93Q2VudGVyKHdpbmRvd0NlbnRlcikge1xyXG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gd2luZG93Q2VudGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVTbG9wZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNjYWxlU2xvcGU7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVzY2FsZVNsb3BlKHJlc2NhbGVTbG9wZSkge1xyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gcmVzY2FsZVNsb3BlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlc2NhbGVJbnRlcmNlcHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcclxuICB9XHJcblxyXG4gIHNldCByZXNjYWxlSW50ZXJjZXB0KHJlc2NhbGVJbnRlcmNlcHQpIHtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSByZXNjYWxlSW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJpdHNBbGxvY2F0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYml0c0FsbG9jYXRlZDtcclxuICB9XHJcblxyXG4gIHNldCBiaXRzQWxsb2NhdGVkKGJpdHNBbGxvY2F0ZWQpIHtcclxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSBiaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpc3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGlzdDtcclxuICB9XHJcblxyXG4gIHNldCBkaXN0KGRpc3QpIHtcclxuICAgIHRoaXMuX2Rpc3QgPSBkaXN0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsU3BhY2luZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbFNwYWNpbmc7XHJcbiAgfVxyXG5cclxuICBzZXQgcGl4ZWxTcGFjaW5nKHBpeGVsU3BhY2luZykge1xyXG4gICAgdGhpcy5fcGl4ZWxTcGFjaW5nID0gcGl4ZWxTcGFjaW5nO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsQXNwZWN0UmF0aW8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxBc3BlY3RSYXRpbztcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbEFzcGVjdFJhdGlvKHBpeGVsQXNwZWN0UmF0aW8pIHtcclxuICAgIHRoaXMuX3BpeGVsQXNwZWN0UmF0aW8gPSBwaXhlbEFzcGVjdFJhdGlvO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1pbk1heCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9taW5NYXg7XHJcbiAgfVxyXG5cclxuICBzZXQgbWluTWF4KG1pbk1heCkge1xyXG4gICAgdGhpcy5fbWluTWF4ID0gbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpbWVuc2lvbkluZGV4VmFsdWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbkluZGV4VmFsdWVzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRpbWVuc2lvbkluZGV4VmFsdWVzKGRpbWVuc2lvbkluZGV4VmFsdWVzKSB7XHJcbiAgICB0aGlzLl9kaW1lbnNpb25JbmRleFZhbHVlcyA9IGRpbWVuc2lvbkluZGV4VmFsdWVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGluc3RhbmNlTnVtYmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IGluc3RhbmNlTnVtYmVyKGluc3RhbmNlTnVtYmVyKSB7XHJcbiAgICB0aGlzLl9pbnN0YW5jZU51bWJlciA9IGluc3RhbmNlTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsRGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbERhdGE7XHJcbiAgfVxyXG5cclxuICBzZXQgcGl4ZWxEYXRhKHBpeGVsRGF0YSkge1xyXG4gICAgdGhpcy5fcGl4ZWxEYXRhID0gcGl4ZWxEYXRhO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNvcEluc3RhbmNlVUlEKHNvcEluc3RhbmNlVUlEKSB7XHJcbiAgICB0aGlzLl9zb3BJbnN0YW5jZVVJRCA9IHNvcEluc3RhbmNlVUlEO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNvcEluc3RhbmNlVUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvcEluc3RhbmNlVUlEO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsUmVwcmVzZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxSZXByZXNlbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBwaXhlbFJlcHJlc2VudGF0aW9uKHBpeGVsUmVwcmVzZW50YXRpb24pIHtcclxuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSBwaXhlbFJlcHJlc2VudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBpeGVsVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9waXhlbFR5cGU7XHJcbiAgfVxyXG5cclxuICBzZXQgcGl4ZWxUeXBlKHBpeGVsVHlwZSkge1xyXG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gcGl4ZWxUeXBlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHVybCgpIHtcclxuICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgfVxyXG5cclxuICBzZXQgdXJsKHVybCkge1xyXG4gICAgdGhpcy5fdXJsID0gdXJsO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyKSB7XHJcbiAgICB0aGlzLl9yZWZlcmVuY2VkU2VnbWVudE51bWJlciA9IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJpZ2h0SGFuZGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJpZ2h0SGFuZGVkKHJpZ2h0SGFuZGVkKSB7XHJcbiAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHJpZ2h0SGFuZGVkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xyXG4gIH1cclxuXHJcbiAgc2V0IGluZGV4KGluZGV4KSB7XHJcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgRnJhbWUgZnJvbSAnLi9tb2RlbHMuZnJhbWUnO1xyXG5pbXBvcnQgU3RhY2sgZnJvbSAnLi9tb2RlbHMuc3RhY2snO1xyXG5pbXBvcnQgU2VyaWVzIGZyb20gJy4vbW9kZWxzLnNlcmllcyc7XHJcbmltcG9ydCBWb3hlbCBmcm9tICcuL21vZGVscy52b3hlbCc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBtb2RlbHNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgRnJhbWUsXHJcbiAgU3RhY2ssXHJcbiAgU2VyaWVzLFxyXG4gIFZveGVsLFxyXG59O1xyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IE1vZGVsc0Jhc2UgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5iYXNlJztcclxuXHJcbi8qKlxyXG4gKiBTZXJpZXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAbW9kdWxlIG1vZGVscy9zZXJpZXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsc1NlcmllcyBleHRlbmRzIE1vZGVsc0Jhc2Uge1xyXG4gIC8qKlxyXG4gICAqIE1vZGVscyBzZXJpZXMgY29uc3RydWN0b3JcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fY29uY2F0ZW5hdGlvblVJRCA9IC0xO1xyXG4gICAgdGhpcy5fc2VyaWVzSW5zdGFuY2VVSUQgPSAtMTtcclxuICAgIHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEID0gJyc7XHJcbiAgICB0aGlzLl9zZXJpZXNOdW1iZXIgPSAtMTtcclxuICAgIHRoaXMuX3Nlcmllc0Rlc2NyaXB0aW9uID0gJyc7XHJcbiAgICB0aGlzLl9zdHVkeURlc2NyaXB0aW9uID0gJyc7XHJcbiAgICB0aGlzLl9tb2RhbGl0eSA9ICdNb2RhbGl0eSBub3Qgc2V0JztcclxuICAgIHRoaXMuX2RpbWVuc2lvbkluZGV4U2VxdWVuY2UgPSBbXTtcclxuICAgIC8vIGl0IGlzIHVzZWQgaW4gdGhlIGxvYWRlciBpbiBjYXNlIGEgZGljb20vbmlmdGkgY29udGFpbnMgbXVsdGlwbGUgZnJhbWVzXHJcbiAgICAvLyBzaG91bGQgYmUgdXBkYXRlZCBhZnRlciBtZXJnZSBvciByZW5hbWVkXHJcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IDA7XHJcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcclxuXHJcbiAgICAvLyBwYXRpZW50IGluZm9ybWF0aW9uXHJcbiAgICB0aGlzLl9wYXRpZW50SUQgPSAnJztcclxuICAgIHRoaXMuX3BhdGllbnROYW1lID0gJyc7XHJcbiAgICB0aGlzLl9wYXRpZW50QWdlID0gJyc7XHJcbiAgICB0aGlzLl9wYXRpZW50QmlydGhkYXRlID0gJyc7XHJcbiAgICB0aGlzLl9wYXRpZW50U2V4ID0gJyc7XHJcblxyXG4gICAgLy8gU0VHTUVOVEFUSU9OIFNUVUZGXHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25UeXBlID0gbnVsbDtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzID0gW107XHJcblxyXG4gICAgLy8gU1RBQ0tcclxuICAgIHRoaXMuX3N0YWNrID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSBhIHNlcmllcy5cclxuICAgKlxyXG4gICAqIFJlcXVpcmVtZW50czpcclxuICAgKiAgIC0gbWVyZ2VTZXJpZXMgbWV0aG9kXHJcbiAgICogICAtIF9zZXJpZXNJbnN0YW5jZVVJRFxyXG4gICAqICAgLSBfbnVtYmVyT2ZGcmFtZXNcclxuICAgKiAgIC0gX251bWJlck9mQ2hhbm5lbHNcclxuICAgKiAgIF8gX3N0YWNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01vZGVsc1Nlcmllc30gbW9kZWwgLSBNb2RlbCB0byBiZSB2YWxpZGF0ZWQgYXMgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzZXJpZXMgaXMgdmFsaWQuIEZhbHNlIGlmIG5vdC5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIHZhbGlkYXRlKG1vZGVsKSB7XHJcbiAgICBpZiAoIShzdXBlci52YWxpZGF0ZShtb2RlbCkgJiZcclxuICAgICAgdHlwZW9mIG1vZGVsLm1lcmdlU2VyaWVzID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgIG1vZGVsLmhhc093blByb3BlcnR5KCdfc2VyaWVzSW5zdGFuY2VVSUQnKSAmJlxyXG4gICAgICBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnX251bWJlck9mRnJhbWVzJykgJiZcclxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19udW1iZXJPZkNoYW5uZWxzJykgJiZcclxuICAgICAgbW9kZWwuaGFzT3duUHJvcGVydHkoJ19zdGFjaycpICYmXHJcbiAgICAgIHR5cGVvZiBtb2RlbC5fc3RhY2sgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgIEFycmF5ID09PSBtb2RlbC5fc3RhY2suY29uc3RydWN0b3IpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIGN1cnJlbnQgc2VyaWVzIHdpdGggcHJvdmlkZWQgc2VyaWVzLlxyXG4gICAqIDIgc2VyaWVzIGNhbiBPTkxZIGJlIG1lcmdlIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBTZXJpZXNJbnN0YW5jZVVJRC5cclxuICAgKlxyXG4gICAqIEFsc28gbWVyZ2VzIHRoZSBzdGFja3MgaW5zaWRlIGEgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNb2RlbHNTZXJpZXN9IHNlcmllcyAtIFNlcmllcyB0byBiZSBtZXJnZWQgYWdhaW5zdCBjdXJyZW50IHNlcmllcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgc2VyaWVzIGNvdWxkIGJlIG1lcmdlLiBGYWxzZSBpZiBub3QuXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBtZXJnZShzZXJpZXMpIHtcclxuICAgIGlmICghdGhpcy52YWxpZGF0ZShzZXJpZXMpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc2VyaWVzSW5zdGFuY2VVSUQgPT09IHNlcmllcy5zZXJpZXNJbnN0YW5jZVVJRCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tZXJnZU1vZGVscyh0aGlzLl9zdGFjaywgc2VyaWVzLnN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIGN1cnJlbnQgc2VyaWVzIHdpdGggcHJvdmlkZWQgYXJyYXkgb2Ygc2VyaWVzLlxyXG4gICAqIDIgc2VyaWVzIGNhbiBPTkxZIGJlIG1lcmdlIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBTZXJpZXNJbnN0YW5jZVVJRC5cclxuICAgKlxyXG4gICAqIEFsc28gbWVyZ2VzIHRoZSBzdGFja3MgaW5zaWRlIGEgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48TW9kZWxzU2VyaWVzPn0gdGFyZ2V0IC0gU2VyaWVzIHRvIGJlIG1lcmdlZCBhZ2FpbnN0IGN1cnJlbnQgc2VyaWVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXkuPE1vZGVsc1Nlcmllcz59IEFycmF5IG9mIHNlcmllcyBwcm9wZXJseSBtZXJnZWQuXHJcbiAgICovXHJcbiAgbWVyZ2VTZXJpZXModGFyZ2V0KSB7XHJcbiAgICBsZXQgc2VyaWVzQ29udGFpbmVyID0gW3RoaXNdO1xyXG4gICAgdGhpcy5tZXJnZU1vZGVscyhzZXJpZXNDb250YWluZXIsIHRhcmdldCk7XHJcbiAgICByZXR1cm4gc2VyaWVzQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VyaWVzIGluc3RhbmNlIFVJRCBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc2VyaWVzSW5zdGFuY2VVSURcclxuICAgKi9cclxuICBzZXQgc2VyaWVzSW5zdGFuY2VVSUQoc2VyaWVzSW5zdGFuY2VVSUQpIHtcclxuICAgIHRoaXMuX3Nlcmllc0luc3RhbmNlVUlEID0gc2VyaWVzSW5zdGFuY2VVSUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXJpZXMgaW5zdGFjZSBVSUQgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZXJpZXNJbnN0YW5jZVVJRDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZmVyIHN5bnRheCBVSUQgc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHRyYW5zZmVyU3ludGF4VUlEXHJcbiAgICovXHJcbiAgc2V0IHRyYW5zZmVyU3ludGF4VUlEKHRyYW5zZmVyU3ludGF4VUlEKSB7XHJcbiAgICB0aGlzLl90cmFuc2ZlclN5bnRheFVJRCA9IHRyYW5zZmVyU3ludGF4VUlEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRCBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRCBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHRyYW5zZmVyU3ludGF4VUlETGFiZWwoKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RyYW5zZmVyU3ludGF4VUlEKSB7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuOTAnOlxyXG4gICAgICAgIHJldHVybiAnSlBFRyAyMDAwIExvc3NsZXNzJztcclxuICAgICAgY2FzZSAnMS4yLjg0MC4xMDAwOC4xLjIuNC45MSc6XHJcbiAgICAgICAgcmV0dXJuICdKUEVHIDIwMDAgTG9zc3knO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjU3JzpcclxuICAgICAgICByZXR1cm4gJ0pQRUcgTG9zc2xlc3MsIE5vbmhpZXJhcmNoaWNhbCAoUHJvY2Vzc2VzIDE0KSc7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yLjQuNzAnOlxyXG4gICAgICAgIHJldHVybiAnSlBFRyBMb3NzbGVzcywgTm9uaGllcmFyY2hpY2FsIChQcm9jZXNzZXMgMTQgW1NlbGVjdGlvbiAxXSknO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjUwJzpcclxuICAgICAgICByZXR1cm4gJ0pQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAxICg4IGJpdCknO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi40LjUxJzpcclxuICAgICAgICByZXR1cm4gJ0pQRUcgQmFzZWxpbmUgbG9zc3kgcHJvY2VzcyAyICYgNCAoMTIgYml0KSc7XHJcbiAgICAgIGNhc2UgJzEuMi44NDAuMTAwMDguMS4yJzpcclxuICAgICAgICByZXR1cm4gJ0ltcGxpY2l0IFZSIExpdHRsZSBFbmRpYW4nO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi4xJzpcclxuICAgICAgICByZXR1cm4gJ0V4cGxpY2l0IFZSIExpdHRsZSBFbmRpYW4nO1xyXG4gICAgICBjYXNlICcxLjIuODQwLjEwMDA4LjEuMi4yJzpcclxuICAgICAgICByZXR1cm4gJ0V4cGxpY2l0IFZSIEJpZyBFbmRpYW4nO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBgVW5rbm93biB0cmFuc2ZlcnN5bnRheDogJHt0aGlzLl90cmFuc2ZlclN5bnRheFVJRH1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3R1ZHkgZGVzY3JpcGl0aW9uIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBzdHVkeURlc2NyaXB0aW9uXHJcbiAgICovXHJcbiAgc2V0IHN0dWR5RGVzY3JpcHRpb24oc3R1ZHlEZXNjcmlwdGlvbikge1xyXG4gICAgdGhpcy5fc3R1ZHlEZXNjcmlwdGlvbiA9IHN0dWR5RGVzY3JpcHRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHVkeSBkZXNjcmlwdGlvbiBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHN0dWR5RGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3R1ZHlEZXNjcmlwdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcmllcyBkZXNjcmlwaXRpb24gc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHNlcmllc0Rlc2NyaXB0aW9uXHJcbiAgICovXHJcbiAgc2V0IHNlcmllc0Rlc2NyaXB0aW9uKHNlcmllc0Rlc2NyaXB0aW9uKSB7XHJcbiAgICB0aGlzLl9zZXJpZXNEZXNjcmlwdGlvbiA9IHNlcmllc0Rlc2NyaXB0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VyaWVzIGRlc2NyaXB0aW9uIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgc2VyaWVzRGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzRGVzY3JpcHRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IElEIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBwYXRpZW50SURcclxuICAgKi9cclxuICBzZXQgcGF0aWVudElEKHBhdGllbnRJRCkge1xyXG4gICAgdGhpcy5fcGF0aWVudElEID0gcGF0aWVudElEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBJRCBnZXR0ZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGllbnRJRCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXRpZW50SUQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IG5hbWUgc2V0dGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHBhdGllbnROYW1lXHJcbiAgICovXHJcbiAgc2V0IHBhdGllbnROYW1lKHBhdGllbnROYW1lKSB7XHJcbiAgICB0aGlzLl9wYXRpZW50TmFtZSA9IHBhdGllbnROYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBuYW1lIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgcGF0aWVudE5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF0aWVudE5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IGFnZSBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudEFnZVxyXG4gICAqL1xyXG4gIHNldCBwYXRpZW50QWdlKHBhdGllbnRBZ2UpIHtcclxuICAgIHRoaXMuX3BhdGllbnRBZ2UgPSBwYXRpZW50QWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBhZ2UgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBwYXRpZW50QWdlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnRBZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IGJpcnRoZGF0ZSBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudEJpcnRoZGF0ZVxyXG4gICAqL1xyXG4gIHNldCBwYXRpZW50QmlydGhkYXRlKHBhdGllbnRCaXJ0aGRhdGUpIHtcclxuICAgIHRoaXMuX3BhdGllbnRCaXJ0aGRhdGUgPSBwYXRpZW50QmlydGhkYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBiaXJ0aGRhdGUgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBwYXRpZW50QmlydGhkYXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnRCaXJ0aGRhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IHNleCBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcGF0aWVudFNleFxyXG4gICAqL1xyXG4gIHNldCBwYXRpZW50U2V4KHBhdGllbnRTZXgpIHtcclxuICAgIHRoaXMuX3BhdGllbnRTZXggPSBwYXRpZW50U2V4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBzZXggZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBwYXRpZW50U2V4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdGllbnRTZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOdW1iZXIgb2YgZnJhbWVzIHNldHRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBudW1iZXJPZkZyYW1lc1xyXG4gICAqL1xyXG4gIHNldCBudW1iZXJPZkZyYW1lcyhudW1iZXJPZkZyYW1lcykge1xyXG4gICAgdGhpcy5fbnVtYmVyT2ZGcmFtZXMgPSBudW1iZXJPZkZyYW1lcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE51bWJlciBvZiBmcmFtZXMgZ2V0dGVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBudW1iZXJPZkZyYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9udW1iZXJPZkZyYW1lcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE51bWJlciBvZiBjaGFubmVscyBzZXR0ZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gbnVtYmVyT2ZDaGFubmVsc1xyXG4gICAqL1xyXG4gIHNldCBudW1iZXJPZkNoYW5uZWxzKG51bWJlck9mQ2hhbm5lbHMpIHtcclxuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSBudW1iZXJPZkNoYW5uZWxzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTnVtYmVyIG9mIGNoYW5uZWxzIGdldHRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBnZXQgbnVtYmVyT2ZDaGFubmVscygpIHtcclxuICAgIHJldHVybiB0aGlzLl9udW1iZXJPZkNoYW5uZWxzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHN0YWNrKHN0YWNrKSB7XHJcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xyXG4gIH1cclxuXHJcbiAgc2V0IG1vZGFsaXR5KG1vZGFsaXR5KSB7XHJcbiAgICB0aGlzLl9tb2RhbGl0eSA9IG1vZGFsaXR5O1xyXG4gIH1cclxuXHJcbiAgZ2V0IG1vZGFsaXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGFsaXR5O1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvblR5cGUoc2VnbWVudGF0aW9uVHlwZSkge1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IHNlZ21lbnRhdGlvblR5cGU7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VnbWVudGF0aW9uVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWdtZW50YXRpb25UeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKHNlZ21lbnRhdGlvblNlZ21lbnRzKSB7XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50cyA9IHNlZ21lbnRhdGlvblNlZ21lbnRzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNlZ21lbnRhdGlvblNlZ21lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzO1xyXG4gIH1cclxufVxyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IENvcmVDb2xvcnMgZnJvbSAnLi4vY29yZS9jb3JlLmNvbG9ycyc7XHJcbmltcG9ydCBDb3JlVXRpbHMgZnJvbSAnLi4vY29yZS9jb3JlLnV0aWxzJztcclxuaW1wb3J0IE1vZGVsc0Jhc2UgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5iYXNlJztcclxuXHJcbmNvbnN0IGJpbmFyeVN0cmluZyA9IHJlcXVpcmUoJ21hdGgtZmxvYXQzMi10by1iaW5hcnktc3RyaW5nJyk7XHJcblxyXG4vKipcclxuICogU3RhY2sgb2JqZWN0LlxyXG4gKlxyXG4gKiBAbW9kdWxlIG1vZGVscy9zdGFja1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzU3RhY2sgZXh0ZW5kcyBNb2RlbHNCYXNlIHtcclxuICAvKipcclxuICAgKiBNb2RlbHMgU3RhY2sgY29uc3RydWN0b3JcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fdWlkID0gbnVsbDtcclxuICAgIHRoaXMuX3N0YWNrSUQgPSAtMTtcclxuXHJcbiAgICB0aGlzLl9mcmFtZSA9IFtdO1xyXG4gICAgdGhpcy5fbnVtYmVyT2ZGcmFtZXMgPSAwO1xyXG5cclxuICAgIHRoaXMuX3Jvd3MgPSAwO1xyXG4gICAgdGhpcy5fY29sdW1ucyA9IDA7XHJcbiAgICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID0gMTtcclxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSA4O1xyXG4gICAgdGhpcy5fcGl4ZWxUeXBlID0gMDtcclxuICAgIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb24gPSAwO1xyXG5cclxuICAgIHRoaXMuX3RleHR1cmVTaXplID0gNDA5NjtcclxuICAgIHRoaXMuX25iVGV4dHVyZXMgPSA3O1xyXG4gICAgdGhpcy5fcmF3RGF0YSA9IFtdO1xyXG5cclxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IDA7XHJcbiAgICB0aGlzLl93aW5kb3dXaWR0aCA9IDA7XHJcblxyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gMTtcclxuICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQgPSAwO1xyXG5cclxuICAgIHRoaXMuX21pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcclxuXHJcbiAgICAvLyBUUkFOU0ZPUk1BVElPTiBNQVRSSUNFU1xyXG4gICAgdGhpcy5fcmVnTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbiAgICB0aGlzLl9pamsyTFBTID0gbnVsbDtcclxuICAgIHRoaXMuX2xwczJJSksgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2FhYmIyTFBTID0gbnVsbDtcclxuICAgIHRoaXMuX2xwczJBQUJCID0gbnVsbDtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gSUpLIGRpbWVuc2lvbnNcclxuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPSBudWxsO1xyXG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnNJSksgPSBudWxsO1xyXG4gICAgdGhpcy5fc3BhY2luZyA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpO1xyXG4gICAgdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMgPSAwO1xyXG4gICAgdGhpcy5fc2xpY2VUaGlja25lc3MgPSAwO1xyXG4gICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcclxuICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX3hDb3NpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKTtcclxuICAgIHRoaXMuX3lDb3NpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKTtcclxuICAgIHRoaXMuX3pDb3NpbmUgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcclxuXHJcbiAgICAvLyBjb252ZW5pZW5jZSB2YXJzXHJcbiAgICB0aGlzLl9wcmVwYXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGFja2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wYWNrZWRQZXJQaXhlbCA9IDE7XHJcblxyXG4gICAgLy9cclxuICAgIHRoaXMuX21vZGFsaXR5ID0gJ01vZGFsaXR5IG5vdCBzZXQnO1xyXG5cclxuICAgIC8vIFNFR01FTlRBVElPTiBTVFVGRlxyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uVHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uRGVmYXVsdENvbG9yID0gWzYzLCAxNzQsIDEyOF07XHJcbiAgICB0aGlzLl9mcmFtZVNlZ21lbnQgPSBbXTtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVCA9IFtdO1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uTFVUTyA9IFtdO1xyXG5cclxuICAgIC8vIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gTW9ub2Nocm9tZTEgVlMgTW9ub2Nocm9tZTJcclxuICAgIHRoaXMuX2ludmVydCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJlcGFyZSBzZWdtZW50YXRpb24gc3RhY2suXHJcbiAgICogQSBzZWdtZW50YXRpb24gc3RhY2sgY2FuIGhvbGQgeCBmcmFtZXMgdGhhdCBhcmUgYXQgdGhlIHNhbWUgbG9jYXRpb25cclxuICAgKiBidXQgc2VnbWVudGF0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uOlxyXG4gICAqIC0gRnJhbWUgWCBjb250YWlucyB2b3hlbHMgZm9yIHNlZ21lbnRhdGlvbiBBLlxyXG4gICAqIC0gRnJhbWUgWSBjb250YWlucyB2b3hlbHMgZm9yIHNlZ21lbnR0YXRpb24gQi5cclxuICAgKiAtIEZyYW1lIFggYW5kIFkgYXJlIGF0IHRoZSBzYW1lIGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogV2UgY3VycmVudGx5IG1lcmdlIG92ZXJsYXBpbmcgZnJhbWVzIGludG8gMS5cclxuICAgKi9cclxuICBwcmVwYXJlU2VnbWVudGF0aW9uKCkge1xyXG4gICAgLy8gc3RvcmUgZnJhbWUgYW5kIGRvIHNwZWNpYWwgcHJlLXByb2Nlc3NpbmdcclxuICAgIHRoaXMuX2ZyYW1lU2VnbWVudCA9IHRoaXMuX2ZyYW1lO1xyXG4gICAgbGV0IG1lcmdlZEZyYW1lcyA9IFtdO1xyXG5cclxuICAgIC8vIG9yZGVyIGZyYW1lc1xyXG4gICAgdGhpcy5jb21wdXRlQ29zaW5lcygpO1xyXG4gICAgdGhpcy5fZnJhbWUubWFwKHRoaXMuX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwLmJpbmQobnVsbCwgdGhpcy5fekNvc2luZSkpO1xyXG4gICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0RGlzdGFuY2VBcnJheVNvcnQpO1xyXG5cclxuICAgIC8vIG1lcmdlIGZyYW1lc1xyXG4gICAgbGV0IHByZXZJbmRleCA9IC0xO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGk8dGhpcy5fZnJhbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFtZXJnZWRGcmFtZXNbcHJldkluZGV4XSB8fFxyXG4gICAgICAgICAgbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX2Rpc3QgIT0gdGhpcy5fZnJhbWVbaV0uX2Rpc3QpIHtcclxuICAgICAgICBtZXJnZWRGcmFtZXMucHVzaCh0aGlzLl9mcmFtZVtpXSk7XHJcbiAgICAgICAgcHJldkluZGV4Kys7XHJcblxyXG4gICAgICAgIC8vIFNjYWxlIGZyYW1lXHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBlYWNoIGZyYW1lIGNvbnRhaW5zIGJpbmFyeSBkYXRhIGFib3V0IGEgc2VnbWVudGF0aW9uLlxyXG4gICAgICAgIC8vIHdlIHNjYWxlIGl0IGJ5IHRoZSByZWZlcmVuY2VTZWdtZW50TnVtYmVyIGluIG9yZGVyIHRvIGhhdmUgYVxyXG4gICAgICAgIC8vIHNlZ21lbnRhdGlvbiBzcGVjaWZpYyB2b3hlbCB2YWx1ZSByYXRoZXIgdGhhbiAwIG9yIDEuXHJcbiAgICAgICAgLy8gVGhhdCBhbGxvd3MgdXMgdG8gbWVyZ2UgZnJhbWVzIGxhdGVyIG9uLlxyXG4gICAgICAgIC8vIElmIHdlIG1lcmdlIGZyYW1lcyB3aXRob3V0IHNjYWxpbmcsIHRoZW4gd2UgY2FuIG5vdCBkaWZmZXJlbmNpYXRlXHJcbiAgICAgICAgLy8gdm94ZWxzIGZyb20gc2VnbWVudGF0aW9uIEEgb3IgQiBhcyB0aGUgdmFsdWUgaXMgMCBvciAxIGluIGJvdGggY2FzZXMuXHJcbiAgICAgICAgZm9yIChcclxuICAgICAgICAgIGxldCBrPTA7XHJcbiAgICAgICAgICBrPG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9yb3dzICogbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX2NvbHVtbnM7XHJcbiAgICAgICAgICBrKyspIHtcclxuICAgICAgICAgIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGFba10gKj1cclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVbaV0uX3JlZmVyZW5jZWRTZWdtZW50TnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmcmFtZSBhbHJlYWR5IGV4c2l0cyBhdCB0aGlzIGxvY2F0aW9uLlxyXG4gICAgICAgIC8vIG1lcmdlIGRhdGEgZnJvbSB0aGlzIHNlZ21lbnRhdGlvbiBpbnRvIGV4aXN0aW5nIGZyYW1lXHJcbiAgICAgICAgZm9yIChcclxuICAgICAgICAgIGxldCBrPTA7XHJcbiAgICAgICAgICBrPG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9yb3dzICogbWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX2NvbHVtbnM7XHJcbiAgICAgICAgICBrKyspIHtcclxuICAgICAgICAgIG1lcmdlZEZyYW1lc1twcmV2SW5kZXhdLl9waXhlbERhdGFba10gKz1cclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVbaV0ucGl4ZWxEYXRhW2tdICpcclxuICAgICAgICAgICAgICB0aGlzLl9mcmFtZVtpXS5fcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtZXJnZWRGcmFtZXNbcHJldkluZGV4XS5taW5NYXggPVxyXG4gICAgICAgIENvcmVVdGlscy5taW5NYXgobWVyZ2VkRnJhbWVzW3ByZXZJbmRleF0uX3BpeGVsRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IHNlZ21lbnRzXHJcbiAgICBsZXQgZGljdCA9IHt9O1xyXG4gICAgbGV0IG1heCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaTx0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtYXggPVxyXG4gICAgICAgIE1hdGgubWF4KFxyXG4gICAgICAgICAgbWF4LCBwYXJzZUludCh0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50c1tpXS5zZWdtZW50TnVtYmVyLCAxMCkpO1xyXG5cclxuICAgICAgbGV0IGNvbG9yID0gdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHNbaV0ucmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiO1xyXG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcclxuICAgICAgICBkaWN0W3RoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzW2ldLnNlZ21lbnROdW1iZXJdID1cclxuICAgICAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkRlZmF1bHRDb2xvcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkaWN0W3RoaXMuX3NlZ21lbnRhdGlvblNlZ21lbnRzW2ldLnNlZ21lbnROdW1iZXJdID1cclxuICAgICAgICAgIENvcmVDb2xvcnMuY2llbGFiMlJHQiguLi5jb2xvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBMVVRzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXg7IGkrKykge1xyXG4gICAgICBsZXQgaW5kZXggPSBpIC8gbWF4O1xyXG4gICAgICBsZXQgb3BhY2l0eSA9IGkgPyAxIDogMDtcclxuICAgICAgbGV0IHJnYiA9IFswLCAwLCAwXTtcclxuICAgICAgaWYgKGRpY3QuaGFzT3duUHJvcGVydHkoaS50b1N0cmluZygpKSkge1xyXG4gICAgICAgIHJnYiA9IGRpY3RbaS50b1N0cmluZygpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmdiWzBdIC89IDI1NTtcclxuICAgICAgcmdiWzFdIC89IDI1NTtcclxuICAgICAgcmdiWzJdIC89IDI1NTtcclxuXHJcbiAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVC5wdXNoKFtpbmRleCwgLi4ucmdiXSk7XHJcbiAgICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8ucHVzaChbaW5kZXgsIG9wYWNpdHldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mcmFtZSA9IG1lcmdlZEZyYW1lcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgY29zaW5lc1xyXG4gICAqIE9yZGVyIGZyYW1lc1xyXG4gICAqIGNvbXB1dGVTcGFjaW5nXHJcbiAgICogc2FuaXR5Q2hlY2tcclxuICAgKiBpbml0IHNvbWUgdmFyc1xyXG4gICAqIGNvbXB1dGUgbWluL21heFxyXG4gICAqIGNvbXB1dGUgdHJhbnNmb3JtYXRpb24gbWF0cmljZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcHJlcGFyZSgpIHtcclxuICAgIC8vIGlmIHNlZ21lbnRhdGlvbiwgbWVyZ2Ugc29tZSBmcmFtZXMuLi5cclxuICAgIGlmICh0aGlzLl9tb2RhbGl0eSA9PT0gJ1NFRycpIHtcclxuICAgICAgdGhpcy5wcmVwYXJlU2VnbWVudGF0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgbmVlZCBhdCBsZWFzdCAxIGZyYW1lXHJcbiAgICBpZiAodGhpcy5fZnJhbWUgJiYgdGhpcy5fZnJhbWUubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IHRoaXMuX2ZyYW1lLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnX2ZyYW1lIGRvZXNuXFwndCBjb250YWluIGFueXRoaW5nLi4uLicpO1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZnJhbWUpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGFzcyBwYXJhbWV0ZXJzIGZyb20gZnJhbWUgdG8gc3RhY2tcclxuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9mcmFtZVswXS5yb3dzO1xyXG4gICAgdGhpcy5fY29sdW1ucyA9IHRoaXMuX2ZyYW1lWzBdLmNvbHVtbnM7XHJcbiAgICB0aGlzLl9kaW1lbnNpb25zSUpLID1cclxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5fY29sdW1ucywgdGhpcy5fcm93cywgdGhpcy5fbnVtYmVyT2ZGcmFtZXMpO1xyXG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnNJSksgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy54IC8gMixcclxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy55IC8gMixcclxuICAgICAgdGhpcy5fZGltZW5zaW9uc0lKSy56IC8gMlxyXG4gICAgKTtcclxuICAgIHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzID0gdGhpcy5fZnJhbWVbMF0uc3BhY2luZ0JldHdlZW5TbGljZXM7XHJcbiAgICB0aGlzLl9zbGljZVRoaWNrbmVzcyA9IHRoaXMuX2ZyYW1lWzBdLnNsaWNlVGhpY2tuZXNzO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgZGlyZWN0aW9uIGNvc2luZXNcclxuICAgIHRoaXMuY29tcHV0ZUNvc2luZXMoKTtcclxuXHJcbiAgICAvLyBvcmRlciB0aGUgZnJhbWVzXHJcbiAgICB0aGlzLm9yZGVyRnJhbWVzKCk7XHJcblxyXG4gICAgLy8gY29tcHV0ZS9ndWVzcyBzcGFjaW5nXHJcbiAgICB0aGlzLmNvbXB1dGVTcGFjaW5nKCk7XHJcbiAgICAvLyBzZXQgZXh0cmEgdmFycyBpZiBudWxsc1xyXG4gICAgLy8gZG8gaXQgbm93IGJlY2F1c2UgYmVmb3JlIHdlIHdvdWxkIHRoaW5rIGltYWdlIHBvc2l0aW9uL29yaWVudGF0aW9uXHJcbiAgICAvLyBhcmUgZGVmaW5lZCBhbmQgd2Ugd291bGQgdXNlIGl0IHRvIGNvbXB1dGUgc3BhY2luZy5cclxuICAgIGlmICghdGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbikge1xyXG4gICAgICB0aGlzLl9mcmFtZVswXS5pbWFnZVBvc2l0aW9uID0gWzAsIDAsIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9mcmFtZVswXS5pbWFnZU9yaWVudGF0aW9uKSB7XHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmltYWdlT3JpZW50YXRpb24gPSBbMSwgMCwgMCwgMCwgMSwgMF07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fYXJyYXlUb1ZlY3RvcjModGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbiwgMCk7XHJcblxyXG4gICAgLy8gY29tcHV0ZSB0cmFuc2Zvcm1zXHJcbiAgICB0aGlzLmNvbXB1dGVJSksyTFBTKCk7XHJcblxyXG4gICAgdGhpcy5jb21wdXRlTFBTMkFBQkIoKTtcclxuICAgIC8vIHRoaXMucGFja0VjaG9zKCk7XHJcblxyXG4gICAgdGhpcy5fcmVzY2FsZVNsb3BlID0gdGhpcy5fZnJhbWVbMF0ucmVzY2FsZVNsb3BlIHx8IDE7XHJcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gdGhpcy5fZnJhbWVbMF0ucmVzY2FsZUludGVyY2VwdCB8fCAwO1xyXG5cclxuICAgIC8vIHJlc2NhbGUvc2xvcGUgbWluIG1heFxyXG4gICAgdGhpcy5jb21wdXRlTWluTWF4SW50ZW5zaXRpZXMoKTtcclxuICAgIHRoaXMuX21pbk1heFswXSA9IE1vZGVsc1N0YWNrLnZhbHVlUmVzY2FsZVNsb3BlSW50ZXJjZXB0KFxyXG4gICAgICB0aGlzLl9taW5NYXhbMF0sXHJcbiAgICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSxcclxuICAgICAgdGhpcy5fcmVzY2FsZUludGVyY2VwdCk7XHJcbiAgICB0aGlzLl9taW5NYXhbMV0gPSBNb2RlbHNTdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdChcclxuICAgICAgdGhpcy5fbWluTWF4WzFdLFxyXG4gICAgICB0aGlzLl9yZXNjYWxlU2xvcGUsXHJcbiAgICAgIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQpO1xyXG5cclxuICAgIGxldCB3aWR0aCA9IHRoaXMuX2ZyYW1lWzBdLndpbmRvd1dpZHRoIHx8IHRoaXMuX21pbk1heFsxXSAtIHRoaXMuX21pbk1heFswXTtcclxuICAgIHRoaXMuX3dpbmRvd1dpZHRoID0gdGhpcy5fcmVzY2FsZVNsb3BlICogd2lkdGggKyB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0O1xyXG5cclxuICAgIGxldCBjZW50ZXIgPSB0aGlzLl9mcmFtZVswXS53aW5kb3dDZW50ZXIgfHwgdGhpcy5fbWluTWF4WzBdICsgd2lkdGggLyAyO1xyXG4gICAgdGhpcy5fd2luZG93Q2VudGVyID0gdGhpcy5fcmVzY2FsZVNsb3BlICogY2VudGVyICsgdGhpcy5fcmVzY2FsZUludGVyY2VwdDtcclxuXHJcbiAgICB0aGlzLl9iaXRzQWxsb2NhdGVkID0gdGhpcy5fZnJhbWVbMF0uYml0c0FsbG9jYXRlZDtcclxuICAgIHRoaXMuX3ByZXBhcmVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHBhY2tFY2hvcygpIHtcclxuICAgIC8vIDQgZWNobyB0aW1lcy4uLlxyXG4gICAgbGV0IGVjaG9zID0gNDtcclxuICAgIGxldCBwYWNrZWRFY2hvID0gW107XHJcbiAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuX2ZyYW1lLmxlbmd0aDsgaSs9ZWNob3MpIHtcclxuICAgICAgbGV0IGZyYW1lID0gdGhpcy5fZnJhbWVbaV07XHJcbiAgICAgIGZvciAobGV0IGs9MDsgazx0aGlzLl9yb3dzICogdGhpcy5fY29sdW1uczsgaysrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaj0xOyBqPGVjaG9zOyBqKyspIHtcclxuICAgICAgICAgIGZyYW1lLnBpeGVsRGF0YVtrXSArPSB0aGlzLl9mcmFtZVtpK2pdLnBpeGVsRGF0YVtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhbWUucGl4ZWxEYXRhW2tdIC89IGVjaG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHBhY2tlZEVjaG8ucHVzaChmcmFtZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9mcmFtZSA9IHBhY2tlZEVjaG87XHJcbiAgICB0aGlzLl9udW1iZXJPZkZyYW1lcyA9IHRoaXMuX2ZyYW1lLmxlbmd0aDtcclxuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPVxyXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyh0aGlzLl9jb2x1bW5zLCB0aGlzLl9yb3dzLCB0aGlzLl9udW1iZXJPZkZyYW1lcyk7XHJcbiAgICB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSyA9IG5ldyBUSFJFRS5WZWN0b3IzKFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggLyAyLFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnkgLyAyLFxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnogLyAyXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gZnJhbWUuY29zaW5lcyAtIHJldHVybnMgYXJyYXkgW3gsIHksIHpdXHJcbiAgY29tcHV0ZUNvc2luZXMoKSB7XHJcbiAgICBpZiAodGhpcy5fZnJhbWUgJiZcclxuICAgICAgdGhpcy5fZnJhbWVbMF0pIHtcclxuICAgICAgbGV0IGNvc2luZXMgPSB0aGlzLl9mcmFtZVswXS5jb3NpbmVzKCk7XHJcbiAgICAgIHRoaXMuX3hDb3NpbmUgPSBjb3NpbmVzWzBdO1xyXG4gICAgICB0aGlzLl95Q29zaW5lID0gY29zaW5lc1sxXTtcclxuICAgICAgdGhpcy5fekNvc2luZSA9IGNvc2luZXNbMl07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvcmRlckZyYW1lcygpIHtcclxuICAgIC8vIG9yZGVyIHRoZSBmcmFtZXMgYmFzZWQgb24gdGhlaXJzIGRpbWVuc2lvbiBpbmRpY2VzXHJcbiAgICAvLyBmaXJzdCBpbmRleCBpcyB0aGUgbW9zdCBpbXBvcnRhbnQuXHJcbiAgICAvLyAxLDEsMSwxIHdpbGxsIGJlIGZpcnN0XHJcbiAgICAvLyAxLDEsMiwxIHdpbGwgYmUgbmV4dFxyXG4gICAgLy8gMSwxLDIsMyB3aWxsIGJlIG5leHRcclxuICAgIC8vIDEsMSwzLDEgd2lsIGJlIG5leHRcclxuICAgIGlmICh0aGlzLl9mcmFtZVswXS5kaW1lbnNpb25JbmRleFZhbHVlcykge1xyXG4gICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX29yZGVyRnJhbWVPbkRpbWVuc2lvbkluZGljZXNBcnJheVNvcnQpO1xyXG5cclxuICAgIC8vIGVsc2Ugb3JkZXIgd2l0aCBpbWFnZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb25cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmltYWdlUG9zaXRpb24gJiYgdGhpcy5fZnJhbWVbMF0uaW1hZ2VPcmllbnRhdGlvbiAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVsxXSAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVsxXS5pbWFnZVBvc2l0aW9uICYmIHRoaXMuX2ZyYW1lWzFdLmltYWdlT3JpZW50YXRpb24gJiZcclxuICAgICAgdGhpcy5fZnJhbWVbMF0uaW1hZ2VQb3NpdGlvbi5qb2luKCkgIT09IHRoaXMuX2ZyYW1lWzFdLmltYWdlUG9zaXRpb24uam9pbigpKSB7XHJcbiAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xyXG4gICAgICB0aGlzLl9mcmFtZS5tYXAodGhpcy5fY29tcHV0ZURpc3RhbmNlQXJyYXlNYXAuYmluZChudWxsLCB0aGlzLl96Q29zaW5lKSk7XHJcbiAgICAgIHRoaXMuX2ZyYW1lLnNvcnQodGhpcy5fc29ydERpc3RhbmNlQXJyYXlTb3J0KTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSBudWxsICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzFdICYmIHRoaXMuX2ZyYW1lWzFdLmluc3RhbmNlTnVtYmVyICE9PSBudWxsICYmXHJcbiAgICAgIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcikge1xyXG4gICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnRJbnN0YW5jZU51bWJlckFycmF5U29ydCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0aGlzLl9mcmFtZVswXS5zb3BJbnN0YW5jZVVJRCAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVsxXSAmJiB0aGlzLl9mcmFtZVsxXS5zb3BJbnN0YW5jZVVJRCAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVswXS5zb3BJbnN0YW5jZVVJRCAhPT0gdGhpcy5fZnJhbWVbMV0uc29wSW5zdGFuY2VVSUQpIHtcclxuICAgICAgdGhpcy5fZnJhbWUuc29ydCh0aGlzLl9zb3J0U29wSW5zdGFuY2VVSURBcnJheVNvcnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lWzBdKTtcclxuICAgICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lWzFdKTtcclxuICAgICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSBudWxsICYmIHRydWUpO1xyXG4gICAgICAvLyB3aW5kb3cuY29uc29sZS5sb2coXHJcbiAgICAgIC8vIHRoaXMuX2ZyYW1lWzBdLmluc3RhbmNlTnVtYmVyICE9PSB0aGlzLl9mcmFtZVsxXS5pbnN0YW5jZU51bWJlcik7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnZG8gbm90IGtub3cgaG93IHRvIG9yZGVyIHRoZSBmcmFtZXMuLi4nKTtcclxuICAgICAgLy8gZWxzZSBzbGljZSBsb2NhdGlvblxyXG4gICAgICAvLyBpbWFnZSBudW1iZXJcclxuICAgICAgLy8gT1JERVJJTkcgQkFTRUQgT04gaW5zdGFuY2UgbnVtYmVyXHJcbiAgICAgIC8vIF9vcmRlcmluZyA9ICdpbnN0YW5jZV9udW1iZXInO1xyXG4gICAgICAvLyBmaXJzdF9pbWFnZS5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgIC8vIHJldHVybiBhW1wiaW5zdGFuY2VfbnVtYmVyXCJdLWJbXCJpbnN0YW5jZV9udW1iZXJcIl19KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXB1dGVTcGFjaW5nKCkge1xyXG4gICAgdGhpcy54eVNwYWNpbmcoKTtcclxuICAgIHRoaXMuelNwYWNpbmcoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgc3RhY2sgeiBzcGFjaW5nXHJcbiAgICovXHJcbiAgelNwYWNpbmcoKSB7XHJcbiAgICBpZiAodGhpcy5fbnVtYmVyT2ZGcmFtZXMgPiAxKSB7XHJcbiAgICAgIGlmICh0aGlzLl9mcmFtZVswXS5waXhlbFNwYWNpbmcgJiYgdGhpcy5fZnJhbWVbMF0ucGl4ZWxTcGFjaW5nWzJdKSB7XHJcbiAgICAgICAgdGhpcy5fc3BhY2luZy56ID0gdGhpcy5fZnJhbWVbMF0ucGl4ZWxTcGFjaW5nWzJdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGNvbXB1dGUgYW5kIHNvcnQgYnkgZGlzdCBpbiB0aGlzIHNlcmllc1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lLm1hcChcclxuICAgICAgICAgIHRoaXMuX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwLmJpbmQobnVsbCwgdGhpcy5fekNvc2luZSkpO1xyXG5cclxuICAgICAgICAvLyBpZiBkaXN0YW5jZXMgYXJlIGRpZmZlcmVudCwgcmUtc29ydCBhcnJheVxyXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZVsxXS5kaXN0ICE9PSB0aGlzLl9mcmFtZVswXS5kaXN0KSB7XHJcbiAgICAgICAgICB0aGlzLl9mcmFtZS5zb3J0KHRoaXMuX3NvcnREaXN0YW5jZUFycmF5U29ydCk7XHJcbiAgICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9mcmFtZVsxXS5kaXN0IC0gdGhpcy5fZnJhbWVbMF0uZGlzdDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NwYWNpbmdCZXR3ZWVuU2xpY2VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZyYW1lWzBdLnNsaWNlVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgICB0aGlzLl9zcGFjaW5nLnogPSB0aGlzLl9mcmFtZVswXS5zbGljZVRoaWNrbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTcGFjaW5nXHJcbiAgICAvLyBjYW4gbm90IGJlIDAgaWYgbm90IG1hdHJpeCBjYW4gbm90IGJlIGludmVydGVkLlxyXG4gICAgaWYgKHRoaXMuX3NwYWNpbmcueiA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9zcGFjaW5nLnogPSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogIEZSQU1FIENBTiBETyBJVFxyXG4gICAqL1xyXG4gIHh5U3BhY2luZygpIHtcclxuICAgIGlmICh0aGlzLl9mcmFtZSAmJlxyXG4gICAgICB0aGlzLl9mcmFtZVswXSkge1xyXG4gICAgICBsZXQgc3BhY2luZ1hZID0gdGhpcy5fZnJhbWVbMF0uc3BhY2luZ1hZKCk7XHJcbiAgICAgIHRoaXMuX3NwYWNpbmcueCA9IHNwYWNpbmdYWVswXTtcclxuICAgICAgdGhpcy5fc3BhY2luZy55ID0gc3BhY2luZ1hZWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCBtaW4gYW5kIG1heCBpbnRlbnNpdGllcyBhbW9uZyBhbGwgZnJhbWVzLlxyXG4gICAqL1xyXG4gIGNvbXB1dGVNaW5NYXhJbnRlbnNpdGllcygpIHtcclxuICAgIC8vIHdoYXQgYWJvdXQgY29sb3JzISEhIT9cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZnJhbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gZ2V0IG1pbi9tYXhcclxuICAgICAgdGhpcy5fbWluTWF4WzBdID0gTWF0aC5taW4odGhpcy5fbWluTWF4WzBdLCB0aGlzLl9mcmFtZVtpXS5taW5NYXhbMF0pO1xyXG4gICAgICB0aGlzLl9taW5NYXhbMV0gPSBNYXRoLm1heCh0aGlzLl9taW5NYXhbMV0sIHRoaXMuX2ZyYW1lW2ldLm1pbk1heFsxXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIElKSyB0byBMUFMgYW5kIGludmVydCB0cmFuc2Zvcm1zXHJcbiAgICovXHJcbiAgY29tcHV0ZUlKSzJMUFMoKSB7XHJcbiAgICAvLyBpamsgdG8gbHBzXHJcbiAgICB0aGlzLl9pamsyTFBTID0gQ29yZVV0aWxzLmlqazJMUFMoXHJcbiAgICAgIHRoaXMuX3hDb3NpbmUsIHRoaXMuX3lDb3NpbmUsIHRoaXMuX3pDb3NpbmUsXHJcbiAgICAgIHRoaXMuX3NwYWNpbmcsIHRoaXMuX29yaWdpbixcclxuICAgICAgdGhpcy5fcmVnTWF0cml4XHJcbiAgICApO1xyXG5cclxuICAgIC8vIGxwcyAyIGlqa1xyXG4gICAgdGhpcy5fbHBzMklKSyA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcbiAgICB0aGlzLl9scHMySUpLLmdldEludmVyc2UodGhpcy5faWprMkxQUyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIExQUyB0byBBQUJCIGFuZCBpbnZlcnQgdHJhbnNmb3Jtc1xyXG4gICAqL1xyXG4gIGNvbXB1dGVMUFMyQUFCQigpIHtcclxuICAgIHRoaXMuX2FhYmIyTFBTID0gQ29yZVV0aWxzLmFhYmIyTFBTKFxyXG4gICAgICB0aGlzLl94Q29zaW5lLCB0aGlzLl95Q29zaW5lLCB0aGlzLl96Q29zaW5lLFxyXG4gICAgICB0aGlzLl9vcmlnaW5cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5fbHBzMkFBQkIgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4gICAgdGhpcy5fbHBzMkFBQkIuZ2V0SW52ZXJzZSh0aGlzLl9hYWJiMkxQUyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZXJnZSBzdGFja3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc3RhY2tcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgbWVyZ2Uoc3RhY2spIHtcclxuICAgIC8vIGFsc28gbWFrZSBzdXJlIHgveS96IGNvc2luZXMgYXJlIGEgbWF0Y2ghXHJcbiAgICBpZiAodGhpcy5fc3RhY2tJRCA9PT0gc3RhY2suc3RhY2tJRCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tZXJnZU1vZGVscyh0aGlzLl9mcmFtZSwgc3RhY2suZnJhbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFjayBjdXJyZW50IHN0YWNrIHBpeGVsIGRhdGEgaW50byA4IGJpdHMgYXJyYXkgYnVmZmVyc1xyXG4gICAqL1xyXG4gIHBhY2soKSB7XHJcbiAgICAvLyBHZXQgdG90YWwgbnVtYmVyIG9mIHZveGVsc1xyXG4gICAgY29uc3QgbmJWb3hlbHMgPVxyXG4gICAgICB0aGlzLl9kaW1lbnNpb25zSUpLLnggKiB0aGlzLl9kaW1lbnNpb25zSUpLLnkgKiB0aGlzLl9kaW1lbnNpb25zSUpLLno7XHJcblxyXG4gICAgLy8gUGFja2luZyBzdHlsZVxyXG4gICAgaWYgKHRoaXMuX2JpdHNBbGxvY2F0ZWQgPT09IDE2ICYmIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPT09IDEpIHtcclxuICAgICAgdGhpcy5fcGFja2VkUGVyUGl4ZWwgPSAyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHRleHR1cmVzIHdlIG5lZWRcclxuICAgIGNvbnN0IHRleHR1cmVEaW1lbnNpb24gPSB0aGlzLl90ZXh0dXJlU2l6ZSAqIHRoaXMuX3RleHR1cmVTaXplO1xyXG4gICAgY29uc3QgcmVxdWlyZWRUZXh0dXJlcyA9XHJcbiAgICAgIE1hdGguY2VpbChuYlZveGVscyAvICh0ZXh0dXJlRGltZW5zaW9uICogdGhpcy5fcGFja2VkUGVyUGl4ZWwpKTtcclxuICAgIGxldCB2b3hlbEluZGV4U3RhcnQgPSAwO1xyXG4gICAgbGV0IHZveGVsSW5kZXhTdG9wID0gdGhpcy5fcGFja2VkUGVyUGl4ZWwgKiB0ZXh0dXJlRGltZW5zaW9uO1xyXG4gICAgaWYgKHZveGVsSW5kZXhTdG9wID4gbmJWb3hlbHMpIHtcclxuICAgICAgdm94ZWxJbmRleFN0b3AgPSBuYlZveGVscztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcmVxdWlyZWRUZXh0dXJlczsgaWkrKykge1xyXG4gICAgICBsZXQgcGFja2VkID1cclxuICAgICAgICB0aGlzLl9wYWNrVG84Qml0cyhcclxuICAgICAgICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMsXHJcbiAgICAgICAgICB0aGlzLl9mcmFtZSxcclxuICAgICAgICAgIHRoaXMuX3RleHR1cmVTaXplLFxyXG4gICAgICAgICAgdm94ZWxJbmRleFN0YXJ0LFxyXG4gICAgICAgICAgdm94ZWxJbmRleFN0b3ApO1xyXG4gICAgICB0aGlzLl90ZXh0dXJlVHlwZSA9IHBhY2tlZC50ZXh0dXJlVHlwZTtcclxuICAgICAgdGhpcy5fcmF3RGF0YS5wdXNoKHBhY2tlZC5kYXRhKTtcclxuXHJcbiAgICAgIHZveGVsSW5kZXhTdGFydCArPSB0aGlzLl9wYWNrZWRQZXJQaXhlbCAqIHRleHR1cmVEaW1lbnNpb247XHJcbiAgICAgIHZveGVsSW5kZXhTdG9wICs9IHRoaXMuX3BhY2tlZFBlclBpeGVsICogdGV4dHVyZURpbWVuc2lvbjtcclxuICAgICAgaWYgKHZveGVsSW5kZXhTdG9wID4gbmJWb3hlbHMpIHtcclxuICAgICAgICB2b3hlbEluZGV4U3RvcCA9IG5iVm94ZWxzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGFja2VkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhY2sgZnJhbWUgZGF0YSB0byAzMiBiaXRzIHRleHR1cmVcclxuICAgKiBAcGFyYW0geyp9IGNoYW5uZWxzXHJcbiAgICogQHBhcmFtIHsqfSBmcmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gdGV4dHVyZVNpemVcclxuICAgKiBAcGFyYW0geyp9IHN0YXJ0Vm94ZWxcclxuICAgKiBAcGFyYW0geyp9IHN0b3BWb3hlbFxyXG4gICAqL1xyXG4gIF9wYWNrVG84Qml0cyhjaGFubmVscywgZnJhbWUsIHRleHR1cmVTaXplLCBzdGFydFZveGVsLCBzdG9wVm94ZWwpIHtcclxuICAgIGNvbnN0IHBhY2tlZCA9IHtcclxuICAgICAgdGV4dHVyZVR5cGU6IG51bGwsXHJcbiAgICAgIGRhdGE6IG51bGwsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGJpdHNBbGxvY2F0ZWQgPSBmcmFtZVswXS5iaXRzQWxsb2NhdGVkO1xyXG4gICAgY29uc3QgcGl4ZWxUeXBlID0gZnJhbWVbMF0ucGl4ZWxUeXBlO1xyXG5cclxuICAgIC8vIHRyYW5zZm9ybSBzaWduZWQgdG8gdW5zaWduZWQgZm9yIGNvbnZlbmllbmNlXHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGlmICh0aGlzLl9taW5NYXhbMF0gPCAwKSB7XHJcbiAgICAgIG9mZnNldCAtPSB0aGlzLl9taW5NYXhbMF07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBhY2tJbmRleCA9IDA7XHJcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XHJcbiAgICBsZXQgaW5GcmFtZUluZGV4ID0gMDtcclxuICAgIC8vIGZyYW1lIHNob3VsZCByZXR1cm4gaXQhXHJcbiAgICBjb25zdCBmcmFtZURpbWVuc2lvbiA9IGZyYW1lWzBdLnJvd3MgKiBmcmFtZVswXS5jb2x1bW5zO1xyXG5cclxuICAgIGlmIChiaXRzQWxsb2NhdGVkID09PSA4ICYmIGNoYW5uZWxzID09PSAxIHx8IGJpdHNBbGxvY2F0ZWQgPT09IDEpIHtcclxuICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMSk7XHJcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgZGF0YVtwYWNrSW5kZXhdID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XHJcbiAgICAgICAgcGFja0luZGV4Kys7XHJcbiAgICAgIH1cclxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0O1xyXG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDE2ICYmIGNoYW5uZWxzID09PSAxKSB7XHJcbiAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZSAqIDQpO1xyXG4gICAgICBsZXQgY29vcmRpbmF0ZSA9IDA7XHJcbiAgICAgIGxldCBjaGFubmVsT2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydFZveGVsOyBpIDwgc3RvcFZveGVsOyBpKyspIHtcclxuICAgICAgICBmcmFtZUluZGV4ID0gfn4oaSAvIGZyYW1lRGltZW5zaW9uKTtcclxuICAgICAgICBpbkZyYW1lSW5kZXggPSBpICUgKGZyYW1lRGltZW5zaW9uKTtcclxuXHJcblxyXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuICAgICAgICBkYXRhWzQgKiBjb29yZGluYXRlICsgMiAqIGNoYW5uZWxPZmZzZXRdID0gcmF3ICYgMHgwMEZGO1xyXG4gICAgICAgIGRhdGFbNCAqIGNvb3JkaW5hdGUgKyAyICogY2hhbm5lbE9mZnNldCArIDFdID0gKHJhdyA+Pj4gOCkgJiAweDAwRkY7XHJcblxyXG4gICAgICAgIHBhY2tJbmRleCsrO1xyXG4gICAgICAgIGNvb3JkaW5hdGUgPSBNYXRoLmZsb29yKHBhY2tJbmRleCAvIDIpO1xyXG4gICAgICAgIGNoYW5uZWxPZmZzZXQgPSBwYWNrSW5kZXggJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xyXG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDMyICYmIGNoYW5uZWxzID09PSAxICYmIHBpeGVsVHlwZSA9PT0gMCkge1xyXG4gICAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVTaXplICogdGV4dHVyZVNpemUgKiA0KTtcclxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Vm94ZWw7IGkgPCBzdG9wVm94ZWw7IGkrKykge1xyXG4gICAgICAgIGZyYW1lSW5kZXggPSB+fihpIC8gZnJhbWVEaW1lbnNpb24pO1xyXG4gICAgICAgIGluRnJhbWVJbmRleCA9IGkgJSAoZnJhbWVEaW1lbnNpb24pO1xyXG5cclxuICAgICAgICBsZXQgcmF3ID0gb2Zmc2V0ICsgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhW2luRnJhbWVJbmRleF07XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4XSA9IHJhdyAmIDB4MDAwMDAwRkY7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSAocmF3ID4+PiA4KSAmIDB4MDAwMDAwRkY7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMl0gPSAocmF3ID4+PiAxNikgJiAweDAwMDAwMEZGO1xyXG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleCArIDNdID0gKHJhdyA+Pj4gMjQpICYgMHgwMDAwMDBGRjtcclxuXHJcbiAgICAgICAgcGFja0luZGV4Kys7XHJcbiAgICAgIH1cclxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCQUZvcm1hdDtcclxuICAgICAgcGFja2VkLmRhdGEgPSBkYXRhO1xyXG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMiAmJiBjaGFubmVscyA9PT0gMSAmJiBwaXhlbFR5cGUgPT09IDEpIHtcclxuICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogNCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XHJcbiAgICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XHJcbiAgICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XHJcblxyXG4gICAgICAgIGxldCByYXcgPSBvZmZzZXQgKyBmcmFtZVtmcmFtZUluZGV4XS5waXhlbERhdGFbaW5GcmFtZUluZGV4XTtcclxuICAgICAgICBsZXQgYml0U3RyaW5nID0gYmluYXJ5U3RyaW5nKHJhdyk7XHJcbiAgICAgICAgbGV0IGJpdFN0cmluZ0FycmF5ID0gYml0U3RyaW5nLm1hdGNoKC8uezEsOH0vZyk7XHJcblxyXG4gICAgICAgIGRhdGFbNCAqIHBhY2tJbmRleF0gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVswXSwgMik7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMV0gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVsxXSwgMik7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgMl0gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVsyXSwgMik7XHJcbiAgICAgICAgZGF0YVs0ICogcGFja0luZGV4ICsgM10gPSBwYXJzZUludChiaXRTdHJpbmdBcnJheVszXSwgMik7XHJcblxyXG4gICAgICAgIHBhY2tJbmRleCsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWNrZWQudGV4dHVyZVR5cGUgPSBUSFJFRS5SR0JBRm9ybWF0O1xyXG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgICB9IGVsc2UgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDggJiYgY2hhbm5lbHMgPT09IDMpIHtcclxuICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlU2l6ZSAqIHRleHR1cmVTaXplICogMyk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRWb3hlbDsgaSA8IHN0b3BWb3hlbDsgaSsrKSB7XHJcbiAgICAgICAgZnJhbWVJbmRleCA9IH5+KGkgLyBmcmFtZURpbWVuc2lvbik7XHJcbiAgICAgICAgaW5GcmFtZUluZGV4ID0gaSAlIChmcmFtZURpbWVuc2lvbik7XHJcblxyXG4gICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleF0gPVxyXG4gICAgICAgICAgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXhdO1xyXG4gICAgICAgIGRhdGFbMyAqIHBhY2tJbmRleCArIDFdID1cclxuICAgICAgICAgIGZyYW1lW2ZyYW1lSW5kZXhdLnBpeGVsRGF0YVszICogaW5GcmFtZUluZGV4ICsgMV07XHJcbiAgICAgICAgZGF0YVszICogcGFja0luZGV4ICsgMl0gPVxyXG4gICAgICAgICAgZnJhbWVbZnJhbWVJbmRleF0ucGl4ZWxEYXRhWzMgKiBpbkZyYW1lSW5kZXggKyAyXTtcclxuICAgICAgICBwYWNrSW5kZXgrKztcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFja2VkLnRleHR1cmVUeXBlID0gVEhSRUUuUkdCRm9ybWF0O1xyXG4gICAgICBwYWNrZWQuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhY2tlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhY2sgd29ybGQgY2VudGVyXHJcbiAgICpcclxuICAgKkByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgd29ybGRDZW50ZXIoKSB7XHJcbiAgICBsZXQgY2VudGVyID0gdGhpcy5faGFsZkRpbWVuc2lvbnNJSksuY2xvbmUoKS5hZGRTY2FsYXIoLTAuNSlcclxuICAgICAgLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKTtcclxuICAgIHJldHVybiBjZW50ZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YWNrIHdvcmxkIGJvdW5kaW5nIGJveFxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgd29ybGRCb3VuZGluZ0JveCgpIHtcclxuICAgIGxldCBiYm94ID0gW1xyXG4gICAgICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLFxyXG4gICAgICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLFxyXG4gICAgICBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCBkaW1zID0gdGhpcy5fZGltZW5zaW9uc0lKSztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBkaW1zLng7IGkgKz0gZGltcy54KSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGRpbXMueTsgaiArPSBkaW1zLnkpIHtcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8PSBkaW1zLno7IGsgKz0gZGltcy56KSB7XHJcbiAgICAgICAgICBsZXQgd29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMyhpLCBqLCBrKS5hcHBseU1hdHJpeDQodGhpcy5faWprMkxQUyk7XHJcbiAgICAgICAgICBiYm94ID0gW1xyXG4gICAgICAgICAgICBNYXRoLm1pbihiYm94WzBdLCB3b3JsZC54KSwgTWF0aC5tYXgoYmJveFsxXSwgd29ybGQueCksIC8vIHggbWluL21heFxyXG4gICAgICAgICAgICBNYXRoLm1pbihiYm94WzJdLCB3b3JsZC55KSwgTWF0aC5tYXgoYmJveFszXSwgd29ybGQueSksXHJcbiAgICAgICAgICAgIE1hdGgubWluKGJib3hbNF0sIHdvcmxkLnopLCBNYXRoLm1heChiYm94WzVdLCB3b3JsZC56KSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmJveDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBBQUJCIHNpemUgaW4gTFBTIHNwYWNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBBQUJCb3goKSB7XHJcbiAgICBsZXQgd29ybGQwID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5hZGRTY2FsYXIoLTAuNSlcclxuICAgICAgLmFwcGx5TWF0cml4NCh0aGlzLl9pamsyTFBTKVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KHRoaXMuX2xwczJBQUJCKTtcclxuXHJcbiAgICBsZXQgd29ybGQ3ID0gdGhpcy5fZGltZW5zaW9uc0lKSy5jbG9uZSgpLmFkZFNjYWxhcigtMC41KVxyXG4gICAgICAuYXBwbHlNYXRyaXg0KHRoaXMuX2lqazJMUFMpXHJcbiAgICAgIC5hcHBseU1hdHJpeDQodGhpcy5fbHBzMkFBQkIpO1xyXG5cclxuICAgIGxldCBtaW5CQm94ID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIE1hdGguYWJzKHdvcmxkMC54IC0gd29ybGQ3LngpLFxyXG4gICAgICBNYXRoLmFicyh3b3JsZDAueSAtIHdvcmxkNy55KSxcclxuICAgICAgTWF0aC5hYnMod29ybGQwLnogLSB3b3JsZDcueilcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG1pbkJCb3g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgQUFCQiBjZW50ZXIgaW4gTFBTIHNwYWNlXHJcbiAgICovXHJcbiAgY2VudGVyQUFCQm94KCkge1xyXG4gICAgbGV0IGNlbnRlckJCb3ggPSB0aGlzLndvcmxkQ2VudGVyKCk7XHJcbiAgICBjZW50ZXJCQm94LmFwcGx5TWF0cml4NCh0aGlzLl9scHMyQUFCQik7XHJcbiAgICByZXR1cm4gY2VudGVyQkJveDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBpbmRleEluRGltZW5zaW9ucyhpbmRleCwgZGltZW5zaW9ucykge1xyXG4gICAgaWYgKGluZGV4LnggPj0gMCAmJlxyXG4gICAgICAgICBpbmRleC55ID49IDAgJiZcclxuICAgICAgICAgaW5kZXgueiA+PSAwICYmXHJcbiAgICAgICAgIGluZGV4LnggPCBkaW1lbnNpb25zLnggJiZcclxuICAgICAgICAgaW5kZXgueSA8IGRpbWVuc2lvbnMueSAmJlxyXG4gICAgICAgICBpbmRleC56IDwgZGltZW5zaW9ucy56KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIF9hcnJheVRvVmVjdG9yMyhhcnJheSwgaW5kZXgpIHtcclxuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgYXJyYXlbaW5kZXhdLFxyXG4gICAgICBhcnJheVtpbmRleCArIDFdLFxyXG4gICAgICBhcnJheVtpbmRleCArIDJdXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICBfb3JkZXJGcmFtZU9uRGltZW5zaW9uSW5kaWNlc0FycmF5U29ydChhLCBiKSB7XHJcbiAgICBpZiAoJ2RpbWVuc2lvbkluZGV4VmFsdWVzJyBpbiBhICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhLmRpbWVuc2lvbkluZGV4VmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAnZGltZW5zaW9uSW5kZXhWYWx1ZXMnIGluIGIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIuZGltZW5zaW9uSW5kZXhWYWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5kaW1lbnNpb25JbmRleFZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwYXJzZUludChhLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkgPiBwYXJzZUludChiLmRpbWVuc2lvbkluZGV4VmFsdWVzW2ldLCAxMCkpIHtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyc2VJbnQoYS5kaW1lbnNpb25JbmRleFZhbHVlc1tpXSwgMTApIDwgcGFyc2VJbnQoYi5kaW1lbnNpb25JbmRleFZhbHVlc1tpXSwgMTApKSB7XHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coJ09uZSBvZiB0aGUgZnJhbWVzIGRvZXNuXFwndCBoYXZlIGEgZGltZW5zaW9uSW5kZXhWYWx1ZXMgYXJyYXkuJyk7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhKTtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKGIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgX2NvbXB1dGVEaXN0YW5jZUFycmF5TWFwKG5vcm1hbCwgZnJhbWUpIHtcclxuICAgIGZyYW1lLmRpc3QgPSBmcmFtZS5pbWFnZVBvc2l0aW9uWzBdICogbm9ybWFsLnggK1xyXG4gICAgICBmcmFtZS5pbWFnZVBvc2l0aW9uWzFdICogbm9ybWFsLnkgK1xyXG4gICAgICBmcmFtZS5pbWFnZVBvc2l0aW9uWzJdICogbm9ybWFsLno7XHJcbiAgICByZXR1cm4gZnJhbWU7XHJcbiAgfVxyXG5cclxuICBfc29ydERpc3RhbmNlQXJyYXlTb3J0KGEsIGIpIHtcclxuICAgIHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7XHJcbiAgfVxyXG4gIF9zb3J0SW5zdGFuY2VOdW1iZXJBcnJheVNvcnQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuaW5zdGFuY2VOdW1iZXIgLSBiLmluc3RhbmNlTnVtYmVyO1xyXG4gIH1cclxuICBfc29ydFNvcEluc3RhbmNlVUlEQXJyYXlTb3J0KGEsIGIpIHtcclxuICAgIHJldHVybiBhLnNvcEluc3RhbmNlVUlEIC0gYi5zb3BJbnN0YW5jZVVJRDtcclxuICB9XHJcblxyXG4gIHNldCBudW1iZXJPZkNoYW5uZWxzKG51bWJlck9mQ2hhbm5lbHMpIHtcclxuICAgIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPSBudW1iZXJPZkNoYW5uZWxzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IG51bWJlck9mQ2hhbm5lbHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZDaGFubmVscztcclxuICB9XHJcblxyXG4gIHNldCBmcmFtZShmcmFtZSkge1xyXG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcclxuICB9XHJcblxyXG4gIGdldCBmcmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcclxuICB9XHJcblxyXG4gIHNldCBwcmVwYXJlZChwcmVwYXJlZCkge1xyXG4gICAgdGhpcy5fcHJlcGFyZWQgPSBwcmVwYXJlZDtcclxuICB9XHJcblxyXG4gIGdldCBwcmVwYXJlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcmVwYXJlZDtcclxuICB9XHJcblxyXG4gIHNldCBwYWNrZWQocGFja2VkKSB7XHJcbiAgICB0aGlzLl9wYWNrZWQgPSBwYWNrZWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgcGFja2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhY2tlZDtcclxuICB9XHJcblxyXG4gIHNldCBwYWNrZWRQZXJQaXhlbChwYWNrZWRQZXJQaXhlbCkge1xyXG4gICAgdGhpcy5fcGFja2VkUGVyUGl4ZWwgPSBwYWNrZWRQZXJQaXhlbDtcclxuICB9XHJcblxyXG4gIGdldCBwYWNrZWRQZXJQaXhlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYWNrZWRQZXJQaXhlbDtcclxuICB9XHJcblxyXG4gIHNldCBkaW1lbnNpb25zSUpLKGRpbWVuc2lvbnNJSkspIHtcclxuICAgIHRoaXMuX2RpbWVuc2lvbnNJSksgPSBkaW1lbnNpb25zSUpLO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRpbWVuc2lvbnNJSksoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGltZW5zaW9uc0lKSztcclxuICB9XHJcblxyXG4gIHNldCBoYWxmRGltZW5zaW9uc0lKSyhoYWxmRGltZW5zaW9uc0lKSykge1xyXG4gICAgdGhpcy5faGFsZkRpbWVuc2lvbnNJSksgPSBoYWxmRGltZW5zaW9uc0lKSztcclxuICB9XHJcblxyXG4gIGdldCBoYWxmRGltZW5zaW9uc0lKSygpIHtcclxuICAgIHJldHVybiB0aGlzLl9oYWxmRGltZW5zaW9uc0lKSztcclxuICB9XHJcblxyXG4gIHNldCByZWdNYXRyaXgocmVnTWF0cml4KSB7XHJcbiAgICB0aGlzLl9yZWdNYXRyaXggPSByZWdNYXRyaXg7XHJcbiAgfVxyXG5cclxuICBnZXQgcmVnTWF0cml4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlZ01hdHJpeDtcclxuICB9XHJcblxyXG4gIHNldCBpamsyTFBTKGlqazJMUFMpIHtcclxuICAgIHRoaXMuX2lqazJMUFMgPSBpamsyTFBTO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlqazJMUFMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faWprMkxQUztcclxuICB9XHJcblxyXG4gIHNldCBscHMySUpLKGxwczJJSkspIHtcclxuICAgIHRoaXMuX2xwczJJSksgPSBscHMySUpLO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxwczJJSksoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbHBzMklKSztcclxuICB9XHJcblxyXG4gIHNldCBscHMyQUFCQihscHMyQUFCQikge1xyXG4gICAgdGhpcy5fbHBzMkFBQkIgPSBscHMyQUFCQjtcclxuICB9XHJcblxyXG4gIGdldCBscHMyQUFCQigpIHtcclxuICAgIHJldHVybiB0aGlzLl9scHMyQUFCQjtcclxuICB9XHJcblxyXG4gIHNldCB0ZXh0dXJlU2l6ZSh0ZXh0dXJlU2l6ZSkge1xyXG4gICAgdGhpcy5fdGV4dHVyZVNpemUgPSB0ZXh0dXJlU2l6ZTtcclxuICB9XHJcblxyXG4gIGdldCB0ZXh0dXJlU2l6ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU2l6ZTtcclxuICB9XHJcblxyXG4gIHNldCB0ZXh0dXJlVHlwZSh0ZXh0dXJlVHlwZSkge1xyXG4gICAgdGhpcy5fdGV4dHVyZVR5cGUgPSB0ZXh0dXJlVHlwZTtcclxuICB9XHJcblxyXG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlVHlwZTtcclxuICB9XHJcblxyXG4gIHNldCBiaXRzQWxsb2NhdGVkKGJpdHNBbGxvY2F0ZWQpIHtcclxuICAgIHRoaXMuX2JpdHNBbGxvY2F0ZWQgPSBiaXRzQWxsb2NhdGVkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGJpdHNBbGxvY2F0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYml0c0FsbG9jYXRlZDtcclxuICB9XHJcblxyXG4gIHNldCByYXdEYXRhKHJhd0RhdGEpIHtcclxuICAgIHRoaXMuX3Jhd0RhdGEgPSByYXdEYXRhO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHJhd0RhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmF3RGF0YTtcclxuICB9XHJcblxyXG4gIGdldCB3aW5kb3dXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLl93aW5kb3dXaWR0aDtcclxuICB9XHJcblxyXG4gIHNldCB3aW5kb3dXaWR0aCh3aW5kb3dXaWR0aCkge1xyXG4gICAgdGhpcy5fd2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcclxuICB9XHJcblxyXG4gIGdldCB3aW5kb3dDZW50ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2luZG93Q2VudGVyO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdpbmRvd0NlbnRlcih3aW5kb3dDZW50ZXIpIHtcclxuICAgIHRoaXMuX3dpbmRvd0NlbnRlciA9IHdpbmRvd0NlbnRlcjtcclxuICB9XHJcblxyXG4gIGdldCByZXNjYWxlU2xvcGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzY2FsZVNsb3BlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHJlc2NhbGVTbG9wZShyZXNjYWxlU2xvcGUpIHtcclxuICAgIHRoaXMuX3Jlc2NhbGVTbG9wZSA9IHJlc2NhbGVTbG9wZTtcclxuICB9XHJcblxyXG4gIGdldCByZXNjYWxlSW50ZXJjZXB0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc2NhbGVJbnRlcmNlcHQ7XHJcbiAgfVxyXG5cclxuICBzZXQgcmVzY2FsZUludGVyY2VwdChyZXNjYWxlSW50ZXJjZXB0KSB7XHJcbiAgICB0aGlzLl9yZXNjYWxlSW50ZXJjZXB0ID0gcmVzY2FsZUludGVyY2VwdDtcclxuICB9XHJcblxyXG4gIGdldCB4Q29zaW5lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3hDb3NpbmU7XHJcbiAgfVxyXG5cclxuICBzZXQgeENvc2luZSh4Q29zaW5lKSB7XHJcbiAgICB0aGlzLl94Q29zaW5lID0geENvc2luZTtcclxuICB9XHJcblxyXG4gIGdldCB5Q29zaW5lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3lDb3NpbmU7XHJcbiAgfVxyXG5cclxuICBzZXQgeUNvc2luZSh5Q29zaW5lKSB7XHJcbiAgICB0aGlzLl95Q29zaW5lID0geUNvc2luZTtcclxuICB9XHJcblxyXG4gIGdldCB6Q29zaW5lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3pDb3NpbmU7XHJcbiAgfVxyXG5cclxuICBzZXQgekNvc2luZSh6Q29zaW5lKSB7XHJcbiAgICB0aGlzLl96Q29zaW5lID0gekNvc2luZTtcclxuICB9XHJcblxyXG4gIGdldCBtaW5NYXgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgc2V0IG1pbk1heChtaW5NYXgpIHtcclxuICAgIHRoaXMuX21pbk1heCA9IG1pbk1heDtcclxuICB9XHJcblxyXG4gIGdldCBzdGFja0lEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrSUQ7XHJcbiAgfVxyXG5cclxuICBzZXQgc3RhY2tJRChzdGFja0lEKSB7XHJcbiAgICB0aGlzLl9zdGFja0lEID0gc3RhY2tJRDtcclxuICB9XHJcblxyXG4gIGdldCBwaXhlbFR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGl4ZWxUeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IHBpeGVsVHlwZShwaXhlbFR5cGUpIHtcclxuICAgIHRoaXMuX3BpeGVsVHlwZSA9IHBpeGVsVHlwZTtcclxuICB9XHJcblxyXG4gIGdldCBwaXhlbFJlcHJlc2VudGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BpeGVsUmVwcmVzZW50YXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgcGl4ZWxSZXByZXNlbnRhdGlvbihwaXhlbFJlcHJlc2VudGF0aW9uKSB7XHJcbiAgICB0aGlzLl9waXhlbFJlcHJlc2VudGF0aW9uID0gcGl4ZWxSZXByZXNlbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIHNldCBpbnZlcnQoaW52ZXJ0KSB7XHJcbiAgICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XHJcbiAgfVxyXG5cclxuICBnZXQgaW52ZXJ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludmVydDtcclxuICB9XHJcblxyXG4gIHNldCBtb2RhbGl0eShtb2RhbGl0eSkge1xyXG4gICAgdGhpcy5fbW9kYWxpdHkgPSBtb2RhbGl0eTtcclxuICB9XHJcblxyXG4gIGdldCBtb2RhbGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9tb2RhbGl0eTtcclxuICB9XHJcblxyXG4gIGdldCByaWdodEhhbmRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yaWdodEhhbmRlZDtcclxuICB9XHJcblxyXG4gIHNldCByaWdodEhhbmRlZChyaWdodEhhbmRlZCkge1xyXG4gICAgdGhpcy5fcmlnaHRIYW5kZWQgPSByaWdodEhhbmRlZDtcclxuICB9XHJcblxyXG4gIGdldCBzcGFjaW5nQmV0d2VlblNsaWNlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zcGFjaW5nQmV0d2VlblNsaWNlcztcclxuICB9XHJcblxyXG4gIHNldCBzcGFjaW5nQmV0d2VlblNsaWNlcyhzcGFjaW5nQmV0d2VlblNsaWNlcykge1xyXG4gICAgdGhpcy5fc3BhY2luZ0JldHdlZW5TbGljZXMgPSBzcGFjaW5nQmV0d2VlblNsaWNlcztcclxuICB9XHJcblxyXG4gIHNldCBzZWdtZW50YXRpb25TZWdtZW50cyhzZWdtZW50YXRpb25TZWdtZW50cykge1xyXG4gICAgdGhpcy5fc2VnbWVudGF0aW9uU2VnbWVudHMgPSBzZWdtZW50YXRpb25TZWdtZW50cztcclxuICB9XHJcblxyXG4gIGdldCBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWdtZW50YXRpb25TZWdtZW50cztcclxuICB9XHJcblxyXG4gIHNldCBzZWdtZW50YXRpb25UeXBlKHNlZ21lbnRhdGlvblR5cGUpIHtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvblR5cGUgPSBzZWdtZW50YXRpb25UeXBlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNlZ21lbnRhdGlvblR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uVHlwZTtcclxuICB9XHJcblxyXG4gIHNldCBzZWdtZW50YXRpb25MVVQoc2VnbWVudGF0aW9uTFVUKSB7XHJcbiAgICB0aGlzLl9zZWdtZW50YXRpb25MVVQgPSBzZWdtZW50YXRpb25MVVQ7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VnbWVudGF0aW9uTFVUKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRhdGlvbkxVVDtcclxuICB9XHJcblxyXG4gIHNldCBzZWdtZW50YXRpb25MVVRPKHNlZ21lbnRhdGlvbkxVVE8pIHtcclxuICAgIHRoaXMuX3NlZ21lbnRhdGlvbkxVVE8gPSBzZWdtZW50YXRpb25MVVRPO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNlZ21lbnRhdGlvbkxVVE8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudGF0aW9uTFVUTztcclxuICB9XHJcblxyXG4gIC8vIERFUFJFQ0FURUQgRlVOQ1RJT05cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWQgZm9yIGNvcmUudXRpbHMudmFsdWVcclxuICAgKlxyXG4gICAqIEdldCB2b3hlbCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc3RhY2tcclxuICAgKiBAcGFyYW0geyp9IGNvb3JkaW5hdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIHZhbHVlKHN0YWNrLCBjb29yZGluYXRlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBtb2RlbHMuc3RhY2sudmFsdWUgaXMgZGVwcmVjYXRlZC5cclxuICAgICAgIFBsZWFzZSB1c2UgY29yZS51dGlscy52YWx1ZSBpbnN0ZWFkLmApO1xyXG4gICAgcmV0dXJuIENvcmVVdGlscy52YWx1ZShzdGFjaywgY29vcmRpbmF0ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBmb3IgY29yZS51dGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHRcclxuICAgKlxyXG4gICAqIEFwcGx5IHNsb3BlL2ludGVyY2VwdCB0byBhIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7Kn0gc2xvcGVcclxuICAgKiBAcGFyYW0geyp9IGludGVyY2VwdFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdGF0aWMgdmFsdWVSZXNjYWxlU2xvcGVJbnRlcmNlcHQodmFsdWUsIHNsb3BlLCBpbnRlcmNlcHQpIHtcclxuICAgIGNvbnNvbGUud2FybihcclxuICAgICAgYG1vZGVscy5zdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdCBpcyBkZXByZWNhdGVkLlxyXG4gICAgICAgUGxlYXNlIHVzZSBjb3JlLnV0aWxzLnJlc2NhbGVTbG9wZUludGVyY2VwdCBpbnN0ZWFkLmApO1xyXG4gICAgcmV0dXJuIENvcmVVdGlscy5yZXNjYWxlU2xvcGVJbnRlcmNlcHQoXHJcbiAgICAgIHZhbHVlLCBzbG9wZSwgaW50ZXJjZXB0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIGZvciBjb3JlLnV0aWxzLndvcmxkVG9EYXRhXHJcbiAgICpcclxuICAgKiBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZnJvbSB3b3JsZCBjb29yZGluYXRlIHRvIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gc3RhY2tcclxuICAgKiBAcGFyYW0geyp9IHdvcmxkQ29vcmRpbmF0ZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgc3RhdGljIHdvcmxkVG9EYXRhKHN0YWNrLCB3b3JsZENvb3JkaW5hdGVzKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBtb2RlbHMuc3RhY2sud29ybGRUb0RhdGEgaXMgZGVwcmVjYXRlZC5cclxuICAgICAgIFBsZWFzZSB1c2UgY29yZS51dGlscy53b3JsZFRvRGF0YSBpbnN0ZWFkLmApO1xyXG5cclxuICAgIHJldHVybiBDb3JlVXRpbHMud29ybGRUb0RhdGEoc3RhY2suX2xwczJJSkssIHdvcmxkQ29vcmRpbmF0ZXMpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXHJcbi8vIHNob3VsZCBmb2xsb3cgaXQuLi5cclxuIC8vIDg5NyAgIGlmICggKHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdICE9IGlkeFNlcmllc0luc3RhbmNlVUlEICYmIHRoaXMtPkluZGV4U2VyaWVzSW5zdGFuY2VVSURzW2tdID49IDAgJiYgaWR4U2VyaWVzSW5zdGFuY2VVSUQgPj0gMCkgfHxcclxuIC8vIDg5OCAgICAgICAgKHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gIT0gaWR4Q29udGVudFRpbWUgJiYgdGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSA+PSAwICYmIGlkeENvbnRlbnRUaW1lID49IDApIHx8XHJcbiAvLyA4OTkgICAgICAgICh0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdICE9IGlkeFRyaWdnZXJUaW1lICYmIHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gPj0gMCAmJiBpZHhUcmlnZ2VyVGltZSA+PSAwKSB8fFxyXG4gLy8gOTAwICAgICAgICAodGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSAhPSBpZHhFY2hvTnVtYmVycyAmJiB0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdID49IDAgJiYgaWR4RWNob051bWJlcnMgPj0gMCkgfHxcclxuIC8vIDkwMSAgICAgICAgKHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSAhPSBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uICAmJiB0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gPj0gMCAmJiBpZHhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uID49IDApIHx8XHJcbiAvLyA5MDIgICAgICAgICh0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gIT0gaWR4U2xpY2VMb2NhdGlvbiAmJiB0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gPj0gMCAmJiBpZHhTbGljZUxvY2F0aW9uID49IDApIHx8XHJcbiAvLyA5MDMgICAgICAgICh0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdICE9IGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ICYmIHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gPj0gMCAmJiBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCA+PSAwKSApXHJcbiAvLyA5MDQgICAgIHtcclxuIC8vIDkwNSAgICAgICBjb250aW51ZTtcclxuIC8vIDkwNiAgICAgfVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBtb2RlbHMvdm94ZWxcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbHNWb3hlbCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9pZCA9IC0xO1xyXG4gICAgdGhpcy5fd29ybGRDb29yZGluYXRlcyA9IG51bGw7XHJcbiAgICB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fc2NyZWVuQ29vcmRpbmF0ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdvcmxkQ29vcmRpbmF0ZXMod29ybGRDb29yZGluYXRlcykge1xyXG4gICAgdGhpcy5fd29ybGRDb29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBnZXQgd29ybGRDb29yZGluYXRlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl93b3JsZENvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgc2V0IGRhdGFDb29yZGluYXRlcyhkYXRhQ29vcmRpbmF0ZXMpIHtcclxuICAgIHRoaXMuX2RhdGFDb29yZGluYXRlcyA9IGRhdGFDb29yZGluYXRlcztcclxuICB9XHJcblxyXG4gIGdldCBkYXRhQ29vcmRpbmF0ZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YUNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNjcmVlbkNvb3JkaW5hdGVzKHNjcmVlbkNvb3JkaW5hdGVzKSB7XHJcbiAgICB0aGlzLl9zY3JlZW5Db29yZGluYXRlcyA9IHNjcmVlbkNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcmVlbkNvb3JkaW5hdGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NjcmVlbkNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGlkKGlkKSB7XHJcbiAgICB0aGlzLl9pZCA9IGlkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gIH1cclxufVxyXG4iLCIvLyBmdHA6Ly9tZWRpY2FsLm5lbWEub3JnL01FRElDQUwvRGljb20vMjAxNGMvb3V0cHV0L2NodG1sL3BhcnQwNS9zZWN0XzYuMi5odG1sL1xyXG5cclxuLy8gU2xpY2VyIHdheSB0byBoYW5kbGUgaW1hZ2VzXHJcbi8vIHNob3VsZCBmb2xsb3cgaXQuLi5cclxuLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxyXG4vLyA4OTggICAgICAgICh0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdICE9IGlkeENvbnRlbnRUaW1lICYmIHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gPj0gMCAmJiBpZHhDb250ZW50VGltZSA+PSAwKSB8fFxyXG4vLyA4OTkgICAgICAgICh0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdICE9IGlkeFRyaWdnZXJUaW1lICYmIHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gPj0gMCAmJiBpZHhUcmlnZ2VyVGltZSA+PSAwKSB8fFxyXG4vLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxyXG4vLyA5MDEgICAgICAgICh0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gIT0gaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiAgJiYgdGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdID49IDAgJiYgaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiA+PSAwKSB8fFxyXG4vLyA5MDIgICAgICAgICh0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gIT0gaWR4U2xpY2VMb2NhdGlvbiAmJiB0aGlzLT5JbmRleFNsaWNlTG9jYXRpb25ba10gPj0gMCAmJiBpZHhTbGljZUxvY2F0aW9uID49IDApIHx8XHJcbi8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcclxuLy8gOTA0ICAgICB7XHJcbi8vIDkwNSAgICAgICBjb250aW51ZTtcclxuLy8gOTA2ICAgICB9XHJcblxyXG4vKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XHJcblxyXG5sZXQgRGljb21QYXJzZXIgPSByZXF1aXJlKCdkaWNvbS1wYXJzZXInKTtcclxubGV0IEpwZWcgPSByZXF1aXJlKCdqcGVnLWxvc3NsZXNzLWRlY29kZXItanMnKTtcclxubGV0IEpwZWdCYXNlbGluZSA9IHJlcXVpcmUoJy4uLy4uL2V4dGVybmFsL3NjcmlwdHMvanBlZycpO1xyXG5sZXQgSnB4ID0gcmVxdWlyZSgnLi4vLi4vZXh0ZXJuYWwvc2NyaXB0cy9qcHgnKTtcclxuXHJcbi8qKlxyXG4gKiBEaWNvbSBwYXJzZXIgaXMgYSBjb21iaW5hdGlvbiBvZiB1dGlsaXRpZXMgdG8gZ2V0IGEgVkpTIGltYWdlIGZyb20gZGljb20gZmlsZXMuXHJcbiAqc2NyaXB0c1xyXG4gKiBSZWxpZXMgb24gZGNtanMsIGpxdWVyeSwgSFRNTDUgZmV0Y2ggQVBJLCBIVE1MNSBwcm9taXNlIEFQSS5cclxuICpcclxuICogQG1vZHVsZSBwYXJzZXJzL2RpY29tXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciB7YXJyYXlidWZmZXJ9IC0gTGlzdCBvZiBmaWxlcyB0byBiZSBwYXJzZWQuIEl0IGlzIHVybHMgZnJvbSB3aGljaFxyXG4gKiBWSlMucGFyc2Vycy5kaWNvbSBjYW4gcHVsbCB0aGUgZGF0YSBmcm9tLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc0RpY29tIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2lkID0gaWQ7XHJcblxyXG4gICAgdGhpcy5fYXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcclxuXHJcbiAgICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYXJyYXlCdWZmZXIpO1xyXG5cclxuICAgIC8vIGNhdGNoIGVycm9yXHJcbiAgICAvLyB0aHJvdyBlcnJvciBpZiBhbnkhXHJcbiAgICB0aGlzLl9kYXRhU2V0ID0gbnVsbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLl9kYXRhU2V0ID0gRGljb21QYXJzZXIucGFyc2VEaWNvbShieXRlQXJyYXkpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB3aW5kb3cuY29uc29sZS5sb2coZSk7XHJcbiAgICAgIHRocm93ICdwYXJzZXJzLmRpY29tIGNvdWxkIG5vdCBwYXJzZSB0aGUgZmlsZSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBpbWFnZS9mcmFtZSBzcGVjaWZpY1xyXG4gIHNlcmllc0luc3RhbmNlVUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAyMDAwMGUnKTtcclxuICB9XHJcblxyXG4gIHN0dWR5SW5zdGFuY2VVSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDIwMDAwZCcpO1xyXG4gIH1cclxuXHJcbiAgbW9kYWxpdHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDA2MCcpO1xyXG4gIH1cclxuXHJcbiAgc2VnbWVudGF0aW9uVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwNjIwMDAxJyk7XHJcbiAgfVxyXG5cclxuICBzZWdtZW50YXRpb25TZWdtZW50cygpIHtcclxuICAgIGxldCBzZWdtZW50YXRpb25TZWdtZW50cyA9IFtdO1xyXG4gICAgbGV0IHNlZ21lbnRTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDAwNjIwMDAyO1xyXG5cclxuICAgIGlmICghc2VnbWVudFNlcXVlbmNlKSB7XHJcbiAgICAgIHJldHVybiBzZWdtZW50YXRpb25TZWdtZW50cztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaTwgc2VnbWVudFNlcXVlbmNlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCByZWNvbW1lbmRlZERpc3BsYXlDSUVMYWIgPVxyXG4gICAgICAgIHRoaXMuX3JlY29tbWVuZGVkRGlzcGxheUNJRUxhYihzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0pO1xyXG4gICAgICBsZXQgc2VnbWVudGF0aW9uQ29kZSA9IHRoaXMuX3NlZ21lbnRhdGlvbkNvZGUoc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldKTtcclxuICAgICAgbGV0IHNlZ21lbnROdW1iZXIgPSBzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0uZGF0YVNldC51aW50MTYoJ3gwMDYyMDAwNCcpO1xyXG4gICAgICBsZXQgc2VnbWVudExhYmVsID0gc2VnbWVudFNlcXVlbmNlLml0ZW1zW2ldLmRhdGFTZXQuc3RyaW5nKCd4MDA2MjAwMDUnKTtcclxuICAgICAgbGV0IHNlZ21lbnRBbGdvcml0aG1UeXBlID1cclxuICAgICAgICBzZWdtZW50U2VxdWVuY2UuaXRlbXNbaV0uZGF0YVNldC5zdHJpbmcoJ3gwMDYyMDAwOCcpO1xyXG5cclxuICAgICAgc2VnbWVudGF0aW9uU2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgcmVjb21tZW5kZWREaXNwbGF5Q0lFTGFiLFxyXG4gICAgICAgIHNlZ21lbnRhdGlvbkNvZGVEZXNpZ25hdG9yOlxyXG4gICAgICAgICAgc2VnbWVudGF0aW9uQ29kZVsnc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3InXSxcclxuICAgICAgICBzZWdtZW50YXRpb25Db2RlVmFsdWU6IHNlZ21lbnRhdGlvbkNvZGVbJ3NlZ21lbnRhdGlvbkNvZGVWYWx1ZSddLFxyXG4gICAgICAgIHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nOiBzZWdtZW50YXRpb25Db2RlWydzZWdtZW50YXRpb25Db2RlTWVhbmluZyddLFxyXG4gICAgICAgIHNlZ21lbnROdW1iZXIsXHJcbiAgICAgICAgc2VnbWVudExhYmVsLFxyXG4gICAgICAgIHNlZ21lbnRBbGdvcml0aG1UeXBlLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2VnbWVudGF0aW9uU2VnbWVudHM7XHJcbiAgfVxyXG5cclxuICBfc2VnbWVudGF0aW9uQ29kZShzZWdtZW50KSB7XHJcbiAgICBsZXQgc2VnbWVudGF0aW9uQ29kZURlc2lnbmF0b3IgPSAndW5rbm93bic7XHJcbiAgICBsZXQgc2VnbWVudGF0aW9uQ29kZVZhbHVlID0gJ3Vua25vd24nO1xyXG4gICAgbGV0IHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nID0gJ3Vua25vd24nO1xyXG4gICAgbGV0IGVsZW1lbnQgPSBzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwMDgyMjE4O1xyXG5cclxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXRlbXMgJiYgZWxlbWVudC5pdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVEZXNpZ25hdG9yID0gZWxlbWVudC5pdGVtc1swXS5kYXRhU2V0LnN0cmluZygneDAwMDgwMTAyJyk7XHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVWYWx1ZSA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwMCcpO1xyXG4gICAgICBzZWdtZW50YXRpb25Db2RlTWVhbmluZyA9IGVsZW1lbnQuaXRlbXNbMF0uZGF0YVNldC5zdHJpbmcoJ3gwMDA4MDEwNCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVEZXNpZ25hdG9yLFxyXG4gICAgICBzZWdtZW50YXRpb25Db2RlVmFsdWUsXHJcbiAgICAgIHNlZ21lbnRhdGlvbkNvZGVNZWFuaW5nLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIF9yZWNvbW1lbmRlZERpc3BsYXlDSUVMYWIoc2VnbWVudCkge1xyXG4gICAgaWYgKCFzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwNjIwMDBkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvZmZzZXQgPSBzZWdtZW50LmRhdGFTZXQuZWxlbWVudHMueDAwNjIwMDBkLmRhdGFPZmZzZXQ7XHJcbiAgICBsZXQgbGVuZ3RoID0gc2VnbWVudC5kYXRhU2V0LmVsZW1lbnRzLngwMDYyMDAwZC5sZW5ndGg7XHJcbiAgICBsZXQgYnl0ZUFycmF5ID0gc2VnbWVudC5kYXRhU2V0LmJ5dGVBcnJheS5zbGljZShvZmZzZXQsIG9mZnNldCsgbGVuZ3RoKTtcclxuXHJcbiAgICAvLyBodHRwczovL3d3dy5kYWJzb2Z0LmNoL2RpY29tLzMvQy4xMC43LjEuMS9cclxuICAgIGxldCBDSUVMYWJTY2FsZWQgPSBuZXcgVWludDE2QXJyYXkobGVuZ3RoLzIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGk8bGVuZ3RoLzI7IGkrKykge1xyXG4gICAgICBDSUVMYWJTY2FsZWRbaV0gPSAoYnl0ZUFycmF5WzIqaSArIDFdIDw8IDgpICsgYnl0ZUFycmF5WzIqaV07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IENJRUxhYk5vcm1hbGl6ZWQgPSBbXHJcbiAgICAgIENJRUxhYlNjYWxlZFswXSAvIDY1NTM1ICogMTAwLFxyXG4gICAgICBDSUVMYWJTY2FsZWRbMV0gLyA2NTUzNSAqIDI1NSAtIDEyOCxcclxuICAgICAgQ0lFTGFiU2NhbGVkWzJdIC8gNjU1MzUgKiAyNTUgLSAxMjgsXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBDSUVMYWJOb3JtYWxpemVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU09QIEluc3RhbmNlIFVJRFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBmcmFtZUluZGV4XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHNvcEluc3RhbmNlVUlEKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgc29wSW5zdGFuY2VVSUQgPVxyXG4gICAgICB0aGlzLl9maW5kU3RyaW5nRXZlcnl3aGVyZSgneDIwMDUxNDBmJywgJ3gwMDA4MDAxOCcsIGZyYW1lSW5kZXgpO1xyXG4gICAgcmV0dXJuIHNvcEluc3RhbmNlVUlEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmZXIgc3ludGF4IFVJRFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICB0cmFuc2ZlclN5bnRheFVJRCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMDIwMDEwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHVkeSBkZXNjcmlwdGlvblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzdHVkeURlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAwODEwMzAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcmllcyBkZXNjcmlwdGlvblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzZXJpZXNEZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMDgxMDNlJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IG5hbWVcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudE5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMDAxMCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBJRFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50SUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMDAyMCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF0aWVudCBiaXJ0aGRhdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudEJpcnRoZGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMTAwMDMwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXRpZW50IHNleFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50U2V4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc3RyaW5nKCd4MDAxMDAwNDAnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdGllbnQgYWdlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnRBZ2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zdHJpbmcoJ3gwMDEwMTAxMCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb25cclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnN0cmluZygneDAwMjgwMDA0Jyk7XHJcbiAgfVxyXG5cclxuICBwbGFuYXJDb25maWd1cmF0aW9uKCkge1xyXG4gICAgbGV0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDA2Jyk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwbGFuYXJDb25maWd1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBwbGFuYXJDb25maWd1cmF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGxhbmFyQ29uZmlndXJhdGlvbjtcclxuICB9XHJcblxyXG4gIHNhbXBsZXNQZXJQaXhlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMDAyJyk7XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkZyYW1lcygpIHtcclxuICAgIGxldCBudW1iZXJPZkZyYW1lcyA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMDgnKTtcclxuXHJcbiAgICAvLyBuZWVkIHNvbWV0aGluZyBzbWFydGVyIVxyXG4gICAgaWYgKHR5cGVvZiBudW1iZXJPZkZyYW1lcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgbnVtYmVyT2ZGcmFtZXMgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudW1iZXJPZkZyYW1lcztcclxuICB9XHJcblxyXG4gIG51bWJlck9mQ2hhbm5lbHMoKSB7XHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IDE7XHJcbiAgICBsZXQgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IHRoaXMucGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbigpO1xyXG5cclxuICAgIGlmICghKHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gIT09ICdSR0InICYmXHJcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1BBTEVUVEUgQ09MT1InICYmXHJcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9GVUxMJyAmJlxyXG4gICAgICAgIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gIT09ICdZQlJfRlVMTF80MjInICYmXHJcbiAgICAgICAgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiAhPT0gJ1lCUl9QQVJUSUFMXzQyMicgJiZcclxuICAgICAgICBwaG90b21ldHJpY0ludGVycHJldGF0aW9uICE9PSAnWUJSX1BBUlRJQUxfNDIwJyAmJlxyXG4gICAgICAgIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gIT09ICdZQlJfUkNUJykpIHtcclxuICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IDM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIG51bWJlciEgKG5vdCBhIHN0cmluZyEpXHJcbiAgICByZXR1cm4gbnVtYmVyT2ZDaGFubmVscztcclxuICB9XHJcblxyXG4gIGludmVydCgpIHtcclxuICAgIGxldCBwaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gdGhpcy5waG90b21ldHJpY0ludGVycHJldGF0aW9uKCk7XHJcblxyXG4gICAgcmV0dXJuICgocGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9PT0gJ01PTk9DSFJPTUUxJykgPyB0cnVlIDogZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gZXhwZWN0IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0IDAhXHJcbiAgICBsZXQgaW1hZ2VPcmllbnRhdGlvbiA9IHRoaXMuX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKCd4MDAyMDkxMTYnLCAneDAwMjAwMDM3JywgZnJhbWVJbmRleCk7XHJcblxyXG4gICAgLy8gZm9ybWF0IGltYWdlIG9yaWVudGF0aW9uICgnMVxcMFxcMFxcMFxcMVxcMCcpIHRvIGFycmF5IGNvbnRhaW5pbmcgNiBudW1iZXJzXHJcbiAgICBpZiAoaW1hZ2VPcmllbnRhdGlvbikge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcclxuICAgICAgLy8gbWlnaHQgbm90IG5lZWQgdG8gc3BsaXQgKGZsb2F0U3RyaW5nICsgaW5kZXgpXHJcbiAgICAgIGltYWdlT3JpZW50YXRpb24gPSBpbWFnZU9yaWVudGF0aW9uLnNwbGl0KCdcXFxcJykubWFwKE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGltYWdlT3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICByZWZlcmVuY2VkU2VnbWVudE51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHJlZmVyZW5jZWRTZWdtZW50TnVtYmVyID0gLTE7XHJcbiAgICBsZXQgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXJFbGVtZW50ID0gdGhpcy5fZmluZEluR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjMwJywgJ3gwMDYyMDAwYScsIGZyYW1lSW5kZXgpO1xyXG5cclxuICAgIGlmIChyZWZlcmVuY2VkU2VnbWVudE51bWJlckVsZW1lbnQgIT09IG51bGwpIHtcclxuICAgICAgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIgPSByZWZlcmVuY2VkU2VnbWVudE51bWJlckVsZW1lbnQudWludDE2KCd4MDA2MjAwMGInKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVmZXJlbmNlZFNlZ21lbnROdW1iZXI7XHJcbiAgfVxyXG5cclxuICBwaXhlbEFzcGVjdFJhdGlvKCkge1xyXG4gICAgbGV0IHBpeGVsQXNwZWN0UmF0aW8gPSBbXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyODAwMzQnLCAwKSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5pbnRTdHJpbmcoJ3gwMDI4MDAzNCcsIDEpLFxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBuZWVkIHNvbWV0aGluZyBzbWFydGVyIVxyXG4gICAgaWYgKHR5cGVvZiBwaXhlbEFzcGVjdFJhdGlvWzBdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBwaXhlbEFzcGVjdFJhdGlvID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgbnVtYmVyISAobm90IGEgc3RyaW5nISlcclxuICAgIHJldHVybiBwaXhlbEFzcGVjdFJhdGlvO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGltYWdlUG9zaXRpb24gPSB0aGlzLl9maW5kU3RyaW5nRXZlcnl3aGVyZSgneDAwMjA5MTEzJywgJ3gwMDIwMDAzMicsIGZyYW1lSW5kZXgpO1xyXG5cclxuICAgIC8vIGZvcm1hdCBpbWFnZSBvcmllbnRhdGlvbiAoJzFcXDBcXDBcXDBcXDFcXDAnKSB0byBhcnJheSBjb250YWluaW5nIDYgbnVtYmVyc1xyXG4gICAgaWYgKGltYWdlUG9zaXRpb24pIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIG51bWJlciEgKG5vdCBhIHN0cmluZyEpXHJcbiAgICAgIGltYWdlUG9zaXRpb24gPSBpbWFnZVBvc2l0aW9uLnNwbGl0KCdcXFxcJykubWFwKE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGltYWdlUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGluc3RhbmNlTnVtYmVyID0gbnVsbDtcclxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIGZyYW1lIVxyXG4gICAgLy8gcGVyIGZyYW1lIGZ1bmN0aW9ubmFsIGdyb3VwIHNlcXVlbmNlXHJcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBpZiAocGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2VcclxuICAgICAgICAgICAgICAuaXRlbXNbZnJhbWVJbmRleF0uZGF0YVNldC5lbGVtZW50cy54MjAwNTE0MGYpIHtcclxuICAgICAgICBsZXQgcGxhbmVPcmllbnRhdGlvblNlcXVlbmNlID0gcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2VcclxuICAgICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDIwMDUxNDBmLml0ZW1zWzBdLmRhdGFTZXQ7XHJcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBwbGFuZU9yaWVudGF0aW9uU2VxdWVuY2UuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZU51bWJlciA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAyMDAwMTMnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZU51bWJlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGluc3RhbmNlTnVtYmVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHNob3VsZCB3ZSBkZWZhdWx0IHRvIHVuZGVmaW5lZD8/XHJcbiAgICAgIC8vIGRlZmF1bHQgb3JpZW50YXRpb25cclxuICAgICAgaW5zdGFuY2VOdW1iZXIgPSB0aGlzLl9kYXRhU2V0LmludFN0cmluZygneDAwMjAwMDEzJyk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlTnVtYmVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGluc3RhbmNlTnVtYmVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZU51bWJlcjtcclxuICB9XHJcblxyXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gZXhwZWN0IGZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0IDAhXHJcbiAgICBsZXQgcGl4ZWxTcGFjaW5nID0gdGhpcy5fZmluZFN0cmluZ0V2ZXJ5d2hlcmUoJ3gwMDI4OTExMCcsICd4MDAyODAwMzAnLCBmcmFtZUluZGV4KTtcclxuXHJcbiAgICAvLyBmb3JtYXQgaW1hZ2Ugb3JpZW50YXRpb24gKCcxXFwwXFwwXFwwXFwxXFwwJykgdG8gYXJyYXkgY29udGFpbmluZyA2IG51bWJlcnNcclxuICAgIC8vIHNob3VsZCB3ZSBkZWZhdWx0IHRvIHVuZGVmaW5lZD8/XHJcbiAgICBpZiAocGl4ZWxTcGFjaW5nKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSByZXR1cm4gYXJyYXkgb2YgbnVtYmVycyEgKG5vdCBzdHJpbmdzISlcclxuICAgICAgcGl4ZWxTcGFjaW5nID0gcGl4ZWxTcGFjaW5nLnNwbGl0KCdcXFxcJykubWFwKE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBpeGVsU3BhY2luZztcclxuICB9XHJcblxyXG4gIHJvd3MoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCByb3dzID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAxMCcpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygcm93cyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcm93cyA9IG51bGw7XHJcbiAgICAgIC8vIHByaW50IHdhcm5pbmcgYXQgbGVhc3QuLi5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm93cztcclxuICB9XHJcblxyXG4gIGNvbHVtbnMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBjb2x1bW5zID0gdGhpcy5fZGF0YVNldC51aW50MTYoJ3gwMDI4MDAxMScpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgY29sdW1ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29sdW1ucyA9IG51bGw7XHJcbiAgICAgIC8vIHByaW50IHdhcm5pbmcgYXQgbGVhc3QuLi5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sdW1ucztcclxuICB9XHJcblxyXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gMCBpbnRlZ2VyLCAxIGZsb2F0XHJcbiAgICAvLyBkaWNvbSBvbmx5IHN1cHBvcnQgaW50ZWdlcnNcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxSZXByZXNlbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHBpeGVsUmVwcmVzZW50YXRpb24gPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMTAzJyk7XHJcbiAgICByZXR1cm4gcGl4ZWxSZXByZXNlbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIGJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMTAwJyk7XHJcbiAgICByZXR1cm4gYml0c0FsbG9jYXRlZDtcclxuICB9XHJcblxyXG4gIGhpZ2hCaXQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGV4cGVjdCBmcmFtZSBpbmRleCB0byBzdGFydCBhdCAwIVxyXG4gICAgbGV0IGhpZ2hCaXQgPSB0aGlzLl9kYXRhU2V0LnVpbnQxNigneDAwMjgwMTAyJyk7XHJcbiAgICByZXR1cm4gaGlnaEJpdDtcclxuICB9XHJcblxyXG4gIHJlc2NhbGVJbnRlcmNlcHQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShcclxuICAgICAgJ3gwMDI4OTE0NScsICd4MDAyODEwNTInLCBmcmFtZUluZGV4KTtcclxuICB9XHJcblxyXG4gIHJlc2NhbGVTbG9wZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxyXG4gICAgICAneDAwMjg5MTQ1JywgJ3gwMDI4MTA1MycsIGZyYW1lSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmluZEZsb2F0U3RyaW5nSW5GcmFtZUdyb3VwU2VxdWVuY2UoXHJcbiAgICAgICd4MDAyODkxMzInLCAneDAwMjgxMDUwJywgZnJhbWVJbmRleCk7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKFxyXG4gICAgICAneDAwMjg5MTMyJywgJ3gwMDI4MTA1MScsIGZyYW1lSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgc2xpY2VUaGlja25lc3MoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShcclxuICAgICAgJ3gwMDI4OTExMCcsICd4MDAxODAwNTAnLCBmcmFtZUluZGV4KTtcclxuICB9XHJcblxyXG4gIHNwYWNpbmdCZXR3ZWVuU2xpY2VzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgc3BhY2luZyA9IHRoaXMuX2RhdGFTZXQuaW50U3RyaW5nKCd4MDAxODAwODgnKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHNwYWNpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHNwYWNpbmcgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzcGFjaW5nO1xyXG4gIH1cclxuXHJcbiAgZGltZW5zaW9uSW5kZXhWYWx1ZXMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBkaW1lbnNpb25JbmRleFZhbHVlcyA9IG51bGw7XHJcblxyXG4gICAgLy8gdHJ5IHRvIGdldCBpdCBmcm9tIGVuaGFuY2VkIE1SIGltYWdlc1xyXG4gICAgLy8gcGVyLWZyYW1lIGZ1bmN0aW9ubmFsIGdyb3VwIHNlcXVlbmNlXHJcbiAgICBsZXQgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgPSB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng1MjAwOTIzMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBsZXQgZnJhbWVDb250ZW50U2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxyXG4gICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDAwMjA5MTExO1xyXG4gICAgICBpZiAoZnJhbWVDb250ZW50U2VxdWVuY2UgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgZnJhbWVDb250ZW50U2VxdWVuY2UgIT09IG51bGwpIHtcclxuICAgICAgICBmcmFtZUNvbnRlbnRTZXF1ZW5jZSA9IGZyYW1lQ29udGVudFNlcXVlbmNlLml0ZW1zWzBdLmRhdGFTZXQ7XHJcbiAgICAgICAgbGV0IGRpbWVuc2lvbkluZGV4VmFsdWVzRWx0ID0gZnJhbWVDb250ZW50U2VxdWVuY2UuZWxlbWVudHMueDAwMjA5MTU3O1xyXG4gICAgICAgIGlmIChkaW1lbnNpb25JbmRleFZhbHVlc0VsdCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZGV4VmFsdWVzRWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAvLyAvNCBiZWNhdXNlIFVMXHJcbiAgICAgICAgICBsZXQgbmJWYWx1ZXMgPSBkaW1lbnNpb25JbmRleFZhbHVlc0VsdC5sZW5ndGggLyA0O1xyXG4gICAgICAgICAgZGltZW5zaW9uSW5kZXhWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iVmFsdWVzOyBpKyspIHtcclxuICAgICAgICAgICAgZGltZW5zaW9uSW5kZXhWYWx1ZXMucHVzaChcclxuICAgICAgICAgICAgICBmcmFtZUNvbnRlbnRTZXF1ZW5jZS51aW50MzIoJ3gwMDIwOTE1NycsIGkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGltZW5zaW9uSW5kZXhWYWx1ZXM7XHJcbiAgfVxyXG5cclxuICBpblN0YWNrUG9zaXRpb25OdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBpblN0YWNrUG9zaXRpb25OdW1iZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIHRyeSB0byBnZXQgaXQgZnJvbSBlbmhhbmNlZCBNUiBpbWFnZXNcclxuICAgIC8vIHBlci1mcmFtZSBmdW5jdGlvbm5hbCBncm91cCBzZXF1ZW5jZVxyXG4gICAgbGV0IHBlckZyYW1lRnVuY3Rpb25uYWxHcm91cFNlcXVlbmNlID0gdGhpcy5fZGF0YVNldC5lbGVtZW50cy54NTIwMDkyMzA7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gTk9UIEEgUEhJTElQUyBUUklDSyFcclxuICAgICAgbGV0IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UgPSBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZVxyXG4gICAgICAgICAgLml0ZW1zW2ZyYW1lSW5kZXhdLmRhdGFTZXQuZWxlbWVudHMueDAwMjA5MTExLml0ZW1zWzBdLmRhdGFTZXQ7XHJcbiAgICAgIGluU3RhY2tQb3NpdGlvbk51bWJlciA9IHBoaWxpcHNQcml2YXRlU2VxdWVuY2UudWludDMyKCd4MDAyMDkwNTcnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluU3RhY2tQb3NpdGlvbk51bWJlciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYGluc3RhY2sgcG9zaXRpb24gJHtpblN0YWNrUG9zaXRpb25OdW1iZXJ9YCk7XHJcblxyXG4gICAgcmV0dXJuIGluU3RhY2tQb3NpdGlvbk51bWJlcjtcclxuICB9XHJcblxyXG4gIHN0YWNrSUQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBzdGFja0lEID0gbnVsbDtcclxuXHJcbiAgICAvLyB0cnkgdG8gZ2V0IGl0IGZyb20gZW5oYW5jZWQgTVIgaW1hZ2VzXHJcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXAgc2VxdWVuY2VcclxuICAgIGxldCBwZXJGcmFtZUZ1bmN0aW9ubmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDUyMDA5MjMwO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIE5PVCBBIFBISUxJUFMgVFJJQ0shXHJcbiAgICAgIGxldCBwaGlsaXBzUHJpdmF0ZVNlcXVlbmNlID0gcGVyRnJhbWVGdW5jdGlvbm5hbEdyb3VwU2VxdWVuY2VcclxuICAgICAgICAgIC5pdGVtc1tmcmFtZUluZGV4XS5kYXRhU2V0LmVsZW1lbnRzLngwMDIwOTExMS5pdGVtc1swXS5kYXRhU2V0O1xyXG4gICAgICBzdGFja0lEID0gcGhpbGlwc1ByaXZhdGVTZXF1ZW5jZS5pbnRTdHJpbmcoJ3gwMDIwOTA1NicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhY2tJRCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0YWNrSUQ7XHJcbiAgfVxyXG5cclxuICBleHRyYWN0UGl4ZWxEYXRhKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBkZWNvbXByZXNzXHJcbiAgICBsZXQgZGVjb21wcmVzc2VkRGF0YSA9IHRoaXMuX2RlY29kZVBpeGVsRGF0YShmcmFtZUluZGV4KTtcclxuXHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xyXG5cclxuICAgIGlmIChudW1iZXJPZkNoYW5uZWxzID4gMSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9yU3BhY2UoZGVjb21wcmVzc2VkRGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZGVjb21wcmVzc2VkRGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG1pbk1heFBpeGVsRGF0YShwaXhlbERhdGEgPSBbXSkge1xyXG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcclxuICAgIGxldCBudW1QaXhlbHMgPSBwaXhlbERhdGEubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBudW1QaXhlbHM7IGluZGV4KyspIHtcclxuICAgICAgbGV0IHNwdiA9IHBpeGVsRGF0YVtpbmRleF07XHJcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgc3B2KTtcclxuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBzcHYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW5NYXg7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIHByaXZhdGUgbWV0aG9kc1xyXG4gIC8vXHJcblxyXG4gIF9maW5kSW5Hcm91cFNlcXVlbmNlKHNlcXVlbmNlLCBzdWJzZXF1ZW5jZSwgaW5kZXgpIHtcclxuICAgIGxldCBmdW5jdGlvbmFsR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHNbc2VxdWVuY2VdO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGxldCBpblNlcXVlbmNlID0gZnVuY3Rpb25hbEdyb3VwU2VxdWVuY2UuaXRlbXNbaW5kZXhdLmRhdGFTZXQuZWxlbWVudHNbc3Vic2VxdWVuY2VdO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpblNlcXVlbmNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBpblNlcXVlbmNlLml0ZW1zWzBdLmRhdGFTZXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIF9maW5kU3RyaW5nSW5Hcm91cFNlcXVlbmNlKHNlcXVlbmNlLCBzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCkge1xyXG4gICAgLy8gaW5kZXggPSAwIGlmIHNoYXJlZCEhIVxyXG4gICAgbGV0IGRhdGFTZXQgPSB0aGlzLl9maW5kSW5Hcm91cFNlcXVlbmNlKHNlcXVlbmNlLCBzdWJzZXF1ZW5jZSwgaW5kZXgpO1xyXG5cclxuICAgIGlmIChkYXRhU2V0ICE9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBkYXRhU2V0LnN0cmluZyh0YWcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRTdHJpbmdJbkdyb3VwU2VxdWVuY2UoJ3g1MjAwOTIyOScsIHN1YnNlcXVlbmNlLCB0YWcsIDApIHx8XHJcbiAgICAgICAgdGhpcy5fZmluZFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjMwJywgc3Vic2VxdWVuY2UsIHRhZywgaW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgX2ZpbmRTdHJpbmdFdmVyeXdoZXJlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XHJcbiAgICBsZXQgdGFyZ2V0U3RyaW5nID0gdGhpcy5fZmluZFN0cmluZ0luRnJhbWVHcm91cFNlcXVlbmNlKHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KTtcclxuXHJcbiAgICBpZiAodGFyZ2V0U3RyaW5nID09PSBudWxsKSB7XHJcbiAgICAgIHRhcmdldFN0cmluZyA9IHRoaXMuX2RhdGFTZXQuc3RyaW5nKHRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRhcmdldFN0cmluZyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldFN0cmluZztcclxuICB9XHJcblxyXG4gIF9maW5kRmxvYXRTdHJpbmdJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KSB7XHJcbiAgICBsZXQgZGF0YUluR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2RhdGFTZXQuZmxvYXRTdHJpbmcodGFnKTtcclxuXHJcbiAgICAvLyB0cnkgdG8gZ2V0IGl0IGZyb20gZW5oYW5jZWQgTVIgaW1hZ2VzXHJcbiAgICAvLyBwZXItZnJhbWUgZnVuY3Rpb25uYWwgZ3JvdXBcclxuICAgIGlmICh0eXBlb2YgZGF0YUluR3JvdXBTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZGF0YUluR3JvdXBTZXF1ZW5jZSA9IHRoaXMuX2ZpbmRJbkdyb3VwU2VxdWVuY2Uoc2VxdWVuY2UsIHN1YnNlcXVlbmNlLCBpbmRleCk7XHJcblxyXG4gICAgICBpZiAoZGF0YUluR3JvdXBTZXF1ZW5jZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBkYXRhSW5Hcm91cFNlcXVlbmNlLmZsb2F0U3RyaW5nKHRhZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YUluR3JvdXBTZXF1ZW5jZTtcclxuICB9XHJcblxyXG4gIF9maW5kRmxvYXRTdHJpbmdJbkZyYW1lR3JvdXBTZXF1ZW5jZShzdWJzZXF1ZW5jZSwgdGFnLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGbG9hdFN0cmluZ0luR3JvdXBTZXF1ZW5jZSgneDUyMDA5MjI5Jywgc3Vic2VxdWVuY2UsIHRhZywgMCkgfHxcclxuICAgICAgICB0aGlzLl9maW5kRmxvYXRTdHJpbmdJbkdyb3VwU2VxdWVuY2UoJ3g1MjAwOTIzMCcsIHN1YnNlcXVlbmNlLCB0YWcsIGluZGV4KTtcclxuICB9XHJcblxyXG4gIF9kZWNvZGVQaXhlbERhdGEoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGlmIGNvbXByZXNzZWQuLj9cclxuICAgIGxldCB0cmFuc2ZlclN5bnRheFVJRCA9IHRoaXMudHJhbnNmZXJTeW50YXhVSUQoKTtcclxuXHJcbiAgICAvLyBmaW5kIGNvbXByZXNzaW9uIHNjaGVtZVxyXG4gICAgaWYgKFxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuOTAnIHx8XHJcbiAgICAgIC8vIEpQRUcgMjAwMCBMb3NzbGVzc1xyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yLjQuOTEnKSB7XHJcbiAgICAgIC8vIEpQRUcgMjAwMCBMb3NzeVxyXG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlSjJLKGZyYW1lSW5kZXgpO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjU3JyB8fFxyXG4gICAgICAvLyBKUEVHIExvc3NsZXNzLCBOb25oaWVyYXJjaGljYWwgKFByb2Nlc3NlcyAxNClcclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjcwJykge1xyXG4gICAgICAvLyBKUEVHIExvc3NsZXNzLCBOb25oaWVyYXJjaGljYWwgKFByb2Nlc3NlcyAxNCBbU2VsZWN0aW9uIDFdKVxyXG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlSlBFR0xvc3NsZXNzKGZyYW1lSW5kZXgpO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi40LjUwJyB8fFxyXG4gICAgICAvLyBKUEVHIEJhc2VsaW5lIGxvc3N5IHByb2Nlc3MgMSAoOCBiaXQpXHJcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuNC41MScpIHtcclxuICAgICAgLy8gSlBFRyBCYXNlbGluZSBsb3NzeSBwcm9jZXNzIDIgJiA0ICgxMiBiaXQpXHJcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVKUEVHQmFzZWxpbmUoZnJhbWVJbmRleCk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0cmFuc2ZlclN5bnRheFVJRCA9PT0gJzEuMi44NDAuMTAwMDguMS4yJyB8fFxyXG4gICAgICAvLyBJbXBsaWNpdCBWUiBMaXR0bGUgRW5kaWFuXHJcbiAgICAgIHRyYW5zZmVyU3ludGF4VUlEID09PSAnMS4yLjg0MC4xMDAwOC4xLjIuMScpIHtcclxuICAgICAgLy8gRXhwbGljaXQgVlIgTGl0dGxlIEVuZGlhblxyXG4gICAgICByZXR1cm4gdGhpcy5fZGVjb2RlVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdHJhbnNmZXJTeW50YXhVSUQgPT09ICcxLjIuODQwLjEwMDA4LjEuMi4yJykge1xyXG4gICAgICAvLyBFeHBsaWNpdCBWUiBCaWcgRW5kaWFuXHJcbiAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2RlY29kZVVuY29tcHJlc3NlZChmcmFtZUluZGV4KTtcclxuICAgICAgLy8gYW5kIHNhd3AgaXQhXHJcbiAgICAgIHJldHVybiB0aGlzLl9zd2FwRnJhbWUoZnJhbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cge1xyXG4gICAgICAgIGVycm9yOiBgbm8gZGVjb2RlciBmb3IgdHJhbnNmZXIgc3ludGF4ICR7dHJhbnNmZXJTeW50YXhVSUR9YCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9kZWNvZGVKMksoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBlbmNvZGVkUGl4ZWxEYXRhID0gRGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSh0aGlzLl9kYXRhU2V0LCB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMCwgZnJhbWVJbmRleCk7XHJcbiAgICAvLyBsZXQgcGl4ZWxEYXRhRWxlbWVudCA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwO1xyXG4gICAgLy8gbGV0IHBpeGVsRGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2RhdGFTZXQuYnl0ZUFycmF5LmJ1ZmZlciwgcGl4ZWxEYXRhRWxlbWVudC5kYXRhT2Zmc2V0LCBwaXhlbERhdGFFbGVtZW50Lmxlbmd0aCk7XHJcbiAgICBsZXQganB4SW1hZ2UgPSBuZXcgSnB4KCk7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT0hJRi9pbWFnZS1KUEVHMjAwMC9pc3N1ZXMvNlxyXG4gICAgLy8gSXQgY3VycmVudGx5IHJldHVybnMgZWl0aGVyIEludDE2IG9yIFVpbnQxNiBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjb2Rlc3RyZWFtIGlzIHNpZ25lZCBvciBub3QuXHJcbiAgICBqcHhJbWFnZS5wYXJzZShlbmNvZGVkUGl4ZWxEYXRhKTtcclxuXHJcbiAgICAvLyBsZXQgajJrV2lkdGggPSBqcHhJbWFnZS53aWR0aDtcclxuICAgIC8vIGxldCBqMmtIZWlnaHQgPSBqcHhJbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgbGV0IGNvbXBvbmVudHNDb3VudCA9IGpweEltYWdlLmNvbXBvbmVudHNDb3VudDtcclxuICAgIGlmIChjb21wb25lbnRzQ291bnQgIT09IDEpIHtcclxuICAgICAgdGhyb3cgJ0pQRUcyMDAwIGRlY29kZXIgcmV0dXJuZWQgYSBjb21wb25lbnRDb3VudCBvZiAke2NvbXBvbmVudHNDb3VudH0sIHdoZW4gMSBpcyBleHBlY3RlZCc7XHJcbiAgICB9XHJcbiAgICBsZXQgdGlsZUNvdW50ID0ganB4SW1hZ2UudGlsZXMubGVuZ3RoO1xyXG5cclxuICAgIGlmICh0aWxlQ291bnQgIT09IDEpIHtcclxuICAgICAgdGhyb3cgJ0pQRUcyMDAwIGRlY29kZXIgcmV0dXJuZWQgYSB0aWxlQ291bnQgb2YgJHt0aWxlQ291bnR9LCB3aGVuIDEgaXMgZXhwZWN0ZWQnO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB0aWxlQ29tcG9uZW50cyA9IGpweEltYWdlLnRpbGVzWzBdO1xyXG4gICAgbGV0IHBpeGVsRGF0YSA9IHRpbGVDb21wb25lbnRzLml0ZW1zO1xyXG5cclxuICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhqMmtXaWR0aCwgajJrSGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gcGl4ZWxEYXRhO1xyXG4gIH1cclxuXHJcbiAgLy8gZnJvbSBjb3JuZXJzdG9uZVxyXG4gIF9kZWNvZGVKUEVHTG9zc2xlc3MoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBlbmNvZGVkUGl4ZWxEYXRhID0gRGljb21QYXJzZXIucmVhZEVuY2Fwc3VsYXRlZFBpeGVsRGF0YSh0aGlzLl9kYXRhU2V0LCB0aGlzLl9kYXRhU2V0LmVsZW1lbnRzLng3ZmUwMDAxMCwgZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgcGl4ZWxSZXByZXNlbnRhdGlvbiA9IHRoaXMucGl4ZWxSZXByZXNlbnRhdGlvbihmcmFtZUluZGV4KTtcclxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gdGhpcy5iaXRzQWxsb2NhdGVkKGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IGJ5dGVPdXRwdXQgPSBiaXRzQWxsb2NhdGVkIDw9IDggPyAxIDogMjtcclxuICAgIGxldCBkZWNvZGVyID0gbmV3IEpwZWcubG9zc2xlc3MuRGVjb2RlcigpO1xyXG4gICAgbGV0IGRlY29tcHJlc3NlZERhdGEgPSBkZWNvZGVyLmRlY29kZShlbmNvZGVkUGl4ZWxEYXRhLmJ1ZmZlciwgZW5jb2RlZFBpeGVsRGF0YS5ieXRlT2Zmc2V0LCBlbmNvZGVkUGl4ZWxEYXRhLmxlbmd0aCwgYnl0ZU91dHB1dCk7XHJcblxyXG4gICAgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDApIHtcclxuICAgICAgaWYgKGJ5dGVPdXRwdXQgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGRlY29tcHJlc3NlZERhdGEuYnVmZmVyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB1bnRlc3RlZCFcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoZGVjb21wcmVzc2VkRGF0YS5idWZmZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2RlY29kZUpQRUdCYXNlbGluZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGVuY29kZWRQaXhlbERhdGEgPSBEaWNvbVBhcnNlci5yZWFkRW5jYXBzdWxhdGVkUGl4ZWxEYXRhKHRoaXMuX2RhdGFTZXQsIHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwLCBmcmFtZUluZGV4KTtcclxuICAgIGxldCByb3dzID0gdGhpcy5yb3dzKGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgYml0c0FsbG9jYXRlZCA9IHRoaXMuYml0c0FsbG9jYXRlZChmcmFtZUluZGV4KTtcclxuICAgIGxldCBqcGVnQmFzZWxpbmUgPSBuZXcgSnBlZ0Jhc2VsaW5lKCk7XHJcbiAgICBqcGVnQmFzZWxpbmUucGFyc2UoZW5jb2RlZFBpeGVsRGF0YSk7XHJcblxyXG4gICAgaWYgKGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcclxuICAgICAgcmV0dXJuIGpwZWdCYXNlbGluZS5nZXREYXRhKGNvbHVtbnMsIHJvd3MpO1xyXG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAxNikge1xyXG4gICAgICByZXR1cm4ganBlZ0Jhc2VsaW5lLmdldERhdGExNihjb2x1bW5zLCByb3dzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9kZWNvZGVVbmNvbXByZXNzZWQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBwaXhlbFJlcHJlc2VudGF0aW9uID0gdGhpcy5waXhlbFJlcHJlc2VudGF0aW9uKGZyYW1lSW5kZXgpO1xyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCk7XHJcbiAgICBsZXQgcGl4ZWxEYXRhRWxlbWVudCA9IHRoaXMuX2RhdGFTZXQuZWxlbWVudHMueDdmZTAwMDEwO1xyXG4gICAgbGV0IHBpeGVsRGF0YU9mZnNldCA9IHBpeGVsRGF0YUVsZW1lbnQuZGF0YU9mZnNldDtcclxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XHJcbiAgICBsZXQgbnVtUGl4ZWxzID1cclxuICAgICAgdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcclxuICAgIGxldCBmcmFtZU9mZnNldCA9IDA7XHJcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fZGF0YVNldC5ieXRlQXJyYXkuYnVmZmVyO1xyXG5cclxuICAgIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAwICYmIGJpdHNBbGxvY2F0ZWQgPT09IDgpIHtcclxuICAgICAgLy8gdW5zaWduZWQgOCBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzO1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAocGl4ZWxSZXByZXNlbnRhdGlvbiA9PT0gMCAmJiBiaXRzQWxsb2NhdGVkID09PSAxNikge1xyXG4gICAgICAvLyB1bnNpZ25lZCAxNiBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmIChwaXhlbFJlcHJlc2VudGF0aW9uID09PSAxICYmIGJpdHNBbGxvY2F0ZWQgPT09IDE2KSB7XHJcbiAgICAgIC8vIHNpZ25lZCAxNiBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBwaXhlbERhdGFPZmZzZXQgKyBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHBpeGVsUmVwcmVzZW50YXRpb24gPT09IDAgJiYgYml0c0FsbG9jYXRlZCA9PT0gMzIpIHtcclxuICAgICAgLy8gdW5zaWduZWQgMzIgYml0XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gcGl4ZWxEYXRhT2Zmc2V0ICsgZnJhbWVJbmRleCAqIG51bVBpeGVscyAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAocGl4ZWxSZXByZXNlbnRhdGlvbiA9PT0gMCAmJiBiaXRzQWxsb2NhdGVkID09PSAxKSB7XHJcbiAgICAgIGxldCBuZXdCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobnVtUGl4ZWxzKTtcclxuICAgICAgbGV0IG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3QnVmZmVyKTtcclxuXHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gcGl4ZWxEYXRhT2Zmc2V0ICsgZnJhbWVJbmRleCAqIG51bVBpeGVscztcclxuICAgICAgbGV0IGluZGV4ID0gMDtcclxuXHJcbiAgICAgIGxldCBiaXRTdGFydCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XHJcbiAgICAgIGxldCBiaXRFbmQgPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzICsgbnVtUGl4ZWxzO1xyXG5cclxuICAgICAgbGV0IGJ5dGVTdGFydCA9IE1hdGguZmxvb3IoYml0U3RhcnQgLyA4KTtcclxuICAgICAgbGV0IGJpdFN0YXJ0T2Zmc2V0ID0gYml0U3RhcnQgLSBieXRlU3RhcnQgKiA4O1xyXG4gICAgICBsZXQgYnl0ZUVuZCA9IE1hdGguY2VpbChiaXRFbmQgLyA4KTtcclxuXHJcbiAgICAgIGxldCB0YXJnZXRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHBpeGVsRGF0YU9mZnNldCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gYnl0ZVN0YXJ0OyBpIDw9IGJ5dGVFbmQ7IGkrKykge1xyXG4gICAgICAgIHdoaWxlIChiaXRTdGFydE9mZnNldCA8IDgpIHtcclxuICAgICAgICAgIHN3aXRjaCAoYml0U3RhcnRPZmZzZXQpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMSAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMiAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gMyAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNCAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNSAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNiAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgIG5ld0FycmF5W2luZGV4XSA9IHRhcmdldEJ1ZmZlcltpXSA+Pj4gNyAmIDB4MDAwMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBiaXRTdGFydE9mZnNldCsrO1xyXG4gICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgIC8vIGlmIHJldHVybi4uXHJcbiAgICAgICAgICBpZiAoaW5kZXggPj0gbnVtUGl4ZWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYml0U3RhcnRPZmZzZXQgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY29udmVydENvbG9yU3BhY2UodW5jb21wcmVzc2VkRGF0YSkge1xyXG4gICAgbGV0IHJnYkRhdGEgPSBudWxsO1xyXG4gICAgbGV0IHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPSB0aGlzLnBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24oKTtcclxuICAgIGxldCBwbGFuYXJDb25maWd1cmF0aW9uID0gdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uKCk7XHJcblxyXG4gICAgaWYgKHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPT09ICdSR0InICYmXHJcbiAgICAgICAgcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMCkge1xyXG4gICAgICAvLyBBTEwgR09PRCwgQUxSRUFEWSBPUkRFUkVEXHJcbiAgICAgIC8vIHBsYW5hciBvciBub24gcGxhbmFyIHBsYW5hckNvbmZpZ3VyYXRpb25cclxuICAgICAgcmdiRGF0YSA9IHVuY29tcHJlc3NlZERhdGE7XHJcbiAgICB9IGVsc2UgaWYgKHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPT09ICdSR0InICYmXHJcbiAgICAgICAgcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xyXG4gICAgICBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgSW50OEFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmICh1bmNvbXByZXNzZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcclxuICAgICAgICByZ2JEYXRhID0gbmV3IEludDE2QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xyXG4gICAgICAgIHJnYkRhdGEgPSBuZXcgVWludDE2QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93ICd1bnN1cG9ydGVkIHR5cGVkIGFycmF5OiAke3VuY29tcHJlc3NlZERhdGF9JztcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG51bVBpeGVscyA9IHVuY29tcHJlc3NlZERhdGEubGVuZ3RoIC8gMztcclxuICAgICAgbGV0IHJnYmFJbmRleCA9IDA7XHJcbiAgICAgIGxldCBySW5kZXggPSAwO1xyXG4gICAgICBsZXQgZ0luZGV4ID0gbnVtUGl4ZWxzO1xyXG4gICAgICBsZXQgYkluZGV4ID0gbnVtUGl4ZWxzICogMjtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykge1xyXG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0gdW5jb21wcmVzc2VkRGF0YVtySW5kZXgrK107IC8vIHJlZFxyXG4gICAgICAgIHJnYkRhdGFbcmdiYUluZGV4KytdID0gdW5jb21wcmVzc2VkRGF0YVtnSW5kZXgrK107IC8vIGdyZWVuXHJcbiAgICAgICAgcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSB1bmNvbXByZXNzZWREYXRhW2JJbmRleCsrXTsgLy8gYmx1ZVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPT09ICdZQlJfRlVMTCcpIHtcclxuICAgICAgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcclxuICAgICAgICByZ2JEYXRhID0gbmV3IEludDhBcnJheSh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodW5jb21wcmVzc2VkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQ4QXJyYXkodW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHVuY29tcHJlc3NlZERhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XHJcbiAgICAgICAgcmdiRGF0YSA9IG5ldyBJbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmICh1bmNvbXByZXNzZWREYXRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcclxuICAgICAgICByZ2JEYXRhID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyAndW5zdXBvcnRlZCB0eXBlZCBhcnJheTogJHt1bmNvbXByZXNzZWREYXRhfSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFmZXkvY29ybmVyc3RvbmVXQURPSW1hZ2VMb2FkZXIvYmxvYi9tYXN0ZXIvc3JjL2RlY29kZVlCUkZ1bGwuanNcclxuICAgICAgbGV0IG5QaXhlbHMgPSB1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAvIDM7XHJcbiAgICAgIGxldCB5YnJJbmRleCA9IDA7XHJcbiAgICAgIGxldCByZ2JhSW5kZXggPSAwO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QaXhlbHM7IGkrKykge1xyXG4gICAgICAgIGxldCB5ID0gdW5jb21wcmVzc2VkRGF0YVt5YnJJbmRleCsrXTtcclxuICAgICAgICBsZXQgY2IgPSB1bmNvbXByZXNzZWREYXRhW3lickluZGV4KytdO1xyXG4gICAgICAgIGxldCBjciA9IHVuY29tcHJlc3NlZERhdGFbeWJySW5kZXgrK107XHJcbiAgICAgICAgcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSB5ICsgMS40MDIwMCAqIChjciAtIDEyOCk7Ly8gcmVkXHJcbiAgICAgICAgcmdiRGF0YVtyZ2JhSW5kZXgrK10gPSB5IC0gMC4zNDQxNCAqIChjYiAtIDEyOCkgLSAwLjcxNDE0ICogKGNyIC0gMTI4KTsgLy8gZ3JlZW5cclxuICAgICAgICByZ2JEYXRhW3JnYmFJbmRleCsrXSA9IHkgKyAxLjc3MjAwICogKGNiIC0gMTI4KTsgLy8gYmx1ZVxyXG4gICAgICAgIC8vIHJnYkRhdGFbcmdiYUluZGV4KytdID0gMjU1OyAvL2FscGhhXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93ICdwaG90b21ldHJpYyBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQ6ICR7cGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbn0nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZ2JEYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3dhcCBieXRlcyBpbiBmcmFtZS5cclxuICAgKi9cclxuICBfc3dhcEZyYW1lKGZyYW1lKSB7XHJcbiAgICAvLyBzd2FwIGJ5dGVzICggaWYgOGJpdHMgKDFieXRlKSwgbm90aGluZyB0byBzd2FwKVxyXG4gICAgbGV0IGJpdHNBbGxvY2F0ZWQgPSB0aGlzLmJpdHNBbGxvY2F0ZWQoKTtcclxuXHJcbiAgICBpZiAoYml0c0FsbG9jYXRlZCA9PT0gMTYpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZyYW1lW2ldID0gdGhpcy5fc3dhcDE2KGZyYW1lW2ldKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChiaXRzQWxsb2NhdGVkID09PSAzMikge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZnJhbWVbaV0gPSB0aGlzLl9zd2FwMzIoZnJhbWVbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZyYW1lO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8vIFZKUy5wYXJzZXJzLmRpY29tLnByb3RvdHlwZS5mcmFtZU9mUmVmZXJlbmNlVUlEID0gZnVuY3Rpb24oaW1hZ2VKcXVlcnlEb20pIHtcclxuLy8gICAvLyB0cnkgdG8gYWNjZXNzIGZyYW1lIG9mIHJlZmVyZW5jZSBVSUQgdGhyb3VnaCBpdHMgRElDT00gdGFnXHJcbi8vICAgbGV0IHNlcmllc051bWJlciA9IGltYWdlSnF1ZXJ5RG9tLmZpbmQoJ1t0YWc9XCIwMDIwMDA1MlwiXSBWYWx1ZScpLnRleHQoKTtcclxuXHJcbi8vICAgLy8gaWYgbm90IGF2YWlsYWJsZSwgYXNzdW1lIHdlIG9ubHkgaGF2ZSAxIGZyYW1lXHJcbi8vICAgaWYgKHNlcmllc051bWJlciA9PT0gJycpIHtcclxuLy8gICAgIHNlcmllc051bWJlciA9IDE7XHJcbi8vICAgfVxyXG4vLyAgIHJldHVybiBzZXJpZXNOdW1iZXI7XHJcbi8vIH07XHJcblxyXG4vL1xyXG4vLyBFTkRJQU4gTkVTUyBOT1QgVEFLRU4gQ0FSRSBPRlxyXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUzMjA0MzkvaG93LWRvLWktc3dhcC1lbmRpYW4tbmVzcy1ieXRlLW9yZGVyLW9mLWEtbGV0aWFibGUtaW4tamF2YXNjcmlwdFxyXG4vLyBodHRwOi8vd3d3LmJhcnJlLm5vbS5mci9tZWRpY2FsL3NhbXBsZXMvXHJcbi8vXHJcbi8vXHJcbiIsImltcG9ydCBEaWNvbSBmcm9tICcuL3BhcnNlcnMuZGljb20nO1xyXG5pbXBvcnQgTmlmdGkgZnJvbSAnLi9wYXJzZXJzLm5pZnRpJztcclxuaW1wb3J0IE5ycmQgZnJvbSAnLi9wYXJzZXJzLm5ycmQnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgcGFyc2Vyc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBEaWNvbSxcclxuICBOaWZ0aSxcclxuICBOcnJkLFxyXG59O1xyXG4iLCIvKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBwYXJzZXJzL21oZFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc01IRCBleHRlbmRzIFBhcnNlcnNWb2x1bWUge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIEBtZW1iZXJcclxuICAgICAgKiBAdHlwZSB7YXJyYXlidWZmZXJ9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5faWQgPSBpZDtcclxuICAgIHRoaXMuX3VybCA9IGRhdGEudXJsO1xyXG4gICAgdGhpcy5faGVhZGVyID0ge307XHJcbiAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIHBhcnNlIGhlYWRlciAobWhkKSBkYXRhXHJcbiAgICAgIGxldCBsaW5lcyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhLm1oZEJ1ZmZlcikuc3BsaXQoJ1xcbicpO1xyXG4gICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XHJcbiAgICAgICAgICBsZXQga2V5dmFsdWUgPSBsaW5lLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICBpZiAoa2V5dmFsdWUubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcltrZXl2YWx1ZVswXS50cmltKCldID0ga2V5dmFsdWVbMV0udHJpbSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX2hlYWRlci5EaW1TaXplID0gdGhpcy5faGVhZGVyLkRpbVNpemUuc3BsaXQoJyAnKTtcclxuICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nID0gdGhpcy5faGVhZGVyLkVsZW1lbnRTcGFjaW5nLnNwbGl0KCcgJyk7XHJcbiAgICAgIHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXggPSB0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4LnNwbGl0KCcgJyk7XHJcbiAgICAgIHRoaXMuX2hlYWRlci5PZmZzZXQgPSB0aGlzLl9oZWFkZXIuT2Zmc2V0LnNwbGl0KCcgJyk7XHJcbiAgICAgIC8vXHJcbiAgICAgIHRoaXMuX2J1ZmZlciA9IGRhdGEucmF3QnVmZmVyO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdvb29wcy4uLiA6KCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmlnaHRIYW5kZWQoKSB7XHJcbiAgICBsZXQgYW5hdG9taWNhbE9yaWVudGF0aW9uID0gdGhpcy5faGVhZGVyLkFuYXRvbWljYWxPcmllbnRhdGlvbjtcclxuICAgIGlmIChhbmF0b21pY2FsT3JpZW50YXRpb24gPT09ICdSQVMnIHx8XHJcbiAgICAgICAgYW5hdG9taWNhbE9yaWVudGF0aW9uID09PSAnUlBJJyB8fFxyXG4gICAgICAgIGFuYXRvbWljYWxPcmllbnRhdGlvbiA9PT0gJ0xQUycgfHxcclxuICAgICAgICBhbmF0b21pY2FsT3JpZW50YXRpb24gPT09ICdMQUknKSB7XHJcbiAgICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3JpZ2h0SGFuZGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3JpZ2h0SGFuZGVkO1xyXG4gIH1cclxuXHJcbiAgc2VyaWVzSW5zdGFuY2VVSUQoKSB7XHJcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cclxuICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkZyYW1lcygpIHtcclxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl9oZWFkZXIuRGltU2l6ZVsyXSwgMTApO1xyXG4gIH1cclxuXHJcbiAgc29wSW5zdGFuY2VVSUQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBmcmFtZUluZGV4O1xyXG4gIH1cclxuXHJcbiAgcm93cyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2hlYWRlci5EaW1TaXplWzFdLCAxMCk7XHJcbiAgfVxyXG5cclxuICBjb2x1bW5zKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5faGVhZGVyLkRpbVNpemVbMF0sIDEwKTtcclxuICB9XHJcblxyXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gMCAtIGludFxyXG4gICAgLy8gMSAtIGZsb2F0XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIGJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcclxuXHJcbiAgICBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VDSEFSJyB8fFxyXG4gICAgICAgIHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xyXG4gICAgICBiaXRzQWxsb2NhdGVkID0gODtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcgfHxcclxuICAgICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfU0hPUlQnKSB7XHJcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAxNjtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgdGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VGTE9BVCcgfHxcclxuICAgICAgICB0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfRkxPQVQnKSB7XHJcbiAgICAgIGJpdHNBbGxvY2F0ZWQgPSAzMjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYml0c0FsbG9jYXRlZDtcclxuICB9XHJcblxyXG4gIHBpeGVsU3BhY2luZyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IHggPSBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5FbGVtZW50U3BhY2luZ1swXSwgMTApO1xyXG4gICAgbGV0IHkgPSBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5FbGVtZW50U3BhY2luZ1sxXSwgMTApO1xyXG4gICAgbGV0IHogPSBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5FbGVtZW50U3BhY2luZ1syXSwgMTApO1xyXG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcclxuICB9XHJcblxyXG4gIGltYWdlT3JpZW50YXRpb24oZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBpbnZlcnRYID0gdGhpcy5faGVhZGVyLkFuYXRvbWljYWxPcmllbnRhdGlvbi5tYXRjaCgvTC8pID8gLTEgOiAxO1xyXG4gICAgbGV0IGludmVydFkgPSB0aGlzLl9oZWFkZXIuQW5hdG9taWNhbE9yaWVudGF0aW9uLm1hdGNoKC9QLykgPyAtMSA6IDE7XHJcblxyXG4gICAgbGV0IHggPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzBdKSAqIGludmVydFgsXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFsxXSkgKiBpbnZlcnRZLFxyXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbMl0pKTtcclxuICAgIHgubm9ybWFsaXplKCk7XHJcblxyXG4gICAgbGV0IHkgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgcGFyc2VGbG9hdCh0aGlzLl9oZWFkZXIuVHJhbnNmb3JtTWF0cml4WzNdKSAqIGludmVydFgsXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLlRyYW5zZm9ybU1hdHJpeFs0XSkgKiBpbnZlcnRZLFxyXG4gICAgICBwYXJzZUZsb2F0KHRoaXMuX2hlYWRlci5UcmFuc2Zvcm1NYXRyaXhbNV0pKTtcclxuICAgIHkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeC54LCB4LnksIHgueixcclxuICAgICAgeS54LCB5LnksIHkueixcclxuICAgICAgXTtcclxuICB9XHJcblxyXG4gIGltYWdlUG9zaXRpb24oZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLk9mZnNldFswXSksXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLk9mZnNldFsxXSksXHJcbiAgICAgIHBhcnNlRmxvYXQodGhpcy5faGVhZGVyLk9mZnNldFsyXSksXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XHJcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGxldCBzcHYgPSBwaXhlbERhdGFbaW5kZXhdO1xyXG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XHJcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XHJcbiAgfVxyXG5cclxuICBfZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcclxuICAgIGxldCBudW1iZXJPZkNoYW5uZWxzID0gdGhpcy5udW1iZXJPZkNoYW5uZWxzKCk7XHJcbiAgICBsZXQgbnVtUGl4ZWxzID1cclxuICAgICAgdGhpcy5yb3dzKGZyYW1lSW5kZXgpICogdGhpcy5jb2x1bW5zKGZyYW1lSW5kZXgpICogbnVtYmVyT2ZDaGFubmVscztcclxuICAgIGlmICghdGhpcy5yaWdodEhhbmRlZCgpKSB7XHJcbiAgICAgIGZyYW1lSW5kZXggPSB0aGlzLm51bWJlck9mRnJhbWVzKCkgLSAxIC0gZnJhbWVJbmRleDtcclxuICAgIH1cclxuICAgIGxldCBmcmFtZU9mZnNldCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHM7XHJcblxyXG4gICAgaWYgKHRoaXMuX2hlYWRlci5FbGVtZW50VHlwZSA9PT0gJ01FVF9DSEFSJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0O1xyXG4gICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfVUNIQVInKSB7XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQ7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9oZWFkZXIuRWxlbWVudFR5cGUgPT09ICdNRVRfU0hPUlQnKSB7XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiAyO1xyXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX1VTSE9SVCcpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5faGVhZGVyLkVsZW1lbnRUeXBlID09PSAnTUVUX0ZMT0FUJykge1xyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogNDtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiLy8gdXNlIG5pZnRpLWpzIGFuZCBqdXN0IHBhcnNlIGhlYWRlci4/Pz9cclxuXHJcbi8vIFNsaWNlciB3YXkgdG8gaGFuZGxlIGltYWdlc1xyXG4vLyBzaG91bGQgZm9sbG93IGl0Li4uXHJcbiAvLyA4OTcgICBpZiAoICh0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSAhPSBpZHhTZXJpZXNJbnN0YW5jZVVJRCAmJiB0aGlzLT5JbmRleFNlcmllc0luc3RhbmNlVUlEc1trXSA+PSAwICYmIGlkeFNlcmllc0luc3RhbmNlVUlEID49IDApIHx8XHJcbiAvLyA4OTggICAgICAgICh0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdICE9IGlkeENvbnRlbnRUaW1lICYmIHRoaXMtPkluZGV4Q29udGVudFRpbWVba10gPj0gMCAmJiBpZHhDb250ZW50VGltZSA+PSAwKSB8fFxyXG4gLy8gODk5ICAgICAgICAodGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSAhPSBpZHhUcmlnZ2VyVGltZSAmJiB0aGlzLT5JbmRleFRyaWdnZXJUaW1lW2tdID49IDAgJiYgaWR4VHJpZ2dlclRpbWUgPj0gMCkgfHxcclxuIC8vIDkwMCAgICAgICAgKHRoaXMtPkluZGV4RWNob051bWJlcnNba10gIT0gaWR4RWNob051bWJlcnMgJiYgdGhpcy0+SW5kZXhFY2hvTnVtYmVyc1trXSA+PSAwICYmIGlkeEVjaG9OdW1iZXJzID49IDApIHx8XHJcbiAvLyA5MDEgICAgICAgICh0aGlzLT5JbmRleERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb25ba10gIT0gaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiAgJiYgdGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdID49IDAgJiYgaWR4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbiA+PSAwKSB8fFxyXG4gLy8gOTAyICAgICAgICAodGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdICE9IGlkeFNsaWNlTG9jYXRpb24gJiYgdGhpcy0+SW5kZXhTbGljZUxvY2F0aW9uW2tdID49IDAgJiYgaWR4U2xpY2VMb2NhdGlvbiA+PSAwKSB8fFxyXG4gLy8gOTAzICAgICAgICAodGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSAhPSBpZHhJbWFnZU9yaWVudGF0aW9uUGF0aWVudCAmJiB0aGlzLT5JbmRleEltYWdlT3JpZW50YXRpb25QYXRpZW50W2tdID49IDAgJiYgaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgPj0gMCkgKVxyXG4gLy8gOTA0ICAgICB7XHJcbiAvLyA5MDUgICAgICAgY29udGludWU7XHJcbiAvLyA5MDYgICAgIH1cclxuXHJcbi8vIGh0dHA6Ly9icmFpbmRlci5vcmcvMjAxMi8wOS8yMy90aGUtbmlmdGktZmlsZS1mb3JtYXQvXHJcblxyXG4vKiogKiBJbXBvcnRzICoqKi9cclxuaW1wb3J0IFBhcnNlcnNWb2x1bWUgZnJvbSAnLi9wYXJzZXJzLnZvbHVtZSc7XHJcblxyXG5sZXQgTmlmdGlSZWFkZXIgPSByZXF1aXJlKCduaWZ0aS1yZWFkZXItanMnKTtcclxuLyoqXHJcbiAqIEBtb2R1bGUgcGFyc2Vycy9uaWZ0aVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2Vyc05pZnRpIGV4dGVuZHMgUGFyc2Vyc1ZvbHVtZSB7XHJcbiAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQG1lbWJlclxyXG4gICAgICAqIEB0eXBlIHthcnJheWJ1ZmZlcn1cclxuICAgICovXHJcbiAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgdGhpcy5fYXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcclxuICAgIHRoaXMuX3VybCA9IGRhdGEudXJsO1xyXG4gICAgdGhpcy5fZGF0YVNldCA9IG51bGw7XHJcbiAgICB0aGlzLl9uaWZ0aUhlYWRlciA9IG51bGw7XHJcbiAgICB0aGlzLl9uaWZ0aUltYWdlID0gbnVsbDtcclxuICAgIHRoaXMuX29yZGVyZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fb3JkZXJlZERhdGEgPSBudWxsO1xyXG5cclxuICAgIC8vXHJcbiAgICB0aGlzLl9xZmFjID0gMS4wO1xyXG5cclxuICAgIGlmIChOaWZ0aVJlYWRlci5pc05JRlRJKHRoaXMuX2FycmF5QnVmZmVyKSkge1xyXG4gICAgICB0aGlzLl9kYXRhU2V0ID0gTmlmdGlSZWFkZXIucmVhZEhlYWRlcih0aGlzLl9hcnJheUJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuX25pZnRpSW1hZ2UgPVxyXG4gICAgICAgIE5pZnRpUmVhZGVyLnJlYWRJbWFnZSh0aGlzLl9kYXRhU2V0LCB0aGlzLl9hcnJheUJ1ZmZlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyAncGFyc2Vycy5uaWZ0aSBjb3VsZCBub3QgcGFyc2UgdGhlIGZpbGUnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2VyaWVzSW5zdGFuY2VVSUQoKSB7XHJcbiAgICAvLyB1c2UgZmlsZW5hbWUgKyB0aW1lc3RhbXAuLj9cclxuICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkZyYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LmRpbXNbM107XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkNoYW5uZWxzKCkge1xyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xyXG5cclxuICAgIC8vIGNhbiBkaW1zWzBdID49IDUgYW5kIG5vdCBtdWx0aSBjaGFubmVscyB3aXRoIFJHQiBkYXRhdHlwZWNvZGU/XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuZGltc1swXSA+PSA1KSB7XHJcbiAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLl9kYXRhU2V0LmRpbXNbNV07XHJcbiAgICAgIHRoaXMuX29yZGVyZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDEyOCkge1xyXG4gICAgICBudW1iZXJPZkNoYW5uZWxzID0gMztcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDIzMDQpIHtcclxuICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IDQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICBzb3BJbnN0YW5jZVVJRChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICByb3dzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5kaW1zWzJdO1xyXG4gIH1cclxuXHJcbiAgY29sdW1ucyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuZGltc1sxXTtcclxuICB9XHJcblxyXG4gIHBpeGVsVHlwZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UOCAgICAgICAgICAgPSAyO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDE2ICAgICAgICAgICA9IDQ7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfSU5UMzIgICAgICAgICAgID0gODtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9GTE9BVDMyICAgICAgICA9IDE2O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVg2NCAgICAgID0gMzI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQ2NCAgICAgICAgPSA2NDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9SR0IyNCAgICAgICAgID0gMTI4O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDggICAgICAgICAgPSAyNTY7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDE2ICAgICAgICA9IDUxMjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9VSU5UMzIgICAgICAgID0gNzY4O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDY0ICAgICAgICA9IDEwMjQ7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDY0ICAgICAgID0gMTI4MDtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9GTE9BVDEyOCAgICAgPSAxNTM2O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgxMjggICA9IDE3OTI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfQ09NUExFWDI1NiAgID0gMjA0ODtcclxuXHJcbiAgICAvLyAwIGludGVnZXIsIDEgZmxvYXRcclxuXHJcbiAgICBsZXQgcGl4ZWxUeXBlID0gMDtcclxuICAgIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMTYgfHxcclxuICAgICAgdGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDY0IHx8XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxNTM2KSB7XHJcbiAgICAgIHBpeGVsVHlwZSA9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGl4ZWxUeXBlO1xyXG4gIH1cclxuXHJcbiAgYml0c0FsbG9jYXRlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQubnVtQml0c1BlclZveGVsO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxTcGFjaW5nKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLl9kYXRhU2V0LnBpeERpbXNbMV0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQucGl4RGltc1syXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5waXhEaW1zWzNdLFxyXG4gICAgICBdO1xyXG4gIH1cclxuXHJcbiAgc2xpY2VUaGlja25lc3MoKSB7XHJcbiAgICAvLyBzaG91bGQgYmUgYSBzdHJpbmcuLi5cclxuICAgIHJldHVybiBudWxsOy8vIHRoaXMuX2RhdGFTZXQucGl4RGltc1szXS50b1N0cmluZygpO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VPcmllbnRhdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMuX2RhdGFTZXQpO1xyXG4gICAgLy8gaHR0cDovL25pZnRpLm5pbWgubmloLmdvdi9wdWIvZGlzdC9zcmMvbmlmdGlsaWIvbmlmdGkxLmhcclxuICAgIC8vIGh0dHA6Ly9uaWZ0aS5uaW1oLm5paC5nb3YvcHViL2Rpc3Qvc3JjL25pZnRpbGliL25pZnRpMV9pby5jXHJcbiAgICBpZiAodGhpcy5fZGF0YVNldC5xZm9ybV9jb2RlID4gMCkge1xyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2l0d2FyZS9JVEsvYmxvYi9tYXN0ZXIvTW9kdWxlcy9JTy9OSUZUSS9zcmMvaXRrTmlmdGlJbWFnZUlPLmN4eFxyXG4gICAgICBsZXQgYSA9IDAuMDtcclxuICAgICAgbGV0IGIgPSB0aGlzLl9kYXRhU2V0LnF1YXRlcm5fYjtcclxuICAgICAgbGV0IGMgPSB0aGlzLl9kYXRhU2V0LnF1YXRlcm5fYztcclxuICAgICAgbGV0IGQgPSB0aGlzLl9kYXRhU2V0LnF1YXRlcm5fZDtcclxuICAgICAgLy8gY29tcHV0ZSBhXHJcbiAgICAgIGEgPSAxLjAgLSAoYipiICsgYypjICsgZCpkKTtcclxuICAgICAgaWYgKGEgPCAwLjAwMDAwMDEpIHtcclxuICAgICAgICAgICAgICAgICAgIC8qIHNwZWNpYWwgY2FzZSAqL1xyXG5cclxuICAgICAgICBhID0gMS4wIC8gTWF0aC5zcXJ0KGIqYitjKmMrZCpkKTtcclxuICAgICAgICBiICo9IGE7IGMgKj0gYTsgZCAqPSBhOyAgICAgICAgLyogbm9ybWFsaXplIChiLGMsZCkgdmVjdG9yICovXHJcbiAgICAgICAgYSA9IDAuMDsgICAgICAgICAgICAgICAgICAgICAgIC8qIGEgPSAwID09PiAxODAgZGVncmVlIHJvdGF0aW9uICovXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IE1hdGguc3FydChhKTsgICAgICAgICAgICAgICAgICAgICAvKiBhbmdsZSA9IDIqYXJjY29zKGEpICovXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9kYXRhU2V0LnBpeERpbXNbMF0gPCAwLjApIHtcclxuICAgICAgICB0aGlzLl9yaWdodEhhbmRlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIC0oYSphK2IqYi1jKmMtZCpkKSxcclxuICAgICAgICAgIC0yKihiKmMrYSpkKSxcclxuICAgICAgICAgIDIqKGIqZC1hKmMpLFxyXG4gICAgICAgICAgLTIqKGIqYy1hKmQpLFxyXG4gICAgICAgICAgLShhKmErYypjLWIqYi1kKmQpLFxyXG4gICAgICAgICAgMiooYypkK2EqYiksXHJcbiAgICAgICAgXTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5zZm9ybV9jb2RlID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnc2Zvcm0gPiAwJyk7XHJcblxyXG4gICAgICBsZXQgc3ggPSB0aGlzLl9kYXRhU2V0LnNyb3dfeDtcclxuICAgICAgbGV0IHN5ID0gdGhpcy5fZGF0YVNldC5zcm93X3k7XHJcbiAgICAgIGxldCBzeiA9IHRoaXMuX2RhdGFTZXQuc3Jvd196O1xyXG4gICAgICAvLyBmaWxsIElKS1RvUkFTXHJcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAwLCBzeFswXSwgc3hbMV0sIHN4WzJdLCBzeFszXSk7XHJcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAxLCBzeVswXSwgc3lbMV0sIHN5WzJdLCBzeVszXSk7XHJcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAyLCBzelswXSwgc3pbMV0sIHN6WzJdLCBzelszXSk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQucWZvcm1fY29kZSA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZygncWZvcm0gPT09IDAnKTtcclxuXHJcblxyXG4gICAgICAvLyBmaWxsIElKS1RvUkFTXHJcbiAgICAgIC8vIGdvb2cudmVjLk1hdDQuc2V0Um93VmFsdWVzKElKS1RvUkFTLCAwLCBNUkkucGl4ZGltWzFdLCAwLCAwLCAwKTtcclxuICAgICAgLy8gZ29vZy52ZWMuTWF0NC5zZXRSb3dWYWx1ZXMoSUpLVG9SQVMsIDEsIDAsIE1SSS5waXhkaW1bMl0sIDAsIDApO1xyXG4gICAgICAvLyBnb29nLnZlYy5NYXQ0LnNldFJvd1ZhbHVlcyhJSktUb1JBUywgMiwgMCwgMCwgTVJJLnBpeGRpbVszXSwgMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDEsIDBdO1xyXG4gIH1cclxuXHJcbiAgaW1hZ2VQb3NpdGlvbihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gcW9mZnNldCBpcyBSQVNcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC10aGlzLl9kYXRhU2V0LnFvZmZzZXRfeCxcclxuICAgICAgLXRoaXMuX2RhdGFTZXQucW9mZnNldF95LFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnFvZmZzZXRfeixcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dDZW50ZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dXaWR0aChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgLy8gY2FsYyBtaW4gYW5kIGNhbGMgbWF4XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJlc2NhbGVTbG9wZShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc2NsX3Nsb3BlO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc2NsX2ludGVyY2VwdDtcclxuICB9XHJcblxyXG4gIG1pbk1heFBpeGVsRGF0YShwaXhlbERhdGEgPSBbXSkge1xyXG4gICAgbGV0IG1pbk1heCA9IFs2NTUzNSwgLTMyNzY4XTtcclxuICAgIGxldCBudW1QaXhlbHMgPSBwaXhlbERhdGEubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVBpeGVsczsgaW5kZXgrKykge1xyXG4gICAgICBsZXQgc3B2ID0gcGl4ZWxEYXRhW2luZGV4XTtcclxuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBzcHYpO1xyXG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIHNwdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbk1heDtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RQaXhlbERhdGEoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXgpO1xyXG4gICAgLy8gbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQuaW1hZ2VEYXRhO1xyXG4gICAgLy8gaWYgKHRoaXMuX2RhdGFTZXQuY29tcHJlc3NlZCkge1xyXG4gICAgLy8gbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQucmF3RGF0YVswXTtcclxuICAgIC8vIHRyeSB7XHJcbiAgICAvLyAgIGxldCBkYXRhID0gcGFrby5pbmZsYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xyXG4gICAgLy8gICBidWZmZXIgPSBkYXRhLmJ1ZmZlcjtcclxuICAgIC8vIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyhidWZmZXIpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIGlzIGl0IGNvbXByZXNzZWQ/XHJcbiAgICAvLyB5ZXMvbm9cclxuXHJcbiAgICAvLyAgICAgdHJ5IHtcclxuICAgIC8vICAgdmFyIHJlc3VsdCA9IHBha28uaW5mbGF0ZShjb21wcmVzc2VkKTtcclxuICAgIC8vIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHdpbmRvdy5jb25zb2xlLmxvZyh0aGlzKTtcclxuICB9XHJcblxyXG4gIF9kZWNvbXByZXNzVW5jb21wcmVzc2VkKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDggICAgICAgICAgID0gMjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9JTlQxNiAgICAgICAgICAgPSA0O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0lOVDMyICAgICAgICAgICA9IDg7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQzMiAgICAgICAgPSAxNjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9DT01QTEVYNjQgICAgICA9IDMyO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0ZMT0FUNjQgICAgICAgID0gNjQ7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfUkdCMjQgICAgICAgICA9IDEyODtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9JTlQ4ICAgICAgICAgID0gMjU2O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQxNiAgICAgICAgPSA1MTI7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfVUlOVDMyICAgICAgICA9IDc2ODtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9JTlQ2NCAgICAgICAgPSAxMDI0O1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX1VJTlQ2NCAgICAgICA9IDEyODA7XHJcbiAgICAvLyBwYXBheWEudm9sdW1lLm5pZnRpLk5JRlRJX1RZUEVfRkxPQVQxMjggICAgID0gMTUzNjtcclxuICAgIC8vIHBhcGF5YS52b2x1bWUubmlmdGkuTklGVElfVFlQRV9DT01QTEVYMTI4ICAgPSAxNzkyO1xyXG4gICAgLy8gcGFwYXlhLnZvbHVtZS5uaWZ0aS5OSUZUSV9UWVBFX0NPTVBMRVgyNTYgICA9IDIwNDg7XHJcblxyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcclxuICAgIGxldCBudW1QaXhlbHMgPVxyXG4gICAgICB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgLy8gaWYoICF0aGlzLnJpZ2h0SGFuZGVkKCkgKXtcclxuICAgIC8vICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xyXG4gICAgLy8gfVxyXG4gICAgbGV0IGZyYW1lT2Zmc2V0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcclxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9uaWZ0aUltYWdlO1xyXG5cclxuICAgIC8vIHVzZSBiaXRzIGFsbG9jYXRlZCAmJiBwaXhlbCByZXByZW5zZW50YXRpb24gdG9vXHJcbiAgICBpZiAoIXRoaXMuX29yZGVyZWQgJiYgdGhpcy5fb3JkZXJlZERhdGEgPT09IG51bGwpIHtcclxuICAgICAgLy8gb3JkZXIgdGhlblxyXG4gICAgICB0aGlzLl9yZW9yZGVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9vcmRlcmVkRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBqdXN0IGEgc2xpY2UuLi5cclxuICAgICAgcmV0dXJuIHRoaXMuX29yZGVyZWREYXRhLnNsaWNlKGZyYW1lT2Zmc2V0LCBmcmFtZU9mZnNldCArIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyKSB7XHJcbiAgICAgIC8vIHVuc2lnbmVkIGludCA4IGJpdFxyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDI1Nikge1xyXG4gICAgICAvLyBzaWduZWQgaW50IDggYml0XHJcbiAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA1MTIpIHtcclxuICAgICAgLy8gdW5zaWduZWQgaW50IDE2IGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gNCkge1xyXG4gICAgICAvLyBzaWduZWQgaW50IDE2IGJpdFxyXG4gICAgICBmcmFtZU9mZnNldCA9IGZyYW1lT2Zmc2V0ICogMjtcclxuICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA4KSB7XHJcbiAgICAgIC8vIHNpZ25lZCBpbnQgMzIgYml0XHJcbiAgICAgIGZyYW1lT2Zmc2V0ID0gZnJhbWVPZmZzZXQgKiA0O1xyXG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDE2KSB7XHJcbiAgICAgIC8vIHNpZ25lZCBmbG9hdCAzMiBiaXRcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgVW5rbm93biBkYXRhIHR5cGU6IGRhdGF0eXBlQ29kZSA6ICR7dGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGV9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcmVvcmRlckRhdGEoKSB7XHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ3JlLW9yZGVyJyk7XHJcbiAgICBsZXQgbnVtYmVyT2ZDaGFubmVscyA9IHRoaXMubnVtYmVyT2ZDaGFubmVscygpO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHRoaXMucm93cygpICogdGhpcy5jb2x1bW5zKCkgKiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX25pZnRpSW1hZ2U7XHJcblxyXG4gICAgbGV0IHRvdGFsTnVtUGl4ZWxzID0gbnVtUGl4ZWxzICogdGhpcy5udW1iZXJPZkZyYW1lcygpO1xyXG4gICAgbGV0IHRtcCA9IG51bGw7XHJcbiAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAyKSB7XHJcbiAgICAgIC8vIHVuc2lnbmVkIDggYml0XHJcbiAgICAgIHRtcCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBVaW50OEFycmF5KHRtcC5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhU2V0LmRhdGF0eXBlQ29kZSA9PT0gMjU2KSB7XHJcbiAgICAgIC8vIHNpZ25lZCA4IGJpdFxyXG4gICAgICB0bXAgPSBuZXcgSW50OEFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkodG1wLmxlbmd0aCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSA1MTIpIHtcclxuICAgICAgdG1wID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBVaW50MTZBcnJheSh0bXAubGVuZ3RoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YVNldC5kYXRhdHlwZUNvZGUgPT09IDQpIHtcclxuICAgICAgdG1wID0gbmV3IEludDE2QXJyYXkoYnVmZmVyLCAwLCB0b3RhbE51bVBpeGVscyk7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhID0gbmV3IEludDE2QXJyYXkodG1wLmxlbmd0aCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQuZGF0YXR5cGVDb2RlID09PSAxNikge1xyXG4gICAgICB0bXAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgMCwgdG90YWxOdW1QaXhlbHMpO1xyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodG1wLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmUtb3JkZXIgcGl4ZWxzLi4uXHJcbiAgICBsZXQgbnVtUGl4ZWxzMiA9IHRtcC5sZW5ndGggLyAzO1xyXG4gICAgbGV0IHJnYmFJbmRleCA9IDA7XHJcbiAgICBsZXQgckluZGV4ID0gMDtcclxuICAgIGxldCBnSW5kZXggPSBudW1QaXhlbHMyO1xyXG4gICAgbGV0IGJJbmRleCA9IG51bVBpeGVsczIgKiAyO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGl4ZWxzMjsgaSsrKSB7XHJcbiAgICAgIHRoaXMuX29yZGVyZWREYXRhW3JnYmFJbmRleCsrXSA9IHRtcFtySW5kZXgrK107IC8vIHJlZFxyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YVtyZ2JhSW5kZXgrK10gPSB0bXBbZ0luZGV4KytdOyAvLyBncmVlblxyXG4gICAgICB0aGlzLl9vcmRlcmVkRGF0YVtyZ2JhSW5kZXgrK10gPSB0bXBbYkluZGV4KytdOyAvLyBibHVlXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb3JkZXJlZCA9IHRydWU7XHJcbiAgfVxyXG59XHJcbiIsIi8vIHVzZSBuaWZ0aS1qcyBhbmQganVzdCBwYXJzZSBoZWFkZXIuPz8/XHJcblxyXG4vLyBTbGljZXIgd2F5IHRvIGhhbmRsZSBpbWFnZXNcclxuLy8gc2hvdWxkIGZvbGxvdyBpdC4uLlxyXG4gLy8gODk3ICAgaWYgKCAodGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gIT0gaWR4U2VyaWVzSW5zdGFuY2VVSUQgJiYgdGhpcy0+SW5kZXhTZXJpZXNJbnN0YW5jZVVJRHNba10gPj0gMCAmJiBpZHhTZXJpZXNJbnN0YW5jZVVJRCA+PSAwKSB8fFxyXG4gLy8gODk4ICAgICAgICAodGhpcy0+SW5kZXhDb250ZW50VGltZVtrXSAhPSBpZHhDb250ZW50VGltZSAmJiB0aGlzLT5JbmRleENvbnRlbnRUaW1lW2tdID49IDAgJiYgaWR4Q29udGVudFRpbWUgPj0gMCkgfHxcclxuIC8vIDg5OSAgICAgICAgKHRoaXMtPkluZGV4VHJpZ2dlclRpbWVba10gIT0gaWR4VHJpZ2dlclRpbWUgJiYgdGhpcy0+SW5kZXhUcmlnZ2VyVGltZVtrXSA+PSAwICYmIGlkeFRyaWdnZXJUaW1lID49IDApIHx8XHJcbiAvLyA5MDAgICAgICAgICh0aGlzLT5JbmRleEVjaG9OdW1iZXJzW2tdICE9IGlkeEVjaG9OdW1iZXJzICYmIHRoaXMtPkluZGV4RWNob051bWJlcnNba10gPj0gMCAmJiBpZHhFY2hvTnVtYmVycyA+PSAwKSB8fFxyXG4gLy8gOTAxICAgICAgICAodGhpcy0+SW5kZXhEaWZmdXNpb25HcmFkaWVudE9yaWVudGF0aW9uW2tdICE9IGlkeERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb24gICYmIHRoaXMtPkluZGV4RGlmZnVzaW9uR3JhZGllbnRPcmllbnRhdGlvbltrXSA+PSAwICYmIGlkeERpZmZ1c2lvbkdyYWRpZW50T3JpZW50YXRpb24gPj0gMCkgfHxcclxuIC8vIDkwMiAgICAgICAgKHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSAhPSBpZHhTbGljZUxvY2F0aW9uICYmIHRoaXMtPkluZGV4U2xpY2VMb2NhdGlvbltrXSA+PSAwICYmIGlkeFNsaWNlTG9jYXRpb24gPj0gMCkgfHxcclxuIC8vIDkwMyAgICAgICAgKHRoaXMtPkluZGV4SW1hZ2VPcmllbnRhdGlvblBhdGllbnRba10gIT0gaWR4SW1hZ2VPcmllbnRhdGlvblBhdGllbnQgJiYgdGhpcy0+SW5kZXhJbWFnZU9yaWVudGF0aW9uUGF0aWVudFtrXSA+PSAwICYmIGlkeEltYWdlT3JpZW50YXRpb25QYXRpZW50ID49IDApIClcclxuIC8vIDkwNCAgICAge1xyXG4gLy8gOTA1ICAgICAgIGNvbnRpbnVlO1xyXG4gLy8gOTA2ICAgICB9XHJcblxyXG4vLyBodHRwOi8vYnJhaW5kZXIub3JnLzIwMTIvMDkvMjMvdGhlLW5pZnRpLWZpbGUtZm9ybWF0L1xyXG5cclxuLyoqICogSW1wb3J0cyAqKiovXHJcbmltcG9ydCBQYXJzZXJzVm9sdW1lIGZyb20gJy4vcGFyc2Vycy52b2x1bWUnO1xyXG5cclxubGV0IHBha28gPSByZXF1aXJlKCdwYWtvJyk7XHJcbmxldCBOcnJkUmVhZGVyID0gcmVxdWlyZSgnbnJyZC1qcycpO1xyXG4vKipcclxuICogQG1vZHVsZSBwYXJzZXJzL25pZnRpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzTmlmdGkgZXh0ZW5kcyBQYXJzZXJzVm9sdW1lIHtcclxuICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBAbWVtYmVyXHJcbiAgICAgICogQHR5cGUge2FycmF5YnVmZmVyfVxyXG4gICAgKi9cclxuICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB0aGlzLl9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xyXG4gICAgdGhpcy5fdXJsID0gZGF0YS51cmw7XHJcbiAgICB0aGlzLl9kYXRhU2V0ID0gbnVsbDtcclxuICAgIHRoaXMuX3VucGFja2VkRGF0YSA9IG51bGw7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5fZGF0YVNldCA9IE5ycmRSZWFkZXIucGFyc2UodGhpcy5fYXJyYXlCdWZmZXIpO1xyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLl9kYXRhU2V0KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnb29vcHMuLi4gOignKTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcy5fZGF0YVNldCk7XHJcbiAgfVxyXG5cclxuICByaWdodEhhbmRlZCgpIHtcclxuICAgIGlmICh0aGlzLl9kYXRhU2V0LnNwYWNlLm1hdGNoKC9ecmlnaHQtYW50ZXJpb3Itc3VwZXJpb3IvKSB8fFxyXG4gICAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL15sZWZ0LXBvc3Rlcmlvci1zdXBlcmlvci8pKSB7XHJcbiAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fcmlnaHRIYW5kZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XHJcbiAgfVxyXG5cclxuICBzZXJpZXNJbnN0YW5jZVVJRCgpIHtcclxuICAgIC8vIHVzZSBmaWxlbmFtZSArIHRpbWVzdGFtcC4uP1xyXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICB9XHJcblxyXG4gIG51bWJlck9mRnJhbWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTZXQuc2l6ZXNbMl07XHJcbiAgfVxyXG5cclxuICBudW1iZXJPZkNoYW5uZWxzKCkge1xyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSAxO1xyXG4gICAgcmV0dXJuIG51bWJlck9mQ2hhbm5lbHM7XHJcbiAgfVxyXG5cclxuICBzb3BJbnN0YW5jZVVJRChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICByb3dzKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YVNldC5zaXplc1sxXTtcclxuICB9XHJcblxyXG4gIGNvbHVtbnMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9kYXRhU2V0LnNpemVzWzBdO1xyXG4gIH1cclxuXHJcbiAgcGl4ZWxUeXBlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyAwIC0gaW50XHJcbiAgICAvLyAxIC0gZmxvYXRcclxuICAgIGxldCBwaXhlbFR5cGUgPSAwO1xyXG4gICAgaWYgKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2Zsb2F0Jykge1xyXG4gICAgICBwaXhlbFR5cGUgPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBpeGVsVHlwZTtcclxuICB9XHJcblxyXG4gIGJpdHNBbGxvY2F0ZWQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCBiaXRzQWxsb2NhdGVkID0gMTtcclxuXHJcbiAgICBpZiAodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50OCcgfHxcclxuICAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQ4JyB8fFxyXG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnY2hhcicpIHtcclxuICAgICAgYml0c0FsbG9jYXRlZCA9IDg7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDE2JyB8fFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MTYnIHx8XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICBiaXRzQWxsb2NhdGVkID0gMTY7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2ludDMyJyB8fFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50MzInIHx8XHJcbiAgICAgIHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ2Zsb2F0Jykge1xyXG4gICAgICBiaXRzQWxsb2NhdGVkID0gMzI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJpdHNBbGxvY2F0ZWQ7XHJcbiAgfVxyXG5cclxuICBwaXhlbFNwYWNpbmcoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIGxldCB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzBdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVsxXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMl0pO1xyXG5cclxuICAgIGxldCB5ID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzBdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVsxXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMl0pO1xyXG5cclxuICAgIGxldCB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzJdWzBdLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1syXVsxXSxcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMl1bMl0pO1xyXG5cclxuICAgIHJldHVybiBbeC5sZW5ndGgoKSwgeS5sZW5ndGgoKSwgei5sZW5ndGgoKV07XHJcbiAgfVxyXG5cclxuICBzbGljZVRoaWNrbmVzcygpIHtcclxuICAgIC8vIHNob3VsZCBiZSBhIHN0cmluZy4uLlxyXG4gICAgcmV0dXJuIG51bGw7Ly8gdGhpcy5fZGF0YVNldC5waXhEaW1zWzNdLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBpbWFnZU9yaWVudGF0aW9uKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICBsZXQgaW52ZXJ0WCA9IHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL3JpZ2h0LykgPyAtMSA6IDE7XHJcbiAgICBsZXQgaW52ZXJ0WSA9IHRoaXMuX2RhdGFTZXQuc3BhY2UubWF0Y2goL2FudGVyaW9yLykgPyAtMSA6IDE7XHJcblxyXG4gICAgbGV0IHggPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMF1bMF0gKiBpbnZlcnRYLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1swXVsxXSAqIGludmVydFksXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzBdWzJdKTtcclxuICAgIHgubm9ybWFsaXplKCk7XHJcblxyXG4gICAgbGV0IHkgPSBuZXcgVEhSRUUuVmVjdG9yMyhcclxuICAgICAgdGhpcy5fZGF0YVNldC5zcGFjZURpcmVjdGlvbnNbMV1bMF0gKiBpbnZlcnRYLFxyXG4gICAgICB0aGlzLl9kYXRhU2V0LnNwYWNlRGlyZWN0aW9uc1sxXVsxXSAqIGludmVydFksXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VEaXJlY3Rpb25zWzFdWzJdKTtcclxuICAgIHkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgeC54LCB4LnksIHgueixcclxuICAgICAgeS54LCB5LnksIHkueixcclxuICAgICAgXTtcclxuICB9XHJcblxyXG4gIGltYWdlUG9zaXRpb24oZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VPcmlnaW5bMF0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VPcmlnaW5bMV0sXHJcbiAgICAgIHRoaXMuX2RhdGFTZXQuc3BhY2VPcmlnaW5bMl0sXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgZGltZW5zaW9uSW5kZXhWYWx1ZXMoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaW5zdGFuY2VOdW1iZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBmcmFtZUluZGV4O1xyXG4gIH1cclxuXHJcbiAgd2luZG93Q2VudGVyKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICAvLyBjYWxjIG1pbiBhbmQgY2FsYyBtYXhcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgd2luZG93V2lkdGgoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIC8vIGNhbGMgbWluIGFuZCBjYWxjIG1heFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXNjYWxlU2xvcGUoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiAxOy8vIHRoaXMuX2RhdGFTZXQuc2NsX3Nsb3BlO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZUludGVyY2VwdChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIDA7Ly8gdGhpcy5fZGF0YVNldC5zY2xfaW50ZXJjZXB0O1xyXG4gIH1cclxuXHJcbiAgbWluTWF4UGl4ZWxEYXRhKHBpeGVsRGF0YSA9IFtdKSB7XHJcbiAgICBsZXQgbWluTWF4ID0gWzY1NTM1LCAtMzI3NjhdO1xyXG4gICAgbGV0IG51bVBpeGVscyA9IHBpeGVsRGF0YS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtUGl4ZWxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGxldCBzcHYgPSBwaXhlbERhdGFbaW5kZXhdO1xyXG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHNwdik7XHJcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgc3B2KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWluTWF4O1xyXG4gIH1cclxuXHJcbiAgZXh0cmFjdFBpeGVsRGF0YShmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoZnJhbWVJbmRleCk7XHJcbiAgfVxyXG5cclxuICBfZGVjb21wcmVzc1VuY29tcHJlc3NlZChmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2RhdGFTZXQuYnVmZmVyO1xyXG4gICAgbGV0IG51bWJlck9mQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHMoKTtcclxuICAgIGxldCBudW1QaXhlbHMgPSB0aGlzLnJvd3MoZnJhbWVJbmRleCkgKiB0aGlzLmNvbHVtbnMoZnJhbWVJbmRleCkgKiBudW1iZXJPZkNoYW5uZWxzO1xyXG4gICAgaWYgKCF0aGlzLnJpZ2h0SGFuZGVkKCkpIHtcclxuICAgICAgZnJhbWVJbmRleCA9IHRoaXMubnVtYmVyT2ZGcmFtZXMoKSAtIDEgLSBmcmFtZUluZGV4O1xyXG4gICAgfVxyXG4gICAgbGV0IGZyYW1lT2Zmc2V0ID0gZnJhbWVJbmRleCAqIG51bVBpeGVscztcclxuXHJcbiAgICAvLyB1bnBhY2sgZGF0YSBpZiBuZWVkZWRcclxuICAgIGlmICh0aGlzLl91bnBhY2tlZERhdGEgPT09IG51bGwgJiZcclxuICAgICAgdGhpcy5fZGF0YVNldC5lbmNvZGluZyA9PT0gJ2d6aXAnKSB7XHJcbiAgICAgIGxldCB1bnBhY2tlZERhdGEgPSBwYWtvLmluZmxhdGUodGhpcy5fZGF0YVNldC5idWZmZXIpO1xyXG4gICAgICB0aGlzLl91bnBhY2tlZERhdGEgPSB1bnBhY2tlZERhdGEuYnVmZmVyO1xyXG4gICAgICBidWZmZXIgPSB0aGlzLl91bnBhY2tlZERhdGE7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC5lbmNvZGluZyA9PT0gJ2d6aXAnKSB7XHJcbiAgICAgIGJ1ZmZlciA9IHRoaXMuX3VucGFja2VkRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQ4JyB8fFxyXG4gICAgICAgdGhpcy5fZGF0YVNldC50eXBlID09PSAnY2hhcicpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldDtcclxuICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICd1aW50OCcpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldDtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9IGVsc2UgaWYodGhpcy5fZGF0YVNldC50eXBlID09PSAnaW50MTYnIHx8XHJcbiAgICAgICB0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdzaG9ydCcpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XHJcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQxNicpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDI7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdpbnQzMicpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIsIGZyYW1lT2Zmc2V0LCBudW1QaXhlbHMpO1xyXG4gICAgfSBlbHNlIGlmKHRoaXMuX2RhdGFTZXQudHlwZSA9PT0gJ3VpbnQzMicpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBmcmFtZU9mZnNldCwgbnVtUGl4ZWxzKTtcclxuICAgIH0gZWxzZSBpZih0aGlzLl9kYXRhU2V0LnR5cGUgPT09ICdmbG9hdCcpIHtcclxuICAgICAgZnJhbWVPZmZzZXQgPSBmcmFtZU9mZnNldCAqIDQ7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgZnJhbWVPZmZzZXQsIG51bVBpeGVscyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAbW9kdWxlIHBhcnNlcnMvdm9sdW1lXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZXJzVm9sdW1lIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9yaWdodEhhbmRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBwaXhlbFJlcHJlc2VudGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBtb2RhbGl0eSgpIHtcclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbiAgfVxyXG5cclxuICBzZWdtZW50YXRpb25UeXBlKCkge1xyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcblxyXG4gIHNlZ21lbnRhdGlvblNlZ21lbnRzKCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgcmVmZXJlbmNlZFNlZ21lbnROdW1iZXIoZnJhbWVJbmRleCkge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgcmlnaHRIYW5kZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRIYW5kZWQ7XHJcbiAgfVxyXG5cclxuICBzcGFjaW5nQmV0d2VlblNsaWNlcygpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgbnVtYmVyT2ZDaGFubmVscygpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgc2xpY2VUaGlja25lc3MoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG5cclxuICBkaW1lbnNpb25JbmRleFZhbHVlcyhmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpbnN0YW5jZU51bWJlcihmcmFtZUluZGV4ID0gMCkge1xyXG4gICAgcmV0dXJuIGZyYW1lSW5kZXg7XHJcbiAgfVxyXG5cclxuICB3aW5kb3dDZW50ZXIoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgd2luZG93V2lkdGgoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmVzY2FsZVNsb3BlKGZyYW1lSW5kZXggPSAwKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcblxyXG4gIHJlc2NhbGVJbnRlcmNlcHQoZnJhbWVJbmRleCA9IDApIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgX2RlY29tcHJlc3NVbmNvbXByZXNzZWQoKSB7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzIwNDM5L2hvdy1kby1pLXN3YXAtZW5kaWFuLW5lc3MtYnl0ZS1vcmRlci1vZi1hLXZhcmlhYmxlLWluLWphdmFzY3JpcHRcclxuICBfc3dhcDE2KHZhbCkge1xyXG4gICAgcmV0dXJuICgodmFsICYgMHhGRikgPDwgOClcclxuICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYpO1xyXG4gIH1cclxuXHJcbiAgX3N3YXAzMih2YWwpIHtcclxuICAgIHJldHVybiAoKHZhbCAmIDB4RkYpIDw8IDI0KVxyXG4gICAgICAgICAgIHwgKCh2YWwgJiAweEZGMDApIDw8IDgpXHJcbiAgICAgICAgICAgfCAoKHZhbCA+PiA4KSAmIDB4RkYwMClcclxuICAgICAgICAgICB8ICgodmFsID4+IDI0KSAmIDB4RkYpO1xyXG4gIH1cclxuXHJcbiAgaW52ZXJ0KCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0cmFuc2ZlciBzeW50YXggVUlELlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgdHJhbnNmZXJTeW50YXhVSUQoKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3R1ZHkgZGVzY2lwdGlvbi5cclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHN0dWR5RGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2VyaWVzIGRlc2NpcHRpb24uXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzZXJpZXNEZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRpZW50IElELlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudElEKCkge1xyXG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGllbnQgbmFtZS5cclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnROYW1lKCkge1xyXG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGllbnQgYWdlLlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgcGF0aWVudEFnZSgpIHtcclxuICAgIHJldHVybiAnbm8gdmFsdWUgcHJvdmlkZWQnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRpZW50IGJpcnRoZGF0ZS5cclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIHBhdGllbnRCaXJ0aGRhdGUoKSB7XHJcbiAgICByZXR1cm4gJ25vIHZhbHVlIHByb3ZpZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGF0aWVudCBzZXguXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBwYXRpZW50U2V4KCkge1xyXG4gICAgcmV0dXJuICdubyB2YWx1ZSBwcm92aWRlZCc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCBTaGFkZXJzQmFzZSBmcm9tICcuLi9zaGFkZXJzLmJhc2UnO1xyXG5cclxuY2xhc3MgSW50ZXJzZWN0Qm94IGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJzZWN0Qm94JztcclxuXHJcbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcclxuICAgIHRoaXMuX3JheU9yaWdpbiA9ICdyYXlPcmlnaW4nO1xyXG4gICAgdGhpcy5fcmF5RGlyZWN0aW9uID0gJ3JheURpcmVjdGlvbic7XHJcbiAgICB0aGlzLl9hYWJiTWluID0gJ2FhYmJNaW4nO1xyXG4gICAgdGhpcy5fYWFiYk1heCA9ICdhYWJiTWF4JztcclxuICAgIHRoaXMuX3ROZWFyID0gJ3ROZWFyJztcclxuICAgIHRoaXMuX3RGYXIgPSAndEZhcic7XHJcbiAgICB0aGlzLl9pbnRlcnNlY3QgPSAnaW50ZXJzZWN0JztcclxuICB9XHJcblxyXG4gIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLFxyXG4gICAgICAgcmF5T3JpZ2luID0gdGhpcy5fcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24gPSB0aGlzLl9yYXlEaXJlY3Rpb24sXHJcbiAgICAgICBhYWJiTWluID0gdGhpcy5fYWFiYk1pbiwgYWFiYk1heCA9IHRoaXMuX2FhYmJNYXgsXHJcbiAgICAgICB0TmVhciA9IHRoaXMuX3ROZWFyLCB0RmFyID0gdGhpcy5fdEZhcixcclxuICAgICAgIGludGVyc2VjdCA9IHRoaXMuX2ludGVyc2VjdCkge1xyXG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcclxuICAgIHJldHVybiB0aGlzLmNvbXB1dGUocmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGFhYmJNaW4sIGFhYmJNYXgsIHROZWFyLCB0RmFyLCBpbnRlcnNlY3QpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYWFiYk1pbiwgYWFiYk1heCwgdE5lYXIsIHRGYXIsIGludGVyc2VjdCkge1xyXG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xyXG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zW3RoaXMuX25hbWVdID0gdGhpcy5fZGVmaW5pdGlvbjtcclxuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke3JheU9yaWdpbn0sICR7cmF5RGlyZWN0aW9ufSwgJHthYWJiTWlufSwgJHthYWJiTWF4fSwgJHt0TmVhcn0sICR7dEZhcn0sICR7aW50ZXJzZWN0fSk7YDtcclxuICB9XHJcblxyXG5cclxuICBjb21wdXRlRGVmaW5pdGlvbigpIHtcclxuICAgIHRoaXMuX2RlZmluaXRpb24gPSBgXHJcbnZvaWQgJHt0aGlzLl9uYW1lfSh2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYm94TWluLCB2ZWMzIGJveE1heCwgb3V0IGZsb2F0IHROZWFyLCBvdXQgZmxvYXQgdEZhciwgb3V0IGJvb2wgaW50ZXJzZWN0KXtcclxuICAvLyBjb21wdXRlIGludGVyc2VjdGlvbiBvZiByYXkgd2l0aCBhbGwgc2l4IGJib3ggcGxhbmVzXHJcbiAgdmVjMyBpbnZSYXkgPSB2ZWMzKDEuKSAvIHJheURpcmVjdGlvbjtcclxuICB2ZWMzIHRCb3QgPSBpbnZSYXkgKiAoYm94TWluIC0gcmF5T3JpZ2luKTtcclxuICB2ZWMzIHRUb3AgPSBpbnZSYXkgKiAoYm94TWF4IC0gcmF5T3JpZ2luKTtcclxuICAvLyByZS1vcmRlciBpbnRlcnNlY3Rpb25zIHRvIGZpbmQgc21hbGxlc3QgYW5kIGxhcmdlc3Qgb24gZWFjaCBheGlzXHJcbiAgdmVjMyB0TWluID0gbWluKHRUb3AsIHRCb3QpO1xyXG4gIHZlYzMgdE1heCA9IG1heCh0VG9wLCB0Qm90KTtcclxuICAvLyBmaW5kIHRoZSBsYXJnZXN0IHRNaW4gYW5kIHRoZSBzbWFsbGVzdCB0TWF4XHJcbiAgZmxvYXQgbGFyZ2VzdF90TWluID0gbWF4KG1heCh0TWluLngsIHRNaW4ueSksIG1heCh0TWluLngsIHRNaW4ueikpO1xyXG4gIGZsb2F0IHNtYWxsZXN0X3RNYXggPSBtaW4obWluKHRNYXgueCwgdE1heC55KSwgbWluKHRNYXgueCwgdE1heC56KSk7XHJcbiAgdE5lYXIgPSBsYXJnZXN0X3RNaW47XHJcbiAgdEZhciA9IHNtYWxsZXN0X3RNYXg7XHJcbiAgaW50ZXJzZWN0ID0gc21hbGxlc3RfdE1heCA+IGxhcmdlc3RfdE1pbjtcclxufVxyXG5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVyc2VjdEJveCgpO1xyXG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcclxuXHJcbmNsYXNzIFRleHR1cmUzZCBleHRlbmRzIFNoYWRlcnNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gJ3RleHR1cmUzZCc7XHJcblxyXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXHJcbiAgICB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMgPSAnZGF0YUNvb3JkaW5hdGVzJztcclxuICAgIHRoaXMuX2RhdGFWYWx1ZSA9ICdkYXRhVmFsdWUnO1xyXG4gICAgdGhpcy5fb2Zmc2V0ID0gJ29mZnNldCc7XHJcbiAgfVxyXG5cclxuICAgIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBkYXRhQ29vcmRpbmF0ZXMgPSB0aGlzLl9kYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSA9IHRoaXMuX2RhdGFWYWx1ZSwgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KSB7XHJcbiAgICB0aGlzLl9iYXNlID0gYmFzZUZyYWdtZW50O1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZShkYXRhQ29vcmRpbmF0ZXMsIGRhdGFWYWx1ZSwgb2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoZGF0YUNvb3JkaW5hdGVzLCBkYXRhVmFsdWUsIG9mZnNldCkge1xyXG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xyXG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zW3RoaXMuX25hbWVdID0gdGhpcy5fZGVmaW5pdGlvbjtcclxuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2RhdGFDb29yZGluYXRlc30sICR7ZGF0YVZhbHVlfSwgJHtvZmZzZXR9KTtgO1xyXG4gIH1cclxuXHJcblxyXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcclxudm9pZCAke3RoaXMuX25hbWV9KGluIGl2ZWMzIGRhdGFDb29yZGluYXRlcywgb3V0IHZlYzQgZGF0YVZhbHVlLCBvdXQgaW50IG9mZnNldCl7XHJcbiAgICBcclxuICBpbnQgaW5kZXggPSBkYXRhQ29vcmRpbmF0ZXMueFxyXG4gICAgICAgICAgICArIGRhdGFDb29yZGluYXRlcy55ICogdURhdGFEaW1lbnNpb25zLnhcclxuICAgICAgICAgICAgKyBkYXRhQ29vcmRpbmF0ZXMueiAqIHVEYXRhRGltZW5zaW9ucy55ICogdURhdGFEaW1lbnNpb25zLng7XHJcbiAgaW50IGluZGV4UCA9IGludChpbmRleC91UGFja2VkUGVyUGl4ZWwpO1xyXG4gIG9mZnNldCA9IGluZGV4IC0gMippbmRleFA7XHJcblxyXG4gIC8vIE1hcCBkYXRhIGluZGV4IHRvIHJpZ2h0IHNhbXBsZXIyRCB0ZXh0dXJlXHJcbiAgaW50IHZveGVsc1BlclRleHR1cmUgPSB1VGV4dHVyZVNpemUqdVRleHR1cmVTaXplO1xyXG4gIGludCB0ZXh0dXJlSW5kZXggPSBpbnQoZmxvb3IoZmxvYXQoaW5kZXhQKSAvIGZsb2F0KHZveGVsc1BlclRleHR1cmUpKSk7XHJcbiAgLy8gbW9kdWxvIHNlZW1zIGluY29ycmVjdCBzb21ldGltZXMuLi5cclxuICAvLyBpbnQgaW5UZXh0dXJlSW5kZXggPSBpbnQobW9kKGZsb2F0KGluZGV4KSwgZmxvYXQodGV4dHVyZVNpemUqdGV4dHVyZVNpemUpKSk7XHJcbiAgaW50IGluVGV4dHVyZUluZGV4ID0gaW5kZXhQIC0gdm94ZWxzUGVyVGV4dHVyZSp0ZXh0dXJlSW5kZXg7XHJcblxyXG4gIC8vIEdldCByb3cgYW5kIGNvbHVtbiBpbiB0aGUgdGV4dHVyZVxyXG4gIGludCBjb2xJbmRleCA9IGludChtb2QoZmxvYXQoaW5UZXh0dXJlSW5kZXgpLCBmbG9hdCh1VGV4dHVyZVNpemUpKSk7XHJcbiAgaW50IHJvd0luZGV4ID0gaW50KGZsb29yKGZsb2F0KGluVGV4dHVyZUluZGV4KS9mbG9hdCh1VGV4dHVyZVNpemUpKSk7XHJcblxyXG4gIC8vIE1hcCByb3cgYW5kIGNvbHVtbiB0byB1dlxyXG4gIHZlYzIgdXYgPSB2ZWMyKDAsMCk7XHJcbiAgdXYueCA9ICgwLjUgKyBmbG9hdChjb2xJbmRleCkpIC8gZmxvYXQodVRleHR1cmVTaXplKTtcclxuICB1di55ID0gMS4gLSAoMC41ICsgZmxvYXQocm93SW5kZXgpKSAvIGZsb2F0KHVUZXh0dXJlU2l6ZSk7XHJcblxyXG4gIC8vXHJcbiAgaWYodGV4dHVyZUluZGV4ID09IDApeyBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQodVRleHR1cmVDb250YWluZXJbMF0sIHV2KTsgfVxyXG4gIGVsc2UgaWYodGV4dHVyZUluZGV4ID09IDEpe2RhdGFWYWx1ZSA9IHRleHR1cmUyRCh1VGV4dHVyZUNvbnRhaW5lclsxXSwgdXYpO31cclxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAyKXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzJdLCB1dik7IH1cclxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSAzKXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzNdLCB1dik7IH1cclxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSA0KXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzRdLCB1dik7IH1cclxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSA1KXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzVdLCB1dik7IH1cclxuICBlbHNlIGlmKHRleHR1cmVJbmRleCA9PSA2KXsgZGF0YVZhbHVlID0gdGV4dHVyZTJEKHVUZXh0dXJlQ29udGFpbmVyWzZdLCB1dik7IH1cclxuXHJcbn1cclxuICAgIGA7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFRleHR1cmUzZCgpO1xyXG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcclxuXHJcbmNsYXNzIFVucGFjayBleHRlbmRzIFNoYWRlcnNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gJ3VucGFjayc7XHJcblxyXG4gICAgLy8gZGVmYXVsdCBwcm9wZXJ0aWVzIG5hbWVzXHJcbiAgICB0aGlzLl9wYWNrZWREYXRhID0gJ3BhY2tlZERhdGEnO1xyXG4gICAgdGhpcy5fb2Zmc2V0ID0gJ29mZnNldCc7XHJcbiAgICB0aGlzLl91bnBhY2tlZERhdGEgPSAndW5wYWNrZWREYXRhJztcclxuXHJcbiAgICB0aGlzLl9iYXNlLl91bmlmb3JtcyA9e1xyXG4gICAgICB1TnVtYmVyT2ZDaGFubmVsczoge1xyXG4gICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICB9LFxyXG4gICAgICB1Qml0c0FsbG9jYXRlZDoge1xyXG4gICAgICAgIHZhbHVlOiAxNixcclxuICAgICAgfSxcclxuICAgICAgdVBpeGVsVHlwZToge1xyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBwYWNrZWREYXRhID0gdGhpcy5fcGFja2VkRGF0YSwgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0LCB1bnBhY2tlZERhdGEgPSB0aGlzLl91bnBhY2tlZERhdGEpIHtcclxuICAgIHRoaXMuX2Jhc2UgPSBiYXNlRnJhZ21lbnQ7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlKHBhY2tlZERhdGEsIG9mZnNldCwgdW5wYWNrZWREYXRhKTtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUocGFja2VkRGF0YSwgb2Zmc2V0LCB1bnBhY2tlZERhdGEpIHtcclxuICAgIHRoaXMuY29tcHV0ZURlZmluaXRpb24oKTtcclxuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1t0aGlzLl9uYW1lXSA9IHRoaXMuX2RlZmluaXRpb247XHJcbiAgICByZXR1cm4gYCR7dGhpcy5fbmFtZX0oJHtwYWNrZWREYXRhfSwgJHtvZmZzZXR9LCAke3VucGFja2VkRGF0YX0pO2A7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlRGVmaW5pdGlvbigpIHtcclxuICAgIC8vIGZ1biBzdHVmZlxyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGlmICh0aGlzLl9iYXNlLl91bmlmb3Jtcy51TnVtYmVyT2ZDaGFubmVscy52YWx1ZSA9PT0gMSkge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuX2Jhc2UuX3VuaWZvcm1zLnVCaXRzQWxsb2NhdGVkLnZhbHVlKSB7XHJcblxyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy51cGFjazgoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgY29udGVudCA9IHRoaXMudXBhY2sxNigpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy51cGFjazMyKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnVwYWNrRGVmYXVsdCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZW50ID0gdGhpcy51cGFja0lkZW50aXR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcclxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzQgcGFja2VkRGF0YSwgaW4gaW50IG9mZnNldCwgb3V0IHZlYzQgdW5wYWNrZWREYXRhKXtcclxuXHJcbiR7Y29udGVudH1cclxuXHJcbn0gIFxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVwYWNrOCgpIHtcclxuICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUludDgnXSA9IHRoaXMudUludDgoKTtcclxuXHJcbiAgICByZXR1cm4gYFxyXG51SW50OChcclxuICBwYWNrZWREYXRhLnIsXHJcbiAgdW5wYWNrZWREYXRhLngpO1xyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVwYWNrMTYoKSB7XHJcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbJ3VJbnQxNiddID0gdGhpcy51SW50MTYoKTtcclxuXHJcbiAgICByZXR1cm4gYFxyXG51SW50MTYoXHJcbiAgcGFja2VkRGF0YS5yICogZmxvYXQoIDEgLSBvZmZzZXQpICsgcGFja2VkRGF0YS5iICogZmxvYXQob2Zmc2V0KSxcclxuICBwYWNrZWREYXRhLmcgKiBmbG9hdCggMSAtIG9mZnNldCkgKyBwYWNrZWREYXRhLmEgKiBmbG9hdChvZmZzZXQpLFxyXG4gIHVucGFja2VkRGF0YS54KTtcclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICB1cGFjazMyKCkge1xyXG4gICAgaWYgKHRoaXMuX2Jhc2UuX3VuaWZvcm1zLnVQaXhlbFR5cGUudmFsdWUgPT09IDApIHtcclxuICAgICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zWyd1SW50MzInXSA9IHRoaXMudUludDMyKCk7XHJcblxyXG4gICAgICByZXR1cm4gYFxyXG51SW50MzIoXHJcbiAgcGFja2VkRGF0YS5yLFxyXG4gIHBhY2tlZERhdGEuZyxcclxuICBwYWNrZWREYXRhLmIsXHJcbiAgcGFja2VkRGF0YS5hLFxyXG4gIHVucGFja2VkRGF0YS54KTtcclxuICAgICAgYDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2Jhc2UuX2Z1bmN0aW9uc1sndUZsb2F0MzInXSA9IHRoaXMudUZsb2F0MzIoKTtcclxuXHJcbiAgICAgIHJldHVybiBgXHJcbnVGbG9hdDMyKFxyXG4gIHBhY2tlZERhdGEucixcclxuICBwYWNrZWREYXRhLmcsXHJcbiAgcGFja2VkRGF0YS5iLFxyXG4gIHBhY2tlZERhdGEuYSxcclxuICB1bnBhY2tlZERhdGEueCk7XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGFja0lkZW50aXR5KCkge1xyXG4gICAgcmV0dXJuIGBcclxuXHJcbnVucGFja2VkRGF0YSA9IHBhY2tlZERhdGE7XHJcblxyXG4gICAgICBgO1xyXG4gIH1cclxuXHJcbiAgdUludDgoKSB7XHJcbiAgICByZXR1cm4gYFxyXG52b2lkIHVJbnQ4KGluIGZsb2F0IHIsIG91dCBmbG9hdCB2YWx1ZSl7XHJcbiAgdmFsdWUgPSByICogMjU2LjtcclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVJbnQxNigpIHtcclxuICAgIHJldHVybiBgXHJcbnZvaWQgdUludDE2KGluIGZsb2F0IHIsIGluIGZsb2F0IGEsIG91dCBmbG9hdCB2YWx1ZSl7XHJcbiAgdmFsdWUgPSByICogMjU2LiArIGEgKiA2NTUzNi47XHJcbn1cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICB1SW50MzIoKSB7XHJcbiAgICByZXR1cm4gYFxyXG52b2lkIHVJbnQzMihpbiBmbG9hdCByLCBpbiBmbG9hdCBnLCBpbiBmbG9hdCBiLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xyXG4gIHZhbHVlID0gciAqIDI1Ni4gKyBnICogNjU1MzYuICsgYiAqIDE2Nzc3MjE2LiArIGEgKiA0Mjk0OTY3Mjk2LjtcclxufVxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIHVGbG9hdDMyKCkge1xyXG4gICAgcmV0dXJuIGBcclxudm9pZCB1RmxvYXQzMihpbiBmbG9hdCByLCBpbiBmbG9hdCBnLCBpbiBmbG9hdCBiLCBpbiBmbG9hdCBhLCBvdXQgZmxvYXQgdmFsdWUpe1xyXG5cclxuICAvLyBjcmVhdGUgYXJyYXlzIGNvbnRhaW5pbmcgYml0cyBmb3IgcmdiYSB2YWx1ZXNcclxuICAvLyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxyXG4gIHZhbHVlID0gciAqIDI1NS47XHJcbiAgaW50IGJ5dGVtZVJbOF07XHJcbiAgYnl0ZW1lUlswXSA9IGludChmbG9vcih2YWx1ZSAvIDEyOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzBdICogMTI4KTtcclxuICBieXRlbWVSWzFdID0gaW50KGZsb29yKHZhbHVlIC8gNjQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUlsxXSAqIDY0KTtcclxuICBieXRlbWVSWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUlsyXSAqIDMyKTtcclxuICBieXRlbWVSWzNdID0gaW50KGZsb29yKHZhbHVlIC8gMTYuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUlszXSAqIDE2KTtcclxuICBieXRlbWVSWzRdID0gaW50KGZsb29yKHZhbHVlIC8gOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVSWzRdICogOCk7XHJcbiAgYnl0ZW1lUls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lUls1XSAqIDQpO1xyXG4gIGJ5dGVtZVJbNl0gPSBpbnQoZmxvb3IodmFsdWUgLyAyLikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZVJbNl0gKiAyKTtcclxuICBieXRlbWVSWzddID0gaW50KGZsb29yKHZhbHVlKSk7XHJcblxyXG4gIHZhbHVlID0gZyAqIDI1NS47XHJcbiAgaW50IGJ5dGVtZUdbOF07XHJcbiAgYnl0ZW1lR1swXSA9IGludChmbG9vcih2YWx1ZSAvIDEyOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzBdICogMTI4KTtcclxuICBieXRlbWVHWzFdID0gaW50KGZsb29yKHZhbHVlIC8gNjQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1sxXSAqIDY0KTtcclxuICBieXRlbWVHWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1syXSAqIDMyKTtcclxuICBieXRlbWVHWzNdID0gaW50KGZsb29yKHZhbHVlIC8gMTYuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1szXSAqIDE2KTtcclxuICBieXRlbWVHWzRdID0gaW50KGZsb29yKHZhbHVlIC8gOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVHWzRdICogOCk7XHJcbiAgYnl0ZW1lR1s1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lR1s1XSAqIDQpO1xyXG4gIGJ5dGVtZUdbNl0gPSBpbnQoZmxvb3IodmFsdWUgLyAyLikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUdbNl0gKiAyKTtcclxuICBieXRlbWVHWzddID0gaW50KGZsb29yKHZhbHVlKSk7XHJcblxyXG4gIHZhbHVlID0gYiAqIDI1NS47XHJcbiAgaW50IGJ5dGVtZUJbOF07XHJcbiAgYnl0ZW1lQlswXSA9IGludChmbG9vcih2YWx1ZSAvIDEyOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzBdICogMTI4KTtcclxuICBieXRlbWVCWzFdID0gaW50KGZsb29yKHZhbHVlIC8gNjQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQlsxXSAqIDY0KTtcclxuICBieXRlbWVCWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQlsyXSAqIDMyKTtcclxuICBieXRlbWVCWzNdID0gaW50KGZsb29yKHZhbHVlIC8gMTYuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQlszXSAqIDE2KTtcclxuICBieXRlbWVCWzRdID0gaW50KGZsb29yKHZhbHVlIC8gOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVCWzRdICogOCk7XHJcbiAgYnl0ZW1lQls1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQls1XSAqIDQpO1xyXG4gIGJ5dGVtZUJbNl0gPSBpbnQoZmxvb3IodmFsdWUgLyAyLikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUJbNl0gKiAyKTtcclxuICBieXRlbWVCWzddID0gaW50KGZsb29yKHZhbHVlKSk7XHJcblxyXG4gIHZhbHVlID0gYSAqIDI1NS47XHJcbiAgaW50IGJ5dGVtZUFbOF07XHJcbiAgYnl0ZW1lQVswXSA9IGludChmbG9vcih2YWx1ZSAvIDEyOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzBdICogMTI4KTtcclxuICBieXRlbWVBWzFdID0gaW50KGZsb29yKHZhbHVlIC8gNjQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVsxXSAqIDY0KTtcclxuICBieXRlbWVBWzJdID0gaW50KGZsb29yKHZhbHVlIC8gMzIuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVsyXSAqIDMyKTtcclxuICBieXRlbWVBWzNdID0gaW50KGZsb29yKHZhbHVlIC8gMTYuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVszXSAqIDE2KTtcclxuICBieXRlbWVBWzRdID0gaW50KGZsb29yKHZhbHVlIC8gOC4pKTtcclxuICB2YWx1ZSAtPSBmbG9hdChieXRlbWVBWzRdICogOCk7XHJcbiAgYnl0ZW1lQVs1XSA9IGludChmbG9vcih2YWx1ZSAvIDQuKSk7XHJcbiAgdmFsdWUgLT0gZmxvYXQoYnl0ZW1lQVs1XSAqIDQpO1xyXG4gIGJ5dGVtZUFbNl0gPSBpbnQoZmxvb3IodmFsdWUgLyAyLikpO1xyXG4gIHZhbHVlIC09IGZsb2F0KGJ5dGVtZUFbNl0gKiAyKTtcclxuICBieXRlbWVBWzddID0gaW50KGZsb29yKHZhbHVlKSk7XHJcblxyXG4gIC8vIGNvbXB1dGUgZmxvYXQzMiB2YWx1ZSBmcm9tIGJpdCBhcnJheXNcclxuXHJcbiAgLy8gc2lnblxyXG4gIGludCBpc3NpZ25lZCA9IDEgLSAyICogYnl0ZW1lUlswXTtcclxuICAvLyAgIGlzc2lnbmVkID0gaW50KHBvdygtMS4sIGZsb2F0KGJ5dGVtZVJbMF0pKSk7XHJcblxyXG4gIC8vIGV4cG9uZW50XHJcbiAgaW50IGV4cG9uZW50ID0gMDtcclxuXHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUlsxXSAqIGludChwb3coMi4sIDcuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUlsyXSAqIGludChwb3coMi4sIDYuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUlszXSAqIGludChwb3coMi4sIDUuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls0XSAqIGludChwb3coMi4sIDQuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls1XSAqIGludChwb3coMi4sIDMuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls2XSAqIGludChwb3coMi4sIDIuKSk7XHJcbiAgZXhwb25lbnQgKz0gYnl0ZW1lUls3XSAqIGludChwb3coMi4sIDEuKSk7XHJcblxyXG4gIGV4cG9uZW50ICs9IGJ5dGVtZUdbMF07XHJcblxyXG5cclxuICAvLyBmcmFjdGlvblxyXG4gIGZsb2F0IGZyYWN0aW9uID0gMC47XHJcblxyXG4gIGZyYWN0aW9uID0gZmxvYXQoYnl0ZW1lR1sxXSkgKiBwb3coMi4sIC0xLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1syXSkgKiBwb3coMi4sIC0yLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1szXSkgKiBwb3coMi4sIC0zLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s0XSkgKiBwb3coMi4sIC00Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s1XSkgKiBwb3coMi4sIC01Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s2XSkgKiBwb3coMi4sIC02Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lR1s3XSkgKiBwb3coMi4sIC03Lik7XHJcblxyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbMF0pICogcG93KDIuLCAtOC4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbMV0pICogcG93KDIuLCAtOS4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbMl0pICogcG93KDIuLCAtMTAuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzNdKSAqIHBvdygyLiwgLTExLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQls0XSkgKiBwb3coMi4sIC0xMi4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUJbNV0pICogcG93KDIuLCAtMTMuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVCWzZdKSAqIHBvdygyLiwgLTE0Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQls3XSkgKiBwb3coMi4sIC0xNS4pO1xyXG5cclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzBdKSAqIHBvdygyLiwgLTE2Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVsxXSkgKiBwb3coMi4sIC0xNy4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbMl0pICogcG93KDIuLCAtMTguKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzNdKSAqIHBvdygyLiwgLTE5Lik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVs0XSkgKiBwb3coMi4sIC0yMC4pO1xyXG4gIGZyYWN0aW9uICs9IGZsb2F0KGJ5dGVtZUFbNV0pICogcG93KDIuLCAtMjEuKTtcclxuICBmcmFjdGlvbiArPSBmbG9hdChieXRlbWVBWzZdKSAqIHBvdygyLiwgLTIyLik7XHJcbiAgZnJhY3Rpb24gKz0gZmxvYXQoYnl0ZW1lQVs3XSkgKiBwb3coMi4sIC0yMy4pO1xyXG5cclxuICB2YWx1ZSA9IGZsb2F0KGlzc2lnbmVkKSAqIHBvdyggMi4sIGZsb2F0KGV4cG9uZW50IC0gMTI3KSkgKiAoMS4gKyBmcmFjdGlvbik7XHJcbn1cclxuICAgIGA7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFVucGFjaygpO1xyXG4iLCJpbXBvcnQgU2hhZGVyc0Jhc2UgZnJvbSAnLi4vc2hhZGVycy5iYXNlJztcclxuaW1wb3J0IFVucGFjayBmcm9tICcuLi9oZWxwZXJzL3NoYWRlcnMuaGVscGVycy51bnBhY2snO1xyXG5pbXBvcnQgVGV4dHVyZTNkIGZyb20gJy4uL2hlbHBlcnMvc2hhZGVycy5oZWxwZXJzLnRleHR1cmUzZCc7XHJcblxyXG5cclxuY2xhc3MgSW50ZXJwb2xhdGlvbklkZW50aXR5IGV4dGVuZHMgU2hhZGVyc0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSAnaW50ZXJwb2xhdGlvbklkZW50aXR5JztcclxuXHJcbiAgICAvLyBkZWZhdWx0IHByb3BlcnRpZXMgbmFtZXNcclxuICAgIHRoaXMuX2N1cnJlbnRWb3hlbCA9ICdjdXJyZW50Vm94ZWwnO1xyXG4gICAgdGhpcy5fZGF0YVZhbHVlID0gJ2RhdGFWYWx1ZSc7XHJcbiAgfVxyXG5cclxuICAgIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBjdXJyZW50Vm94ZWwgPSB0aGlzLl9jdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSA9IHRoaXMuX2RhdGFWYWx1ZSkge1xyXG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcclxuICAgIHJldHVybiB0aGlzLmNvbXB1dGUoY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShjdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSkge1xyXG4gICAgdGhpcy5jb21wdXRlRGVmaW5pdGlvbigpO1xyXG4gICAgdGhpcy5fYmFzZS5fZnVuY3Rpb25zW3RoaXMuX25hbWVdID0gdGhpcy5fZGVmaW5pdGlvbjtcclxuICAgIHJldHVybiBgJHt0aGlzLl9uYW1lfSgke2N1cnJlbnRWb3hlbH0sICR7ZGF0YVZhbHVlfSk7YDtcclxuICB9XHJcblxyXG5cclxuICBjb21wdXRlRGVmaW5pdGlvbigpIHtcclxuICAgIHRoaXMuX2RlZmluaXRpb24gPSBgXHJcbnZvaWQgJHt0aGlzLl9uYW1lfShpbiB2ZWMzIGN1cnJlbnRWb3hlbCwgb3V0IHZlYzQgZGF0YVZhbHVlKXtcclxuICAvLyBsb3dlciBib3VuZFxyXG4gIHZlYzMgcmN1cnJlbnRWb3hlbCA9IHZlYzMoZmxvb3IoY3VycmVudFZveGVsLnggKyAwLjUgKSwgZmxvb3IoY3VycmVudFZveGVsLnkgKyAwLjUgKSwgZmxvb3IoY3VycmVudFZveGVsLnogKyAwLjUgKSk7XHJcbiAgaXZlYzMgdm94ZWwgPSBpdmVjMyhpbnQocmN1cnJlbnRWb3hlbC54KSwgaW50KHJjdXJyZW50Vm94ZWwueSksIGludChyY3VycmVudFZveGVsLnopKTtcclxuXHJcbiAgdmVjNCB0bXAgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcclxuICBpbnQgb2Zmc2V0ID0gMDtcclxuXHJcbiAgJHtUZXh0dXJlM2QuYXBpKHRoaXMuX2Jhc2UsICd2b3hlbCcsICd0bXAnLCAnb2Zmc2V0Jyl9XHJcbiAgJHtVbnBhY2suYXBpKHRoaXMuX2Jhc2UsICd0bXAnLCAnb2Zmc2V0JywgJ2RhdGFWYWx1ZScpfVxyXG59XHJcbiAgICBgO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBJbnRlcnBvbGF0aW9uSWRlbnRpdHkoKTtcclxuIiwiaW1wb3J0IEludGVycG9sYXRpb25JZGVudGl0eSBmcm9tICcuL3NoYWRlcnMuaW50ZXJwb2xhdGlvbi5pZGVudGl0eSc7XHJcbmltcG9ydCBJbnRlcnBvbGF0aW9uVHJpbGluZWFyIGZyb20gJy4vc2hhZGVycy5pbnRlcnBvbGF0aW9uLnRyaWxpbmVhcic7XHJcblxyXG5mdW5jdGlvbiBzaGFkZXJzSW50ZXJwb2xhdGlvbihiYXNlRnJhZ21lbnQsIGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlLCBncmFkaWVudCkge1xyXG4gIHN3aXRjaChiYXNlRnJhZ21lbnQuX3VuaWZvcm1zLnVJbnRlcnBvbGF0aW9uLnZhbHVlKSB7XHJcblxyXG4gICAgY2FzZSAwOlxyXG4gICAgICAvLyBubyBpbnRlcnBvbGF0aW9uXHJcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUpO1xyXG5cclxuICAgIGNhc2UgMTpcclxuICAgICAgLy8gdHJpbGluZWFyIGludGVycG9sYXRpb25cclxuICAgICAgcmV0dXJuIEludGVycG9sYXRpb25UcmlsaW5lYXIuYXBpKGJhc2VGcmFnbWVudCwgY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KTtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbklkZW50aXR5LmFwaShiYXNlRnJhZ21lbnQsIGN1cnJlbnRWb3hlbCwgZGF0YVZhbHVlKTtcclxuXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzaGFkZXJzSW50ZXJwb2xhdGlvbjtcclxuIiwiaW1wb3J0IFNoYWRlcnNCYXNlIGZyb20gJy4uL3NoYWRlcnMuYmFzZSc7XHJcbmltcG9ydCBJbnRlcnBvbGF0aW9uSWRlbnRpdHkgZnJvbSAnLi9zaGFkZXJzLmludGVycG9sYXRpb24uaWRlbnRpdHknO1xyXG5cclxuY2xhc3MgSW50ZXJwb2xhdGlvblRyaWxpbmVhciBleHRlbmRzIFNoYWRlcnNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gJ2ludGVycG9sYXRpb25UcmlsaW5lYXInO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgcHJvcGVydGllcyBuYW1lc1xyXG4gICAgdGhpcy5fY3VycmVudFZveGVsID0gJ2N1cnJlbnRWb3hlbCc7XHJcbiAgICB0aGlzLl9kYXRhVmFsdWUgPSAnZGF0YVZhbHVlJztcclxuICAgIHRoaXMuX2dyYWRpZW50ID0gJ2dyYWRpZW50JztcclxuICB9XHJcblxyXG4gIGFwaShiYXNlRnJhZ21lbnQgPSB0aGlzLl9iYXNlLCBjdXJyZW50Vm94ZWwgPSB0aGlzLl9jdXJyZW50Vm94ZWwsIGRhdGFWYWx1ZSA9IHRoaXMuX2RhdGFWYWx1ZSwgZ3JhZGllbnQgPSB0aGlzLl9ncmFkaWVudCkge1xyXG4gICAgdGhpcy5fYmFzZSA9IGJhc2VGcmFnbWVudDtcclxuICAgIHJldHVybiB0aGlzLmNvbXB1dGUoY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KTtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoY3VycmVudFZveGVsLCBkYXRhVmFsdWUsIGdyYWRpZW50KSB7XHJcbiAgICB0aGlzLmNvbXB1dGVEZWZpbml0aW9uKCk7XHJcbiAgICB0aGlzLl9iYXNlLl9mdW5jdGlvbnNbdGhpcy5fbmFtZV0gPSB0aGlzLl9kZWZpbml0aW9uO1xyXG4gICAgcmV0dXJuIGAke3RoaXMuX25hbWV9KCR7Y3VycmVudFZveGVsfSwgJHtkYXRhVmFsdWV9LCAke2dyYWRpZW50fSk7YDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGVEZWZpbml0aW9uKCkge1xyXG4gICAgdGhpcy5fZGVmaW5pdGlvbiA9IGBcclxudm9pZCAke3RoaXMuX25hbWV9KGluIHZlYzMgY3VycmVudFZveGVsLCBvdXQgdmVjNCBkYXRhVmFsdWUsIG91dCB2ZWMzIGdyYWRpZW50KXtcclxuXHJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpbGluZWFyX2ludGVycG9sYXRpb25cclxuICB2ZWMzIGxvd2VyX2JvdW5kID0gdmVjMyhmbG9vcihjdXJyZW50Vm94ZWwueCksIGZsb29yKGN1cnJlbnRWb3hlbC55KSwgZmxvb3IoY3VycmVudFZveGVsLnopKTtcclxuICBpZihsb3dlcl9ib3VuZC54IDwgMC4pe1xyXG4gICAgbG93ZXJfYm91bmQueCA9IDAuO1xyXG4gIH1cclxuICBpZihsb3dlcl9ib3VuZC55IDwgMC4pe1xyXG4gICAgbG93ZXJfYm91bmQueSA9IDAuO1xyXG4gIH1cclxuICBpZihsb3dlcl9ib3VuZC56IDwgMC4pe1xyXG4gICAgbG93ZXJfYm91bmQueiA9IDAuO1xyXG4gIH1cclxuICBcclxuICB2ZWMzIGhpZ2hlcl9ib3VuZCA9IGxvd2VyX2JvdW5kICsgdmVjMygxKTtcclxuXHJcbiAgZmxvYXQgeGQgPSAoIGN1cnJlbnRWb3hlbC54IC0gbG93ZXJfYm91bmQueCApIC8gKCBoaWdoZXJfYm91bmQueCAtIGxvd2VyX2JvdW5kLnggKTtcclxuICBmbG9hdCB5ZCA9ICggY3VycmVudFZveGVsLnkgLSBsb3dlcl9ib3VuZC55ICkgLyAoIGhpZ2hlcl9ib3VuZC55IC0gbG93ZXJfYm91bmQueSApO1xyXG4gIGZsb2F0IHpkID0gKCBjdXJyZW50Vm94ZWwueiAtIGxvd2VyX2JvdW5kLnogKSAvICggaGlnaGVyX2JvdW5kLnogLSBsb3dlcl9ib3VuZC56ICk7XHJcblxyXG4gIC8vXHJcbiAgLy8gYzAwXHJcbiAgLy9cclxuXHJcbiAgLy9cclxuXHJcbiAgdmVjNCB2MDAwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gIHZlYzMgYzAwMCA9IHZlYzMobG93ZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XHJcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMDAwJywgJ3YwMDAnKX1cclxuICB2ZWMzIGcwMDAgPSB2MDAwLnIgKiB2ZWMzKC0xLiwgLTEuLCAtMS4pO1xyXG5cclxuICAvL1xyXG5cclxuICB2ZWM0IHYxMDAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMTAwID0gdmVjMyhoaWdoZXJfYm91bmQueCwgbG93ZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XHJcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMTAwJywgJ3YxMDAnKX1cclxuICB2ZWMzIGcxMDAgPSB2MTAwLnIgKiB2ZWMzKDEuLCAtMS4sIC0xLik7XHJcblxyXG4gIHZlYzQgYzAwID0gdjAwMCAqICggMS4wIC0geGQgKSArIHYxMDAgKiB4ZDtcclxuXHJcbiAgLy9cclxuICAvLyBjMDFcclxuICAvL1xyXG4gIHZlYzQgdjAwMSA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICB2ZWMzIGMwMDEgPSB2ZWMzKGxvd2VyX2JvdW5kLngsIGxvd2VyX2JvdW5kLnksIGhpZ2hlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMDEnLCAndjAwMScpfVxyXG4gIHZlYzMgZzAwMSA9IHYwMDEuciAqIHZlYzMoLTEuLCAtMS4sIDEuKTtcclxuXHJcbiAgdmVjNCB2MTAxID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gIHZlYzMgYzEwMSA9IHZlYzMoaGlnaGVyX2JvdW5kLngsIGxvd2VyX2JvdW5kLnksIGhpZ2hlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMDEnLCAndjEwMScpfVxyXG4gIHZlYzMgZzEwMSA9IHYxMDEuciAqIHZlYzMoMS4sIC0xLiwgMS4pO1xyXG5cclxuICB2ZWM0IGMwMSA9IHYwMDEgKiAoIDEuMCAtIHhkICkgKyB2MTAxICogeGQ7XHJcblxyXG4gIC8vXHJcbiAgLy8gYzEwXHJcbiAgLy9cclxuICB2ZWM0IHYwMTAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMDEwID0gdmVjMyhsb3dlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XHJcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMDEwJywgJ3YwMTAnKX1cclxuICB2ZWMzIGcwMTAgPSB2MDEwLnIgKiB2ZWMzKC0xLiwgMS4sIC0xLik7XHJcblxyXG4gIHZlYzQgdjExMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICB2ZWMzIGMxMTAgPSB2ZWMzKGhpZ2hlcl9ib3VuZC54LCBoaWdoZXJfYm91bmQueSwgbG93ZXJfYm91bmQueik7XHJcbiAgJHtJbnRlcnBvbGF0aW9uSWRlbnRpdHkuYXBpKHRoaXMuX2Jhc2UsICdjMTEwJywgJ3YxMTAnKX1cclxuICB2ZWMzIGcxMTAgPSB2MTEwLnIgKiB2ZWMzKDEuLCAxLiwgLTEuKTtcclxuXHJcbiAgdmVjNCBjMTAgPSB2MDEwICogKCAxLjAgLSB4ZCApICsgdjExMCAqIHhkO1xyXG5cclxuICAvL1xyXG4gIC8vIGMxMVxyXG4gIC8vXHJcbiAgdmVjNCB2MDExID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gIHZlYzMgYzAxMSA9IHZlYzMobG93ZXJfYm91bmQueCwgaGlnaGVyX2JvdW5kLnksIGhpZ2hlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MwMTEnLCAndjAxMScpfVxyXG4gIHZlYzMgZzAxMSA9IHYwMTEuciAqIHZlYzMoLTEuLCAxLiwgMS4pO1xyXG5cclxuICB2ZWM0IHYxMTEgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XHJcbiAgdmVjMyBjMTExID0gdmVjMyhoaWdoZXJfYm91bmQueCwgaGlnaGVyX2JvdW5kLnksIGhpZ2hlcl9ib3VuZC56KTtcclxuICAke0ludGVycG9sYXRpb25JZGVudGl0eS5hcGkodGhpcy5fYmFzZSwgJ2MxMTEnLCAndjExMScpfVxyXG4gIHZlYzMgZzExMSA9IHYxMTEuciAqIHZlYzMoMS4sIDEuLCAxLik7XHJcblxyXG4gIHZlYzQgYzExID0gdjAxMSAqICggMS4wIC0geGQgKSArIHYxMTEgKiB4ZDtcclxuXHJcbiAgLy8gYzAgYW5kIGMxXHJcbiAgdmVjNCBjMCA9IGMwMCAqICggMS4wIC0geWQpICsgYzEwICogeWQ7XHJcbiAgdmVjNCBjMSA9IGMwMSAqICggMS4wIC0geWQpICsgYzExICogeWQ7XHJcblxyXG4gIC8vIGNcclxuICB2ZWM0IGMgPSBjMCAqICggMS4wIC0gemQpICsgYzEgKiB6ZDtcclxuICBkYXRhVmFsdWUgPSBjO1xyXG5cclxuICAvLyBjb21wdXRlIGdyYWRpZW50XHJcbiAgZ3JhZGllbnQgPSBnMDAwICsgZzEwMCArIGcwMTAgKyBnMTEwICsgZzAxMSArIGcxMTEgKyBnMTEwICsgZzAxMTtcclxuICAvLyBncmFkaWVudE1hZ25pdHVkZSA9IGxlbmd0aChncmFkaWVudCk7XHJcbiAgLy8gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsXyhnZW9tZXRyeSkjVHJhbnNmb3JtaW5nX25vcm1hbHNcclxuICAvLyB2ZWMzIGxvY2FsTm9ybWFsID0gKC0xLiAvIGdyYWRpZW50TWFnbml0dWRlKSAqIGdyYWRpZW50O1xyXG4gIC8vIG5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxQaXhlbFRvUGF0aWVudCR7dGhpcy5pZH0gKiBsb2NhbE5vcm1hbCk7XHJcbiAgLy9ub3JtYWwgPSBncmFkaWVudDtcclxuXHJcbn1cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBJbnRlcnBvbGF0aW9uVHJpbGluZWFyKCk7XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9uYW1lID0gJ3NoYWRlcnNCYXNlJztcclxuICAgIHRoaXMuX2Jhc2UgPSB7XHJcbiAgICAgIF9mdW5jdGlvbnM6IHt9LFxyXG4gICAgICBfdW5pZm9ybXM6IHt9LFxyXG4gICAgfTtcclxuICAgIHRoaXMuX2RlZmluaXRpb24gPSAnJztcclxuICB9XHJcblxyXG4gIGdldCBuYW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgfVxyXG5cclxuICBzZXQgbmFtZShuYW1lKSB7XHJcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyc0ZyYWdtZW50IHtcclxuXHJcbiAgLy8gcGFzcyB1bmlmb3JtcyBvYmplY3RcclxuICBjb25zdHJ1Y3Rvcih1bmlmb3Jtcykge1xyXG4gICAgdGhpcy5fdW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICAgIHRoaXMuX2Z1bmN0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fbWFpbiA9ICcnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb25zKCkge1xyXG4gICAgaWYodGhpcy5fbWFpbiA9PT0gJycpIHtcclxuICAgICAgLy8gaWYgbWFpbiBpcyBlbXB0eSwgZnVuY3Rpb25zIGNhbiBub3QgaGF2ZSBiZWVuIGNvbXB1dGVkXHJcbiAgICAgIHRoaXMubWFpbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl9mdW5jdGlvbnMpIHtcclxuICAgICAgY29udGVudCArPSB0aGlzLl9mdW5jdGlvbnNbcHJvcGVydHldICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICB1bmlmb3JtcygpIHtcclxuICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzLl91bmlmb3Jtcykge1xyXG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMuX3VuaWZvcm1zW3Byb3BlcnR5XTtcclxuICAgICAgY29udGVudCArPSBgdW5pZm9ybSAke3VuaWZvcm0udHlwZUdMU0x9ICR7cHJvcGVydHl9YDtcclxuXHJcbiAgICAgIGlmKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCArPSAnO1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBtYWluKCkge1xyXG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XHJcbiAgICB0aGlzLl9tYWluID0gYFxyXG5cclxuICAgIGZsb2F0IGx1bWEgKHZlYzMgcmdiKSB7XHJcblx0cmV0dXJuIChyZ2IuciArIHJnYi5nICsgcmdiLmIpLzMuMDtcclxufVxyXG5cclxuY29uc3QgZmxvYXQgVCA9IDAuMDQ7XHJcbmNvbnN0IGZsb2F0IE0gPSAxLjA7XHJcbmNvbnN0IGZsb2F0IEwgPSAwLjAwMjtcclxuXHJcbnZvaWQgbWFpbih2b2lkKSB7XHJcblxyXG4gIHZlYzIgdGV4Q29vcmQgPSB2ZWMyKCgodlByb2plY3RlZENvb3Jkcy54IC8gdlByb2plY3RlZENvb3Jkcy53KSArIDEuMCApIC8gMi4wLFxyXG4gICAgICAgICAgICAgICAgKCh2UHJvamVjdGVkQ29vcmRzLnkgLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAgKTtcclxuXHJcbiAgZmxvYXQgYm9yZGVyV2lkdGggPSB1V2lkdGg7IC8vIGluIHB4XHJcbiAgZmxvYXQgc3RlcF91ID0gYm9yZGVyV2lkdGggKiAxLjAgLyB1Q2FudmFzV2lkdGg7XHJcbiAgZmxvYXQgc3RlcF92ID0gYm9yZGVyV2lkdGggKiAxLjAgLyB1Q2FudmFzSGVpZ2h0O1xyXG4gIHZlYzQgY2VudGVyUGl4ZWwgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkKTtcclxuXHJcbiAgdmVjNCByaWdodFBpeGVsICA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKHN0ZXBfdSwgMC4wKSk7XHJcbiAgdmVjNCBib3R0b21QaXhlbCA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKDAuMCwgc3RlcF92KSk7XHJcblxyXG4gIC8vIG5vdyBtYW51YWxseSBjb21wdXRlIHRoZSBkZXJpdmF0aXZlc1xyXG4gIGZsb2F0IF9kRmRYID0gbGVuZ3RoKHJpZ2h0UGl4ZWwgLSBjZW50ZXJQaXhlbCkgLyBzdGVwX3U7XHJcbiAgZmxvYXQgX2RGZFkgPSBsZW5ndGgoYm90dG9tUGl4ZWwgLSBjZW50ZXJQaXhlbCkgLyBzdGVwX3Y7XHJcblxyXG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gX2RGZFg7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSBfZEZkWTtcclxuICBnbF9GcmFnQ29sb3IuciA9IG1heChtYXgoY2VudGVyUGl4ZWwuciwgcmlnaHRQaXhlbC5yKSwgYm90dG9tUGl4ZWwucik7XHJcbiAgZ2xfRnJhZ0NvbG9yLmcgPSBtYXgobWF4KGNlbnRlclBpeGVsLmcsIHJpZ2h0UGl4ZWwuZyksIGJvdHRvbVBpeGVsLmcpO1xyXG4gIGdsX0ZyYWdDb2xvci5iID0gbWF4KG1heChjZW50ZXJQaXhlbC5iLCByaWdodFBpeGVsLmIpLCBib3R0b21QaXhlbC5iKTtcclxuICBnbF9GcmFnQ29sb3IuYSA9IG1heChfZEZkWCwgX2RGZFkpO1xyXG5cclxuICByZXR1cm47XHJcbiAgZmxvYXQgaCA9IDEuL3VDYW52YXNIZWlnaHQ7XHJcbiAgZmxvYXQgdyA9IDEuL3VDYW52YXNXaWR0aDtcclxuICB2ZWM0IG5bOV07XHJcbiAgblswXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgLWgpKTtcclxuICBuWzFdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoMC4wLCAtaCkpO1xyXG4gIG5bMl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggIHcsIC1oKSk7XHJcbiAgblszXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgMC4wKSk7XHJcbiAgbls0XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMpO1xyXG4gIG5bNV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggIHcsIDAuMCkpO1xyXG4gIG5bNl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggLXcsIGgpKTtcclxuICBuWzddID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoMC4wLCBoKSk7XHJcbiAgbls4XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgaCkpO1xyXG4gIHZlYzQgc29iZWxfaG9yaXpFZGdlID0gblsyXSArICgyLjAqbls1XSkgKyBuWzhdIC0gKG5bMF0gKyAoMi4wKm5bM10pICsgbls2XSk7XHJcbiAgdmVjNCBzb2JlbF92ZXJ0RWRnZSAgPSBuWzBdICsgKDIuMCpuWzFdKSArIG5bMl0gLSAobls2XSArICgyLjAqbls3XSkgKyBuWzhdKTtcclxuICB2ZWMzIHNvYmVsID0gc3FydCgoc29iZWxfaG9yaXpFZGdlLnJnYiAqIHNvYmVsX2hvcml6RWRnZS5yZ2IpICsgKHNvYmVsX3ZlcnRFZGdlLnJnYiAqIHNvYmVsX3ZlcnRFZGdlLnJnYikpO1xyXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNvYmVsLCBtYXgobWF4KHNvYmVsLnIsIHNvYmVsLmcpLCBzb2JlbC5iKSApO1xyXG5cclxuXHJcbiAgcmV0dXJuO1xyXG5cclxuICBnbF9GcmFnQ29sb3IuciA9ICh0ZXhDb29yZCArIHZlYzIoMC4wLCBzdGVwX3YpKS5yO1xyXG4gIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMihzdGVwX3UsIDAuMCkpLmc7XHJcbiAgZ2xfRnJhZ0NvbG9yID0gY2VudGVyUGl4ZWw7XHJcbiAgZ2xfRnJhZ0NvbG9yLnIgPSB0ZXhDb29yZC54O1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gKHRleENvb3JkICsgdmVjMigwLjAsIHN0ZXBfdikpLng7XHJcbiAgZ2xfRnJhZ0NvbG9yLmIgPSAodGV4Q29vcmQgKyB2ZWMyKHN0ZXBfdSwgMC4wKSkueDtcclxuICBnbF9GcmFnQ29sb3IucmcgPSAodGV4Q29vcmQgKyB2ZWMyKDAuMCwgc3RlcF92KSk7XHJcbiAgZ2xfRnJhZ0NvbG9yLmIgPSAwLjtcclxuICByZXR1cm47XHJcbiAgdmVjMiB0ZXhDb29yZFNsb3BlID0gZndpZHRoKHRleENvb3JkKTtcclxuICB2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMpO1xyXG4gIC8vIGRmZHggdGhhdCB2UHJvamVjdGVkVGV4dENvb3Jkc1xyXG4gIGZsb2F0IGwgPSBsdW1hIChjb2xvcjIucmdiKSA7XHJcbiAgICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QoY29sb3IyLnJnYix2ZWMzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKTtcclxuXHJcbiAgXHRmbG9hdCBxMCA9IGZ3aWR0aCAobHVtaW5hbmNlKTtcclxuICAgIGlmKHEwID4gMC4wMSl7XHJcbiAgICAgIHEwID0gMS4wO1xyXG4gICAgfVxyXG5cdGZsb2F0IHExID0gYWJzIChkRmR4IChsKSk7IFxyXG5cdGZsb2F0IHEyID0gYWJzIChkRmR5IChsKSk7XHJcblxyXG4gIFx0dmVjNCBjdCA9IHZlYzQgKDEuMCwgMS4wLCAxLjAsIDAuMCk7XHJcblx0dmVjNCBjMCA9IG1peCAoY3QsIHZlYzQgKDEuMCwgMC4wLCAwLjAsIDEuMCksIFxyXG5cdFx0c21vb3Roc3RlcCAoVCAqICgxLjAgLSBNKSwgVCAqICgxLjAgKyBNKSwgcTApKTtcclxuXHJcbmdsX0ZyYWdDb2xvci5yID0gZndpZHRoKGNvbG9yMi5yKTsvL2FicyhkRmR4KGNvbG9yMi5iKSk7Ly90ZXhDb29yZDsvL2NvbG9yMi5yZ2I7XHJcbmdsX0ZyYWdDb2xvci5nID0gZndpZHRoKGNvbG9yMi5nKTtcclxuZ2xfRnJhZ0NvbG9yLmIgPSBmd2lkdGgoY29sb3IyLmIpO1xyXG5nbF9GcmFnQ29sb3IuYSA9IDEuO1xyXG4vLyBnbF9GcmFnQ29sb3IuYSA9IHEwO1xyXG4vLyBnbF9GcmFnQ29sb3IgPSBjb2xvcjI7XHJcbi8vcmV0dXJuO1xyXG5cclxuXHJcbiAgLy9UaGUgYmFjayBwb3NpdGlvbiBpcyB0aGUgd29ybGQgc3BhY2UgcG9zaXRpb24gc3RvcmVkIGluIHRoZSB0ZXh0dXJlLlxyXG4gIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkKTtcclxuICBmbG9hdCBsQ29sb3IgPSBsZW5ndGgoY29sb3IucmdiKTtcclxuICBmbG9hdCBtYXhDb2xvciA9IGxlbmd0aChjb2xvci5yZ2IpOy8vbWF4KG1heChjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7XHJcbiAgLy8gaWYobWF4Q29sb3IgPiAwLjEpe1xyXG4gIC8vICAgbWF4Q29sb3IgPSAxLjA7XHJcbiAgLy8gfVxyXG5cclxuXHJcblxyXG4gIC8vIGdsX0ZyYWdDb2xvciA9IGNvbG9yOy8vdmVjNChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCAxKTtcclxuICAvLyByZXR1cm47XHJcbiAgLy8gZmxvYXQgdG1weHggID0gYWJzKGRGZHgobENvbG9yKSk7XHJcbiAgLy8gZmxvYXQgdG1weHkgID0gYWJzKGRGZHkobENvbG9yKSk7XHJcbiAgLy8gZmxvYXQgdG1weCA9IG1heCh0bXB4eCx0bXB4eSk7XHJcblxyXG4gIC8vIGZsb2F0IHRtcHl4ICA9IGFicyhkRmR4KGNvbG9yLnkpKTtcclxuICAvLyBmbG9hdCB0bXB5eSAgPSBhYnMoZEZkeShjb2xvci55KSk7XHJcbiAgLy8gZmxvYXQgdG1weSA9IG1heCh0bXB5eCx0bXB5eSk7XHJcblxyXG4gIC8vIGZsb2F0IHRtcHp4ICA9IGFicyhkRmR4KGNvbG9yLnopKTtcclxuICAvLyBmbG9hdCB0bXB6eSAgPSBhYnMoZEZkeShjb2xvci56KSk7XHJcbiAgLy8gZmxvYXQgdG1weiA9IG1heCh0bXB6eCx0bXB6eSk7XHJcblxyXG4gIC8vIGZsb2F0IHRtcG1heCA9IG1heChtYXgodG1weCwgdG1weSksIHRtcHopO1xyXG4gIC8vIGlmKHRtcG1heCA+IDAuMDEpe1xyXG4gIC8vICAgdG1wbWF4ID0gMS4wO1xyXG4gIC8vIH1cclxuICAvLyBnbF9GcmFnQ29sb3IuciA9IHRtcHg7Ly9zbW9vdGhzdGVwKHRtcHgtNS4sIHRtcHgrNS4sIGxDb2xvcik7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmcgPSB0bXB4O1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5iID0gdG1weDtcclxuXHJcbiAgLy8gdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZlYzIodGV4Y1gsIHRleGNZKSk7XHJcblxyXG4gIC8vIGdsX0ZyYWdDb2xvci5yID0gY29sb3IuciAtIHRleGNYO1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5nID0gY29sb3IuZyAtIHRleGNZO1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5iID0gY29sb3IuYiAtIGNvbG9yMi5iO1xyXG4gIC8vIGdsX0ZyYWdDb2xvci5hID0gMS47XHJcblxyXG4gIC8vIGZsb2F0IHRocmVzaG9sZCA9IDAuNztcclxuICAvLyBmbG9hdCBhZndpZHRoID0gbGVuZ3RoKHZlYzIoZEZkeChtYXhDb2xvciksIGRGZHkobWF4Q29sb3IpKSk7XHJcbiAgLy8gZ2xfRnJhZ0NvbG9yLmEgPSBhZndpZHRoO1xyXG4gIC8vIGZsb2F0IG9wYWNpdHkgPVxyXG4gIC8vICAgc21vb3Roc3RlcChhZndpZHRoIC0gdGhyZXNob2xkLCBhZndpZHRoICsgdGhyZXNob2xkLCBtYXhDb2xvcik7XHJcblxyXG4gIC8vIGdsX0ZyYWdDb2xvci5hID0gbWF4Q29sb3I7XHJcblxyXG4vLyBmbG9hdCBhYWYgPSBmd2lkdGgobWF4Q29sb3IpO1xyXG4vLyBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoLjAxLCAuOCwgYWFmKTtcclxuLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2IsIGFscGhhKTtcclxuXHJcbiAgLy8gZmxvYXQgaCA9IDEuL3VDYW52YXNIZWlnaHQ7XHJcbiAgLy8gZmxvYXQgdyA9IDEuL3VDYW52YXNXaWR0aDtcclxuICAvLyB2ZWM0IG5bOV07XHJcbiAgLy8gblswXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgLWgpKTtcclxuICAvLyBuWzFdID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB2UHJvamVjdGVkVGV4dENvb3JkcyArIHZlYzIoMC4wLCAtaCkpO1xyXG4gIC8vIG5bMl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHZQcm9qZWN0ZWRUZXh0Q29vcmRzICsgdmVjMiggIHcsIC1oKSk7XHJcbiAgLy8gblszXSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMgKyB2ZWMyKCAtdywgMC4wKSk7XHJcbiAgLy8gbls0XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdlByb2plY3RlZFRleHRDb29yZHMpO1xyXG4gIC8vIG5bNV0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggIHcsIDAuMCkpO1xyXG4gIC8vIG5bNl0gPSB0ZXh0dXJlMkQodVRleHR1cmVGaWxsZWQsIHRleENvb3JkICsgdmVjMiggLXcsIGgpKTtcclxuICAvLyBuWzddID0gdGV4dHVyZTJEKHVUZXh0dXJlRmlsbGVkLCB0ZXhDb29yZCArIHZlYzIoMC4wLCBoKSk7XHJcbiAgLy8gbls4XSA9IHRleHR1cmUyRCh1VGV4dHVyZUZpbGxlZCwgdGV4Q29vcmQgKyB2ZWMyKCAgdywgaCkpO1xyXG4gIC8vIHZlYzQgc29iZWxfaG9yaXpFZGdlID0gblsyXSArICgyLjAqbls1XSkgKyBuWzhdIC0gKG5bMF0gKyAoMi4wKm5bM10pICsgbls2XSk7XHJcbiAgLy8gdmVjNCBzb2JlbF92ZXJ0RWRnZSAgPSBuWzBdICsgKDIuMCpuWzFdKSArIG5bMl0gLSAobls2XSArICgyLjAqbls3XSkgKyBuWzhdKTtcclxuICAvLyB2ZWMzIHNvYmVsID0gc3FydCgoc29iZWxfaG9yaXpFZGdlLnJnYiAqIHNvYmVsX2hvcml6RWRnZS5yZ2IpICsgKHNvYmVsX3ZlcnRFZGdlLnJnYiAqIHNvYmVsX3ZlcnRFZGdlLnJnYikpO1xyXG4gIC8vIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG5bMV0ucmdiLCAxLjAgKTtcclxuICAvLyBnbF9GcmFnQ29sb3IuciA9IDEuMDtcclxuXHJcbiAgcmV0dXJuO1xyXG59XHJcbiAgIGA7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlKCkge1xyXG4gICAgbGV0IHNoYWRlckludGVycG9sYXRpb24gPSAnJztcclxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5mdW5jdGlvbnMoYXJncylcclxuXHJcbiAgICByZXR1cm4gYFxyXG4vLyB1bmlmb3Jtc1xyXG4ke3RoaXMudW5pZm9ybXMoKX1cclxuXHJcbi8vIHZhcnlpbmcgKHNob3VsZCBmZXRjaCBpdCBmcm9tIHZlcnRleCBkaXJlY3RseSlcclxudmFyeWluZyB2ZWM0ICAgICAgdlBvcztcclxudmFyeWluZyB2ZWM0ICAgICAgdlByb2plY3RlZENvb3JkcztcclxudmFyeWluZyB2ZWMyICAgICAgdlByb2plY3RlZFRleHRDb29yZHM7XHJcbnZhcnlpbmcgbWF0NCAgICAgIHZQcm9qZWN0aW9uVmlld01hdHJpeDtcclxuXHJcbi8vIHRhaWxvcmVkIGZ1bmN0aW9uc1xyXG4ke3RoaXMuZnVuY3Rpb25zKCl9XHJcblxyXG4vLyBtYWluIGxvb3BcclxuJHt0aGlzLl9tYWlufVxyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLyoqXHJcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVW5pZm9ybSB7XHJcbiAgc3RhdGljIHVuaWZvcm1zKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ3VDYW52YXNXaWR0aCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVdpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMS4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VGV4dHVyZUZpbGxlZCc6IHtcclxuICAgICAgICB0eXBlOiAndCcsXHJcbiAgICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG52YXJ5aW5nIHZlYzQgdlByb2plY3RlZENvb3JkcztcclxudmFyeWluZyBtYXQ0IHZQcm9qZWN0aW9uVmlld01hdHJpeDtcclxudmFyeWluZyB2ZWMyIHZQcm9qZWN0ZWRUZXh0Q29vcmRzO1xyXG5cclxuLy9cclxuLy8gbWFpblxyXG4vL1xyXG52b2lkIG1haW4oKSB7XHJcblxyXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG4gIHZQcm9qZWN0aW9uVmlld01hdHJpeCA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4O1xyXG4gIHZQcm9qZWN0ZWRDb29yZHMgPSAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcclxuICB2UHJvamVjdGVkVGV4dENvb3JkcyA9IHZlYzIoKCh2UHJvamVjdGVkQ29vcmRzLnggLyB2UHJvamVjdGVkQ29vcmRzLncpICsgMS4wICkgLyAyLjAsXHJcbiAgICAgICAgICAgICAgICAoKHZQcm9qZWN0ZWRDb29yZHMueSAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCApO1xyXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG5cclxufVxyXG4gICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNGcmFnbWVudCB7XHJcblxyXG4gIC8vIHBhc3MgdW5pZm9ybXMgb2JqZWN0XHJcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuX21haW4gPSAnJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9ucygpIHtcclxuICAgIGlmICh0aGlzLl9tYWluID09PSAnJykge1xyXG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcclxuICAgICAgdGhpcy5tYWluKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX2Z1bmN0aW9ucykge1xyXG4gICAgICBjb250ZW50ICs9IHRoaXMuX2Z1bmN0aW9uc1twcm9wZXJ0eV0gKyAnXFxuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGVudDtcclxuICB9XHJcblxyXG4gIHVuaWZvcm1zKCkge1xyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMuX3VuaWZvcm1zKSB7XHJcbiAgICAgIGxldCB1bmlmb3JtID0gdGhpcy5fdW5pZm9ybXNbcHJvcGVydHldO1xyXG4gICAgICBjb250ZW50ICs9IGB1bmlmb3JtICR7dW5pZm9ybS50eXBlR0xTTH0gJHtwcm9wZXJ0eX1gO1xyXG5cclxuICAgICAgaWYgKHVuaWZvcm0gJiYgdW5pZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZW50ICs9IGBbJHt1bmlmb3JtLmxlbmd0aH1dYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCArPSAnO1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgfVxyXG5cclxuICBtYWluKCkge1xyXG4gICAgLy8gbmVlZCB0byBwcmUtY2FsbCBtYWluIHRvIGZpbGwgdXAgdGhlIGZ1bmN0aW9ucyBsaXN0XHJcbiAgICB0aGlzLl9tYWluID0gYFxyXG52b2lkIG1haW4odm9pZCkge1xyXG5cclxuICAvLyBkcmF3IGJvcmRlciBpZiBzbGljZSBpcyBjcm9wcGVkXHJcbiAgLy8gZmxvYXQgdUJvcmRlckRhc2hMZW5ndGggPSAxMC47XHJcblxyXG4gIGlmKCB1Q2FudmFzV2lkdGggPiAwLiAmJlxyXG4gICAgICAoKGdsX0ZyYWdDb29yZC54ID4gdUJvcmRlck1hcmdpbiAmJiAoZ2xfRnJhZ0Nvb3JkLnggLSB1Qm9yZGVyTWFyZ2luKSA8IHVCb3JkZXJXaWR0aCkgfHxcclxuICAgICAgIChnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSAmJiAoZ2xfRnJhZ0Nvb3JkLnggKyB1Qm9yZGVyTWFyZ2luKSA+ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyV2lkdGgpICkpKXtcclxuICAgIGZsb2F0IHZhbHVlWSA9IG1vZChnbF9GcmFnQ29vcmQueSwgMi4gKiB1Qm9yZGVyRGFzaExlbmd0aCk7XHJcbiAgICBpZiggdmFsdWVZIDwgdUJvcmRlckRhc2hMZW5ndGggJiYgZ2xfRnJhZ0Nvb3JkLnkgPiB1Qm9yZGVyTWFyZ2luICYmIGdsX0ZyYWdDb29yZC55IDwgKHVDYW52YXNIZWlnaHQgLSB1Qm9yZGVyTWFyZ2luKSApe1xyXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVCb3JkZXJDb2xvciwgMS4pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiggdUNhbnZhc0hlaWdodCA+IDAuICYmXHJcbiAgICAgICgoZ2xfRnJhZ0Nvb3JkLnkgPiB1Qm9yZGVyTWFyZ2luICYmIChnbF9GcmFnQ29vcmQueSAtIHVCb3JkZXJNYXJnaW4pIDwgdUJvcmRlcldpZHRoKSB8fFxyXG4gICAgICAgKGdsX0ZyYWdDb29yZC55IDwgKHVDYW52YXNIZWlnaHQgLSB1Qm9yZGVyTWFyZ2luKSAmJiAoZ2xfRnJhZ0Nvb3JkLnkgKyB1Qm9yZGVyTWFyZ2luKSA+ICh1Q2FudmFzSGVpZ2h0IC0gdUJvcmRlcldpZHRoKSApKSl7XHJcbiAgICBmbG9hdCB2YWx1ZVggPSBtb2QoZ2xfRnJhZ0Nvb3JkLngsIDIuICogdUJvcmRlckRhc2hMZW5ndGgpO1xyXG4gICAgaWYoIHZhbHVlWCA8IHVCb3JkZXJEYXNoTGVuZ3RoICYmIGdsX0ZyYWdDb29yZC54ID4gdUJvcmRlck1hcmdpbiAmJiBnbF9GcmFnQ29vcmQueCA8ICh1Q2FudmFzV2lkdGggLSB1Qm9yZGVyTWFyZ2luKSApe1xyXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVCb3JkZXJDb2xvciwgMS4pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgdGV4dHVyZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBpeGVsXHJcbiAgdmVjNCBkYXRhQ29vcmRpbmF0ZXMgPSB1V29ybGRUb0RhdGEgKiB2UG9zO1xyXG4gIHZlYzMgY3VycmVudFZveGVsID0gdmVjMyhkYXRhQ29vcmRpbmF0ZXMueCwgZGF0YUNvb3JkaW5hdGVzLnksIGRhdGFDb29yZGluYXRlcy56KTtcclxuICB2ZWM0IGRhdGFWYWx1ZSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xyXG4gIHZlYzMgZ3JhZGllbnQgPSB2ZWMzKDAuLCAwLiwgMC4pO1xyXG4gICR7c2hhZGVyc0ludGVycG9sYXRpb24odGhpcywgJ2N1cnJlbnRWb3hlbCcsICdkYXRhVmFsdWUnLCAnZ3JhZGllbnQnKX1cclxuXHJcbiAgLy8gaG93IGRvIHdlIGRlYWwgd2lsIG1vcmUgdGhhbiAxIGNoYW5uZWw/XHJcbiAgaWYodU51bWJlck9mQ2hhbm5lbHMgPT0gMSl7XHJcbiAgICBmbG9hdCBpbnRlbnNpdHkgPSBkYXRhVmFsdWUucjtcclxuXHJcbiAgICAvLyByZXNjYWxlL3Nsb3BlXHJcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkqdVJlc2NhbGVTbG9wZUludGVyY2VwdFswXSArIHVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMV07XHJcblxyXG4gICAgZmxvYXQgd2luZG93TWluID0gdVdpbmRvd0NlbnRlcldpZHRoWzBdIC0gdVdpbmRvd0NlbnRlcldpZHRoWzFdICogMC41O1xyXG4gICAgZmxvYXQgd2luZG93TWF4ID0gdVdpbmRvd0NlbnRlcldpZHRoWzBdICsgdVdpbmRvd0NlbnRlcldpZHRoWzFdICogMC41O1xyXG4gICAgaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgLSB3aW5kb3dNaW4gKSAvIHVXaW5kb3dDZW50ZXJXaWR0aFsxXTtcclxuXHJcbiAgICBkYXRhVmFsdWUuciA9IGRhdGFWYWx1ZS5nID0gZGF0YVZhbHVlLmIgPSBpbnRlbnNpdHk7XHJcbiAgICBkYXRhVmFsdWUuYSA9IDEuMDtcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IExVVCB0YWJsZS4uLlxyXG4gIC8vXHJcbiAgaWYodUx1dCA9PSAxKXtcclxuICAgIC8vIHNob3VsZCBvcGFjaXR5IGJlIGdyYWJiZWQgdGhlcmU/XHJcbiAgICBkYXRhVmFsdWUgPSB0ZXh0dXJlMkQoIHVUZXh0dXJlTFVULCB2ZWMyKCBkYXRhVmFsdWUuciAsIDEuMCkgKTtcclxuICB9XHJcblxyXG4gIGlmKHVJbnZlcnQgPT0gMSl7XHJcbiAgICBkYXRhVmFsdWUgPSB2ZWM0KDEuKSAtIGRhdGFWYWx1ZTtcclxuICAgIC8vIGhvdyBkbyB3ZSBkZWFsIHdpdGggdGhhdCBhbmQgb3BhY2l0eT9cclxuICAgIGRhdGFWYWx1ZS5hID0gMS47XHJcbiAgfVxyXG5cclxuICBnbF9GcmFnQ29sb3IgPSBkYXRhVmFsdWU7XHJcblxyXG4gICAgLy8gaWYgb24gZWRnZSwgZHJhdyBsaW5lXHJcbiAgLy8gZmxvYXQgeFBvcyA9IGdsX0ZyYWdDb29yZC54LzUxMi47XHJcbiAgLy8gZmxvYXQgeVBvcyA9IGdsX0ZyYWdDb29yZC55LzUxMi47XHJcbiAgLy8gaWYoIHhQb3MgPCAwLjA1IHx8IHhQb3MgPiAuOTUgfHwgeVBvcyA8IDAuMDUgfHwgeVBvcyA+IC45NSl7XHJcbiAgLy8gICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHhQb3MsIHlQb3MsIDAuLCAxLik7Ly9kYXRhVmFsdWU7XHJcbiAgLy8gICAvL3JldHVybjtcclxuICAvLyB9XHJcblxyXG59XHJcbiAgIGA7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlKCkge1xyXG4gICAgbGV0IHNoYWRlckludGVycG9sYXRpb24gPSAnJztcclxuICAgIC8vIHNoYWRlckludGVycG9sYXRpb24uaW5saW5lKGFyZ3MpIC8vdHJ1ZS9mYWxzZVxyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5mdW5jdGlvbnMoYXJncylcclxuXHJcbiAgICByZXR1cm4gYFxyXG4vLyB1bmlmb3Jtc1xyXG4ke3RoaXMudW5pZm9ybXMoKX1cclxuXHJcbi8vIHZhcnlpbmcgKHNob3VsZCBmZXRjaCBpdCBmcm9tIHZlcnRleCBkaXJlY3RseSlcclxudmFyeWluZyB2ZWM0ICAgICAgdlBvcztcclxuXHJcbi8vIHRhaWxvcmVkIGZ1bmN0aW9uc1xyXG4ke3RoaXMuZnVuY3Rpb25zKCl9XHJcblxyXG4vLyBtYWluIGxvb3BcclxuJHt0aGlzLl9tYWlufVxyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLyoqXHJcbiAqIEBtb2R1bGUgc2hhZGVycy9kYXRhXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVW5pZm9ybSB7XHJcbiAgLyoqXHJcbiAgICogU2hhZGVycyBkYXRhIHVuaWZvcm1zXHJcbiAgICovXHJcbiAgc3RhdGljIHVuaWZvcm1zKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ3VUZXh0dXJlU2l6ZSc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVRleHR1cmVDb250YWluZXInOiB7XHJcbiAgICAgICAgdHlwZTogJ3R2JyxcclxuICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdzYW1wbGVyMkQnLFxyXG4gICAgICAgIGxlbmd0aDogNyxcclxuICAgICAgfSxcclxuICAgICAgJ3VEYXRhRGltZW5zaW9ucyc6IHtcclxuICAgICAgICB0eXBlOiAnaXYnLFxyXG4gICAgICAgIHZhbHVlOiBbMCwgMCwgMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpdmVjMycsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1V29ybGRUb0RhdGEnOiB7XHJcbiAgICAgICAgdHlwZTogJ200JyxcclxuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuICAgICAgICB0eXBlR0xTTDogJ21hdDQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVdpbmRvd0NlbnRlcldpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmdjEnLFxyXG4gICAgICAgIHZhbHVlOiBbMC4wLCAwLjBdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICAgIGxlbmd0aDogMixcclxuICAgICAgfSxcclxuICAgICAgJ3VSZXNjYWxlU2xvcGVJbnRlcmNlcHQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2Z2MScsXHJcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgICAgbGVuZ3RoOiAyLFxyXG4gICAgICB9LFxyXG4gICAgICAndU51bWJlck9mQ2hhbm5lbHMnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VCaXRzQWxsb2NhdGVkJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogOCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1SW52ZXJ0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1THV0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VGV4dHVyZUxVVCc6IHtcclxuICAgICAgICB0eXBlOiAndCcsXHJcbiAgICAgICAgdmFsdWU6IFtdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnc2FtcGxlcjJEJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQaXhlbFR5cGUnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQYWNrZWRQZXJQaXhlbCc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUludGVycG9sYXRpb24nOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VDYW52YXNXaWR0aCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUNhbnZhc0hlaWdodCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUJvcmRlckNvbG9yJzoge1xyXG4gICAgICAgIHR5cGU6ICd2MycsXHJcbiAgICAgICAgdmFsdWU6IFsxLjAsIDAuMCwgMC41XSxcclxuICAgICAgICB0eXBlR0xTTDogJ3ZlYzMnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUJvcmRlcldpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMi4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Qm9yZGVyTWFyZ2luJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMi4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Qm9yZGVyRGFzaExlbmd0aCc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDEwLixcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNWZXJ0ZXgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbnZhcnlpbmcgdmVjNCB2UG9zO1xyXG5cclxuLy9cclxuLy8gbWFpblxyXG4vL1xyXG52b2lkIG1haW4oKSB7XHJcblxyXG4gIHZQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG5cclxufVxyXG4gICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBDb250b3VyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMuY29udG91ci51bmlmb3JtJztcclxuaW1wb3J0IENvbnRvdXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMuY29udG91ci5mcmFnbWVudCc7XHJcbmltcG9ydCBDb250b3VyVmVydGV4IGZyb20gJy4vc2hhZGVycy5jb250b3VyLnZlcnRleCc7XHJcblxyXG5pbXBvcnQgRGF0YVVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLmRhdGEudW5pZm9ybSc7XHJcbmltcG9ydCBEYXRhRnJhZ21lbnQgZnJvbSAnLi9zaGFkZXJzLmRhdGEuZnJhZ21lbnQnO1xyXG5pbXBvcnQgRGF0YVZlcnRleCBmcm9tICcuL3NoYWRlcnMuZGF0YS52ZXJ0ZXgnO1xyXG5cclxuaW1wb3J0IFZSVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMudnIudW5pZm9ybSc7XHJcbmltcG9ydCBWUkZyYWdtZW50IGZyb20gJy4vc2hhZGVycy52ci5mcmFnbWVudCc7XHJcbmltcG9ydCBWUlZlcnRleCBmcm9tICcuL3NoYWRlcnMudnIudmVydGV4JztcclxuXHJcbmltcG9ydCBMYXllclVuaWZvcm0gZnJvbSAnLi9zaGFkZXJzLmxheWVyLnVuaWZvcm0nO1xyXG5pbXBvcnQgTGF5ZXJGcmFnbWVudCBmcm9tICcuL3NoYWRlcnMubGF5ZXIuZnJhZ21lbnQnO1xyXG5pbXBvcnQgTGF5ZXJWZXJ0ZXggZnJvbSAnLi9zaGFkZXJzLmxheWVyLnZlcnRleCc7XHJcblxyXG5pbXBvcnQgTG9jYWxpemVyVW5pZm9ybSBmcm9tICcuL3NoYWRlcnMubG9jYWxpemVyLnVuaWZvcm0nO1xyXG5pbXBvcnQgTG9jYWxpemVyRnJhZ21lbnQgZnJvbSAnLi9zaGFkZXJzLmxvY2FsaXplci5mcmFnbWVudCc7XHJcbmltcG9ydCBMb2NhbGl6ZXJWZXJ0ZXggZnJvbSAnLi9zaGFkZXJzLmxvY2FsaXplci52ZXJ0ZXgnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgc2hhZGVyc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBDb250b3VyVW5pZm9ybSxcclxuICBDb250b3VyRnJhZ21lbnQsXHJcbiAgQ29udG91clZlcnRleCxcclxuXHJcbiAgRGF0YVVuaWZvcm0sXHJcbiAgRGF0YUZyYWdtZW50LFxyXG4gIERhdGFWZXJ0ZXgsXHJcblxyXG4gIFZSVW5pZm9ybSxcclxuICBWUkZyYWdtZW50LFxyXG4gIFZSVmVydGV4LFxyXG5cclxuICBMYXllclVuaWZvcm0sXHJcbiAgTGF5ZXJGcmFnbWVudCxcclxuICBMYXllclZlcnRleCxcclxuXHJcbiAgTG9jYWxpemVyVW5pZm9ybSxcclxuICBMb2NhbGl6ZXJGcmFnbWVudCxcclxuICBMb2NhbGl6ZXJWZXJ0ZXgsXHJcbn07XHJcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNGcmFnbWVudCB7XHJcblxyXG4gIC8vIHBhc3MgdW5pZm9ybXMgb2JqZWN0XHJcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuX21haW4gPSAnJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9ucygpIHtcclxuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XHJcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxyXG4gICAgICB0aGlzLm1haW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XHJcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgdW5pZm9ybXMoKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcclxuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XHJcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XHJcblxyXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGVudCArPSBgWyR7dW5pZm9ybS5sZW5ndGh9XWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRlbnQgKz0gJztcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgbWFpbigpIHtcclxuICAgIC8vIG5lZWQgdG8gcHJlLWNhbGwgbWFpbiB0byBmaWxsIHVwIHRoZSBmdW5jdGlvbnMgbGlzdFxyXG4gICAgdGhpcy5fbWFpbiA9IGBcclxudm9pZCBtYWluKHZvaWQpIHtcclxuXHJcbiAgdmVjMiB0ZXhjID0gdmVjMigoKHZQcm9qZWN0ZWRDb29yZHMueCAvIHZQcm9qZWN0ZWRDb29yZHMudykgKyAxLjAgKSAvIDIuMCxcclxuICAgICAgICAgICAgICAgICgodlByb2plY3RlZENvb3Jkcy55IC8gdlByb2plY3RlZENvb3Jkcy53KSArIDEuMCApIC8gMi4wICk7XHJcblxyXG4gIC8vIGp1c3Qgc2lsZW5jZSB3YXJuaW5nIGZvclxyXG4gIHZlYzQgZHVtbXkgPSB2UG9zO1xyXG5cclxuICAvL1RoZSBiYWNrIHBvc2l0aW9uIGlzIHRoZSB3b3JsZCBzcGFjZSBwb3NpdGlvbiBzdG9yZWQgaW4gdGhlIHRleHR1cmUuXHJcbiAgdmVjNCBiYXNlQ29sb3IwID0gdGV4dHVyZTJEKHVUZXh0dXJlQmFja1Rlc3QwLCB0ZXhjKTtcclxuICB2ZWM0IGJhc2VDb2xvcjEgPSB0ZXh0dXJlMkQodVRleHR1cmVCYWNrVGVzdDEsIHRleGMpO1xyXG5cclxuICBpZiggdVRyYWNrTW91c2UgPT0gMSApe1xyXG5cclxuICAgICAgaWYoIHZQcm9qZWN0ZWRDb29yZHMueCA8IHVNb3VzZS54ICl7XHJcblxyXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvcjA7XHJcblxyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcblxyXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgdU9wYWNpdHkxICk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gIH1cclxuICBlbHNle1xyXG5cclxuICAgIGlmKCB1VHlwZTEgPT0gMCApe1xyXG5cclxuICAgICAgLy9tZXJnZSBhbiBpbWFnZSBpbnRvXHJcbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgdU9wYWNpdHkxICk7XHJcblxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuXHJcbiAgICAgIGZsb2F0IG9wYWNpdHkgPSBiYXNlQ29sb3IxLmE7XHJcbiAgICAgIGdsX0ZyYWdDb2xvciA9IG1peCggYmFzZUNvbG9yMCwgYmFzZUNvbG9yMSwgb3BhY2l0eSAqIHVPcGFjaXR5MSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICByZXR1cm47XHJcbn1cclxuICAgYDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoKSB7XHJcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxyXG5cclxuICAgIHJldHVybiBgXHJcbi8vIHVuaWZvcm1zXHJcbiR7dGhpcy51bmlmb3JtcygpfVxyXG5cclxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxyXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xyXG52YXJ5aW5nIHZlYzQgICAgICB2UHJvamVjdGVkQ29vcmRzO1xyXG5cclxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXHJcbiR7dGhpcy5mdW5jdGlvbnMoKX1cclxuXHJcbi8vIG1haW4gbG9vcFxyXG4ke3RoaXMuX21haW59XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcclxuICBzdGF0aWMgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgJ3VUZXh0dXJlQmFja1Rlc3QwJzoge1xyXG4gICAgICAgIHR5cGU6ICd0JyxcclxuICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdzYW1wbGVyMkQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVRleHR1cmVCYWNrVGVzdDEnOiB7XHJcbiAgICAgICAgdHlwZTogJ3QnLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1T3BhY2l0eTAnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAxLjAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1T3BhY2l0eTEnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAxLjAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VHlwZTAnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUeXBlMSc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVRyYWNrTW91c2UnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VNb3VzZSc6IHtcclxuICAgICAgICB0eXBlOiAndjInLFxyXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gICAgICAgIHR5cGVHTFNMOiAndmVjMicsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVmVydGV4IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gYFxyXG52YXJ5aW5nIHZlYzQgdlBvcztcclxudmFyeWluZyB2ZWM0IHZQcm9qZWN0ZWRDb29yZHM7XHJcblxyXG4vL1xyXG4vLyBtYWluXHJcbi8vXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcbiAgdlBvcyA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wICk7XHJcbiAgdlByb2plY3RlZENvb3JkcyA9ICBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xyXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCApO1xyXG5cclxufVxyXG4gICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBzaGFkZXJzSW50ZXJwb2xhdGlvbiBmcm9tICcuL2ludGVycG9sYXRpb24vc2hhZGVycy5pbnRlcnBvbGF0aW9uJztcclxuXHJcbi8qKlxyXG4gKiBMb2NhbGl6ZXIgZnJhZ21lbnQgc2hhZGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHVuaWZvcm1zKSB7XHJcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zO1xyXG4gICAgdGhpcy5fZnVuY3Rpb25zID0ge307XHJcbiAgICB0aGlzLl9tYWluID0gJyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBcclxuICAgKi9cclxuICBmdW5jdGlvbnMoKSB7XHJcbiAgICBpZih0aGlzLl9tYWluID09PSAnJykge1xyXG4gICAgICAvLyBpZiBtYWluIGlzIGVtcHR5LCBmdW5jdGlvbnMgY2FuIG5vdCBoYXZlIGJlZW4gY29tcHV0ZWRcclxuICAgICAgdGhpcy5tYWluKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbnRlbnQgPSAnJztcclxuICAgIGZvcihsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XHJcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICovXHJcbiAgdW5pZm9ybXMoKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcclxuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XHJcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XHJcblxyXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGVudCArPSBgWyR7dW5pZm9ybS5sZW5ndGh9XWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRlbnQgKz0gJztcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICovXHJcbiAgbWFpbigpIHtcclxuICAgIC8vIG5lZWQgdG8gcHJlLWNhbGwgbWFpbiB0byBmaWxsIHVwIHRoZSBmdW5jdGlvbnMgbGlzdFxyXG4gICAgdGhpcy5fbWFpbiA9IGBcclxudm9pZCBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKFxyXG4gIGluIHZlYzQgcGxhbmUsXHJcbiAgaW4gdmVjNCBzbGljZSxcclxuICBvdXQgdmVjMyBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uKXtcclxuXHJcbiAgICAgIHZlYzMgaW50ZXJzZWN0aW9uRGlyZWN0aW9uID0gbm9ybWFsaXplKGNyb3NzKHBsYW5lLnh5eiwgc2xpY2UueHl6KSk7XHJcbiAgICAgIHZlYzMgaW50ZXJzZWN0aW9uUG9pbnQgPSBcclxuICAgICAgICBjcm9zcyhpbnRlcnNlY3Rpb25EaXJlY3Rpb24sc2xpY2UueHl6KSAqIHBsYW5lLncgK1xyXG4gICAgICAgIGNyb3NzKHBsYW5lLnh5eiwgaW50ZXJzZWN0aW9uRGlyZWN0aW9uKSAqIHNsaWNlLnc7XHJcblxyXG4gICAgICBpbnRlcnNlY3Rpb25Qcm9qZWN0aW9uID1cclxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC54eXogK1xyXG4gICAgICAgIChkb3QodlBvcy54eXogLSBpbnRlcnNlY3Rpb25Qb2ludCwgaW50ZXJzZWN0aW9uRGlyZWN0aW9uKVxyXG4gICAgICAgICAgKiBpbnRlcnNlY3Rpb25EaXJlY3Rpb24pO1xyXG5cclxufVxyXG5cclxudm9pZCBtYWluKHZvaWQpIHtcclxuICAgICAgdmVjNCBjMSA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xyXG4gICAgICB2ZWM0IGMyID0gdmVjNCgwLiwgMC4sIDAuLCAwLik7XHJcbiAgICAgIHZlYzQgYzMgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcclxuXHJcbiAgICAgIC8vIGxvY2FsaXplciAjMVxyXG4gICAgICAvLyBtdXN0IGJlIG5vcm1hbGl6ZWQhXHJcbiAgICAgIGlmKGxlbmd0aCh1UGxhbmUxLnh5eikgPiAwLjUpIHtcclxuICAgICAgICB2ZWMzIHByb2plY3Rpb24xID0gdmVjMygxLik7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcclxuICAgICAgICAgIHVQbGFuZTEsXHJcbiAgICAgICAgICB1U2xpY2UsXHJcbiAgICAgICAgICBwcm9qZWN0aW9uMVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZlYzQgcHJvakludGVyMSA9ICh2UHJvamVjdGlvblZpZXdNYXRyaXggKiB2ZWM0KHByb2plY3Rpb24xLCAxLikpO1xyXG4gICAgICAgIHZlYzMgbmRjMSA9IHByb2pJbnRlcjEueHl6IC8gcHJvakludGVyMS53O1xyXG4gICAgICAgIHZlYzIgc2NyZWVuU3BhY2UxID0gKG5kYzEueHkgKiAuNSArIC41KSAqIHZlYzIodUNhbnZhc1dpZHRoLCB1Q2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZmxvYXQgZDEgPSBkaXN0YW5jZShnbF9GcmFnQ29vcmQueHksIHNjcmVlblNwYWNlMS54eSk7XHJcbiAgICAgICAgYzEgPSB2ZWM0KHVQbGFuZUNvbG9yMSwgMS4gLSBzbW9vdGhzdGVwKC41LCAuNywgZDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbG9jYWxpemVyICMyXHJcbiAgICAgIGlmKGxlbmd0aCh1UGxhbmUyLnh5eikgPiAwLjUpIHtcclxuICAgICAgICB2ZWMzIHByb2plY3Rpb24yID0gdmVjMygxLik7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcclxuICAgICAgICAgIHVQbGFuZTIsXHJcbiAgICAgICAgICB1U2xpY2UsXHJcbiAgICAgICAgICBwcm9qZWN0aW9uMlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZlYzQgcHJvakludGVyMiA9ICh2UHJvamVjdGlvblZpZXdNYXRyaXggKiB2ZWM0KHByb2plY3Rpb24yLCAxLikpO1xyXG4gICAgICAgIHZlYzMgbmRjMiA9IHByb2pJbnRlcjIueHl6IC8gcHJvakludGVyMi53O1xyXG4gICAgICAgIHZlYzIgc2NyZWVuU3BhY2UyID0gKG5kYzIueHkgKiAuNSArIC41KSAqIHZlYzIodUNhbnZhc1dpZHRoLCB1Q2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZmxvYXQgZDIgPSBkaXN0YW5jZShnbF9GcmFnQ29vcmQueHksIHNjcmVlblNwYWNlMi54eSk7XHJcbiAgICAgICAgYzIgPSB2ZWM0KHVQbGFuZUNvbG9yMiwgMS4gLSBzbW9vdGhzdGVwKC41LCAuNywgZDIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbG9jYWxpemVyICMzXHJcbiAgICAgIGlmKGxlbmd0aCh1UGxhbmUzLnh5eikgPiAwLjUpIHtcclxuICAgICAgICB2ZWMzIHByb2plY3Rpb24zID0gdmVjMygxLik7XHJcbiAgICAgICAgaW50ZXJzZWN0aW9uUHJvamVjdGlvbihcclxuICAgICAgICAgIHVQbGFuZTMsXHJcbiAgICAgICAgICB1U2xpY2UsXHJcbiAgICAgICAgICBwcm9qZWN0aW9uM1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZlYzQgcHJvakludGVyMyA9ICh2UHJvamVjdGlvblZpZXdNYXRyaXggKiB2ZWM0KHByb2plY3Rpb24zLCAxLikpO1xyXG4gICAgICAgIHZlYzMgbmRjMyA9IHByb2pJbnRlcjMueHl6IC8gcHJvakludGVyMy53O1xyXG4gICAgICAgIHZlYzIgc2NyZWVuU3BhY2UzID0gKG5kYzMueHkgKiAuNSArIC41KSAqIHZlYzIodUNhbnZhc1dpZHRoLCB1Q2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgZmxvYXQgZDMgPSBkaXN0YW5jZShnbF9GcmFnQ29vcmQueHksIHNjcmVlblNwYWNlMy54eSk7XHJcbiAgICAgICAgYzMgPSB2ZWM0KHVQbGFuZUNvbG9yMywgMS4gLSBzbW9vdGhzdGVwKC41LCAuNywgZDMpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmVjMyBjb2xvck1peCA9IGMxLnh5eipjMS53ICsgYzIueHl6KmMyLncgKyBjMy54eXoqYzMudztcclxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvck1peCwgbWF4KG1heChjMS53LCBjMi53KSxjMy53KSk7XHJcbn1cclxuICAgYDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFxyXG4gICAqL1xyXG4gIGNvbXB1dGUoKSB7XHJcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxyXG5cclxuICAgIHJldHVybiBgXHJcbi8vIHVuaWZvcm1zXHJcbiR7dGhpcy51bmlmb3JtcygpfVxyXG5cclxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxyXG52YXJ5aW5nIHZlYzQgdlBvcztcclxudmFyeWluZyBtYXQ0IHZQcm9qZWN0aW9uVmlld01hdHJpeDtcclxuXHJcbi8vIHRhaWxvcmVkIGZ1bmN0aW9uc1xyXG4ke3RoaXMuZnVuY3Rpb25zKCl9XHJcblxyXG4vLyBtYWluIGxvb3BcclxuJHt0aGlzLl9tYWlufVxyXG4gICAgICBgO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBzaGFkZXJzL2xvY2FsaXplci91bmlmb3Jtc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcclxuICAvKipcclxuICAgKiBTaGFkZXJzIGRhdGEgdW5pZm9ybXNcclxuICAgKi9cclxuICBzdGF0aWMgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAndUNhbnZhc1dpZHRoJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1Q2FudmFzSGVpZ2h0Jzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC4sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1U2xpY2UnOiB7XHJcbiAgICAgICAgdHlwZTogJ3Y0JyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZTEnOiB7XHJcbiAgICAgICAgdHlwZTogJ3Y0JyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZUNvbG9yMSc6IHtcclxuICAgICAgICB0eXBlOiAndjMnLFxyXG4gICAgICAgIHZhbHVlOiBbMS4wLCAxLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZTInOiB7XHJcbiAgICAgICAgdHlwZTogJ3Y0JyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZUNvbG9yMic6IHtcclxuICAgICAgICB0eXBlOiAndjMnLFxyXG4gICAgICAgIHZhbHVlOiBbMS4wLCAxLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZTMnOiB7XHJcbiAgICAgICAgdHlwZTogJ3Y0JyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWM0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VQbGFuZUNvbG9yMyc6IHtcclxuICAgICAgICB0eXBlOiAndjMnLFxyXG4gICAgICAgIHZhbHVlOiBbMS4wLCAxLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICd2ZWMzJyxcclxuICAgICAgfSxcclxuXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgY29tcHV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gYFxyXG52YXJ5aW5nIHZlYzQgdlBvcztcclxudmFyeWluZyBtYXQ0IHZQcm9qZWN0aW9uVmlld01hdHJpeDtcclxuXHJcbi8vXHJcbi8vIG1haW5cclxuLy9cclxudm9pZCBtYWluKCkge1xyXG5cclxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcclxuICB2UHJvamVjdGlvblZpZXdNYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeDtcclxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcclxuXHJcbn1cclxuICAgICAgICBgO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgc2hhZGVyc0ludGVycG9sYXRpb24gZnJvbSAnLi9pbnRlcnBvbGF0aW9uL3NoYWRlcnMuaW50ZXJwb2xhdGlvbic7XHJcbmltcG9ydCBzaGFkZXJzSW50ZXJzZWN0Qm94IGZyb20gJy4vaGVscGVycy9zaGFkZXJzLmhlbHBlcnMuaW50ZXJzZWN0Qm94JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNGcmFnbWVudCB7XHJcblxyXG4gIC8vIHBhc3MgdW5pZm9ybXMgb2JqZWN0XHJcbiAgY29uc3RydWN0b3IodW5pZm9ybXMpIHtcclxuICAgIHRoaXMuX3VuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgICB0aGlzLl9mdW5jdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuX21haW4gPSAnJztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9ucygpIHtcclxuICAgIGlmKHRoaXMuX21haW4gPT09ICcnKSB7XHJcbiAgICAgIC8vIGlmIG1haW4gaXMgZW1wdHksIGZ1bmN0aW9ucyBjYW4gbm90IGhhdmUgYmVlbiBjb21wdXRlZFxyXG4gICAgICB0aGlzLm1haW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fZnVuY3Rpb25zKSB7XHJcbiAgICAgIGNvbnRlbnQgKz0gdGhpcy5fZnVuY3Rpb25zW3Byb3BlcnR5XSArICdcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgdW5pZm9ybXMoKSB7XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5fdW5pZm9ybXMpIHtcclxuICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1twcm9wZXJ0eV07XHJcbiAgICAgIGNvbnRlbnQgKz0gYHVuaWZvcm0gJHt1bmlmb3JtLnR5cGVHTFNMfSAke3Byb3BlcnR5fWA7XHJcblxyXG4gICAgICBpZih1bmlmb3JtICYmIHVuaWZvcm0ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGVudCArPSBgWyR7dW5pZm9ybS5sZW5ndGh9XWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnRlbnQgKz0gJztcXG4nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgbWFpbigpIHtcclxuICAgIC8vIG5lZWQgdG8gcHJlLWNhbGwgbWFpbiB0byBmaWxsIHVwIHRoZSBmdW5jdGlvbnMgbGlzdFxyXG4gICAgdGhpcy5fbWFpbiA9IGBcclxudm9pZCBnZXRJbnRlbnNpdHkoaW4gdmVjMyBkYXRhQ29vcmRpbmF0ZXMsIG91dCBmbG9hdCBpbnRlbnNpdHksIG91dCB2ZWMzIGdyYWRpZW50KXtcclxuXHJcbiAgdmVjNCBkYXRhVmFsdWUgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcclxuICAke3NoYWRlcnNJbnRlcnBvbGF0aW9uKHRoaXMsICdkYXRhQ29vcmRpbmF0ZXMnLCAnZGF0YVZhbHVlJywgJ2dyYWRpZW50Jyl9XHJcblxyXG4gIGludGVuc2l0eSA9IGRhdGFWYWx1ZS5yO1xyXG5cclxuICAvLyByZXNjYWxlL3Nsb3BlXHJcbiAgaW50ZW5zaXR5ID0gaW50ZW5zaXR5KnVSZXNjYWxlU2xvcGVJbnRlcmNlcHRbMF0gKyB1UmVzY2FsZVNsb3BlSW50ZXJjZXB0WzFdO1xyXG4gIC8vIHdpbmRvdyBsZXZlbFxyXG4gIGZsb2F0IHdpbmRvd01pbiA9IHVXaW5kb3dDZW50ZXJXaWR0aFswXSAtIHVXaW5kb3dDZW50ZXJXaWR0aFsxXSAqIDAuNTtcclxuICBpbnRlbnNpdHkgPSAoIGludGVuc2l0eSAtIHdpbmRvd01pbiApIC8gdVdpbmRvd0NlbnRlcldpZHRoWzFdO1xyXG59XHJcblxyXG52b2lkIG1haW4odm9pZCkge1xyXG4gIGNvbnN0IGludCBtYXhTdGVwcyA9IDEwMjQ7XHJcblxyXG4gIC8vIHRoZSByYXlcclxuICB2ZWMzIHJheU9yaWdpbiA9IGNhbWVyYVBvc2l0aW9uO1xyXG4gIHZlYzMgcmF5RGlyZWN0aW9uID0gbm9ybWFsaXplKHZQb3MueHl6IC0gcmF5T3JpZ2luKTtcclxuXHJcbiAgLy8gdGhlIEF4ZS1BbGlnbmVkIEItQm94XHJcbiAgdmVjMyBBQUJCTWluID0gdmVjMyh1V29ybGRCQm94WzBdLCB1V29ybGRCQm94WzJdLCB1V29ybGRCQm94WzRdKTtcclxuICB2ZWMzIEFBQkJNYXggPSB2ZWMzKHVXb3JsZEJCb3hbMV0sIHVXb3JsZEJCb3hbM10sIHVXb3JsZEJCb3hbNV0pO1xyXG5cclxuICAvLyBJbnRlcnNlY3Rpb24gcmF5L2Jib3hcclxuICBmbG9hdCB0TmVhciwgdEZhcjtcclxuICBib29sIGludGVyc2VjdCA9IGZhbHNlO1xyXG4gICR7c2hhZGVyc0ludGVyc2VjdEJveC5hcGkodGhpcywgJ3JheU9yaWdpbicsICdyYXlEaXJlY3Rpb24nLCAnQUFCQk1pbicsICdBQUJCTWF4JywgJ3ROZWFyJywgJ3RGYXInLCAnaW50ZXJzZWN0Jyl9XHJcbiAgaWYgKHROZWFyIDwgMC4wKSB0TmVhciA9IDAuMDtcclxuXHJcbiAgLy8gaW5pdCB0aGUgcmF5IG1hcmNoaW5nXHJcbiAgZmxvYXQgdEN1cnJlbnQgPSB0TmVhcjtcclxuICBmbG9hdCB0U3RlcCA9ICh0RmFyIC0gdE5lYXIpIC8gZmxvYXQodVN0ZXBzKTtcclxuICB2ZWM0IGFjY3VtdWxhdGVkQ29sb3IgPSB2ZWM0KDAuMCk7XHJcbiAgZmxvYXQgYWNjdW11bGF0ZWRBbHBoYSA9IDAuMDtcclxuXHJcbiAgZm9yKGludCByYXlTdGVwID0gMDsgcmF5U3RlcCA8IG1heFN0ZXBzOyByYXlTdGVwKyspe1xyXG4gICAgdmVjMyBjdXJyZW50UG9zaXRpb24gPSByYXlPcmlnaW4gKyByYXlEaXJlY3Rpb24gKiB0Q3VycmVudDtcclxuICAgIC8vIHNvbWUgbm9uLWxpbmVhciBGVU5cclxuICAgIC8vIHNvbWUgb2NjbHVzaW9uIGlzc3VlIHRvIGJlIGZpeGVkXHJcbiAgICB2ZWMzIHRyYW5zZm9ybWVkUG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb247IC8vdHJhbnNmb3JtUG9pbnQoY3VycmVudFBvc2l0aW9uLCB1QW1wbGl0dWRlLCB1RnJlcXVlbmNlKTtcclxuICAgIC8vIHdvcmxkIHRvIGRhdGEgY29vcmRpbmF0ZXNcclxuICAgIC8vIHJvdW5kaW5nIHRyaWNrXHJcbiAgICAvLyBmaXJzdCBjZW50ZXIgb2YgZmlyc3Qgdm94ZWwgaW4gZGF0YSBzcGFjZSBpcyBDRU5URVJFRCBvbiAoMCwwLDApXHJcbiAgICB2ZWM0IGRhdGFDb29yZGluYXRlc1JhdyA9IHVXb3JsZFRvRGF0YSAqIHZlYzQodHJhbnNmb3JtZWRQb3NpdGlvbiwgMS4wKTtcclxuICAgIHZlYzMgY3VycmVudFZveGVsID0gdmVjMyhkYXRhQ29vcmRpbmF0ZXNSYXcueCwgZGF0YUNvb3JkaW5hdGVzUmF3LnksIGRhdGFDb29yZGluYXRlc1Jhdy56KTtcclxuICAgIGZsb2F0IGludGVuc2l0eSA9IDAuMDtcclxuICAgIHZlYzMgZ3JhZGllbnQgPSB2ZWMzKDAuLCAwLiwgMC4pO1xyXG4gICAgZ2V0SW50ZW5zaXR5KGN1cnJlbnRWb3hlbCwgaW50ZW5zaXR5LCBncmFkaWVudCk7XHJcblxyXG4gICAgdmVjNCBjb2xvclNhbXBsZTtcclxuICAgIGZsb2F0IGFscGhhU2FtcGxlO1xyXG4gICAgaWYodUx1dCA9PSAxKXtcclxuICAgICAgdmVjNCBjb2xvckZyb21MVVQgPSB0ZXh0dXJlMkQoIHVUZXh0dXJlTFVULCB2ZWMyKCBpbnRlbnNpdHksIDEuMCkgKTtcclxuICAgICAgLy8gMjU2IGNvbG9yc1xyXG4gICAgICBjb2xvclNhbXBsZSA9IGNvbG9yRnJvbUxVVDtcclxuICAgICAgYWxwaGFTYW1wbGUgPSBjb2xvckZyb21MVVQuYTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgIGFscGhhU2FtcGxlID0gaW50ZW5zaXR5O1xyXG4gICAgICBjb2xvclNhbXBsZS5yID0gY29sb3JTYW1wbGUuZyA9IGNvbG9yU2FtcGxlLmIgPSBpbnRlbnNpdHkgKiBhbHBoYVNhbXBsZTtcclxuICAgIH1cclxuXHJcbiAgICBhbHBoYVNhbXBsZSA9IGFscGhhU2FtcGxlICogdUFscGhhQ29ycmVjdGlvbjtcclxuICAgIGFscGhhU2FtcGxlICo9ICgxLjAgLSBhY2N1bXVsYXRlZEFscGhhKTtcclxuXHJcbiAgICBhY2N1bXVsYXRlZENvbG9yICs9IGFscGhhU2FtcGxlICogY29sb3JTYW1wbGU7XHJcbiAgICBhY2N1bXVsYXRlZEFscGhhICs9IGFscGhhU2FtcGxlO1xyXG5cclxuICAgIHRDdXJyZW50ICs9IHRTdGVwO1xyXG5cclxuICAgIGlmKHRDdXJyZW50ID4gdEZhciB8fCBhY2N1bXVsYXRlZEFscGhhID49IDEuMCApIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhY2N1bXVsYXRlZENvbG9yLnh5eiwgYWNjdW11bGF0ZWRBbHBoYSk7XHJcbn1cclxuICAgYDtcclxuICB9XHJcblxyXG4gIGNvbXB1dGUoKSB7XHJcbiAgICBsZXQgc2hhZGVySW50ZXJwb2xhdGlvbiA9ICcnO1xyXG4gICAgLy8gc2hhZGVySW50ZXJwb2xhdGlvbi5pbmxpbmUoYXJncykgLy90cnVlL2ZhbHNlXHJcbiAgICAvLyBzaGFkZXJJbnRlcnBvbGF0aW9uLmZ1bmN0aW9ucyhhcmdzKVxyXG5cclxuICAgIHJldHVybiBgXHJcbi8vIHVuaWZvcm1zXHJcbiR7dGhpcy51bmlmb3JtcygpfVxyXG5cclxuLy8gdmFyeWluZyAoc2hvdWxkIGZldGNoIGl0IGZyb20gdmVydGV4IGRpcmVjdGx5KVxyXG52YXJ5aW5nIHZlYzQgICAgICB2UG9zO1xyXG5cclxuLy8gdGFpbG9yZWQgZnVuY3Rpb25zXHJcbiR7dGhpcy5mdW5jdGlvbnMoKX1cclxuXHJcbi8vIG1haW4gbG9vcFxyXG4ke3RoaXMuX21haW59XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG4vKipcclxuICogQG1vZHVsZSBzaGFkZXJzL2RhdGFcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlcnNVbmlmb3JtIHtcclxuICBzdGF0aWMgdW5pZm9ybXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAndVRleHR1cmVTaXplJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1VGV4dHVyZUNvbnRhaW5lcic6IHtcclxuICAgICAgICB0eXBlOiAndHYnLFxyXG4gICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB0eXBlR0xTTDogJ3NhbXBsZXIyRCcsXHJcbiAgICAgICAgbGVuZ3RoOiA3LFxyXG4gICAgICB9LFxyXG4gICAgICAndURhdGFEaW1lbnNpb25zJzoge1xyXG4gICAgICAgIHR5cGU6ICdpdicsXHJcbiAgICAgICAgdmFsdWU6IFswLCAwLCAwXSxcclxuICAgICAgICB0eXBlR0xTTDogJ2l2ZWMzJyxcclxuICAgICAgfSxcclxuICAgICAgJ3VXb3JsZFRvRGF0YSc6IHtcclxuICAgICAgICB0eXBlOiAnbTQnLFxyXG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnbWF0NCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1V2luZG93Q2VudGVyV2lkdGgnOiB7XHJcbiAgICAgICAgdHlwZTogJ2Z2MScsXHJcbiAgICAgICAgdmFsdWU6IFswLjAsIDAuMF0sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgICAgbGVuZ3RoOiAyLFxyXG4gICAgICB9LFxyXG4gICAgICAndVJlc2NhbGVTbG9wZUludGVyY2VwdCc6IHtcclxuICAgICAgICB0eXBlOiAnZnYxJyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wXSxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgICBsZW5ndGg6IDIsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1TnVtYmVyT2ZDaGFubmVscyc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUJpdHNBbGxvY2F0ZWQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiA4LFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VJbnZlcnQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VMdXQnOiB7XHJcbiAgICAgICAgdHlwZTogJ2knLFxyXG4gICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnaW50JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VUZXh0dXJlTFVUJzoge1xyXG4gICAgICAgIHR5cGU6ICd0JyxcclxuICAgICAgICB2YWx1ZTogW10sXHJcbiAgICAgICAgdHlwZUdMU0w6ICdzYW1wbGVyMkQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBpeGVsVHlwZSc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVBhY2tlZFBlclBpeGVsJzoge1xyXG4gICAgICAgIHR5cGU6ICdpJyxcclxuICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1SW50ZXJwb2xhdGlvbic6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdpbnQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndVdvcmxkQkJveCc6IHtcclxuICAgICAgICB0eXBlOiAnZnYxJyxcclxuICAgICAgICB2YWx1ZTogWzAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjBdLFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICAgIGxlbmd0aDogNixcclxuICAgICAgfSxcclxuICAgICAgJ3VTdGVwcyc6IHtcclxuICAgICAgICB0eXBlOiAnaScsXHJcbiAgICAgICAgdmFsdWU6IDI1NixcclxuICAgICAgICB0eXBlR0xTTDogJ2ludCcsXHJcbiAgICAgIH0sXHJcbiAgICAgICd1QWxwaGFDb3JyZWN0aW9uJzoge1xyXG4gICAgICAgIHR5cGU6ICdmJyxcclxuICAgICAgICB2YWx1ZTogMC41LFxyXG4gICAgICAgIHR5cGVHTFNMOiAnZmxvYXQnLFxyXG4gICAgICB9LFxyXG4gICAgICAndUZyZXF1ZW5jZSc6IHtcclxuICAgICAgICB0eXBlOiAnZicsXHJcbiAgICAgICAgdmFsdWU6IDAuMCxcclxuICAgICAgICB0eXBlR0xTTDogJ2Zsb2F0JyxcclxuICAgICAgfSxcclxuICAgICAgJ3VBbXBsaXR1ZGUnOiB7XHJcbiAgICAgICAgdHlwZTogJ2YnLFxyXG4gICAgICAgIHZhbHVlOiAwLjAsXHJcbiAgICAgICAgdHlwZUdMU0w6ICdmbG9hdCcsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJzVmVydGV4IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gYFxyXG52YXJ5aW5nIHZlYzQgdlBvcztcclxuXHJcbi8vXHJcbi8vIG1haW5cclxuLy9cclxudm9pZCBtYWluKCkge1xyXG5cclxuICB2UG9zID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcclxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjAgKTtcclxuXHJcbn1cclxuICAgICAgICBgO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xyXG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0Fubm90YXRpb24gZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIGlmKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcblxyXG4gICAgLy8gZG9tIHN0dWZmXHJcbiAgICB0aGlzLl9saW5lID0gbnVsbDtcclxuICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcclxuICAgIHRoaXMuX2NvbmUgPSBudWxsO1xyXG4gICAgdGhpcy5fbGFiZWx0ZXh0ID0gbnVsbDtcclxuXHJcbiAgICAvL2Jvb2xlYW5zXHJcbiAgICB0aGlzLl9hbHJlYWR5Y3JlYXRlZCA9IG51bGw7IC8vYm9vbCB0aGF0IHR1cm5zIHRydWUgd2hlbiB0aGUgdXNlciBlbnRlciB0aGUgbmFtZSBvZiB0aGUgbGFiZWxcclxuICAgIHRoaXMuX21vdmluZ2xhYmVsID0gbnVsbDsgLy9ib29sIHRoYXQgdHVybnMgdHJ1ZSB3aGVuIHRoZSBsYWJlbCBpcyBtb3Zpbmcgd2l0aCB0aGUgbW91c2VcclxuICAgIHRoaXMuX2xhYmVsbW92ZWQgPSBmYWxzZTsgLy9ib29sIHRoYXQgdHVybnMgdHJ1ZSBvbmNlIHRoZSBsYWJlbCBpcyBtb3ZlZCBieSB0aGUgdXNlciAoYXQgbGVhc3Qgb25jZSlcclxuXHJcbiAgICB0aGlzLl9sYWJlbGhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2hvdmVyZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vdmFyXHJcbiAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IG51bGw7IC8vcG9zaXRpb24gb2YgbGFiZWwgKHRvcCBsZWZ0IGNvcm5lcilcclxuICAgIHRoaXMuX2xhYmVscG9zaXRpb255ID0gbnVsbDsgLy9wb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxyXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx4ID0gMDsgLy9kaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgcG9zaXRpb24gaW4gdGhlIGxhYmVsIGFuZCBwb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxyXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5ID0gMDsgLy9kaWZmZXJlbmNlIGJldHdlZW4gbW91c2UgcG9zaXRpb24gaW4gdGhlIGxhYmVsIGFuZCBwb3NpdGlvbiBvZiBsYWJlbCAodG9wIGxlZnQgY29ybmVyKVxyXG5cclxuICAgIC8vIGFkZCBoYW5kbGVzXHJcbiAgICB0aGlzLl9oYW5kbGVzID0gW107XHJcblxyXG4gICAgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy8gZmlyc3QgaGFuZGxlXHJcbiAgICBsZXQgZmlyc3RIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICBmaXJzdEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkKGZpcnN0SGFuZGxlKTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgIGxldCBzZWNvbmRIYW5kbGUgPSBuZXcgV2lkZ2V0c0hhbmRsZSh0aGlzLl90YXJnZXRNZXNoLCB0aGlzLl9jb250cm9scywgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgc2Vjb25kSGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgc2Vjb25kSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgLy8gYWN0aXZlIGFuZCB0cmFja2luZyBtaWdodCBiZSByZWR1bmRhbnRcclxuICAgIHNlY29uZEhhbmRsZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgc2Vjb25kSGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuYWRkKHNlY29uZEhhbmRsZSk7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKHNlY29uZEhhbmRsZSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGFubm90YXRpb25cclxuXHJcbiAgICB0aGlzLmNyZWF0ZSgpO1xyXG5cclxuICAgIHRoaXMub25Nb3ZlID0gdGhpcy5vbk1vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25Ib3ZlcmxhYmVsID0gdGhpcy5vbkhvdmVybGFiZWwuYmluZCh0aGlzKTtcclxuICAgIHRoaXMubm90b25Ib3ZlcmxhYmVsID0gdGhpcy5ub3RvbkhvdmVybGFiZWwuYmluZCh0aGlzKTsgIFxyXG4gICAgdGhpcy5jaGFuZ2VsYWJlbHRleHQgPSB0aGlzLmNoYW5nZWxhYmVsdGV4dC5iaW5kKHRoaXMpOyBcclxuICAgIHRoaXMubW92ZWxhYmVsID0gdGhpcy5tb3ZlbGFiZWwuYmluZCh0aGlzKTtcclxuICAgIHRoaXMubm90bW92ZWxhYmVsID0gdGhpcy5ub3Rtb3ZlbGFiZWwuYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcblxyXG4gIH1cclxuXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICB0aGlzLl9sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5vbkhvdmVybGFiZWwpO1xyXG4gICAgdGhpcy5fbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMubm90b25Ib3ZlcmxhYmVsKTtcclxuICAgIHRoaXMuX2xhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5jaGFuZ2VsYWJlbHRleHQpO1xyXG4gICAgdGhpcy5fbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3ZlbGFiZWwpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm5vdG1vdmVsYWJlbCk7XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgfVxyXG5cclxuICBtb3ZlbGFiZWwoKSB7IC8vZnVuY3Rpb24gY2FsbGVkIHdoZW4gbW91c2Vkb3duXHJcbiAgICBpZiAodGhpcy5fbGFiZWxob3ZlcmVkID0gdHJ1ZSl7IC8vaWYgbGFiZWwgaG9iZXJlZCB3ZSB3aWxsIG1vdmUgdGhlIGxhYmVsXHJcbiAgICAgICAgdGhpcy5fbW92aW5nbGFiZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBtb3VzZXkgPSAgLSAoLWV2ZW50LmNsaWVudFkgKyB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICBsZXQgbW91c2V4ID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICAvL2NhbGN1bGF0ZSBkaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbCAoZGlmZmVyZW5jZSBiZXR3ZWVuIHJlZiBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcikgYW5kIG1vdXNlIHBvc2l0aW9uIGluIHRoZSBsYWJlbClcclxuICAgICAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHggPSBNYXRoLmFicyhNYXRoLmFicyhtb3VzZXgpIC0gTWF0aC5hYnModGhpcy5fbGFiZWxwb3NpdGlvbngpKTtcclxuICAgICAgICB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHkgPSBNYXRoLmFicyhNYXRoLmFicyhtb3VzZXkpIC0gTWF0aC5hYnModGhpcy5fbGFiZWxwb3NpdGlvbnkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5vdG1vdmVsYWJlbCgpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1vdXNldXBcclxuICAgIHRoaXMuX21vdmluZ2xhYmVsID0gZmFsc2U7XHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLl9jb250cm9scy5lbmFibGVkID0gdHJ1ZTsgLy9tb3ZlIHRoZSBjYW1lcmEgd2hlbiBtb3VzZWRvd24gYW5kIG1vdXNlZG93biBhZ2FpblxyXG4gICAgdGhpcy5faGFuZGxlc1sxXS5fY29udHJvbHMuZW5hYmxlZCA9IHRydWU7IFxyXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx4ID0gMDsgLy9yZXN0YXJ0IHRoZSB2YWx1ZSBvZiBkaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbC4gTmVjZXNzYXJ5P1xyXG4gICAgdGhpcy5fZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWx5ID0gMDtcclxuICB9XHJcblxyXG4gIG9uSG92ZXJsYWJlbCgpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1vdXNlIGVudGVycyB0aGUgbGFiZWwgd2l0aCBcIm1vdXNlZW50ZXJcIiBldmVudFxyXG4gICAgdGhpcy5fbGFiZWxob3ZlcmVkID0gdHJ1ZTtcclxuICB9XHJcbiBcclxuICBub3RvbkhvdmVybGFiZWwoKSB7IC8vdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGxhYmVsIHdpdGggXCJtb3VzZWxlYXZlXCIgZXZlbnRcclxuICAgIHRoaXMuX2xhYmVsaG92ZXJlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgb25Nb3ZlKGV2dCkge1xyXG5cclxuICAgIGlmICh0aGlzLl9tb3ZpbmdsYWJlbCA9PSB0cnVlKXtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS5fY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlOyBcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uTW92ZShldnQpO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS5vbk1vdmUoZXZ0KTtcclxuXHJcbiAgICB0aGlzLl9ob3ZlcmVkID0gdGhpcy5faGFuZGxlc1swXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbMV0uaG92ZXJlZCB8fCB0aGlzLl9sYWJlbGhvdmVyZWQ7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgb25TdGFydChldnQpIHtcclxuXHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlc1swXS5vblN0YXJ0KGV2dCk7XHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLm9uU3RhcnQoZXZ0KTtcclxuXHJcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcblxyXG4gIHNldGxhYmVsdGV4dCgpIHtcclxuICAgIHRoaXMuX2xhYmVsdGV4dCA9IHByb21wdChcIlBsZWFzZSBlbnRlciB0aGUgbmFtZSBvZiB0aGUgbGFiZWxcIiwgXCJcIik7IC8vdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjcmVhdGVzIGEgbmV3IGFycm93XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX2xhYmVsdGV4dCA9PSAnc3RyaW5nJyl7IC8vYXZvaWQgZXJyb3JcclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5pbm5lckhUTUwgPSB0aGlzLl9sYWJlbHRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWwgb25jZSB3ZSBrbm93IHRoZSBjb250ZW50XHJcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWwgb25jZSB3ZSBrbm93IHRoZSBjb250ZW50XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9IHRoaXMuX2xhYmVsdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxyXG4gICAgICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvL2hpZGUgdGhlIGxhYmVsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2hhbmdlbGFiZWx0ZXh0KCkgeyAvL3RoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZG9lcyBkb3VibGUgY2xpY2sgaW4gdGhlIGxhYmVsXHJcbiAgICB0aGlzLl9sYWJlbHRleHQgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgbmV3IG5hbWUgb2YgdGhlIGxhYmVsXCIsIHRoaXMuX2xhYmVsLmlubmVySFRNTCk7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX2xhYmVsdGV4dCA9PSAnc3RyaW5nJyl7IC8vYXZvaWQgZXJyb3JcclxuICAgICAgICBpZiAodGhpcy5fbGFiZWx0ZXh0Lmxlbmd0aCA+IDApeyBcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuaW5uZXJIVE1MID0gdGhpcy5fbGFiZWx0ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vaW4gY3NzIGFuIGVtcHR5IHN0cmluZyBpcyB1c2VkIHRvIHJldmVydCBkaXNwbGF5PW5vbmUuIFNob3cgdGhlIGxhYmVsXHJcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy9pbiBjc3MgYW4gZW1wdHkgc3RyaW5nIGlzIHVzZWQgdG8gcmV2ZXJ0IGRpc3BsYXk9bm9uZS4gU2hvdyB0aGUgbGFiZWxcclxuICAgICAgICB9ZWxzZXsgLy8gaWYgdGhlIGxlbmd0aCBpcyAwIHRoZSB1c2VyIHByZXNzZWQgQ2FuY2VsXHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLmlubmVySFRNTCA9IHRoaXMuX2xhYmVsdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy9oaWRlIHRoZSBsYWJlbFxyXG4gICAgICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvL2hpZGUgdGhlIGxhYmVsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25FbmQoZXZ0KSB7XHJcbiAgICAvLyBGaXJzdCBIYW5kbGVcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ub25FbmQoZXZ0KTtcclxuXHJcbiAgICAvLyBTZWNvbmQgSGFuZGxlXHJcbiAgICBpZih0aGlzLl9kcmFnZ2VkIHx8ICF0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS5vbkVuZChldnQpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VsZi5fYWxyZWFkeWNyZWF0ZWQgIT0gdHJ1ZSl7XHJcbiAgICAgIHRoaXMuc2V0bGFiZWx0ZXh0KCk7XHJcbiAgICAgIHNlbGYuX2FscmVhZHljcmVhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0ZSBvZiBhbm5vdGF0aW9uIHdpZGdldFxyXG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmU7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICB9XHJcblxyXG5cclxuICBjcmVhdGUoKSB7XHJcbiAgICB0aGlzLmNyZWF0ZU1lc2goKTtcclxuICAgIHRoaXMuY3JlYXRlRE9NKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoKSB7XHJcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XHJcblxyXG4gICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XHJcblxyXG4gICAgLy8gRE9NIHN0dWZmXHJcbiAgICB0aGlzLnVwZGF0ZURPTVBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVNZXNoKCkge1xyXG4gICAgLy8gZ2VvbWV0cnlcclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbik7XHJcbiAgICB0aGlzLl9nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbik7XHJcblxyXG4gICAgLy8gbWF0ZXJpYWxcclxuICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG5cclxuICAgIC8vIG1lc2hcclxuICAgIHRoaXMuX21lc2hsaW5lID0gbmV3IFRIUkVFLkxpbmUodGhpcy5fZ2VvbWV0cnksIHRoaXMuX21hdGVyaWFsKTtcclxuICAgIHRoaXMuX21lc2hsaW5lLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIGFkZCBpdCFcclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2hsaW5lKTtcclxuXHJcbiAgICAvL2NyZWF0ZSBjb25lIGFuZCBhZGQgaXRcclxuICAgIHRoaXMuX2NvbmVnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAyLCAxMCApO1xyXG4gICAgdGhpcy5fY29uZWdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLTUsIDAgKTtcclxuICAgIHRoaXMuX2NvbmVnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XHJcbiAgICB0aGlzLl9jb25lID0gbmV3IFRIUkVFLk1lc2goIHRoaXMuX2NvbmVnZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwgKTtcclxuICAgIHRoaXMuX2NvbmUudmlzaWJsZSA9IHRydWU7XHJcbiAgICB0aGlzLmFkZCh0aGlzLl9jb25lKTtcclxuXHJcbiAgfVxyXG5cclxuICB1cGRhdGVNZXNoQ29sb3IoKSB7XHJcbiAgICBpZih0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICB0aGlzLl9tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlTWVzaFBvc2l0aW9uKCkge1xyXG4gICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcclxuICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNyZWF0ZURPTSgpIHtcclxuICAgIC8vIGFkZCBsaW5lIVxyXG4gICAgdGhpcy5fbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fbGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5oZWlnaHQgPSAnMnB4JzsvLzJcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JzsvLzNcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lKTtcclxuXHJcbiAgICAvLyBhZGQgZGFzaCBsaW5lXHJcbiAgICB0aGlzLl9kYXNobGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkYXNobGluZScpO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyVG9wID0gJzIuNXB4IGRhc2hlZCAjRjlGOUY5JztcclxuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XHJcbiAgICB0aGlzLl9kYXNobGluZS5zdHlsZS53aWR0aCA9ICc1MCUnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kYXNobGluZSk7XHJcblxyXG4gICAgLy8gYWRkIGxhYmVsIVxyXG4gICAgdGhpcy5fbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xyXG4gICAgdGhpcy5fbGFiZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsYWJlbCcpO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCAjRjlGOUY5JztcclxuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcclxuICAgIC8vIHRoaXMuX2xhYmVsLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcclxuICAgIHRoaXMuX2xhYmVsLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICB0aGlzLl9sYWJlbC5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2xhYmVsKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ2Z1bmN0aW9uIHVwZGF0ZURPTVBvc2l0aW9uJyk7XHJcbiAgICAvLyB1cGRhdGUgYW5ub3RhdGlvbiBsaW5lcyBhbmQgdGV4dCFcclxuICAgIGxldCB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgIGxldCB5MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueTtcclxuICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgIGxldCB5MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueTtcclxuXHJcbiAgICBsZXQgeDAgPSB4MSArICh4MiAtIHgxKS8yO1xyXG4gICAgbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcclxuXHJcbiAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XHJcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTsgLy9yZXN1bHQgaW4gZGVnXHJcblxyXG4gICAgbGV0IHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgLy8gdXBkYXRlIGxpbmVcclxuICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1l9cHgsIDApYDtcclxuICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xyXG5cclxuICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9IGxlbmd0aCArICdweCc7XHJcblxyXG5cclxuICAgIC8vIHVwZGF0ZSBsYWJlbCBwb3NpdGlvblxyXG4gICAgdmFyIG1vdXNleCA9IDA7XHJcbiAgICB2YXIgbW91c2V5ID0gMDtcclxuXHJcbiAgICBsZXQgcG9zWTA7XHJcblxyXG4gICAgcG9zWTAgPSB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9sYWJlbC5vZmZzZXRIZWlnaHQvMjtcclxuICAgIHgwIC09IHRoaXMuX2xhYmVsLm9mZnNldFdpZHRoLzI7XHJcblxyXG4gICAgdmFyIHg7XHJcbiAgICB2YXIgeTtcclxuXHJcbiAgICBpZiAodGhpcy5fbGFiZWxtb3ZlZCA9PSBmYWxzZSl7IC8vaWYgdGhlIHVzZXIgaGFzbnQgbW92ZWQgdGhlIGxhYmVsLCB0aGUgcG9zaXRpb24gaXMgZGVmaW5lZCBieSB0aGUgcG9zaXRpb24gb2YgdGhlIGFycm93XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTIgPSBgdHJhbnNsYXRlM0QoJHtNYXRoLnJvdW5kKHgwKX1weCwke01hdGgucm91bmQocG9zWTApfXB4LCAwKWA7XHJcbiAgICAgICAgdGhpcy5fbGFiZWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcclxuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IE1hdGgucm91bmQoeDApO1xyXG4gICAgICAgIHRoaXMuX2xhYmVscG9zaXRpb255ID0gTWF0aC5yb3VuZChwb3NZMCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmICh0aGlzLl9tb3ZpbmdsYWJlbCkgeyAvL2lmIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGUgbGFiZWwsIHRoZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBtb3VzZVxyXG4gICAgICAgIG1vdXNleCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgbW91c2V5ID0gIC0oLWV2ZW50LmNsaWVudFkgKyB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9sYWJlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM0QoJHttb3VzZXggLSB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHh9cHgsJHttb3VzZXkgLSB0aGlzLl9kaWZmZXJlbmNlbW91c2VjZW50ZXJsYWJlbHl9cHgsIDApYDsgXHJcbiAgICAgICAgLy93ZSB1c2UgZGlmZmVyZW5jZW1vdXNlY2VudGVybGFiZWwgdG8gY2hlY2sgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGluIHRoZSBsYWJlbCBhbmQgdGhlIHJlZmVyZW5jZSBwb3NpdGlvbiBvZiB0aGUgbGFiZWwgKHRvcC1sZWZ0IGNvcm5lcilcclxuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueCA9IG1vdXNleCAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseDtcclxuICAgICAgICB0aGlzLl9sYWJlbHBvc2l0aW9ueSA9IG1vdXNleSAtIHRoaXMuX2RpZmZlcmVuY2Vtb3VzZWNlbnRlcmxhYmVseTtcclxuICAgIH1cclxuXHJcbiAgICAvL3VwZGF0ZSBjb25lXHJcbiAgICBsZXQgdzAgPSB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb247XHJcbiAgICBsZXQgdzEgPSB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb247XHJcblxyXG4gICAgLy9wb3NpdGlvbiBhbmQgcm90YXRpb24gb2YgY29uZVxyXG4gICAgdGhpcy5fY29uZS5wb3NpdGlvbi5zZXQodzEueCx3MS55LHcxLnopO1xyXG4gICAgdGhpcy5fY29uZS5sb29rQXQodzApO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBkYXNoIGxpbmVcclxuXHJcbiAgICAvL2NhbGN1bGF0ZSB0aGUgcGxhY2UgaW4gdGhlIGxhYmVsOiBjZW50ZXIgb2YgdGhlIGxhYmVsXHJcbiAgICB4MSA9IHRoaXMuX2hhbmRsZXNbMF0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgIHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgeDIgPSB0aGlzLl9sYWJlbHBvc2l0aW9ueDtcclxuICAgIHkyID0gdGhpcy5fbGFiZWxwb3NpdGlvbnkgKyB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0OyAvL3JldmVydCB0aGUgb3BlcmF0aW9uIGluICdtb3VzZXknIHRvIGdldCB0aGUgcHJldmlvdXMgZXZlbnRZXHJcblxyXG4gICAgLy9nZXQgdGhlIHNpemUgb2YgdGhlIGxhYmVsIHNvIHdlIGNhbiBwbGFjZSB0aGUgZGFzaGVkIGxpbmUgaW4gdGhlIGNlbnRlciBvZiBpdFxyXG4gICAgdmFyIGxhYmVsaGVpZ2h0ID0gdGhpcy5fbGFiZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgdmFyIGxhYmVsd2lkdGggPSB0aGlzLl9sYWJlbC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICB2YXIgY2VudGVybGFiZWx4ID0gMDtcclxuICAgIHZhciBjZW50ZXJsYWJlbHkgPSAwO1xyXG5cclxuICAgIGlmIChpc0Zpbml0ZShsYWJlbHdpZHRoKSAmJiBpc0Zpbml0ZShsYWJlbGhlaWdodCkpeyAvL2lmIHRoZSBleHRyYWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc2Z1bGwsIHdlIGNhbGN1bGF0ZSB0aGUgY2VudGVyIG9mIHRoZSBsYWJlbCB3aXRoIHRvdGFsIHNpemVcclxuICAgICAgICBjZW50ZXJsYWJlbHggPSBsYWJlbHdpZHRoLzI7XHJcbiAgICAgICAgY2VudGVybGFiZWx5ID0gbGFiZWxoZWlnaHQvMjtcclxuICAgIH1cclxuXHJcbiAgICB4MiArPSBjZW50ZXJsYWJlbHg7XHJcbiAgICB5MiArPSBjZW50ZXJsYWJlbHk7XHJcblxyXG4gICAgLy9jYWxjdWxhdGUgdGhlIHBsYWNlIGluIHRoZSBhcnJvdzogY2xvc2VzdCBwYXJ0IG9mIHRoZSBsaW5lIHRvIHBsYWNlIHRoZSBkYXNoZWQgbGluZVxyXG4gICAgdmFyIHgxX3RhaWwgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7IC8vZmlyc3QgcG9zaXRpb246IHRhaWwgb2YgYXJyb3dcclxuICAgIHZhciB5MV90YWlsID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgdmFyIHgxX2JvZHkgPSAodGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54ICsgdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54KS8yOyAvL3NlY29uZCBwb3NpdGlvbjogY2VudGVyIG9mIGFycm93XHJcbiAgICB2YXIgeTFfYm9keSA9ICh0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLnkgKyB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnkpLzI7XHJcbiAgICB2YXIgeDFfbm9zZSA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDsgLy90aGlyZCBwb3NpdGlvbjogcGVhayBvZiBhcnJvd1xyXG4gICAgdmFyIHkxX25vc2UgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XHJcblxyXG4gICAgLy9jYWxjdWxhdGUgYWxsIHRoZSBsZW5ndGhzIHRvIHRoZSBsYWJlbCwgc28gd2UgY2FuIGNob29zZSB0aGUgbWluXHJcbiAgICB2YXIgbGVuZ3RodGFpbGxhYmVsID0gTWF0aC5zcXJ0KCh4MV90YWlsLXgyKSooeDFfdGFpbC14MikgKyAoeTFfdGFpbC15MikqKHkxX3RhaWwteTIpKTtcclxuICAgIHZhciBsZW5ndGhib2R5bGFiZWwgPSBNYXRoLnNxcnQoKHgxX2JvZHkteDIpKih4MV9ib2R5LXgyKSArICh5MV9ib2R5LXkyKSooeTFfYm9keS15MikpO1xyXG4gICAgdmFyIGxlbmd0aG5vc2VsYWJlbCA9IE1hdGguc3FydCgoeDFfbm9zZS14MikqKHgxX25vc2UteDIpICsgKHkxX25vc2UteTIpKih5MV9ub3NlLXkyKSk7XHJcblxyXG4gICAgdmFyIGxlbmd0aHMgPSBbbGVuZ3RodGFpbGxhYmVsLCBsZW5ndGhib2R5bGFiZWwsIGxlbmd0aG5vc2VsYWJlbF07XHJcbiAgICB2YXIgbWlubGVuZ3RoID0gTWF0aC5taW4obGVuZ3RodGFpbGxhYmVsLCBsZW5ndGhib2R5bGFiZWwsIGxlbmd0aG5vc2VsYWJlbCk7XHJcbiAgICB2YXIgbWlubGVuZ3RoaW5kZXggPSBsZW5ndGhzLmluZGV4T2YobWlubGVuZ3RoKTtcclxuXHJcbiAgICBpZiAobWlubGVuZ3RoaW5kZXggPT0gMCl7XHJcbiAgICAgICAgeDEgPSB4MV90YWlsO1xyXG4gICAgICAgIHkxID0geTFfdGFpbDtcclxuICAgIH1cclxuICAgIGlmIChtaW5sZW5ndGhpbmRleCA9PSAxKXtcclxuICAgICAgICB4MSA9IHgxX2JvZHk7XHJcbiAgICAgICAgeTEgPSB5MV9ib2R5O1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbmxlbmd0aGluZGV4ID09IDIpe1xyXG4gICAgICAgIHgxID0geDFfbm9zZTtcclxuICAgICAgICB5MSA9IHkxX25vc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25jZSB3ZSBmb3VuZCB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgbGFiZWwsIHdlIGNyZWF0ZSB0aGUgZGFzaGVkIGxpbmUgZnJvbSB0aGF0IHBvaW50XHJcbiAgICBsZXQgbGVuZ3RoZGFzaGxpbmUgPSBNYXRoLnNxcnQoKHgxLXgyKSooeDEteDIpICsgKHkxLXkyKSooeTEteTIpKTtcclxuICAgIGxldCBhbmdsZWRhc2hsaW5lID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEk7IC8vcmVzdWx0IGluIGRlZ1xyXG5cclxuICAgIGxldCBwb3NZZGFzaGxpbmUgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgLy8gdXBkYXRlIGRhc2hlZCBsaW5lXHJcbiAgICBsZXQgdHJhbnNmb3JtZGFzaGxpbmUgPSBgdHJhbnNsYXRlM0QoJHt4MX1weCwke3Bvc1lkYXNobGluZX1weCwgMClgO1xyXG4gICAgdHJhbnNmb3JtZGFzaGxpbmUgKz0gYCByb3RhdGUoJHthbmdsZWRhc2hsaW5lfWRlZylgO1xyXG5cclxuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybWRhc2hsaW5lO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUud2lkdGggPSBsZW5ndGhkYXNobGluZSArICdweCc7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Db2xvcigpIHtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmJvcmRlclRvcCA9ICcyLjVweCBkYXNoZWQgJyArIGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgfVxyXG5cclxuICBnZXQgd29ybGRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xyXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZURPTSgpIHtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB0aGlzLl9sYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgc2hvd0RPTSgpIHtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgdGhpcy5fbGFiZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gIH1cclxuXHJcbiAgaGlkZU1lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNob3dNZXNoKCkge1xyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICB0aGlzLnNob3dET00oKTtcclxuICAgIHRoaXMuc2hvd01lc2goKTtcclxuICB9XHJcblxyXG4gIGhpZGUoKSB7XHJcbiAgICB0aGlzLmhpZGVET00oKTtcclxuICAgIHRoaXMuaGlkZU1lc2goKTtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0Jhc2UgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xyXG4gICAgLy8gaW5pdCBUSFJFRSBPYmplY3QgM0RcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gaXMgd2lkZ2V0IGVuYWJsZWQ/XHJcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBTVEFURSwgRU5VTSBtaWdodCBiZSBiZXR0ZXJcclxuICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9ob3ZlcmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgIC8vIHRob3MuX3N0YXRlID0gJ1NFTEVDVEVEJztcclxuXHJcbiAgICB0aGlzLl9jb2xvcnMgPSB7XHJcbiAgICAgIGRlZmF1bHQ6ICcjMDBCMEZGJyxcclxuICAgICAgYWN0aXZlOiAnI0ZGRUIzQicsXHJcbiAgICAgIGhvdmVyOiAnI0Y1MDA1NycsXHJcbiAgICAgIHNlbGVjdDogJyM3NkZGMDMnLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX2NvbG9yID0gdGhpcy5fY29sb3JzLmRlZmF1bHQ7XHJcblxyXG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgLy8gY2FuIG5vdCBjYWxsIGl0IHZpc2libGUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBUSFJFRS5PYmplY3QzRFxyXG4gICAgdGhpcy5fZGlzcGxheWVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICBpbml0T2Zmc2V0cygpIHtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMuX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuICAgIGNvbnN0IGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XHJcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID1cclxuICAgICAgd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xyXG5cclxuICAgIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xyXG4gICAgY29uc3QgY2xpZW50TGVmdCA9IGRvY0VsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XHJcblxyXG4gICAgY29uc3QgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcclxuICAgIGNvbnN0IGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xyXG5cclxuICAgIHRoaXMuX29mZnNldHMgPSB7XHJcbiAgICAgIHRvcDogTWF0aC5yb3VuZCh0b3ApLFxyXG4gICAgICBsZWZ0OiBNYXRoLnJvdW5kKGxlZnQpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG9mZnNldENoYW5nZWQoKSB7XHJcbiAgICB0aGlzLmluaXRPZmZzZXRzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0TW91c2VPZmZzZXRzKGV2ZW50LCBjb250YWluZXIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IChldmVudC5jbGllbnRYIC0gdGhpcy5fb2Zmc2V0cy5sZWZ0KSAvIGNvbnRhaW5lci5vZmZzZXRXaWR0aCAqIDIgLSAxLFxyXG4gICAgICB5OiAtKChldmVudC5jbGllbnRZIC0gdGhpcy5fb2Zmc2V0cy50b3ApIC8gY29udGFpbmVyLm9mZnNldEhlaWdodClcclxuICAgICAgICAqIDIgKyAxLFxyXG4gICAgICBzY3JlZW5YOiBldmVudC5jbGllbnRYIC0gdGhpcy5fb2Zmc2V0cy5sZWZ0LFxyXG4gICAgICBzY3JlZW5ZOiBldmVudC5jbGllbnRZIC0gdGhpcy5fb2Zmc2V0cy50b3AsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgLy8gdG8gYmUgb3ZlcmxvYWRlZFxyXG4gICAgd2luZG93LmNvbnNvbGUubG9nKCd1cGRhdGUoKSBzaG91bGQgYmUgb3ZlcmxvYWRlZCEnKTtcclxuICB9XHJcblxyXG4gIGZyZWUoKSB7XHJcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQ29sb3IoKSB7XHJcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuX2NvbG9yID0gdGhpcy5fY29sb3JzLmFjdGl2ZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5faG92ZXJlZCkge1xyXG4gICAgICB0aGlzLl9jb2xvciA9IHRoaXMuX2NvbG9ycy5ob3ZlcjtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcclxuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuc2VsZWN0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLl9jb2xvcnMuZGVmYXVsdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBlbmFibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XHJcbiAgfVxyXG5cclxuICBzZXQgZW5hYmxlZChlbmFibGVkKSB7XHJcbiAgICB0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgfVxyXG5cclxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcclxuICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGhvdmVyZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faG92ZXJlZDtcclxuICB9XHJcblxyXG4gIHNldCBob3ZlcmVkKGhvdmVyZWQpIHtcclxuICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcmVkO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBkcmFnZ2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RyYWdnZWQ7XHJcbiAgfVxyXG5cclxuICBzZXQgZHJhZ2dlZChkcmFnZ2VkKSB7XHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gZHJhZ2dlZDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgZGlzcGxheWVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXllZDtcclxuICB9XHJcblxyXG4gIHNldCBkaXNwbGF5ZWQoZGlzcGxheWVkKSB7XHJcbiAgICB0aGlzLl9kaXNwbGF5ZWQgPSBkaXNwbGF5ZWQ7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGFjdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XHJcbiAgfVxyXG5cclxuICBzZXQgYWN0aXZlKGFjdGl2ZSkge1xyXG4gICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBjb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBjb2xvcihjb2xvcikge1xyXG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xyXG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0JpUnVsZXIgZXh0ZW5kcyBXaWRnZXRzQmFzZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XHJcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luaXRPcnRobyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICBpZih0aGlzLl90YXJnZXRNZXNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB0aGlzLl90YXJnZXRNZXNoLnBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIGRvbSBzdHVmZlxyXG4gICAgICAgIHRoaXMuX2xpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gYWRkIGhhbmRsZXNcclxuICAgICAgICB0aGlzLl9oYW5kbGVzID0gW107XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IGhhbmRsZVxyXG4gICAgICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgICAgICBsZXQgc2Vjb25kSGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICBzZWNvbmRIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgc2Vjb25kSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGFjdGl2ZSBhbmQgdHJhY2tpbmcgbWlnaHQgYmUgcmVkdW5kYW50XHJcbiAgICAgICAgc2Vjb25kSGFuZGxlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgc2Vjb25kSGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZChzZWNvbmRIYW5kbGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goc2Vjb25kSGFuZGxlKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcmQgaGFuZGxlXHJcbiAgICAgICAgbGV0IHRoaXJkSGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICB0aGlyZEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICB0aGlyZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlyZEhhbmRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaCh0aGlyZEhhbmRsZSk7XHJcblxyXG4gICAgICAgIC8vIGZvdXJ0aCBoYW5kbGVcclxuICAgICAgICBsZXQgZm91cnRoSGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICBmb3VydGhIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgZm91cnRoSGFuZGxlLmhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkKGZvdXJ0aEhhbmRsZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXMucHVzaChmb3VydGhIYW5kbGUpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcnVsZXJcclxuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG5cclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc2xpY2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdmUoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0ub25Nb3ZlKGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS5vbk1vdmUoZXZ0KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uTW92ZShldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ub25Nb3ZlKGV2dCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9oYW5kbGVzWzBdLmhvdmVyZWQgfHwgdGhpcy5faGFuZGxlc1sxXS5ob3ZlcmVkIHx8IHRoaXMuX2hhbmRsZXNbMl0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzNdLmhvdmVyZWQ7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25TdGFydChldnQpIHtcclxuICAgICAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0ub25TdGFydChldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0ub25TdGFydChldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMl0ub25TdGFydChldnQpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ub25TdGFydChldnQpO1xyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9oYW5kbGVzWzBdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzFdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzJdLmFjdGl2ZSB8fCB0aGlzLl9oYW5kbGVzWzNdLmFjdGl2ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRW5kKGV2dCkge1xyXG4gICAgICAgIC8vIEZpcnN0IEhhbmRsZVxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0ub25FbmQoZXZ0KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLm9uRW5kKGV2dCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS5vbkVuZChldnQpO1xyXG5cclxuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2codGhpcyk7XHJcblxyXG4gICAgICAgIC8vIFNlY29uZCBIYW5kbGVcclxuICAgICAgICBpZih0aGlzLl9kcmFnZ2VkIHx8ICF0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1sxXS5vbkVuZChldnQpO1xyXG4gICAgICAgIH0gZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhdGUgb2YgcnVsZXIgd2lkZ2V0XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1syXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1szXS5hY3RpdmU7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVNZXNoKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlRE9NKCkge1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uaGlkZURPTSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIH1cclxuXHJcbiAgICBzaG93RE9NKCkge1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZU1lc2goKXtcclxuICAgICAgICB0aGlzLl9tZXNoLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9tZXNoMi52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1swXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1szXS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd01lc2goKSB7XHJcbiAgICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9tZXNoMi52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzBdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMV0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLnZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RE9NKCk7XHJcbiAgICAgICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlRE9NKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XHJcblxyXG4gICAgICAgIC8vIG1lc2ggc3R1ZmZcclxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIC8vIERPTSBzdHVmZlxyXG4gICAgICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlTWVzaCgpIHtcclxuICAgICAgICAvLyBnZW9tZXRyeVxyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gZ2VvbWV0cnlcclxuICAgICAgICB0aGlzLl9nZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICB0aGlzLl9nZW9tZXRyeTIudmVydGljZXMucHVzaCh0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5Mi52ZXJ0aWNlcy5wdXNoKHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIC8vIG1hdGVyaWFsXHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbDIgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG5cclxuICAgICAgICAvLyBtZXNoXHJcbiAgICAgICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XHJcbiAgICAgICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9tZXNoMiA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5MiwgdGhpcy5fbWF0ZXJpYWwyKTtcclxuICAgICAgICB0aGlzLl9tZXNoMi52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGl0IVxyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX21lc2gyKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNZXNoQ29sb3IoKSB7XHJcbiAgICAgICAgaWYodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5fbWF0ZXJpYWwyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsMi5jb2xvci5zZXQodGhpcy5fY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5fZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5fZ2VvbWV0cnkyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5Mi52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVET00oKSB7XHJcbiAgICAgICAgLy8gYWRkIGxpbmUhXHJcbiAgICAgICAgdGhpcy5fbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLmhlaWdodCA9ICcycHgnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBkaXN0YW5jZSFcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgZGlzdGFuY2UnKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkJztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XHJcbiAgICAgICAgLy8gdGhpcy5fZGlzdGFuY2Uuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmNvbG9yID0gJyMzNTM1MzUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UuaW5uZXJIVE1MID0gJ0hlbGxvLCB3b3JsZCEnO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kaXN0YW5jZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBsaW5lIVxyXG4gICAgICAgIHRoaXMuX2xpbmUyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBsaW5lJyk7XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUyLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS5oZWlnaHQgPSAnMnB4JztcclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS53aWR0aCA9ICczcHgnO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lMik7XHJcblxyXG4gICAgICAgIC8vIGFkZCBkaXN0YW5jZSFcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd3aWRnZXRzIGhhbmRsZSBkaXN0YW5jZScpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRjlGOUY5JztcclxuICAgICAgICAvLyB0aGlzLl9kaXN0YW5jZTIuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5jb2xvciA9ICcjMzUzNTM1JztcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlMi5pbm5lckhUTUwgPSAnSGVsbG8sIHdvcmxkISc7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2Rpc3RhbmNlMik7XHJcblxyXG4gICAgICAgIC8vIGFkZCBkYXNoIGxpbmVcclxuICAgICAgICB0aGlzLl9kYXNobGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgZGFzaGxpbmUnKTtcclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuX2Rhc2hsaW5lLnN0eWxlLmJvcmRlclRvcCA9ICcyLjVweCBkYXNoZWQgI0Y5RjlGOSc7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUud2lkdGggPSAnNTAlJztcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGFzaGxpbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XHJcbiAgICAgICAgLy8gdXBkYXRlIHJ1bGVycyBsaW5lcyBhbmQgdGV4dCFcclxuICAgICAgICBsZXQgeDEgPSB0aGlzLl9oYW5kbGVzWzBdLnNjcmVlblBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgICAgIGxldCB4MiA9IHRoaXMuX2hhbmRsZXNbMV0uc2NyZWVuUG9zaXRpb24ueDtcclxuICAgICAgICBsZXQgeTIgPSB0aGlzLl9oYW5kbGVzWzFdLnNjcmVlblBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcclxuICAgICAgICAvL2xldCB5MCA9IHkxICsgKHkyIC0geTEpLzI7XHJcbiAgICAgICAgbGV0IHgwID0geDI7XHJcbiAgICAgICAgbGV0IHkwID0geTI7XHJcblxyXG4gICAgICAgIGlmICh5MSA+PSB5Mikge1xyXG4gICAgICAgICAgICB5MCA9IHkyIC0gMzA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeTAgPSB5MiArIDMwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IE1hdGguc3FydCgoeDEteDIpKih4MS14MikgKyAoeTEteTIpKih5MS15MikpO1xyXG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxpbmVcclxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNEKCR7eDF9cHgsJHtwb3NZfXB4LCAwKWA7XHJcbiAgICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XHJcblxyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBkaXN0YW5jZVxyXG4gICAgICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcclxuICAgICAgICBsZXQgdzEgPSB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb247XHJcblxyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9IGAke01hdGguc3FydCgodzAueC13MS54KSoodzAueC13MS54KSArICh3MC55LXcxLnkpKih3MC55LXcxLnkpICsgKHcwLnotdzEueikqKHcwLnotdzEueikpLnRvRml4ZWQoMil9IG1tYDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZVZhbHVlID0gTWF0aC5zcXJ0KCh3MC54LXcxLngpKih3MC54LXcxLngpICsgKHcwLnktdzEueSkqKHcwLnktdzEueSkgKyAodzAuei13MS56KSoodzAuei13MS56KSkudG9GaXhlZCgyKTtcclxuICAgICAgICBsZXQgcG9zWTAgPSB5MCAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRIZWlnaHQvMjtcclxuICAgICAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xyXG5cclxuICAgICAgICBsZXQgdHJhbnNmb3JtMiA9IGB0cmFuc2xhdGUzRCgke01hdGgucm91bmQoeDApfXB4LCR7TWF0aC5yb3VuZChwb3NZMCl9cHgsIDApYDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgcnVsZXJzIGxpbmVzIDIgYW5kIHRleHQhXHJcbiAgICAgICAgbGV0IHgzID0gdGhpcy5faGFuZGxlc1syXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgICAgIGxldCB5MyA9IHRoaXMuX2hhbmRsZXNbMl0uc2NyZWVuUG9zaXRpb24ueTtcclxuICAgICAgICBsZXQgeDQgPSB0aGlzLl9oYW5kbGVzWzNdLnNjcmVlblBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IHk0ID0gdGhpcy5faGFuZGxlc1szXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG5cclxuICAgICAgICAvL2xldCB4MCA9IHgxICsgKHgyIC0geDEpLzI7XHJcbiAgICAgICAgLy9sZXQgeTAgPSB5MSArICh5MiAtIHkxKS8yO1xyXG4gICAgICAgIGxldCB4MDIgPSB4NDtcclxuICAgICAgICBsZXQgeTAyID0geTQ7XHJcblxyXG4gICAgICAgIGlmICh5MyA+PSB5NCkge1xyXG4gICAgICAgICAgICB5MDIgPSB5NCAtIDMwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkwMiA9IHk0ICsgMzA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZW5ndGggPSBNYXRoLnNxcnQoKHgzLXg0KSooeDMteDQpICsgKHkzLXk0KSooeTMteTQpKTtcclxuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoeTQgLSB5MywgeDQgLSB4MykgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICBwb3NZID0geTMgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbGluZVxyXG4gICAgICAgIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gzfXB4LCR7cG9zWX1weCwgMClgO1xyXG4gICAgICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xyXG5cclxuICAgICAgICB0aGlzLl9saW5lMi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUud2lkdGggPSBsZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBkaXN0YW5jZVxyXG4gICAgICAgIGxldCB3MDIgPSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb247XHJcbiAgICAgICAgbGV0IHcxMiA9IHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLmlubmVySFRNTCA9IGAke01hdGguc3FydCgodzAyLngtdzEyLngpKih3MDIueC13MTIueCkgKyAodzAyLnktdzEyLnkpKih3MDIueS13MTIueSkgKyAodzAyLnotdzEyLnopKih3MDIuei13MTIueikpLnRvRml4ZWQoMil9IG1tYDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTJWYWx1ZSA9IE1hdGguc3FydCgodzAyLngtdzEyLngpKih3MDIueC13MTIueCkgKyAodzAyLnktdzEyLnkpKih3MDIueS13MTIueSkgKyAodzAyLnotdzEyLnopKih3MDIuei13MTIueikpLnRvRml4ZWQoMik7XHJcbiAgICAgICAgbGV0IHBvc1kwMiA9IHkwMiAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLl9kaXN0YW5jZTIub2Zmc2V0SGVpZ2h0LzI7XHJcbiAgICAgICAgeDAyIC09IHRoaXMuX2Rpc3RhbmNlMi5vZmZzZXRXaWR0aC8yO1xyXG5cclxuICAgICAgICB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MDIpfXB4LCR7TWF0aC5yb3VuZChwb3NZMDIpfXB4LCAwKWA7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UyLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTI7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBkYXNoIGxpbmVcclxuXHJcbiAgICAgICAgbGV0IGwxY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC41KTtcclxuICAgICAgICBsZXQgbDJjZW50ZXIgPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1szXS53b3JsZFBvc2l0aW9uLCAwLjUpO1xyXG5cclxuICAgICAgICBsZXQgc2NyZWVuMSA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRUb1NjcmVlbihsMWNlbnRlciwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgICAgIGxldCBzY3JlZW4yID0gdGhpcy5faGFuZGxlc1swXS53b3JsZFRvU2NyZWVuKGwyY2VudGVyLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIHgxID0gc2NyZWVuMS54O1xyXG4gICAgICAgIHkxID0gc2NyZWVuMS55O1xyXG4gICAgICAgIHgyID0gc2NyZWVuMi54O1xyXG4gICAgICAgIHkyID0gc2NyZWVuMi55O1xyXG5cclxuICAgICAgICBsZW5ndGggPSBNYXRoLnNxcnQoKHgxLXgyKSooeDEteDIpICsgKHkxLXkyKSooeTEteTIpKTtcclxuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICBwb3NZID0geTEgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgbGluZVxyXG4gICAgICAgIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xyXG4gICAgICAgIHRyYW5zZm9ybSArPSBgIHJvdGF0ZSgke2FuZ2xlfWRlZylgO1xyXG5cclxuICAgICAgICB0aGlzLl9kYXNobGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy5fZGFzaGxpbmUuc3R5bGUud2lkdGggPSBsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRE9NQ29sb3IoKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlckNvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuXHJcbiAgICAgICAgdGhpcy5fbGluZTIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZTIuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHBvaW50QSwgcG9pbnRCLCBwZXJjZW50YWdlKSB7XHJcblxyXG4gICAgICAgIHZhciBkaXIgPSBwb2ludEIuY2xvbmUoKS5zdWIocG9pbnRBKTtcclxuICAgICAgICB2YXIgbGVuID0gZGlyLmxlbmd0aCgpO1xyXG4gICAgICAgIGRpciA9IGRpci5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW4qcGVyY2VudGFnZSk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50QS5jbG9uZSgpLmFkZChkaXIpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbml0T3J0aG8gKCkge1xyXG4gICAgICAgIHRoaXMuX2luaXRPcnRobyA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBwY2VudGVyID0gdGhpcy5nZXRQb2ludEluQmV0d2VlbkJ5UGVyYyh0aGlzLl9oYW5kbGVzWzBdLndvcmxkUG9zaXRpb24sIHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbiwgMC41KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjI1KTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24gPSB0aGlzLmdldFBvaW50SW5CZXR3ZWVuQnlQZXJjKHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiwgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uLCAwLjc1KTtcclxuXHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnggPSBwY2VudGVyLnggLSBNYXRoLnNxcnQoKHBjZW50ZXIueSAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi55KSoocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSA9IHBjZW50ZXIueSArIE1hdGguc3FydCgocGNlbnRlci54IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLngpKihwY2VudGVyLnggLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCkpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzNdLndvcmxkUG9zaXRpb24ueCA9IHBjZW50ZXIueCArIE1hdGguc3FydCgocGNlbnRlci55IC0gdGhpcy5faGFuZGxlc1syXS53b3JsZFBvc2l0aW9uLnkpKihwY2VudGVyLnkgLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueSkpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbi55ID0gcGNlbnRlci55IC0gTWF0aC5zcXJ0KChwY2VudGVyLnggLSB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24ueCkqKHBjZW50ZXIueCAtIHRoaXMuX2hhbmRsZXNbMl0ud29ybGRQb3NpdGlvbi54KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICB0aGlzLl9oYW5kbGVzWzJdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXNbM10ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNob3Rlc3REaXN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLl9kaXN0YW5jZVZhbHVlIDwgdGhpcy5fZGlzdGFuY2UyVmFsdWUpID8gdGhpcy5fZGlzdGFuY2VWYWx1ZSA6IHRoaXMuX2Rpc3RhbmNlMlZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbG9uZ2VzdERpc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuX2Rpc3RhbmNlVmFsdWUgPiB0aGlzLl9kaXN0YW5jZTJWYWx1ZSkgPyB0aGlzLl9kaXN0YW5jZVZhbHVlIDogdGhpcy5fZGlzdGFuY2UyVmFsdWUpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xyXG5pbXBvcnQgQ29yZUludGVyc2VjdGlvbnMgZnJvbSAnLi4vY29yZS9jb3JlLmludGVyc2VjdGlvbnMnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c0hhbmRsZSBleHRlbmRzIFdpZGdldHNCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IodGFyZ2V0TWVzaCwgY29udHJvbHMsIGNhbWVyYSwgY29udGFpbmVyKSB7XHJcbiAgICBzdXBlcihjb250YWluZXIpO1xyXG5cclxuICAgIHRoaXMuX3RhcmdldE1lc2ggPSB0YXJnZXRNZXNoO1xyXG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcclxuICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuXHJcbiAgICAvLyBpZiBubyB0YXJnZXQgbWVzaCwgdXNlIHBsYW5lIGZvciBGUkVFIGRyYWdnaW5nLlxyXG4gICAgdGhpcy5fcGxhbmUgPSB7XHJcbiAgICAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX29mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XHJcblxyXG4gICAgdGhpcy5fdHJhY2tpbmcgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9tb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIC8vIHdvcmxkIChMUFMpIHBvc2l0aW9uIG9mIHRoaXMgaGFuZGxlXHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgICAvLyBzY3JlZW4gcG9zaXRpb24gb2YgdGhpcyBoYW5kbGVcclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIHRoaXMuX21lc2hEaXNwbGF5ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX21lc2hTdHlsZSA9ICdzcGhlcmUnOyAvLyBjdWJlLCBldGMuXHJcblxyXG4gICAgLy8gZG9tIHN0dWZmXHJcbiAgICB0aGlzLl9kb20gPSBudWxsO1xyXG4gICAgdGhpcy5fZG9tRGlzcGxheWVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2RvbVN0eWxlID0gJ2NpcmNsZSc7IC8vIHNxdWFyZSwgdHJpYW5nbGVcclxuXHJcbiAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkodGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxyXG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBoYW5kbGVcclxuICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB0aGlzLmluaXRPZmZzZXRzKCk7XHJcblxyXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uSG92ZXIgPSB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25FbmRDb250cm9sID0gdGhpcy5vbkVuZENvbnRyb2wuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xyXG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xyXG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZSgpIHtcclxuICAgIHRoaXMuY3JlYXRlTWVzaCgpO1xyXG4gICAgdGhpcy5jcmVhdGVET00oKTtcclxuICB9XHJcblxyXG4gIG9uU3RhcnQoZXZ0KSB7XHJcbiAgICBjb25zb2xlLmxvZyhldnQpO1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIHRoaXMuX21vdXNlLnNldChvZmZzZXRzLngsIG9mZnNldHMueSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLl9tb3VzZSk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHJheWNhc3RlclxyXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodGhpcy5fbW91c2UsIHRoaXMuX2NhbWVyYSk7XHJcbiAgICB0aGlzLl9yYXljYXN0ZXIucmF5LnBvc2l0aW9uID0gdGhpcy5fcmF5Y2FzdGVyLnJheS5vcmlnaW47XHJcblxyXG4gICAgaWYgKHRoaXMuX2hvdmVyZWQpIHtcclxuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2gpIHtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0c1RhcmdldCA9XHJcbiAgICAgICAgICB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX3RhcmdldE1lc2gpO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuX29mZnNldC5jb3B5KGludGVyc2VjdHNUYXJnZXRbMF0ucG9pbnQpLnN1Yih0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcGxhbmUucG9zaXRpb24uY29weSh0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9wbGFuZS5kaXJlY3Rpb24uY29weSh0aGlzLl9jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKSk7XHJcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XHJcbiAgICAgICAgICBDb3JlSW50ZXJzZWN0aW9ucy5yYXlQbGFuZSh0aGlzLl9yYXljYXN0ZXIucmF5LCB0aGlzLl9wbGFuZSk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0aW9uKS5zdWIodGhpcy5fcGxhbmUucG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uRW5kKGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gc3RheSBhY3RpdmUgYW5kIGtlZXAgY29udHJvbHMgZGlzYWJsZWRcclxuICAgIGlmICh0aGlzLl90cmFja2luZyA9PT0gdHJ1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdW5zZWxlY3QgaWYgZ28gdXAgd2l0aG91dCBtb3ZpbmdcclxuICAgIGlmICghdGhpcy5fZHJhZ2dlZCAmJiB0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgLy8gY2hhbmdlIHN0YXRlIGlmIHdhcyBub3QgZHJhZ2dpbmdcclxuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAhdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25FbmRDb250cm9sKCkge1xyXG4gICAgaWYgKCF0aGlzLl9sYXN0RXZlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqXHJcbiAgICovXHJcbiAgb25Nb3ZlKGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuZ2V0TW91c2VPZmZzZXRzKGV2dCwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIHRoaXMuX21vdXNlLnNldChvZmZzZXRzLngsIG9mZnNldHMueSk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHJheWNhc3RlclxyXG4gICAgLy8gc2V0IHJheS5wb3NpdGlvbiB0byBzYXRpc2Z5IENvcmVJbnRlcnNlY3Rpb25zOjpyYXlQbGFuZSBBUElcclxuICAgIHRoaXMuX3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHRoaXMuX21vdXNlLCB0aGlzLl9jYW1lcmEpO1xyXG4gICAgdGhpcy5fcmF5Y2FzdGVyLnJheS5wb3NpdGlvbiA9IHRoaXMuX3JheWNhc3Rlci5yYXkub3JpZ2luO1xyXG5cclxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBpbnRlcnNlY3RzVGFyZ2V0ID1cclxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdHNUYXJnZXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdHNUYXJnZXRbMF0ucG9pbnQuc3ViKHRoaXMuX29mZnNldCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5fcGxhbmUuZGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XHJcbiAgICAgICAgICAvLyBmcmVlIG1vZGUhdGhpcy5fdGFyZ2V0TWVzaFxyXG4gICAgICAgICAgdGhpcy5fcGxhbmUucG9zaXRpb24uY29weSh0aGlzLl93b3JsZFBvc2l0aW9uKTtcclxuICAgICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID1cclxuICAgICAgICAgIENvcmVJbnRlcnNlY3Rpb25zLnJheVBsYW5lKHRoaXMuX3JheWNhc3Rlci5yYXksIHRoaXMuX3BsYW5lKTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkoaW50ZXJzZWN0aW9uLnN1Yih0aGlzLl9vZmZzZXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub25Ib3ZlcihudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25Ib3ZlcihldnQpIHtcclxuICAgIGlmIChldnQpIHtcclxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdGhpcy5ob3ZlckRvbShldnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaG92ZXJNZXNoKCk7XHJcblxyXG4gICAgdGhpcy5faG92ZXJlZCA9IHRoaXMuX21lc2hIb3ZlcmVkIHx8IHRoaXMuX2RvbUhvdmVyZWQ7XHJcbiAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5faG92ZXJlZCA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JztcclxuICB9XHJcblxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIC8vIGdlbmVyYWwgdXBkYXRlXHJcbiAgICB0aGlzLnVwZGF0ZUNvbG9yKCk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHNjcmVlbiBwb3NpdGlvbiBvZiBoYW5kbGVcclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID1cclxuICAgICAgdGhpcy53b3JsZFRvU2NyZWVuKHRoaXMuX3dvcmxkUG9zaXRpb24sIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcclxuXHJcbiAgICAvLyBET00gc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgdXBkYXRlTWVzaENvbG9yKCkge1xyXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fbWVzaCkge1xyXG4gICAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnggPSB0aGlzLl93b3JsZFBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMuX21lc2gucG9zaXRpb24ueSA9IHRoaXMuX3dvcmxkUG9zaXRpb24ueTtcclxuICAgICAgdGhpcy5fbWVzaC5wb3NpdGlvbi56ID0gdGhpcy5fd29ybGRQb3NpdGlvbi56O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaG92ZXJNZXNoKCkge1xyXG4gICAgLy8gY2hlY2sgcmF5Y2FzdCBpbnRlcnNlY3Rpb24sIGRvIHdlIHdhbnQgdG8gaG92ZXIgb24gbWVzaCBvciBqdXN0IGNzcz9cclxuICAgIGxldCBpbnRlcnNlY3RzSGFuZGxlID0gdGhpcy5fcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCh0aGlzLl9tZXNoKTtcclxuICAgIHRoaXMuX21lc2hIb3ZlcmVkID0gKGludGVyc2VjdHNIYW5kbGUubGVuZ3RoID4gMCk7XHJcbiAgfVxyXG5cclxuICBob3ZlckRvbShldnQpIHtcclxuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSAoZXZ0LnR5cGUgPT09ICdtb3VzZWVudGVyJyk7XHJcbiAgfVxyXG5cclxuICB3b3JsZFRvU2NyZWVuKHdvcmxkQ29vcmRpbmF0ZSwgY2FtZXJhLCBjYW52YXMpIHtcclxuICAgIGxldCBzY3JlZW5Db29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZS5jbG9uZSgpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMucHJvamVjdChjYW1lcmEpO1xyXG5cclxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnggPVxyXG4gICAgICBNYXRoLnJvdW5kKChzY3JlZW5Db29yZGluYXRlcy54ICsgMSkgKiBjYW52YXMub2Zmc2V0V2lkdGggLyAyKTtcclxuICAgIHNjcmVlbkNvb3JkaW5hdGVzLnkgPVxyXG4gICAgICBNYXRoLnJvdW5kKCgtc2NyZWVuQ29vcmRpbmF0ZXMueSArIDEpICogY2FudmFzLm9mZnNldEhlaWdodCAvIDIpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIHNjcmVlbkNvb3JkaW5hdGVzO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlTWVzaCgpIHtcclxuICAgIC8vIGdlb21ldHJ5XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLCAxNiwgMTYpO1xyXG5cclxuICAgIC8vIG1hdGVyaWFsXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XHJcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxyXG4gICAgICAgIHdpcmVmcmFtZUxpbmV3aWR0aDogMixcclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gbWVzaFxyXG4gICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XHJcbiAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnggPSB0aGlzLl93b3JsZFBvc2l0aW9uLng7XHJcbiAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnkgPSB0aGlzLl93b3JsZFBvc2l0aW9uLnk7XHJcbiAgICB0aGlzLl9tZXNoLnBvc2l0aW9uLnogPSB0aGlzLl93b3JsZFBvc2l0aW9uLno7XHJcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcblxyXG4gICAgLy8gYWRkIGl0IVxyXG4gICAgdGhpcy5hZGQodGhpcy5fbWVzaCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgY3JlYXRlRE9NKCkge1xyXG4gICAgLy8gZG9tXHJcbiAgICB0aGlzLl9kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy51dWlkKTtcclxuICAgIHRoaXMuX2RvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ0FNSSBXaWRnZXQgSGFuZGxlJyk7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmNvbG9yID0gJyNGOUY5RjknO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS53aWR0aCA9ICcxMnB4JztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5oZWlnaHQgPSAnMTJweCc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUubWFyZ2luID0gJy02cHgnO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1MCUnO1xyXG4gICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG5cclxuICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtID1cclxuICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XHJcblxyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG5cclxuICAgIC8vIGFkZCBpdCFcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kb20pO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fZG9tKSB7XHJcbiAgICAgIGxldCBwb3NZID0gdGhpcy5fc2NyZWVuUG9zaXRpb24ueSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgIHRoaXMuX2RvbS5zdHlsZS50cmFuc2Zvcm0gPVxyXG4gICAgICAgIGB0cmFuc2xhdGUzRCgke3RoaXMuX3NjcmVlblBvc2l0aW9uLnh9cHgsICR7cG9zWX1weCwgMClgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlRE9NQ29sb3IoKSB7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gIH1cclxuXHJcbiAgZnJlZSgpIHtcclxuICAgIC8vIHRocmVlanMgc3R1ZmZcclxuXHJcbiAgICAvLyBkb21cclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kb20pO1xyXG4gICAgLy8gZXZlbnRcclxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICBzdXBlci5mcmVlKCk7XHJcbiAgfVxyXG5cclxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkod29ybGRQb3NpdGlvbik7XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgc2NyZWVuUG9zaXRpb24oc2NyZWVuUG9zaXRpb24pIHtcclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID0gc2NyZWVuUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgc2NyZWVuUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBnZXQgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcclxuICB9XHJcblxyXG4gIHNldCBhY3RpdmUoYWN0aXZlKSB7XHJcbiAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAvLyB0aGlzLl90cmFja2luZyA9IHRoaXMuX2FjdGl2ZTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSAhdGhpcy5fYWN0aXZlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgdHJhY2tpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tpbmc7XHJcbiAgfVxyXG5cclxuICBzZXQgdHJhY2tpbmcodHJhY2tpbmcpIHtcclxuICAgIHRoaXMuX3RyYWNraW5nID0gdHJhY2tpbmc7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZURPTSgpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgc2hvd0RPTSgpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgfVxyXG5cclxuICBoaWRlTWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2hvd01lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIHRoaXMuc2hvd0RPTSgpO1xyXG4gICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIHRoaXMuaGlkZURPTSgpO1xyXG4gICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgQW5ub3RhdGlvbiBmcm9tICcuL3dpZGdldHMuYW5ub3RhdGlvbic7XHJcbmltcG9ydCBCaVJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5iaXJ1bGVyJztcclxuaW1wb3J0IEhhbmRsZSBmcm9tICcuL3dpZGdldHMuaGFuZGxlJztcclxuaW1wb3J0IFJvaSBmcm9tICcuL3dpZGdldHMucm9pJztcclxuaW1wb3J0IFJ1bGVyIGZyb20gJy4vd2lkZ2V0cy5ydWxlcic7XHJcbmltcG9ydCBWb3hlbFByb2JlIGZyb20gJy4vd2lkZ2V0cy52b3hlbFByb2JlJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHNcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBBbm5vdGF0aW9uLFxyXG4gICAgQmlSdWxlcixcclxuXHRIYW5kbGUsXHJcbiAgICBSb2ksXHJcbiAgICBSdWxlcixcclxuICAgIFZveGVsUHJvYmUsXHJcbn07XHJcbiIsImltcG9ydCBXaWRnZXRzQmFzZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuYmFzZSc7XHJcbmltcG9ydCBXaWRnZXRzSGFuZGxlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5oYW5kbGUnO1xyXG5cclxuLyoqXHJcbiAqIEBtb2R1bGUgd2lkZ2V0cy9oYW5kbGVcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRzUm9pIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldE1lc2gsIGNvbnRyb2xzLCBjYW1lcmEsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3RhcmdldE1lc2ggPSB0YXJnZXRNZXNoO1xyXG4gICAgICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pbml0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgICAgIGlmKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2dlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gZG9tIHN0dWZmXHJcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9hcmVhID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gYWRkIGhhbmRsZXNcclxuICAgICAgICB0aGlzLl9oYW5kbGVzID0gW107XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IGhhbmRsZVxyXG4gICAgICAgIGxldCBmaXJzdEhhbmRsZSA9IG5ldyBXaWRnZXRzSGFuZGxlKHRoaXMuX3RhcmdldE1lc2gsIHRoaXMuX2NvbnRyb2xzLCB0aGlzLl9jYW1lcmEsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgZmlyc3RIYW5kbGUud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICAgICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hZGQoZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2goZmlyc3RIYW5kbGUpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcnVsZXJcclxuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xyXG5cclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc2xpY2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMub25Nb3ZlKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdmUoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IG51bUhhbmRsZXMgPSAgdGhpcy5faGFuZGxlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiAhdGhpcy5faW5pdCkge1xyXG4gICAgICAgICAgICBsZXQgbGFzdEhhbmRsZSA9IHRoaXMuX2hhbmRsZXNbbnVtSGFuZGxlcy0xXTtcclxuICAgICAgICAgICAgbGFzdEhhbmRsZS5ob3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxhc3RIYW5kbGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxhc3RIYW5kbGUudHJhY2tpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXh0SGFuZGxlID0gbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgbmV4dEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICAgICAgbmV4dEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmV4dEhhbmRsZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZXh0SGFuZGxlLnRyYWNraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hZGQobmV4dEhhbmRsZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnB1c2gobmV4dEhhbmRsZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3TGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ld0xpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobmV3TGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaG92ZXJlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uTW92ZShldnQpO1xyXG4gICAgICAgICAgICBob3ZlcmVkID0gaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzW2luZGV4XS5ob3ZlcmVkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXJlZDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmIG51bUhhbmRsZXMgPiAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFBvcEhhbmRsZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvblN0YXJ0KGV2dCkge1xyXG4gICAgICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLm9uU3RhcnQoZXZ0KTtcclxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbaW5kZXhdLmFjdGl2ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25FbmQoZXZ0KSB7XHJcbiAgICAgICAgLy8gRmlyc3QgSGFuZGxlXHJcbiAgICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMuc2xpY2UoMCwgdGhpcy5faGFuZGxlcy5sZW5ndGgtMikpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0ub25FbmQoZXZ0KTtcclxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbaW5kZXhdLmFjdGl2ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2Vjb25kIEhhbmRsZVxyXG4gICAgICAgIGlmKHRoaXMuX2RyYWdnZWQgfHwgIXRoaXMuX2hhbmRsZXNbdGhpcy5faGFuZGxlcy5sZW5ndGgtMV0udHJhY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTFdLm9uRW5kKGV2dCk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTFdLnRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXS5hY3RpdmVcclxuICAgICAgICAvLyBTdGF0ZSBvZiBydWxlciB3aWRnZXRcclxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggPCB0aGlzLl9oYW5kbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbmV3TGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgbGluZScpO1xyXG4gICAgICAgICAgICBuZXdMaW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLTFweCc7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XHJcbiAgICAgICAgICAgIG5ld0xpbmUuc3R5bGUud2lkdGggPSAnM3B4JztcclxuICAgICAgICAgICAgbmV3TGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0Y5RjlGOSc7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ld0xpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobmV3TGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1lc2goKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZSgpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGVET00oKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5oaWRlRE9NKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9saW5lcykge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0RPTSgpIHtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnNob3dET00oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVNZXNoKCl7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd01lc2goKSB7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuc2hvd0RPTSgpO1xyXG4gICAgICAgIHRoaXMuc2hvd01lc2goKTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZURPTSgpO1xyXG4gICAgICAgIHRoaXMuaGlkZU1lc2goKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcigpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgLy8gRE9NIHN0dWZmXHJcbiAgICAgICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNZXNoKCkge1xyXG4gICAgICAgIC8vIGdlb21ldHJ5XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1tpbmRleF0ud29ybGRQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtYXRlcmlhbFxyXG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXNoQ29sb3IoKTtcclxuXHJcbiAgICAgICAgLy8gbWVzaFxyXG4gICAgICAgIHRoaXMuX21lc2ggPSBuZXcgVEhSRUUuTGluZSh0aGlzLl9nZW9tZXRyeSwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgICAgIHRoaXMuX21lc2gudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGFkZCBpdCFcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLl9tZXNoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNZXNoQ29sb3IoKSB7XHJcbiAgICAgICAgaWYodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuX2NvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTWVzaFBvc2l0aW9uKCkge1xyXG4gICAgICAgIGlmKHRoaXMuX2dlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZURPTSgpIHtcclxuICAgICAgICAvLyBhZGQgbGluZSFcclxuICAgICAgICB0aGlzLl9saW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3dpZGdldHMgaGFuZGxlIGxpbmUnKTtcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLl9saW5lLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDEwMCUnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xyXG4gICAgICAgIHRoaXMuX2xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XHJcbiAgICAgICAgdGhpcy5fbGluZS5zdHlsZS53aWR0aCA9ICczcHgnO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9saW5lKTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUG9pbnRPbkxpbmUgKHBvaW50QSwgcG9pbnRCLCBwb2ludFRvQ2hlY2spIHtcclxuICAgICAgICB2YXIgYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgYy5jcm9zc1ZlY3RvcnMocG9pbnRBLmNsb25lKCkuc3ViKHBvaW50VG9DaGVjayksIHBvaW50Qi5jbG9uZSgpLnN1Yihwb2ludFRvQ2hlY2spKTtcclxuICAgICAgICByZXR1cm4gIWMubGVuZ3RoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVzaFBvcEhhbmRsZSAoKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZTAgPSB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTNdO1xyXG4gICAgICAgIGxldCBoYW5kbGUxID0gdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0yXTtcclxuICAgICAgICBsZXQgbmV3aGFuZGxlID0gdGhpcy5faGFuZGxlc1t0aGlzLl9oYW5kbGVzLmxlbmd0aC0xXTtcclxuXHJcbiAgICAgICAgdmFyIGlzT25MaW5lID0gdGhpcy5pc1BvaW50T25MaW5lKGhhbmRsZTAud29ybGRQb3NpdGlvbiwgaGFuZGxlMS53b3JsZFBvc2l0aW9uLCBuZXdoYW5kbGUud29ybGRQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChpc09uTGluZSkge1xyXG4gICAgICAgICAgICBoYW5kbGUxLl9kb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaGFuZGxlMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzW3RoaXMuX2hhbmRsZXMubGVuZ3RoLTJdID0gbmV3aGFuZGxlO1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVzLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRlbXBMaW5lID0gdGhpcy5fbGluZXMucG9wKCk7XHJcbiAgICAgICAgICAgIHRlbXBMaW5lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0ZW1wTGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaXNPbkxpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTGluZURPTSAobGluZUluZGV4LCBoYW5kbGUwSW5kZXgsIGhhbmRsZTFJbmRleCkge1xyXG4gICAgICAgIC8vIHVwZGF0ZSBydWxlcnMgbGluZXMgYW5kIHRleHQhXHJcbiAgICAgICAgbGV0IHgxID0gdGhpcy5faGFuZGxlc1toYW5kbGUwSW5kZXhdLnNjcmVlblBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1toYW5kbGUwSW5kZXhdLnNjcmVlblBvc2l0aW9uLnk7XHJcbiAgICAgICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1toYW5kbGUxSW5kZXhdLnNjcmVlblBvc2l0aW9uLng7XHJcbiAgICAgICAgbGV0IHkyID0gdGhpcy5faGFuZGxlc1toYW5kbGUxSW5kZXhdLnNjcmVlblBvc2l0aW9uLnk7XHJcblxyXG4gICAgICAgIGxldCB4MCA9IHgyO1xyXG4gICAgICAgIGxldCB5MCA9IHkyO1xyXG5cclxuICAgICAgICBpZiAoeTEgPj0geTIpIHtcclxuICAgICAgICAgICAgeTAgPSB5MiAtIDMwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkwID0geTIgKyAzMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQoKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpKTtcclxuICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgICAgICAgbGV0IHBvc1kgPSB5MSAtIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBsaW5lXHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCAke3Bvc1l9cHgsIDApYDtcclxuICAgICAgICB0cmFuc2Zvcm0gKz0gYCByb3RhdGUoJHthbmdsZX1kZWcpYDtcclxuXHJcbiAgICAgICAgLy90aGlzLl9saW5lc1tsaW5lSW5kZXhdLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB0aGlzLl9saW5lc1tsaW5lSW5kZXhdLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLl9saW5lc1tsaW5lSW5kZXhdLnN0eWxlLndpZHRoID0gbGVuZ3RoICsgJ3B4JztcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVET01Qb3NpdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9saW5lcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lRE9NKGluZGV4LCBpbmRleCwgcGFyc2VJbnQoaW5kZXgpICsgMSA9PSB0aGlzLl9oYW5kbGVzLmxlbmd0aCA/IDAgOiBwYXJzZUludChpbmRleCkgKyAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZURPTUNvbG9yKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2xpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lc1tpbmRleF0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYCR7dGhpcy5fY29sb3J9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRQb2ludEluQmV0d2VlbkJ5UGVyYyhwb2ludEEsIHBvaW50QiwgcGVyY2VudGFnZSkge1xyXG5cclxuICAgICAgICB2YXIgZGlyID0gcG9pbnRCLmNsb25lKCkuc3ViKHBvaW50QSk7XHJcbiAgICAgICAgdmFyIGxlbiA9IGRpci5sZW5ndGgoKTtcclxuICAgICAgICBkaXIgPSBkaXIubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIobGVuKnBlcmNlbnRhZ2UpO1xyXG4gICAgICAgIHJldHVybiBwb2ludEEuY2xvbmUoKS5hZGQoZGlyKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHdvcmxkUG9zaXRpb24od29ybGRQb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiB0aGlzLl9oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXNbaW5kZXhdLl93b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgV2lkZ2V0c0Jhc2UgZnJvbSAnLi4vd2lkZ2V0cy93aWRnZXRzLmJhc2UnO1xyXG5pbXBvcnQgV2lkZ2V0c0hhbmRsZSBmcm9tICcuLi93aWRnZXRzL3dpZGdldHMuaGFuZGxlJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHMvaGFuZGxlXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lkZ2V0c1J1bGVyIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3Rvcih0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy5fdGFyZ2V0TWVzaCA9IHRhcmdldE1lc2g7XHJcbiAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gICAgaWYgKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IHRoaXMuX3RhcmdldE1lc2gucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVzaCBzdHVmZlxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcblxyXG4gICAgLy8gZG9tIHN0dWZmXHJcbiAgICB0aGlzLl9saW5lID0gbnVsbDtcclxuICAgIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcclxuXHJcbiAgICAvLyBhZGQgaGFuZGxlc1xyXG4gICAgdGhpcy5faGFuZGxlcyA9IFtdO1xyXG5cclxuICAgIC8vIGZpcnN0IGhhbmRsZVxyXG4gICAgbGV0IGZpcnN0SGFuZGxlID1cclxuICAgICAgbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIGZpcnN0SGFuZGxlLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG4gICAgZmlyc3RIYW5kbGUuaG92ZXJlZCA9IHRydWU7XHJcbiAgICB0aGlzLmFkZChmaXJzdEhhbmRsZSk7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlcy5wdXNoKGZpcnN0SGFuZGxlKTtcclxuXHJcbiAgICBsZXQgc2Vjb25kSGFuZGxlID1cclxuICAgICAgbmV3IFdpZGdldHNIYW5kbGUodGhpcy5fdGFyZ2V0TWVzaCwgdGhpcy5fY29udHJvbHMsIHRoaXMuX2NhbWVyYSwgdGhpcy5fY29udGFpbmVyKTtcclxuICAgIHNlY29uZEhhbmRsZS53b3JsZFBvc2l0aW9uID0gdGhpcy5fd29ybGRQb3NpdGlvbjtcclxuICAgIHNlY29uZEhhbmRsZS5ob3ZlcmVkID0gdHJ1ZTtcclxuICAgIC8vIGFjdGl2ZSBhbmQgdHJhY2tpbmcgbWlnaHQgYmUgcmVkdW5kYW50XHJcbiAgICBzZWNvbmRIYW5kbGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgIHNlY29uZEhhbmRsZS50cmFja2luZyA9IHRydWU7XHJcbiAgICB0aGlzLmFkZChzZWNvbmRIYW5kbGUpO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXMucHVzaChzZWNvbmRIYW5kbGUpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBydWxlclxyXG4gICAgdGhpcy5jcmVhdGUoKTtcclxuICAgIHRoaXMuaW5pdE9mZnNldHMoKTtcclxuXHJcbiAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uRW5kQ29udHJvbCA9IHRoaXMub25FbmRDb250cm9sLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgfVxyXG5cclxuICBhZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW92ZSk7XHJcblxyXG4gICAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5vbkVuZENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgb25Nb3ZlKGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgdGhpcy5fZHJhZ2dlZCA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5faGFuZGxlc1swXS5vbk1vdmUoZXZ0KTtcclxuICAgIHRoaXMuX2hhbmRsZXNbMV0ub25Nb3ZlKGV2dCk7XHJcblxyXG4gICAgdGhpcy5faG92ZXJlZCA9IHRoaXMuX2hhbmRsZXNbMF0uaG92ZXJlZCB8fCB0aGlzLl9oYW5kbGVzWzFdLmhvdmVyZWQ7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25TdGFydChldnQpIHtcclxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcclxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uU3RhcnQoZXZ0KTtcclxuICAgIHRoaXMuX2hhbmRsZXNbMV0ub25TdGFydChldnQpO1xyXG5cclxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2hhbmRsZXNbMF0uYWN0aXZlIHx8IHRoaXMuX2hhbmRsZXNbMV0uYWN0aXZlO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIG9uRW5kKGV2dCkge1xyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZ0O1xyXG4gICAgLy8gRmlyc3QgSGFuZGxlXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLm9uRW5kKGV2dCk7XHJcblxyXG4gICAgLy8gd2luZG93LmNvbnNvbGUubG9nKHRoaXMpO1xyXG5cclxuICAgIC8vIFNlY29uZCBIYW5kbGVcclxuICAgIGlmICh0aGlzLl9kcmFnZ2VkIHx8ICF0aGlzLl9oYW5kbGVzWzFdLnRyYWNraW5nKSB7XHJcbiAgICAgIHRoaXMuX2hhbmRsZXNbMV0udHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS5vbkVuZChldnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5faGFuZGxlc1sxXS50cmFja2luZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRlIG9mIHJ1bGVyIHdpZGdldFxyXG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5faGFuZGxlc1swXS5hY3RpdmUgfHwgdGhpcy5faGFuZGxlc1sxXS5hY3RpdmU7XHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgb25FbmRDb250cm9sKCkge1xyXG4gICAgaWYgKCF0aGlzLl9sYXN0RXZlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLm9uTW92ZSh0aGlzLl9sYXN0RXZlbnQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGUoKSB7XHJcbiAgICB0aGlzLmNyZWF0ZU1lc2goKTtcclxuICAgIHRoaXMuY3JlYXRlRE9NKCk7XHJcbiAgfVxyXG5cclxuICBoaWRlRE9NKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGZvciAobGV0IGluZGV4IGluIHRoaXMuX2hhbmRsZXMpIHtcclxuICAgICAgdGhpcy5faGFuZGxlc1tpbmRleF0uaGlkZURPTSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2hvd0RPTSgpIHtcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gdGhpcy5faGFuZGxlcykge1xyXG4gICAgICB0aGlzLl9oYW5kbGVzW2luZGV4XS5zaG93RE9NKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoaWRlTWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2hvd01lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIHRoaXMuc2hvd0RPTSgpO1xyXG4gICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIHRoaXMuaGlkZURPTSgpO1xyXG4gICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBoYW5kbGVzXHJcbiAgICB0aGlzLl9oYW5kbGVzWzBdLnVwZGF0ZSgpO1xyXG4gICAgdGhpcy5faGFuZGxlc1sxXS51cGRhdGUoKTtcclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVNZXNoUG9zaXRpb24oKTtcclxuXHJcbiAgICAvLyBET00gc3R1ZmZcclxuICAgIHRoaXMudXBkYXRlRE9NQ29sb3IoKTtcclxuICAgIHRoaXMudXBkYXRlRE9NUG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZU1lc2goKSB7XHJcbiAgICAvLyBnZW9tZXRyeVxyXG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1swXS53b3JsZFBvc2l0aW9uKTtcclxuICAgIHRoaXMuX2dlb21ldHJ5LnZlcnRpY2VzLnB1c2godGhpcy5faGFuZGxlc1sxXS53b3JsZFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBtYXRlcmlhbFxyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuICAgIHRoaXMudXBkYXRlTWVzaENvbG9yKCk7XHJcblxyXG4gICAgLy8gbWVzaFxyXG4gICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5MaW5lKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XHJcbiAgICB0aGlzLl9tZXNoLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIGFkZCBpdCFcclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTWVzaENvbG9yKCkge1xyXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVNZXNoUG9zaXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcclxuICAgICAgdGhpcy5fZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNyZWF0ZURPTSgpIHtcclxuICAgIC8vIGFkZCBsaW5lIVxyXG4gICAgdGhpcy5fbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fbGluZS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy51dWlkKTtcclxuICAgIHRoaXMuX2xpbmUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdBTUkgV2lkZ2V0IFJ1bGVyJyk7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMTAwJSc7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLm1hcmdpblRvcCA9ICctMXB4JztcclxuICAgIHRoaXMuX2xpbmUuc3R5bGUuaGVpZ2h0ID0gJzJweCc7XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gJzNweCc7XHJcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGluZSk7XHJcblxyXG4gICAgLy8gYWRkIGRpc3RhbmNlIVxyXG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnd2lkZ2V0cyBoYW5kbGUgZGlzdGFuY2UnKTtcclxuICAgIHRoaXMuX2Rpc3RhbmNlLnN0eWxlLmJvcmRlciA9ICcycHggc29saWQnO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGOUY5RjknO1xyXG4gICAgLy8gdGhpcy5fZGlzdGFuY2Uuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuY29sb3IgPSAnIzM1MzUzNSc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wYWRkaW5nID0gJzRweCc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl9kaXN0YW5jZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAxMDAlJztcclxuICAgIHRoaXMuX2Rpc3RhbmNlLmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcclxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kaXN0YW5jZSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlRE9NUG9zaXRpb24oKSB7XHJcbiAgICAvLyB1cGRhdGUgcnVsZXJzIGxpbmVzIGFuZCB0ZXh0IVxyXG4gICAgbGV0IHgxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgbGV0IHkxID0gdGhpcy5faGFuZGxlc1swXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG4gICAgbGV0IHgyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi54O1xyXG4gICAgbGV0IHkyID0gdGhpcy5faGFuZGxlc1sxXS5zY3JlZW5Qb3NpdGlvbi55O1xyXG5cclxuICAgIC8vbGV0IHgwID0geDEgKyAoeDIgLSB4MSkvMjtcclxuICAgIC8vbGV0IHkwID0geTEgKyAoeTIgLSB5MSkvMjtcclxuICAgIGxldCB4MCA9IHgyO1xyXG4gICAgbGV0IHkwID0geTI7XHJcblxyXG4gICAgaWYgKHkxID49IHkyKSB7XHJcbiAgICAgIHkwID0geTIgLSAzMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHkwID0geTIgKyAzMDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbGVuZ3RoID0gTWF0aC5zcXJ0KCh4MS14MikqKHgxLXgyKSArICh5MS15MikqKHkxLXkyKSk7XHJcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgICBsZXQgcG9zWSA9IHkxIC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAvLyB1cGRhdGUgbGluZVxyXG4gICAgbGV0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzRCgke3gxfXB4LCR7cG9zWX1weCwgMClgO1xyXG4gICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7YW5nbGV9ZGVnKWA7XHJcblxyXG4gICAgdGhpcy5fbGluZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICB0aGlzLl9saW5lLnN0eWxlLndpZHRoID0gbGVuZ3RoICsgJ3B4JztcclxuXHJcbiAgICAvLyB1cGRhdGUgZGlzdGFuY2VcclxuICAgIGxldCB3MCA9IHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbjtcclxuICAgIGxldCB3MSA9IHRoaXMuX2hhbmRsZXNbMV0ud29ybGRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLl9kaXN0YW5jZS5pbm5lckhUTUwgPVxyXG4gICAgICBgJHtcclxuICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAodzAueC13MS54KSoodzAueC13MS54KSArXHJcbiAgICAgICAgICAodzAueS13MS55KSoodzAueS13MS55KSArXHJcbiAgICAgICAgICAodzAuei13MS56KSoodzAuei13MS56KVxyXG4gICAgICAgICkudG9GaXhlZCgyKX0gbW1gO1xyXG4gICAgbGV0IHBvc1kwID1cclxuICAgICAgeTAgLSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fZGlzdGFuY2Uub2Zmc2V0SGVpZ2h0LzI7XHJcbiAgICB4MCAtPSB0aGlzLl9kaXN0YW5jZS5vZmZzZXRXaWR0aC8yO1xyXG5cclxuICAgIGxldCB0cmFuc2Zvcm0yID1cclxuICAgICAgYHRyYW5zbGF0ZTNEKCR7TWF0aC5yb3VuZCh4MCl9cHgsJHtNYXRoLnJvdW5kKHBvc1kwKX1weCwgMClgO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcclxuICB9XHJcblxyXG4gIHVwZGF0ZURPTUNvbG9yKCkge1xyXG4gICAgdGhpcy5fbGluZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gICAgdGhpcy5fZGlzdGFuY2Uuc3R5bGUuYm9yZGVyQ29sb3IgPSBgJHt0aGlzLl9jb2xvcn1gO1xyXG4gIH1cclxuXHJcbiAgZnJlZSgpIHtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXMuZm9yRWFjaCgoaCkgPT4ge1xyXG4gICAgICBoLmZyZWUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2hhbmRsZXMgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fbGluZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZGlzdGFuY2UpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlKHRoaXMuX21lc2gpO1xyXG5cclxuICAgIHN1cGVyLmZyZWUoKTtcclxuICB9XHJcblxyXG4gIGdldCB3b3JsZFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBzZXQgd29ybGRQb3NpdGlvbih3b3JsZFBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl93b3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcclxuICAgIHRoaXMuX2hhbmRsZXNbMF0ud29ybGRQb3NpdGlvbiA9IHRoaXMuX3dvcmxkUG9zaXRpb247XHJcbiAgICB0aGlzLl9oYW5kbGVzWzFdLndvcmxkUG9zaXRpb24gPSB0aGlzLl93b3JsZFBvc2l0aW9uO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJcclxuaW1wb3J0IFdpZGdldHNCYXNlIGZyb20gJy4uL3dpZGdldHMvd2lkZ2V0cy5iYXNlJztcclxuaW1wb3J0IEdlb21ldHJpZXNWb3hlbCBmcm9tICcuLi9nZW9tZXRyaWVzL2dlb21ldHJpZXMudm94ZWwnO1xyXG5pbXBvcnQgTW9kZWxzU3RhY2sgZnJvbSAnLi4vbW9kZWxzL21vZGVscy5zdGFjayc7XHJcbmltcG9ydCBNb2RlbHNWb3hlbCBmcm9tICcuLi9tb2RlbHMvbW9kZWxzLnZveGVsJztcclxuaW1wb3J0IENvcmVJbnRlcnNlY3Rpb25zIGZyb20gJy4uL2NvcmUvY29yZS5pbnRlcnNlY3Rpb25zJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIHdpZGdldHMvdm94ZWxQcm9iZVxyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpZGdldHNWb3hlbFByb2JlIGV4dGVuZHMgV2lkZ2V0c0Jhc2Uge1xyXG4gIGNvbnN0cnVjdG9yKHN0YWNrLCB0YXJnZXRNZXNoLCBjb250cm9scywgY2FtZXJhLCBjb250YWluZXIpIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcclxuXHJcbiAgICB0aGlzLl90YXJnZXRNZXNoID0gdGFyZ2V0TWVzaDtcclxuICAgIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG4gICAgLy8gaWYgbm8gdGFyZ2V0IG1lc2gsIHVzZSBwbGFuZSBmb3IgRlJFRSBkcmFnZ2luZy5cclxuICAgIHRoaXMuX3BsYW5lID0ge1xyXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG4gICAgICAgIGRpcmVjdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgIHRoaXMuX3JheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKTtcclxuXHJcbiAgICB0aGlzLl90cmFja2luZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX21vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XHJcblxyXG4gICAgLy8gd29ybGQgKExQUykgcG9zaXRpb24gb2YgdGhlIGNlbnRlclxyXG4gICAgdGhpcy5fd29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgLy8gc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXJcclxuICAgIHRoaXMuX3NjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbiAgICAvLyBtZXNoIHN0dWZmXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9nZW9tZXRyeSA9IG51bGw7XHJcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcclxuICAgIHRoaXMuX21lc2hEaXNwbGF5ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX21lc2hTdHlsZSA9ICdzcGhlcmUnOyAvLyBjdWJlLCBldGMuXHJcblxyXG4gICAgLy8gZG9tIHN0dWZmXHJcbiAgICB0aGlzLl9kb20gPSBudWxsO1xyXG4gICAgdGhpcy5fZG9tRGlzcGxheWVkID0gdHJ1ZTtcclxuICAgIHRoaXMuX2RvbUhvdmVyZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2RvbVN0eWxlID0gJ2NpcmNsZSc7IC8vIHNxdWFyZSwgdHJpYW5nbGVcclxuXHJcbiAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl93b3JsZFBvc2l0aW9uLmNvcHkodGhpcy5fdGFyZ2V0TWVzaC5wb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxyXG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBoYW5kbGVcclxuICAgIHRoaXMuY3JlYXRlKCk7XHJcbiAgICB0aGlzLmluaXRPZmZzZXRzKCk7XHJcblxyXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICB0aGlzLm9uTW92ZSA9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uSG92ZXIgPSB0aGlzLm9uSG92ZXIuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25FbmRDb250cm9sID0gdGhpcy5vbkVuZENvbnRyb2wuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xyXG4gICAgdGhpcy5fZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uSG92ZXIpO1xyXG4gICAgdGhpcy5fZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uSG92ZXIpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5vbk1vdmUpO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMub25FbmRDb250cm9sKTtcclxuICB9XHJcblxyXG4gIG9uU3RhcnQoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5nZXRNb3VzZU9mZnNldHMoZXZ0LCB0aGlzLl9jb250YWluZXIpO1xyXG4gICAgdGhpcy5fbW91c2Uuc2V0KG9mZnNldHMueCwgb2Zmc2V0cy55KTtcclxuXHJcbiAgICAvLyB1cGRhdGUgcmF5Y2FzdGVyXHJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcclxuICAgIHRoaXMuX3JheWNhc3Rlci5yYXkucG9zaXRpb24gPSB0aGlzLl9yYXljYXN0ZXIucmF5Lm9yaWdpbjtcclxuXHJcbiAgICBpZiAodGhpcy5faG92ZXJlZCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9jb250cm9scy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAodGhpcy5fdGFyZ2V0TWVzaCkge1xyXG4gICAgICAgIGxldCBpbnRlcnNlY3RzVGFyZ2V0ID1cclxuICAgICAgICAgIHRoaXMuX3JheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QodGhpcy5fdGFyZ2V0TWVzaCk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdHNUYXJnZXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkoaW50ZXJzZWN0c1RhcmdldFswXS5wb2ludCkuc3ViKHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wbGFuZS5wb3NpdGlvbi5jb3B5KHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5jb3B5KHRoaXMuX2NhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpKTtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID1cclxuICAgICAgICAgIENvcmVJbnRlcnNlY3Rpb25zLnJheVBsYW5lKHRoaXMuX3JheWNhc3Rlci5yYXksIHRoaXMuX3BsYW5lKTtcclxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuY29weShpbnRlcnNlY3Rpb24pLnN1Yih0aGlzLl9wbGFuZS5wb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb25FbmQoZXZ0KSB7XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBldnQ7XHJcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBzdGF5IGFjdGl2ZSBhbmQga2VlcCBjb250cm9scyBkaXNhYmxlZFxyXG4gICAgaWYgKHRoaXMuX3RyYWNraW5nID09PSB0cnVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1bnNlbGVjdCBpZiBnbyB1cCB3aXRob3V0IG1vdmluZ1xyXG4gICAgaWYgKCF0aGlzLl9kcmFnZ2VkICYmIHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICAvLyBjaGFuZ2Ugc3RhdGUgaWYgd2FzIG5vdCBkcmFnZ2luZ1xyXG4gICAgICB0aGlzLl9zZWxlY3RlZCA9ICF0aGlzLl9zZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2NvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBvbkVuZENvbnRyb2woKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xhc3RFdmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMub25Nb3ZlKHRoaXMuX2xhc3RFdmVudCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG9uTW92ZShldnQpIHtcclxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcclxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLmdldE1vdXNlT2Zmc2V0cyhldnQsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICB0aGlzLl9tb3VzZS5zZXQob2Zmc2V0cy54LCBvZmZzZXRzLnkpO1xyXG5cclxuICAgIC8vIHVwZGF0ZSByYXljYXN0ZXJcclxuICAgIC8vIHNldCByYXkucG9zaXRpb24gdG8gc2F0aXNmeSBDb3JlSW50ZXJzZWN0aW9uczo6cmF5UGxhbmUgQVBJXHJcbiAgICB0aGlzLl9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLl9tb3VzZSwgdGhpcy5fY2FtZXJhKTtcclxuICAgIHRoaXMuX3JheWNhc3Rlci5yYXkucG9zaXRpb24gPSB0aGlzLl9yYXljYXN0ZXIucmF5Lm9yaWdpbjtcclxuXHJcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XHJcbiAgICAgIHRoaXMuX2RyYWdnZWQgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3RhcmdldE1lc2ggIT09IG51bGwpIHtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0c1RhcmdldCA9XHJcbiAgICAgICAgICB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX3RhcmdldE1lc2gpO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3RzVGFyZ2V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weShpbnRlcnNlY3RzVGFyZ2V0WzBdLnBvaW50LnN1Yih0aGlzLl9vZmZzZXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYW5lLmRpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xyXG4gICAgICAgICAgLy8gZnJlZSBtb2RlIXRoaXMuX3RhcmdldE1lc2hcclxuICAgICAgICAgIHRoaXMuX3BsYW5lLnBvc2l0aW9uLmNvcHkodGhpcy5fd29ybGRQb3NpdGlvbik7XHJcbiAgICAgICAgICB0aGlzLl9wbGFuZS5kaXJlY3Rpb24uY29weSh0aGlzLl9jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKSk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9XHJcbiAgICAgICAgICBDb3JlSW50ZXJzZWN0aW9ucy5yYXlQbGFuZSh0aGlzLl9yYXljYXN0ZXIucmF5LCB0aGlzLl9wbGFuZSk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5fd29ybGRQb3NpdGlvbi5jb3B5KGludGVyc2VjdGlvbi5zdWIodGhpcy5fb2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9uSG92ZXIobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIG9uSG92ZXIoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0KSB7XHJcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2dDtcclxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMuaG92ZXJEb20oZXZ0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmhvdmVyTWVzaCgpO1xyXG5cclxuICAgIHRoaXMuX2hvdmVyZWQgPSB0aGlzLl9tZXNoSG92ZXJlZCB8fCB0aGlzLl9kb21Ib3ZlcmVkO1xyXG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMuX2hvdmVyZWQgPyAncG9pbnRlcicgOiAnZGVmYXVsdCc7XHJcbiAgfVxyXG5cclxuICBob3Zlck1lc2goKSB7XHJcbiAgICAvLyBjaGVjayByYXljYXN0IGludGVyc2VjdGlvbiwgZG8gd2Ugd2FudCB0byBob3ZlciBvbiBtZXNoIG9yIGp1c3QgY3NzP1xyXG4gICAgbGV0IGludGVyc2VjdHNIYW5kbGUgPSB0aGlzLl9yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KHRoaXMuX21lc2gpO1xyXG4gICAgdGhpcy5fbWVzaEhvdmVyZWQgPSAoaW50ZXJzZWN0c0hhbmRsZS5sZW5ndGggPiAwKTtcclxuICB9XHJcblxyXG4gIGhvdmVyRG9tKGV2dCkge1xyXG4gICAgdGhpcy5fZG9tSG92ZXJlZCA9IChldnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcclxuICB9XHJcblxyXG4gIHdvcmxkVG9TY3JlZW4od29ybGRDb29yZGluYXRlLCBjYW1lcmEsIGNhbnZhcykge1xyXG4gICAgbGV0IHNjcmVlbkNvb3JkaW5hdGVzID0gd29ybGRDb29yZGluYXRlLmNsb25lKCk7XHJcbiAgICBzY3JlZW5Db29yZGluYXRlcy5wcm9qZWN0KGNhbWVyYSk7XHJcblxyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueCA9XHJcbiAgICAgIE1hdGgucm91bmQoKHNjcmVlbkNvb3JkaW5hdGVzLnggKyAxKSAqIGNhbnZhcy5vZmZzZXRXaWR0aCAvIDIpO1xyXG4gICAgc2NyZWVuQ29vcmRpbmF0ZXMueSA9XHJcbiAgICAgIE1hdGgucm91bmQoKC1zY3JlZW5Db29yZGluYXRlcy55ICsgMSkgKiBjYW52YXMub2Zmc2V0SGVpZ2h0IC8gMik7XHJcbiAgICBzY3JlZW5Db29yZGluYXRlcy56ID0gMDtcclxuXHJcbiAgICByZXR1cm4gc2NyZWVuQ29vcmRpbmF0ZXM7XHJcbiAgfVxyXG5cclxuICBjcmVhdGUoKSB7XHJcbiAgICB0aGlzLmNyZWF0ZVZveGVsKCk7XHJcbiAgICB0aGlzLmNyZWF0ZU1lc2goKTtcclxuICAgIHRoaXMuY3JlYXRlRE9NKCk7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVWb3hlbCgpIHtcclxuICAgIHRoaXMuX3ZveGVsID0gbmV3IE1vZGVsc1ZveGVsKCk7XHJcbiAgICB0aGlzLl92b3hlbC5pZCA9IHRoaXMuaWQ7XHJcbiAgICB0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzID0gdGhpcy5fd29ybGRDb29yZGluYXRlcztcclxuICB9XHJcblxyXG4gIGNyZWF0ZU1lc2goKSB7XHJcbiAgICBjb25zdCBkYXRhQ29vcmRpbmF0ZXMgPSBNb2RlbHNTdGFjay53b3JsZFRvRGF0YShcclxuICAgICAgdGhpcy5fc3RhY2ssXHJcbiAgICAgIHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX2dlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNWb3hlbChkYXRhQ29vcmRpbmF0ZXMpO1xyXG4gICAgdGhpcy5fbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xyXG4gICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcclxuICAgICAgICB3aXJlZnJhbWVMaW5ld2lkdGg6IDEsXHJcbiAgICAgIH0pO1xyXG4gICAgdGhpcy5fbWVzaCA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuX2dlb21ldHJ5LCB0aGlzLl9tYXRlcmlhbCk7XHJcbiAgICB0aGlzLl9tZXNoLmFwcGx5TWF0cml4KHRoaXMuX3N0YWNrLmlqazJMUFMpO1xyXG4gICAgdGhpcy5fbWVzaC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG5cclxuICAgIHRoaXMuYWRkKHRoaXMuX21lc2gpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTWVzaENvbG9yKCkge1xyXG4gICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgIHRoaXMuX21hdGVyaWFsLmNvbG9yLnNldCh0aGlzLl9jb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjcmVhdGVET00oKSB7XHJcbiAgICAvLyBkb21cclxuICAgIHRoaXMuX2RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnV1aWQpO1xyXG4gICAgdGhpcy5fZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnQU1JIFdpZGdldCBWb3hlbFByb2JlJyk7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUuYm9yZGVyID0gJzJweCBzb2xpZCAjMDAwJztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiKDI0OSwgMjQ5LCAyNDkpJztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5jb2xvciA9ICcjMjEyMTIxJztcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl9kb20uc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzBweCAxMDAlIDBweCc7XHJcblxyXG4gICAgLy8gbWVhc3VyZW5lbnRzXHJcbiAgICBsZXQgbWVhc3VyZW1lbnRzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAvLyBMUFNcclxuICAgIGxldCBscHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGxwc0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2xwc1Bvc2l0aW9uJyk7XHJcbiAgICBtZWFzdXJlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQobHBzQ29udGFpbmVyKTtcclxuICAgIC8vIElKS1xyXG4gICAgbGV0IGlqa0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgaWprQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnaWprUG9zaXRpb24nKTtcclxuICAgIG1lYXN1cmVtZW50c0NvbnRhaW5lci5hcHBlbmRDaGlsZChpamtDb250YWluZXIpO1xyXG4gICAgLy8gVmFsdWVcclxuICAgIGxldCB2YWx1ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdmFsdWVDb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICd2YWx1ZScpO1xyXG4gICAgbWVhc3VyZW1lbnRzQ29udGFpbmVyLmFwcGVuZENoaWxkKHZhbHVlQ29udGFpbmVyKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZURPTUNvbG9yKCk7XHJcbiAgICB0aGlzLl9kb20uYXBwZW5kQ2hpbGQobWVhc3VyZW1lbnRzQ29udGFpbmVyKTtcclxuXHJcbiAgICAvLyBhZGQgaXQhXHJcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZG9tKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZURPTUNvbnRlbnQoKSB7XHJcbiAgICBjb25zdCByYXNDb250YWluZXIgPSB0aGlzLl9kb20ucXVlcnlTZWxlY3RvcignI2xwc1Bvc2l0aW9uJyk7XHJcbiAgICByYXNDb250YWluZXIuaW5uZXJIVE1MID0gYExQUzogXHJcbiAgICAgICR7dGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcy54LnRvRml4ZWQoMil9IDpcclxuICAgICAgJHt0aGlzLl92b3hlbC53b3JsZENvb3JkaW5hdGVzLnkudG9GaXhlZCgyKX0gOlxyXG4gICAgICAke3RoaXMuX3ZveGVsLndvcmxkQ29vcmRpbmF0ZXMuei50b0ZpeGVkKDIpfWA7XHJcblxyXG4gICAgY29uc3QgaWprQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyNpamtQb3NpdGlvbicpO1xyXG4gICAgaWprQ29udGFpbmVyLmlubmVySFRNTCA9IGBJSks6IFxyXG4gICAgICAke3RoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcy54fSA6XHJcbiAgICAgICR7dGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzLnl9IDpcclxuICAgICAgJHt0aGlzLl92b3hlbC5kYXRhQ29vcmRpbmF0ZXMuen1gO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlQ29udGFpbmVyID0gdGhpcy5fZG9tLnF1ZXJ5U2VsZWN0b3IoJyN2YWx1ZScpO1xyXG4gICAgdmFsdWVDb250YWluZXIuaW5uZXJIVE1MID0gYFZhbHVlOiAke3RoaXMuX3ZveGVsLnZhbHVlfWA7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoKSB7XHJcbiAgICAvLyBnZW5lcmFsIHVwZGF0ZVxyXG4gICAgdGhpcy51cGRhdGVDb2xvcigpO1xyXG4gICAgdGhpcy5fc2NyZWVuUG9zaXRpb24gPVxyXG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW4odGhpcy5fd29ybGRQb3NpdGlvbiwgdGhpcy5fY2FtZXJhLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICAgIC8vIHNldCBkYXRhIGNvb3JkaW5hdGVzICYmIHZhbHVlXHJcbiAgICB0aGlzLnVwZGF0ZVZveGVsKHRoaXMuX3dvcmxkUG9zaXRpb24pO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBtZXNoIHBvc2l0aW9uXHJcbiAgICB0aGlzLnVwZGF0ZU1lc2hDb2xvcigpO1xyXG4gICAgaWYgKHRoaXMuX21lc2ggJiYgdGhpcy5fbWVzaC5nZW9tZXRyeSkge1xyXG4gICAgICB0aGlzLl9tZXNoLmdlb21ldHJ5LmxvY2F0aW9uID0gdGhpcy5fdm94ZWwuZGF0YUNvb3JkaW5hdGVzO1xyXG4gICAgICB0aGlzLl9tZXNoLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBkb21cclxuICAgIHRoaXMudXBkYXRlRE9NQ29udGVudCgpO1xyXG4gICAgdGhpcy51cGRhdGVET01Db2xvcigpO1xyXG4gICAgdGhpcy51cGRhdGVET01Qb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIHVwZGF0ZVZveGVsKHdvcmxkQ29vcmRpbmF0ZXMpIHtcclxuICAgIC8vIHVwZGF0ZSB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgdGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcyA9IHdvcmxkQ29vcmRpbmF0ZXM7XHJcblxyXG4gICAgLy8gdXBkYXRlIGRhdGEgY29vcmRpbmF0ZXNcclxuICAgIHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcyA9IE1vZGVsc1N0YWNrLndvcmxkVG9EYXRhKFxyXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayxcclxuICAgICAgICAgICAgICAgICAgdGhpcy5fdm94ZWwud29ybGRDb29yZGluYXRlcyk7XHJcblxyXG4gICAgLy8gdXBkYXRlIHZhbHVlXHJcbiAgICBsZXQgdmFsdWUgPSBNb2RlbHNTdGFjay52YWx1ZShcclxuICAgICAgdGhpcy5fc3RhY2ssXHJcbiAgICAgIHRoaXMuX3ZveGVsLmRhdGFDb29yZGluYXRlcyk7XHJcblxyXG4gICAgdGhpcy5fdm94ZWwudmFsdWUgPSBNb2RlbHNTdGFjay52YWx1ZVJlc2NhbGVTbG9wZUludGVyY2VwdChcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHRoaXMuX3N0YWNrLnJlc2NhbGVTbG9wZSxcclxuICAgICAgdGhpcy5fc3RhY2sucmVzY2FsZUludGVyY2VwdCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Qb3NpdGlvbigpIHtcclxuICAgIGlmICh0aGlzLl9kb20pIHtcclxuICAgICAgbGV0IHBvc1kgPSB0aGlzLl9zY3JlZW5Qb3NpdGlvbi55IC0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgdGhpcy5fZG9tLnN0eWxlLnRyYW5zZm9ybSA9XHJcbiAgICAgICAgYHRyYW5zbGF0ZTNEKCR7dGhpcy5fc2NyZWVuUG9zaXRpb24ueH1weCwgJHtwb3NZfXB4LCAwKWA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1cGRhdGVET01Db2xvcigpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5ib3JkZXJDb2xvciA9IGAke3RoaXMuX2NvbG9yfWA7XHJcbiAgfVxyXG5cclxuICBmcmVlKCkge1xyXG4gICAgdGhpcy5fY29udGFpbmVyLlxyXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB0aGlzLl9jb250YWluZXIuXHJcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVIYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5fY29udGFpbmVyLlxyXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbk1vdXNlTW92ZUhhbmRsZXIsIGZhbHNlKTtcclxuICAgIHRoaXMuX2NvbnRhaW5lci5cclxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLm9uTW91c2VNb3ZlSGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuX3ZveGVsLnJlbW92ZVRlc3QoKTtcclxuICAgIHRoaXMucmVtb3ZlKHRoaXMuX3ZveGVsKTtcclxuICAgIHRoaXMuX3ZveGVsID0gbnVsbDtcclxuXHJcbiAgICBzdXBlci5mcmVlKCk7XHJcbiAgfVxyXG5cclxuICBob3ZlclZveGVsKG1vdXNlU2NyZWVuQ29vcmRpbmF0ZXMsIGN1cnJlbnREYXRhQ29vcmRpbmF0ZXMpIHtcclxuICAgIC8vIHVwZGF0ZSBkaXN0YW5jZSBtb3VzZS90aGlzLl92b3hlbFxyXG4gICAgbGV0IGR4ID1cclxuICAgICAgbW91c2VTY3JlZW5Db29yZGluYXRlcy5zY3JlZW5YIC0gdGhpcy5fdm94ZWwudm94ZWwuc2NyZWVuQ29vcmRpbmF0ZXMueDtcclxuICAgIGxldCBkeSA9XHJcbiAgICAgIG1vdXNlU2NyZWVuQ29vcmRpbmF0ZXMuc2NyZWVuWSAtIHRoaXMuX3ZveGVsLnZveGVsLnNjcmVlbkNvb3JkaW5hdGVzLnk7XHJcbiAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgdGhpcy5fdm94ZWwuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgIGlmIChkaXN0YW5jZSA+PSAwICYmIGRpc3RhbmNlIDwgMTApIHtcclxuICAgICAgdGhpcy5faG92ZXIgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5faG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldCB3b3JsZFBvc2l0aW9uKHdvcmxkUG9zaXRpb24pIHtcclxuICAgIHRoaXMuX3dvcmxkUG9zaXRpb24uY29weSh3b3JsZFBvc2l0aW9uKTtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBzZXQgZGVmYXVsdENvbG9yKGRlZmF1bHRDb2xvcikge1xyXG4gICAgdGhpcy5fZGVmYXVsdENvbG9yID0gZGVmYXVsdENvbG9yO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBkZWZhdWx0Q29sb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdENvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IGFjdGl2ZUNvbG9yKGFjdGl2ZUNvbG9yKSB7XHJcbiAgICB0aGlzLl9hY3RpdmVDb2xvciA9IGFjdGl2ZUNvbG9yO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBhY3RpdmVDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9hY3RpdmVDb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBob3ZlckNvbG9yKGhvdmVyQ29sb3IpIHtcclxuICAgIHRoaXMuX2hvdmVyQ29sb3IgPSBob3ZlckNvbG9yO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBob3ZlckNvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hvdmVyQ29sb3I7XHJcbiAgfVxyXG5cclxuICBzZXQgc2VsZWN0ZWRDb2xvcihzZWxlY3RlZENvbG9yKSB7XHJcbiAgICB0aGlzLl9zZWxlY3RlZENvbG9yID0gc2VsZWN0ZWRDb2xvcjtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2VsZWN0ZWRDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZENvbG9yO1xyXG4gIH1cclxuXHJcbiAgc2V0IHNob3dWb3hlbChzaG93Vm94ZWwpIHtcclxuICAgIHRoaXMuX3Nob3dWb3hlbCA9IHNob3dWb3hlbDtcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2hvd1ZveGVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Nob3dWb3hlbDtcclxuICB9XHJcblxyXG4gIHNldCBzaG93RG9tU1ZHKHNob3dEb21TVkcpIHtcclxuICAgIHRoaXMuX3Nob3dEb21TVkcgPSBzaG93RG9tU1ZHO1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIGdldCBzaG93RG9tU1ZHKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Nob3dEb21TVkc7XHJcbiAgfVxyXG5cclxuICBzZXQgc2hvd0RvbU1lYXN1cmVtZW50cyhzaG93RG9tTWVhc3VyZW1lbnRzKSB7XHJcbiAgICB0aGlzLl9zaG93RG9tTWVhc3VyZW1lbnRzID0gc2hvd0RvbU1lYXN1cmVtZW50cztcclxuICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc2hvd0RvbU1lYXN1cmVtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zaG93RG9tTWVhc3VyZW1lbnRzO1xyXG4gIH1cclxuXHJcbiAgaGlkZURPTSgpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIH1cclxuXHJcbiAgc2hvd0RPTSgpIHtcclxuICAgIHRoaXMuX2RvbS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgfVxyXG5cclxuICBoaWRlTWVzaCgpIHtcclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2hvd01lc2goKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIHRoaXMuc2hvd0RPTSgpO1xyXG4gICAgdGhpcy5zaG93TWVzaCgpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIHRoaXMuaGlkZURPTSgpO1xyXG4gICAgdGhpcy5oaWRlTWVzaCgpO1xyXG4gIH1cclxufVxyXG4iXX0=
